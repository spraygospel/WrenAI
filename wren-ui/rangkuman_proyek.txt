This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.dockerignore
.env.test
.eslintignore
.eslintrc.json
.prettierrc
.yarnrc.yml
codegen.yaml
Dockerfile
e2e/commonTests/home.ts
e2e/commonTests/modeling.ts
e2e/commonTests/onboarding.ts
e2e/config.ts
e2e/global.setup.ts
e2e/global.teardown.ts
e2e/helper.ts
e2e/README.md
e2e/specs/connectBigQuery.spec.ts
e2e/specs/connectClickHouse.spec.ts
e2e/specs/connectDuckDB.spec.ts
e2e/specs/connectMySQL.spec.ts
e2e/specs/connectPostgreSQL.spec.ts
e2e/specs/connectSampleECommerce.spec.ts
e2e/specs/connectSampleHR.spec.ts
e2e/specs/connectSnowflake.spec.ts
e2e/specs/connectSQLServer.spec.ts
e2e/specs/connectTrino.spec.ts
jest.config.js
knexfile.js
migrations/20240125070643_create_project_table.js
migrations/20240125071855_create_model_table.js
migrations/20240125081244_create_model_column_table.js
migrations/20240125083821_create_relation_table.js
migrations/20240125085655_create_metrics_table.js
migrations/20240126100753_create_metrics_measure_table.js
migrations/20240129021453_create_view_table.js
migrations/20240319083758_create_deploy_table.js
migrations/20240327030000_create_ask_table.js
migrations/20240418000000_update_project_table_pg.js
migrations/20240419090558_add_foreign_key_to_model_column_and_metric_measure.js
migrations/20240425000000_add_thread_response_summary.js
migrations/20240430033014_update_model_column_table.js
migrations/20240446090560_update_relationship_table.js
migrations/20240502000000_add_properties_to_relationship.js
migrations/20240524044348_update_project_table.js
migrations/20240524071859_update_thread_table.js
migrations/20240530062133_update_project_table.js
migrations/20240530062809_transfer_project_table_data.js
migrations/20240530105955_drop_project_table_columns.js
migrations/20240531085916_transfer_model_properties.js
migrations/20240610070534_create_schema_change_table.js
migrations/20240928165009_create_model_nested_column.js
migrations/20241021073019_update_project_language.js
migrations/20241029092204_create_learning_table.js
migrations/20241106232204_update_project_table.js
migrations/20241107171828_update_thread_table.js
migrations/20241115031024_drop_thread_response_table_column.js
migrations/20241207000000_update_thread_response_for_answer.js
migrations/20241210072534_update_thread_response_table.js
migrations/20241226135712_remove_thread_sql.js
migrations/20250102074255_create_dashboard_table.js
migrations/20250102074256_create_dashboard_item_table.js
migrations/20250102074256_create_sql_pair_table.js
migrations/20250311046282_create_instruction_table.js
migrations/20250320074256_alter_sql_pair_table.js
migrations/20250422000000_alter_dashboard_table.js
migrations/20250423000000_create_dashboard_cache_refresh_table.js
migrations/20250509000000_create_asking_task.js
migrations/20250509000001_add_task_id_to_thread.js
migrations/20250510000000_add_adjustment_to_thread_response.js
migrations/20250510000001_alter_dashboard_item_table.js
migrations/20250510000002_add_version_to_project.js
migrations/20250511000000-create-api-history.js
next-env.d.ts
next.config.js
openapi.yaml
package.json
playwright.config.ts
public/images/dataSource/athena.svg
public/images/dataSource/bigQuery.svg
public/images/dataSource/clickhouse.svg
public/images/dataSource/duckDb.svg
public/images/dataSource/mysql.svg
public/images/dataSource/oracle.svg
public/images/dataSource/postgreSql.svg
public/images/dataSource/redshift.svg
public/images/dataSource/snowflake.svg
public/images/dataSource/sqlserver.svg
public/images/dataSource/trino.svg
public/images/icon/message-ai.svg
public/images/logo-white-with-text.svg
public/images/logo.svg
README.md
src/apollo/client/graphql/__types__.ts
src/apollo/client/graphql/apiManagement.generated.ts
src/apollo/client/graphql/apiManagement.ts
src/apollo/client/graphql/calculatedField.generated.ts
src/apollo/client/graphql/calculatedField.ts
src/apollo/client/graphql/dashboard.generated.ts
src/apollo/client/graphql/dashboard.ts
src/apollo/client/graphql/dataSource.generated.ts
src/apollo/client/graphql/dataSource.ts
src/apollo/client/graphql/deploy.generated.ts
src/apollo/client/graphql/deploy.ts
src/apollo/client/graphql/diagram.generated.ts
src/apollo/client/graphql/diagram.ts
src/apollo/client/graphql/home.generated.ts
src/apollo/client/graphql/home.ts
src/apollo/client/graphql/instructions.generated.ts
src/apollo/client/graphql/instructions.ts
src/apollo/client/graphql/learning.generated.ts
src/apollo/client/graphql/learning.ts
src/apollo/client/graphql/metadata.generated.ts
src/apollo/client/graphql/metadata.ts
src/apollo/client/graphql/model.generated.ts
src/apollo/client/graphql/model.ts
src/apollo/client/graphql/onboarding.generated.ts
src/apollo/client/graphql/onboarding.ts
src/apollo/client/graphql/relationship.generated.ts
src/apollo/client/graphql/relationship.ts
src/apollo/client/graphql/settings.generated.ts
src/apollo/client/graphql/settings.ts
src/apollo/client/graphql/sql.generated.ts
src/apollo/client/graphql/sql.ts
src/apollo/client/graphql/sqlPairs.generated.ts
src/apollo/client/graphql/sqlPairs.ts
src/apollo/client/graphql/view.generated.ts
src/apollo/client/graphql/view.ts
src/apollo/client/index.ts
src/apollo/server/adaptors/ibisAdaptor.ts
src/apollo/server/adaptors/index.ts
src/apollo/server/adaptors/tests/ibisAdaptor.test.ts
src/apollo/server/adaptors/tests/wrenAIAdaptor.test.ts
src/apollo/server/adaptors/wrenAIAdaptor.ts
src/apollo/server/adaptors/wrenEngineAdaptor.ts
src/apollo/server/backgrounds/adjustmentBackgroundTracker.ts
src/apollo/server/backgrounds/chart.ts
src/apollo/server/backgrounds/dashboardCacheBackgroundTracker.ts
src/apollo/server/backgrounds/index.ts
src/apollo/server/backgrounds/recommend-question.ts
src/apollo/server/backgrounds/textBasedAnswerBackgroundTracker.ts
src/apollo/server/config.ts
src/apollo/server/data/index.ts
src/apollo/server/data/sample.ts
src/apollo/server/data/type.ts
src/apollo/server/dataSource.ts
src/apollo/server/index.ts
src/apollo/server/managers/dataSourceSchemaDetector.ts
src/apollo/server/mdl/mdlBuilder.ts
src/apollo/server/mdl/test/mdlBuilder.test.ts
src/apollo/server/mdl/type.ts
src/apollo/server/models/adaptor.ts
src/apollo/server/models/dashboard.ts
src/apollo/server/models/index.ts
src/apollo/server/models/instruction.ts
src/apollo/server/models/model.ts
src/apollo/server/repositories/apiHistoryRepository.ts
src/apollo/server/repositories/askingTaskRepository.ts
src/apollo/server/repositories/baseRepository.ts
src/apollo/server/repositories/dashboardItemRefreshJobRepository.ts
src/apollo/server/repositories/dashboardItemRepository.ts
src/apollo/server/repositories/dashboardRepository.ts
src/apollo/server/repositories/deployLogRepository.ts
src/apollo/server/repositories/index.ts
src/apollo/server/repositories/instructionRepository.ts
src/apollo/server/repositories/learningRepository.ts
src/apollo/server/repositories/metricsMeasureRepository.ts
src/apollo/server/repositories/metricsRepository.ts
src/apollo/server/repositories/modelColumnRepository.ts
src/apollo/server/repositories/modelNestedColumnRepository.ts
src/apollo/server/repositories/modelRepository.ts
src/apollo/server/repositories/projectRepository.ts
src/apollo/server/repositories/relationshipRepository.ts
src/apollo/server/repositories/schemaChangeRepository.ts
src/apollo/server/repositories/sqlPairRepository.ts
src/apollo/server/repositories/threadRepository.ts
src/apollo/server/repositories/threadResponseRepository.ts
src/apollo/server/repositories/viewRepository.ts
src/apollo/server/resolvers.ts
src/apollo/server/resolvers/apiHistoryResolver.ts
src/apollo/server/resolvers/askingResolver.ts
src/apollo/server/resolvers/dashboardResolver.ts
src/apollo/server/resolvers/diagramResolver.ts
src/apollo/server/resolvers/instructionResolver.ts
src/apollo/server/resolvers/learningResolver.ts
src/apollo/server/resolvers/modelResolver.ts
src/apollo/server/resolvers/projectResolver.ts
src/apollo/server/resolvers/sqlPairResolver.ts
src/apollo/server/scalars.ts
src/apollo/server/schema.ts
src/apollo/server/services/askingService.ts
src/apollo/server/services/askingTaskTracker.ts
src/apollo/server/services/dashboardService.ts
src/apollo/server/services/deployService.ts
src/apollo/server/services/index.ts
src/apollo/server/services/instructionService.ts
src/apollo/server/services/mdlService.ts
src/apollo/server/services/metadataService.ts
src/apollo/server/services/modelService.ts
src/apollo/server/services/projectService.ts
src/apollo/server/services/queryService.ts
src/apollo/server/services/sqlPairService.ts
src/apollo/server/services/tests/askingService.test.ts
src/apollo/server/services/tests/dashboardService.test.ts
src/apollo/server/services/tests/deployService.test.ts
src/apollo/server/services/tests/queryService.test.ts
src/apollo/server/telemetry/telemetry.ts
src/apollo/server/types/context.ts
src/apollo/server/types/dataSource.ts
src/apollo/server/types/diagram.ts
src/apollo/server/types/index.ts
src/apollo/server/types/manifest.ts
src/apollo/server/types/metric.ts
src/apollo/server/types/relationship.ts
src/apollo/server/utils/apiUtils.ts
src/apollo/server/utils/dataUtils.ts
src/apollo/server/utils/docker.ts
src/apollo/server/utils/encode.ts
src/apollo/server/utils/encryptor.ts
src/apollo/server/utils/error.ts
src/apollo/server/utils/helper.ts
src/apollo/server/utils/index.ts
src/apollo/server/utils/knex.ts
src/apollo/server/utils/logger.ts
src/apollo/server/utils/model.ts
src/apollo/server/utils/regex.ts
src/apollo/server/utils/string.ts
src/apollo/server/utils/tests/dataSource.test.ts
src/apollo/server/utils/tests/encryptor.test.ts
src/apollo/server/utils/tests/regex.test.ts
src/apollo/server/utils/timezone.ts
src/common.ts
src/components/ActionButton.tsx
src/components/chart/handler.ts
src/components/chart/index.tsx
src/components/chart/properties/BasicProperties.tsx
src/components/chart/properties/DonutProperties.tsx
src/components/chart/properties/GroupedBarProperties.tsx
src/components/chart/properties/LineProperties.tsx
src/components/chart/properties/StackedBarProperties.tsx
src/components/code/BaseCodeBlock.tsx
src/components/code/JsonCodeBlock.tsx
src/components/code/SQLCodeBlock.tsx
src/components/dataPreview/PreviewData.tsx
src/components/dataPreview/PreviewDataContent.tsx
src/components/deploy/Context.ts
src/components/deploy/Deploy.tsx
src/components/diagram/Context.ts
src/components/diagram/CustomDropdown.tsx
src/components/diagram/customEdge/index.ts
src/components/diagram/customEdge/ModelEdge.tsx
src/components/diagram/customNode/Column.tsx
src/components/diagram/customNode/index.ts
src/components/diagram/customNode/MarkerHandle.tsx
src/components/diagram/customNode/ModelNode.tsx
src/components/diagram/customNode/utils.tsx
src/components/diagram/customNode/ViewNode.tsx
src/components/diagram/CustomPopover.tsx
src/components/diagram/index.tsx
src/components/diagram/Marker.tsx
src/components/diagram/utils.ts
src/components/EditableWrapper.tsx
src/components/editor/AceEditor.tsx
src/components/editor/MarkdownBlock.tsx
src/components/editor/MarkdownEditor.tsx
src/components/editor/SQLEditor.tsx
src/components/EllipsisWrapper.tsx
src/components/ErrorCollapse.tsx
src/components/HeaderBar.tsx
src/components/layouts/PageLayout.tsx
src/components/layouts/SiderLayout.tsx
src/components/layouts/SimpleLayout.tsx
src/components/learning/guide/index.tsx
src/components/learning/guide/stories.tsx
src/components/learning/guide/utils.ts
src/components/learning/index.tsx
src/components/Logo.tsx
src/components/LogoBar.tsx
src/components/modals/AdjustReasoningStepsModal.tsx
src/components/modals/AdjustSQLModal.tsx
src/components/modals/CalculatedFieldModal.tsx
src/components/modals/DeleteModal.tsx
src/components/modals/FixSQLModal.tsx
src/components/modals/ImportDataSourceSQLModal.tsx
src/components/modals/InstructionModal.tsx
src/components/modals/QuestionSQLPairModal.tsx
src/components/modals/RelationModal.tsx
src/components/modals/SaveAsViewModal.tsx
src/components/modals/SchemaChangeModal.tsx
src/components/PageLoading.tsx
src/components/pages/apiManagement/DetailsDrawer.tsx
src/components/pages/home/dashboardGrid/CacheSettingsDrawer.tsx
src/components/pages/home/dashboardGrid/DashboardHeader.tsx
src/components/pages/home/dashboardGrid/EmptyDashboard.tsx
src/components/pages/home/dashboardGrid/index.tsx
src/components/pages/home/preparation/ErrorBoundary.tsx
src/components/pages/home/preparation/index.tsx
src/components/pages/home/preparation/PreparationStatus.tsx
src/components/pages/home/preparation/PreparationSteps.tsx
src/components/pages/home/preparation/step/FixedSQLFinished.tsx
src/components/pages/home/preparation/step/Generating.tsx
src/components/pages/home/preparation/step/Organizing.tsx
src/components/pages/home/preparation/step/Retrieving.tsx
src/components/pages/home/preparation/step/SQLPairFinished.tsx
src/components/pages/home/preparation/step/ViewFinished.tsx
src/components/pages/home/prompt/DemoPrompt.tsx
src/components/pages/home/prompt/index.tsx
src/components/pages/home/prompt/Input.tsx
src/components/pages/home/prompt/RecommendedQuestionsPrompt.tsx
src/components/pages/home/prompt/Result.tsx
src/components/pages/home/promptThread/AnswerResult.tsx
src/components/pages/home/promptThread/ChartAnswer.tsx
src/components/pages/home/promptThread/index.tsx
src/components/pages/home/promptThread/store.tsx
src/components/pages/home/promptThread/TextBasedAnswer.tsx
src/components/pages/home/promptThread/ViewBlock.tsx
src/components/pages/home/promptThread/ViewSQLTabContent.tsx
src/components/pages/home/RecommendedQuestions.tsx
src/components/pages/knowledge/GlobalLabel.tsx
src/components/pages/knowledge/InstructionDrawer.tsx
src/components/pages/knowledge/SQLPairDrawer.tsx
src/components/pages/modeling/EditMetadataModal.tsx
src/components/pages/modeling/form/ModelForm.tsx
src/components/pages/modeling/metadata/EditBasicMetadata.tsx
src/components/pages/modeling/metadata/EditModelMetadata.tsx
src/components/pages/modeling/metadata/EditViewMetadata.tsx
src/components/pages/modeling/metadata/ModelMetadata.tsx
src/components/pages/modeling/metadata/ViewMetadata.tsx
src/components/pages/modeling/MetadataDrawer.tsx
src/components/pages/modeling/ModelDrawer.tsx
src/components/pages/setup/ButtonItem.tsx
src/components/pages/setup/ConnectDataSource.tsx
src/components/pages/setup/ContainerCard.tsx
src/components/pages/setup/dataSources/AthenaProperties.tsx
src/components/pages/setup/dataSources/BigQueryProperties.tsx
src/components/pages/setup/dataSources/ClickHouseProperties.tsx
src/components/pages/setup/dataSources/DuckDBProperties.tsx
src/components/pages/setup/dataSources/MySQLProperties.tsx
src/components/pages/setup/dataSources/OracleProperties.tsx
src/components/pages/setup/dataSources/PostgreSQLProperties.tsx
src/components/pages/setup/dataSources/RedshiftProperties.tsx
src/components/pages/setup/dataSources/SnowflakeProperties.tsx
src/components/pages/setup/dataSources/SQLServerProperties.tsx
src/components/pages/setup/dataSources/TrinoProperties.tsx
src/components/pages/setup/DefineRelations.tsx
src/components/pages/setup/SelectModels.tsx
src/components/pages/setup/Starter.tsx
src/components/pages/setup/utils.tsx
src/components/selectors/CombineFieldSelector.tsx
src/components/selectors/DescriptiveSelector.tsx
src/components/selectors/lineageSelector/FieldSelect.tsx
src/components/selectors/lineageSelector/index.tsx
src/components/selectors/Selector.tsx
src/components/settings/DataSourceSettings.tsx
src/components/settings/index.tsx
src/components/settings/ProjectSettings.tsx
src/components/settings/utils.tsx
src/components/sidebar/APIManagement.tsx
src/components/sidebar/Home.tsx
src/components/sidebar/home/ThreadTree.tsx
src/components/sidebar/home/TreeTitle.tsx
src/components/sidebar/home/TreeTitleInput.tsx
src/components/sidebar/index.tsx
src/components/sidebar/Knowledge.tsx
src/components/sidebar/LabelTitle.tsx
src/components/sidebar/Modeling.tsx
src/components/sidebar/modeling/GroupTreeTitle.tsx
src/components/sidebar/modeling/ModelTree.tsx
src/components/sidebar/modeling/ViewTree.tsx
src/components/sidebar/SidebarMenu.tsx
src/components/sidebar/SidebarTree.tsx
src/components/sidebar/utils.tsx
src/components/table/BaseTable.tsx
src/components/table/CalculatedFieldTable.tsx
src/components/table/EditableBaseTable.tsx
src/components/table/FieldTable.tsx
src/components/table/ModelRelationSelectionTable.tsx
src/components/table/MultiSelectBox.tsx
src/components/table/NestedFieldTable.tsx
src/components/table/RelationTable.tsx
src/components/table/SelectionTable.tsx
src/components/table/TableTransfer.tsx
src/hooks/useAdjustAnswer.tsx
src/hooks/useAskingStreamTask.tsx
src/hooks/useAskProcessState.tsx
src/hooks/useAskPrompt.tsx
src/hooks/useAutoComplete.tsx
src/hooks/useCheckOnboarding.tsx
src/hooks/useCombineFieldOptions.tsx
src/hooks/useDrawerAction.tsx
src/hooks/useDropdown.tsx
src/hooks/useExpressionFieldOptions.tsx
src/hooks/useGlobalConfig.tsx
src/hooks/useHomeSidebar.tsx
src/hooks/useModalAction.tsx
src/hooks/useNativeSQL.tsx
src/hooks/useRecommendedQuestionsInstruction.tsx
src/hooks/useRelationshipModal.tsx
src/hooks/useSetupConnection.tsx
src/hooks/useSetupConnectionDataSource.tsx
src/hooks/useSetupConnectionSampleDataset.tsx
src/hooks/useSetupModels.tsx
src/hooks/useSetupRelations.tsx
src/hooks/useStoreContext.tsx
src/hooks/useTextBasedAnswerStreamTask.tsx
src/import/antd.ts
src/import/icon.ts
src/pages/_app.tsx
src/pages/_document.tsx
src/pages/api-management/history.tsx
src/pages/api/ask_task/streaming_answer.ts
src/pages/api/ask_task/streaming.ts
src/pages/api/config.ts
src/pages/api/graphql.ts
src/pages/api/v1/generate_sql.ts
src/pages/api/v1/generate_vega_chart.ts
src/pages/api/v1/run_sql.ts
src/pages/api/v1/stream_explanation.ts
src/pages/home/[id].tsx
src/pages/home/dashboard.tsx
src/pages/home/index.tsx
src/pages/index.tsx
src/pages/knowledge/instructions.tsx
src/pages/knowledge/question-sql-pairs.tsx
src/pages/modeling.tsx
src/pages/setup/connection.tsx
src/pages/setup/models.tsx
src/pages/setup/relationships.tsx
src/styles/antd-variables.less
src/styles/components/alert.less
src/styles/components/avatar.less
src/styles/components/button.less
src/styles/components/chart.less
src/styles/components/driver.less
src/styles/components/scrollbar.less
src/styles/components/select.less
src/styles/components/table.less
src/styles/components/tag.less
src/styles/components/transfer.less
src/styles/index.less
src/styles/layouts/global.less
src/styles/layouts/main.less
src/styles/utilities/animation.less
src/styles/utilities/border.less
src/styles/utilities/color.less
src/styles/utilities/display.less
src/styles/utilities/flex.less
src/styles/utilities/grid.less
src/styles/utilities/spacing.less
src/styles/utilities/text.less
src/utils/columnType.tsx
src/utils/data/dictionary.ts
src/utils/data/index.ts
src/utils/data/type/index.ts
src/utils/data/type/modeling.ts
src/utils/dataSourceType.ts
src/utils/diagram/creator.ts
src/utils/diagram/index.ts
src/utils/diagram/transformer.ts
src/utils/enum/columnType.ts
src/utils/enum/dataSources.ts
src/utils/enum/diagram.ts
src/utils/enum/dropdown.ts
src/utils/enum/form.ts
src/utils/enum/home.ts
src/utils/enum/index.ts
src/utils/enum/menu.ts
src/utils/enum/modeling.ts
src/utils/enum/path.ts
src/utils/enum/settings.ts
src/utils/enum/setup.ts
src/utils/env.ts
src/utils/error/dictionary.ts
src/utils/error/index.ts
src/utils/errorHandler.tsx
src/utils/events.tsx
src/utils/expressionType.ts
src/utils/helper.ts
src/utils/icons.ts
src/utils/iteration.tsx
src/utils/language.ts
src/utils/modelingHelper.ts
src/utils/nodeType.tsx
src/utils/svgs/CopilotSVG.tsx
src/utils/svgs/EditSVG.tsx
src/utils/svgs/index.ts
src/utils/svgs/InstructionsSVG.tsx
src/utils/svgs/RobotSVG.tsx
src/utils/table.tsx
src/utils/telemetry.ts
src/utils/time.ts
src/utils/validator/calculatedFieldValidator.ts
src/utils/validator/cronValidator.ts
src/utils/validator/hostValidator.ts
src/utils/validator/index.ts
src/utils/validator/relationshipValidator.ts
src/utils/validator/sqlPairValidator.ts
src/utils/validator/viewValidator.ts
src/utils/vegaSpecUtils.test.ts
src/utils/vegaSpecUtils.ts
tools/knex.js
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".dockerignore">
Dockerfile
.dockerignore
node_modules
npm-debug.log
README.md
.next
.git
*.sqlite
*.sqlite3
.env*.local
</file>

<file path=".env.test">
DB_TYPE=sqlite
SQLITE_FILE=testdb.sqlite3
OTHER_SERVICE_USING_DOCKER=true
</file>

<file path=".eslintignore">
**/node_modules
</file>

<file path=".eslintrc.json">
{
  "root": true,
  "parser": "@typescript-eslint/parser",
  "extends": ["next/core-web-vitals", "plugin:@typescript-eslint/recommended", "prettier"],
  "plugins": ["@typescript-eslint", "eslint-plugin-prettier"],
  "ignorePatterns": [
    "!**/*",
    ".next/**/*",
    "src/apollo/client/graphql/__types__.ts",
    "src/apollo/client/graphql/*.generated.ts"
  ],
  "overrides": [
    {
      "files": ["*.ts", "*.tsx", "*.js", "*.jsx"],
      "rules": {
        "@next/next/no-html-link-for-pages": [
          "error",
          "src/pages"
        ],
        "@next/next/no-img-element": "off",
        "react-hooks/exhaustive-deps": "off"
      }
    },
    {
      "files": ["*.ts", "*.tsx"],
      "rules": {}
    },
    {
      "files": ["*.js", "*.jsx"],
      "rules": {}
    }
  ],
  "rules": {
    "prettier/prettier": "error",
    "@next/next/no-html-link-for-pages": "off",
    "react/display-name": 0,
    "react/no-unescaped-entities": 0,
    "@typescript-eslint/no-explicit-any": "off",
    "@typescript-eslint/no-non-null-assertion": "off",
    "@typescript-eslint/no-unused-vars": [
      "error",
      {
        "args": "all",
        "argsIgnorePattern": "^_",
        "caughtErrors": "all",
        "caughtErrorsIgnorePattern": "^_",
        "destructuredArrayIgnorePattern": "^_",
        "varsIgnorePattern": "^_",
        "ignoreRestSiblings": true
      }
    ]
  },
  "env": {
    "jest": true
  }
}
</file>

<file path=".prettierrc">
{
  "singleQuote": true
}
</file>

<file path=".yarnrc.yml">
nodeLinker: node-modules

yarnPath: .yarn/releases/yarn-4.5.3.cjs
</file>

<file path="codegen.yaml">
overwrite: true
schema:
  [
    'http://localhost:3000/api/graphql'
  ]
generates:
  ./src/apollo/client/graphql/__types__.ts:
    plugins:
      - typescript
      - typescript-operations
      - typescript-react-apollo
    config:
      namingConvention:
        enumValues: keep
  ./:
    preset: near-operation-file
    presetConfig:
      extension: .generated.ts
      baseTypesPath: ./src/apollo/client/graphql/__types__.ts
    documents: ./src/apollo/client/graphql/!(*.generated).{ts,tsx}
    plugins:
      - typescript-operations
      - typescript-react-apollo
</file>

<file path="Dockerfile">
FROM node:18-bookworm-slim AS base

# Install required packages
RUN apt-get update && apt-get install -y curl && rm -rf /var/lib/apt/lists/*

# Next.js collects completely anonymous telemetry data about general usage.
# Learn more here: https://nextjs.org/telemetry
# Uncomment the following line in case you want to disable telemetry during the build.
ENV NEXT_TELEMETRY_DISABLED 1
ENV NODE_ENV production

WORKDIR /app

# Enable corepack to manage yarn versions and set the correct yarn version
RUN corepack enable
COPY .yarnrc.yml package.json yarn.lock ./
COPY .yarn/releases/yarn-4.5.3.cjs .yarn/releases/yarn-4.5.3.cjs
RUN corepack prepare yarn@4.5.3 --activate

FROM base AS deps
WORKDIR /app

# Install dependencies based on the preferred package manager
RUN yarn install --immutable
RUN yarn add sharp

# Rebuild the source code only when needed
FROM base AS builder
WORKDIR /app
COPY --from=deps /app/node_modules ./node_modules
COPY public ./public
COPY src ./src
COPY .eslintrc.json ./
COPY .eslintignore ./
COPY .prettierrc ./
COPY next.config.js ./
COPY tsconfig.json ./

RUN yarn build

# Production image, copy all the files and run next
FROM base AS runner
WORKDIR /app

COPY --from=builder /app/public ./public

# Set the correct permission for prerender cache
RUN mkdir .next

# Automatically leverage output traces to reduce image size
# https://nextjs.org/docs/advanced-features/output-file-tracing
COPY --from=builder /app/.next/standalone ./
COPY --from=builder /app/.next/static ./.next/static
COPY migrations ./migrations
COPY knexfile.js ./knexfile.js

# Copy knex and its dependencies from builder to runner
COPY --from=builder /app/node_modules/knex ./node_modules/knex
COPY --from=builder /app/node_modules/rechoir ./node_modules/rechoir
COPY --from=builder /app/node_modules/resolve ./node_modules/resolve
COPY --from=builder /app/node_modules/is-core-module ./node_modules/is-core-module
COPY --from=builder /app/node_modules/hasown ./node_modules/hasown
COPY --from=builder /app/node_modules/function-bind ./node_modules/function-bind
COPY --from=builder /app/node_modules/interpret ./node_modules/interpret
COPY --from=builder /app/node_modules/resolve-from ./node_modules/resolve-from
COPY --from=builder /app/node_modules/tildify ./node_modules/tildify
COPY --from=builder /app/node_modules/getopts ./node_modules/getopts
COPY --from=builder /app/node_modules/escalade/sync ./node_modules/escalade/sync
COPY --from=builder /app/node_modules/.yarn-state.yml ./node_modules/.yarn-state.yml

EXPOSE 3000

ENV PORT 3000

# server.js is created by next build from the standalone output
# https://nextjs.org/docs/pages/api-reference/next-config-js/output
CMD yarn knex migrate:latest && HOSTNAME="0.0.0.0" node server.js
</file>

<file path="e2e/commonTests/home.ts">
import { Page, expect } from '@playwright/test';
import * as helper from '../helper';
import {
  AskingTask,
  AskingTaskStatus,
} from '@/apollo/client/graphql/__types__';
import * as modelingHelper from './modeling';

export const checkAskingProcess = async (page: Page, question: string) => {
  // check process state
  await expect(page.getByTestId('prompt__result')).toBeVisible();
  await expect(page.getByRole('button', { name: 'Stop' })).toBeVisible();
  await expect(page.getByPlaceholder('Ask to explore your data')).toHaveValue(
    question,
  );
  await expect(page.getByRole('button', { name: 'Ask' })).toBeDisabled();
};

export const waitingForAskingTask = async (page: Page) => {
  await helper.waitForGraphQLResponse({ page }, 'askingTask', (data) =>
    [AskingTaskStatus.FAILED, AskingTaskStatus.FINISHED].includes(data?.status),
  );
};

export const checkCandidatesResult = async (page: Page) => {
  await expect(
    page.locator('div').filter({ hasText: 'result(s) found' }).last(),
  ).toBeVisible();
  await expect(page.getByText('result(s) found')).toBeVisible();
};

export const getFirstCandidatesResultSummary = async (page: Page) => {
  const candidatesResultHandle = await page.evaluateHandle(
    (document) => {
      const nodes: any = Array.from(
        document.querySelectorAll('div[role="row"]'),
      );
      const node = nodes[nodes.length - 1];
      const firstResult = node.firstElementChild.lastElementChild;

      return firstResult.childNodes[1].innerText;
    },
    await page.evaluateHandle(() => document),
  );

  const firstResultSummary = await candidatesResultHandle.jsonValue();
  await candidatesResultHandle.dispose();

  return firstResultSummary;
};

export const checkThreadResponseSkeletonLoading = async (page: Page) => {
  await expect(page.locator('.ant-skeleton-content').last()).toBeVisible({
    timeout: 60000,
  });
  await expect(page.locator('.ant-skeleton-content').last()).toBeHidden({
    timeout: 60000,
  });
};

const checkThreadResponseBreakdownContent = async (page: Page) => {
  // switch to the View SQL tab
  await page
    .locator('div')
    .filter({ hasText: /^View SQL$/ })
    .last()
    .click();

  // View SQL tab content
  await expect(
    page.getByLabel('View SQL').locator('.ant-skeleton-content').last(),
  ).toBeVisible();

  await expect(
    page.getByLabel('View SQL').locator('.ant-skeleton-content').last(),
  ).toBeHidden({ timeout: 60000 });

  // check show preview data table as default open
  await expect(
    page.getByLabel('View SQL').locator('.ant-table').last(),
  ).toBeVisible();
  await expect(page.getByText('Showing up to 500 rows').last()).toBeVisible();

  // check up-circle icon with Collapse button
  await expect(
    page.getByLabel('View SQL').getByLabel('up-circle').locator('svg').last(),
  ).toBeVisible();
  await expect(
    page
      .getByLabel('View SQL')
      .getByRole('button', { name: 'Collapse' })
      .last(),
  ).toBeVisible();

  // click View Full SQL button
  await page
    .getByLabel('View SQL')
    .getByRole('button', { name: 'View Full SQL' })
    .last()
    .click();
  await expect(
    page.getByLabel('View SQL').locator('.ace_editor'),
  ).toBeVisible();

  // check collapse and copy button
  await expect(
    page.getByLabel('View SQL').getByLabel('up-circle').locator('svg').last(),
  ).toBeVisible();
  await expect(
    page
      .getByLabel('View SQL')
      .getByRole('button', { name: 'Collapse' })
      .last(),
  ).toBeVisible();
  await expect(
    page.getByLabel('View SQL').getByLabel('copy').locator('svg'),
  ).toBeVisible();
  await expect(
    page.getByLabel('View SQL').getByRole('button', { name: 'Copy' }),
  ).toBeVisible();
};

export const askSuggestionQuestionTest = async ({
  page,
  suggestedQuestion,
}) => {
  await page.goto('/home');
  await expect(page).toHaveURL('/home', { timeout: 60000 });

  await page.getByText(suggestedQuestion).click();

  // check asking process state and wait for asking task to finish
  await checkAskingProcess(page, suggestedQuestion);
  await waitingForAskingTask(page);
  await checkThreadResponseSkeletonLoading(page);

  // check question block
  await expect(page.getByLabel('message').locator('svg')).toBeVisible();
  await expect(
    page.getByRole('heading', { name: suggestedQuestion }),
  ).toBeVisible();

  // check answer result basic UI elements
  await expect(
    page.locator('#rc-tabs-0-tab-answer').getByText('Answer'),
  ).toBeVisible();
  await expect(
    page.locator('#rc-tabs-0-tab-view-sql').getByText('View SQL'),
  ).toBeVisible();

  // check save icon button
  await expect(page.getByLabel('save').locator('svg')).toBeVisible();
  await expect(
    page.getByRole('button', { name: 'Save as View' }),
  ).toBeVisible();

  // Answer tab content
  await expect(page.getByLabel('Answer').locator('div').first()).toBeVisible();

  await checkThreadResponseBreakdownContent(page);
};

export const followUpQuestionTest = async ({ page, question }) => {
  await page.goto('/home');
  await expect(page).toHaveURL('/home', { timeout: 60000 });

  // click existing thread
  await page.locator('.adm-treeTitle__title').first().click();
  await expect(page).toHaveURL(/.*\/home\/\d+/, { timeout: 60000 });

  // ask follow up question
  await page.getByPlaceholder('Ask to explore your data').fill(question);
  await page.getByRole('button', { name: 'Ask' }).click();

  // check asking process state and wait for asking task to finish
  await checkAskingProcess(page, question);
  await waitingForAskingTask(page);
  await checkThreadResponseSkeletonLoading(page);

  // check question block
  await expect(page.getByLabel('message').locator('svg').last()).toBeVisible();
  await expect(page.getByRole('heading', { name: question })).toBeVisible();

  await checkThreadResponseBreakdownContent(page);
};

export const saveAsView = async (
  { page, baseURL }: { page: Page; baseURL: string },
  { question, viewName }: { question: string; viewName: string },
) => {
  await page.goto('/home');
  await expect(page).toHaveURL('/home', { timeout: 60000 });

  await page.getByPlaceholder('Ask to explore your data').fill(question);
  await page.getByRole('button', { name: 'Ask' }).click();

  // check asking process state and wait for asking task to finish
  await checkAskingProcess(page, question);
  await waitingForAskingTask(page);
  await checkThreadResponseSkeletonLoading(page);

  // click save as view button
  await page.getByRole('button', { name: 'Save as View' }).click();

  // check save as view modal
  await expect(page.locator('.ant-modal-mask')).toBeVisible();
  await expect(page.locator('div.ant-modal')).toBeVisible();
  await expect(
    page.locator('div.ant-modal-title').filter({ hasText: 'Save as View' }),
  ).toBeVisible();
  await expect(
    page.getByLabel('Save as View').getByLabel('Close', { exact: true }),
  ).toBeVisible();
  await expect(
    page.getByText(
      'After saving, make sure you go to "Modeling Page" to deploy all saved views.',
    ),
  ).toBeVisible();

  // save as View process
  await page.getByLabel('Name').click();
  await page.getByLabel('Name').fill(viewName);

  await page.getByRole('button', { name: 'Save', exact: true }).click();

  // check save as view success
  await expect(page.getByText('Successfully created view.')).toBeVisible();

  // go to modeling page
  await page.getByRole('button', { name: 'Modeling' }).click();
  await expect(page).toHaveURL('/modeling', { timeout: 60000 });

  // deploy MDL with view
  await expect(page.getByRole('button', { name: 'Deploy' })).toBeEnabled();
  await modelingHelper.executeDeploy({ page, baseURL });

  await page.getByRole('button', { name: 'Home', exact: true }).click();
  await expect(page).toHaveURL('/home', { timeout: 60000 });

  // ask the saved view question
  await page.getByPlaceholder('Ask to explore your data').fill(question);
  await page.getByRole('button', { name: 'Ask' }).click();

  // check asking process state and wait for asking task to finish
  await checkAskingProcess(page, question);
  await waitingForAskingTask(page);
  await checkThreadResponseSkeletonLoading(page);

  // check offer view info for thread response UI
  await expect(page.getByText('Generated from saved view')).toBeVisible();
  await expect(page.getByRole('link', { name: viewName })).toBeVisible();

  // click the view name link will open a new tab and go to the view metadata of the modeling page
  const newWebPagePromise = page.waitForEvent('popup');
  await page.getByRole('link', { name: viewName }).click();
  const modelingPage = await newWebPagePromise;

  // check view metadata
  await expect(
    modelingPage
      .locator('div.ant-drawer-title')
      .filter({ hasText: new RegExp(`^${viewName}$`) }),
  ).toBeVisible();
  await expect(
    modelingPage.getByTestId('metadata__name').getByText(viewName),
  ).toBeVisible();
  await modelingPage
    .locator('div.ant-drawer')
    .getByLabel('Close', { exact: true })
    .click();

  // check view node in diagram
  await expect(
    modelingPage.getByRole('complementary').getByText(viewName),
  ).toBeVisible();
  await modelingPage.getByRole('complementary').getByText(viewName).click();
  await expect(
    modelingPage.getByTestId(`diagram__view-node__${viewName}`),
  ).toBeVisible();
};
</file>

<file path="e2e/commonTests/modeling.ts">
import { Page, expect } from '@playwright/test';
interface Relationship {
  fromFieldModelDisplayName: string;
  fromFieldColumnDisplayName: string;
  toFieldModelDisplayName: string;
  toFieldColumnDisplayName: string;
  relationshipType: string;
}

export const checkDeploySynced = async ({ page }) => {
  await page.goto('/modeling');
  await expect(page).toHaveURL('/modeling', { timeout: 60000 });

  await expect(page.getByLabel('check-circle').locator('svg')).toBeVisible();
  await expect(page.getByText('Synced')).toBeVisible();
  await expect(page.getByRole('button', { name: 'Deploy' })).toBeDisabled();
};

export const checkDeployUndeployedChanges = async ({ page, baseURL }) => {
  if (page.url() !== `${baseURL}/modeling`) {
    await page.goto('/modeling');
    await expect(page).toHaveURL('/modeling', { timeout: 60000 });
  }

  await expect(page.getByLabel('warning').locator('svg')).toBeVisible();
  await expect(page.getByText('Undeployed changes')).toBeVisible();
  await expect(page.getByRole('button', { name: 'Deploy' })).toBeVisible();
  await expect(page.getByRole('button', { name: 'Deploy' })).toBeEnabled();
};

export const executeDeploy = async ({ page, baseURL }) => {
  if (page.url() !== `${baseURL}/modeling`) {
    await page.goto('/modeling');
    await expect(page).toHaveURL('/modeling', { timeout: 60000 });
  }

  await page.getByRole('button', { name: 'Deploy' }).click();
  await expect(
    page.getByRole('img', { name: 'loading' }).locator('svg'),
  ).toBeVisible();
  await expect(page.getByText('Deploying...')).toBeVisible();
  await expect(page.getByText('Deploying...')).toBeVisible({
    visible: false,
    timeout: 60000,
  });
};

export const executeModelCRUD = async (
  page: Page,
  {
    modelDisplayName,
    modelReferenceName,
    primaryKeyColumn,
  }: {
    modelDisplayName: string;
    modelReferenceName: string;
    primaryKeyColumn: string;
  },
) => {
  await page.goto('/modeling');
  await expect(page).toHaveURL('/modeling', { timeout: 60000 });

  // click the model of sidebar
  await page
    .getByRole('complementary')
    .getByText(modelDisplayName, { exact: true })
    .click();

  // delete the model
  await page
    .locator('div')
    .filter({ hasText: new RegExp(`^${modelDisplayName}$`) })
    .getByRole('button')
    .click();
  await page.getByText('Delete', { exact: true }).click();
  await expect(
    page
      .getByRole('dialog')
      .locator('div')
      .filter({ hasText: 'Are you sure you want to delete this model?' })
      .nth(1),
  ).toBeVisible();
  await page.getByRole('button', { name: 'Delete' }).click();

  // check model deleted
  await expect(page.getByText('Successfully deleted model.')).toBeVisible();
  await expect(
    page
      .getByRole('complementary')
      .getByText(modelDisplayName, { exact: true }),
  ).toBeHidden();

  // add the model back
  await page.getByTestId('add-model').click();

  // chkeck Model drawer open
  await expect(page.locator('.ant-drawer-mask')).toBeVisible();
  await expect(
    page
      .locator('div')
      .filter({ hasText: /^Create a data model$/ })
      .first(),
  ).toBeVisible();

  // select resource table and some columns
  await page.getByLabel('Select a table').click();
  await page
    .getByTitle(modelReferenceName, { exact: true })
    .locator('div')
    .click();

  await page
    .getByRole('row', { name: new RegExp(`^${primaryKeyColumn} .*`) })
    .getByLabel('')
    .check();

  await page.getByRole('button', { name: 'right' }).click();

  // set primary key
  await page.getByLabel('Select primary key').click();
  await page
    .locator('form')
    .getByTitle(primaryKeyColumn, { exact: true })
    .locator('div')
    .click();

  await page.getByRole('button', { name: 'Submit' }).click();

  // check model added
  await expect(page.getByText('Successfully created model.')).toBeVisible();
  await expect(
    page
      .getByRole('complementary')
      .getByText(modelReferenceName, { exact: true }),
  ).toBeVisible();
  await expect(
    page.getByTestId(`diagram__model-node__${modelReferenceName}`),
  ).toBeVisible();

  // update columns
  await page
    .locator('div')
    .filter({ hasText: new RegExp(`^${modelReferenceName}$`) })
    .getByRole('button')
    .click();
  await page.getByText('Update Columns').click();

  // select all columns
  await page.getByLabel('', { exact: true }).first().check();
  await page.getByRole('button', { name: 'right' }).click();

  await page.getByRole('button', { name: 'Submit' }).click();

  await expect(page.getByText('Successfully updated model.')).toBeVisible();
};

export const addRelationship = async (
  page: Page,
  {
    fromFieldModelDisplayName,
    fromFieldColumnDisplayName,
    toFieldModelDisplayName,
    toFieldColumnDisplayName,
    relationshipType,
  }: Relationship,
) => {
  // add relationship
  await page
    .getByTestId(`diagram__model-node__${fromFieldModelDisplayName}`)
    .locator('div')
    .filter({ hasText: /^Relationships$/ })
    .getByRole('button')
    .first()
    .click();

  // check relationship modal open
  await expect(
    page
      .locator('div')
      .filter({
        hasText: 'Add relationship',
      })
      .nth(2),
  ).toBeVisible();
  await expect(page.getByText('Add relationship')).toBeVisible();

  // set from field
  await page.getByTestId('common__fields-select').first().click();
  await page
    .getByTestId('common__fields__select-option')
    .filter({ hasText: fromFieldColumnDisplayName })
    .click();

  // set to field
  await page.getByTestId('common__models-select').last().click();
  await page
    .getByTestId('common__models__select-option')
    .filter({ hasText: toFieldModelDisplayName })
    .click();
  await page.getByTestId('common__fields-select').last().click();
  await page
    .getByTestId('common__fields__select-option')
    .filter({ hasText: toFieldColumnDisplayName })
    .last()
    .click();

  // set relationship type
  await page.getByTestId('relationship-form__type-select').click();
  await page.getByTitle(relationshipType).locator('div').click();

  await page.getByRole('button', { name: 'Submit' }).click();

  await expect(
    page.getByText('Successfully created relationship.'),
  ).toBeVisible();
  await expect(
    page
      .getByTestId(`diagram__model-node__${fromFieldModelDisplayName}`)
      .getByTitle(toFieldModelDisplayName, { exact: true }),
  ).toBeVisible();
};

export const executeRelationshipCRUD = async (
  page: Page,
  {
    fromFieldModelDisplayName,
    fromFieldColumnDisplayName,
    toFieldModelDisplayName,
    toFieldColumnDisplayName,
    relationshipType,
  }: Relationship,
) => {
  await page.goto('/modeling');
  await expect(page).toHaveURL('/modeling', { timeout: 60000 });

  await page
    .getByRole('complementary')
    .getByText(fromFieldModelDisplayName, { exact: true })
    .click();

  // delete relationship
  await page
    .getByTestId(`diagram__model-node__${fromFieldModelDisplayName}`)
    .getByRole('button', { name: 'more' })
    .nth(1)
    .click();
  await page.getByText('Delete', { exact: true }).click();

  // check delete relationship modal open
  await expect(
    page
      .getByRole('dialog')
      .locator('div')
      .filter({
        hasText: 'Are you sure you want to delete this relationship?',
      })
      .nth(1),
  ).toBeVisible();
  await expect(
    page.getByText('Are you sure you want to delete this relationship?'),
  ).toBeVisible();
  await expect(page.getByRole('button', { name: 'Cancel' })).toBeVisible();
  await expect(page.getByRole('button', { name: 'Delete' })).toBeVisible();

  await page.getByRole('button', { name: 'Delete' }).click();

  // check relationship deleted
  await expect(
    page.getByText('Successfully deleted relationship.'),
  ).toBeVisible();
  await expect(
    page
      .getByTestId(`diagram__model-node__${fromFieldModelDisplayName}`)
      .getByTitle(toFieldModelDisplayName, { exact: true }),
  ).toBeHidden();

  // add relationship
  await addRelationship(page, {
    fromFieldModelDisplayName,
    fromFieldColumnDisplayName,
    toFieldModelDisplayName,
    toFieldColumnDisplayName,
    relationshipType: 'One-to-one',
  });

  // update relationship
  await page
    .getByRole('complementary')
    .getByText(fromFieldModelDisplayName, { exact: true })
    .click();
  await page
    .getByTestId(`diagram__model-node__${fromFieldModelDisplayName}`)
    .getByRole('button', { name: 'more' })
    .nth(1)
    .click();

  await page.getByText('Edit').click();
  await expect(
    page
      .locator('div')
      .filter({
        hasText: 'Update relationship',
      })
      .nth(2),
  ).toBeVisible();
  await expect(page.getByText('Update relationship')).toBeVisible();

  await page.getByTestId('relationship-form__type-select').click();
  await page.getByTitle(relationshipType).locator('div').click();

  await page.getByRole('button', { name: 'Submit' }).click();

  // check relationship updated
  await expect(
    page.getByText('Successfully updated relationship.'),
  ).toBeVisible();
};

export const updateModelMetadata = async (
  page: Page,
  {
    modelDisplayName,
    modelDescription,
    newModelDisplayName,
    newModelDescription,
  }: {
    modelDisplayName: string;
    modelDescription: string;
    newModelDisplayName: string;
    newModelDescription: string;
  },
) => {
  await page.goto('/modeling');
  await expect(page).toHaveURL('/modeling', { timeout: 60000 });

  await page
    .getByRole('complementary')
    .getByText(modelDisplayName, { exact: true })
    .click();

  // click node to open metadata drawer
  await page.getByTestId(`diagram__model-node__${modelDisplayName}`).click();

  const modelDescriptionString = modelDescription || '-';
  const newModelDescriptionString = newModelDescription || '-';

  // check metadata drawer info
  await expect(page.locator('.ant-drawer-mask')).toBeVisible();
  await expect(page.getByLabel('Close', { exact: true })).toBeVisible();
  await expect(
    page
      .locator('div.ant-drawer-title')
      .filter({ hasText: new RegExp(`^${modelDisplayName}$`) }),
  ).toBeVisible();
  await expect(
    page.getByRole('cell', { name: 'Name' }).locator('div'),
  ).toHaveText(modelDisplayName);
  await expect(page.getByTestId('metadata__alias').locator('div')).toHaveText(
    modelDisplayName,
  );
  await expect(
    page.getByTestId('metadata__description').locator('div'),
  ).toHaveText(modelDescriptionString);

  // click edit metadata button
  await page.getByRole('button', { name: 'Edit' }).click();

  // check edit metadata modal
  await expect(page.locator('.ant-modal-mask')).toBeVisible();
  await expect(page.locator('div.ant-modal')).toBeVisible();
  await expect(
    page.locator('div.ant-modal-title').filter({ hasText: 'Edit metadata' }),
  ).toBeVisible();
  await expect(
    page.getByLabel('Edit metadata').getByLabel('Close', { exact: true }),
  ).toBeVisible();

  // update metadata process
  // update alias
  await page
    .getByTestId('edit-metadata__alias')
    .getByText(modelDisplayName, { exact: true })
    .click();
  await page.locator('#displayName').press('ControlOrMeta+a');
  await page.locator('#displayName').fill(newModelDisplayName);

  // update description
  await page
    .getByTestId('edit-metadata__description')
    .getByText(modelDescriptionString, { exact: true })
    .click();
  await page.locator('#description').press('ControlOrMeta+a');
  await page.locator('#description').fill(newModelDescription);

  await expect(page.getByRole('button', { name: 'Cancel' })).toBeVisible();
  await expect(page.getByRole('button', { name: 'Submit' })).toBeVisible();
  await page.getByRole('button', { name: 'Submit' }).click();

  // check metadata for metadata drawer
  await expect(
    page.getByText('Successfully updated model metadata.'),
  ).toBeVisible();
  await expect(
    page
      .locator('div.ant-drawer-title')
      .filter({ hasText: new RegExp(`^${newModelDisplayName}$`) }),
  ).toBeVisible();
  await expect(
    page.getByRole('cell', { name: 'Name' }).locator('div').first(),
  ).toHaveText(modelDisplayName);
  await expect(
    page.getByTestId('metadata__name').locator('div').first(),
  ).toHaveText(modelDisplayName);
  await expect(page.getByTestId('metadata__alias').locator('div')).toHaveText(
    newModelDisplayName,
  );
  await expect(
    page.getByTestId('metadata__description').locator('div'),
  ).toHaveText(newModelDescriptionString);

  // close metadata drawer
  await page
    .locator('div.ant-drawer')
    .getByLabel('Close', { exact: true })
    .click();

  // check info for modeling page
  await expect(
    page.getByRole('complementary').getByText(newModelDisplayName),
  ).toBeVisible();
  await page.getByRole('complementary').getByText(newModelDisplayName).click();
  await expect(
    page.getByTestId(`diagram__model-node__${newModelDisplayName}`),
  ).toBeVisible();
};

export const updateViewMetadata = async (
  { page, baseURL }: { page: Page; baseURL: string },
  {
    viewDisplayName,
    viewDescription,
    newViewDisplayName,
    newViewDescription,
  }: {
    viewDisplayName: string;
    viewDescription: string;
    newViewDisplayName: string;
    newViewDescription: string;
  },
) => {
  await page.goto('/modeling');
  await expect(page).toHaveURL('/modeling', { timeout: 60000 });

  // will show '-' if viewDescription is empty string
  const viewDescriptionString = viewDescription || '-';
  const newViewDescriptionString = newViewDescription || '-';

  await page
    .getByRole('complementary')
    .getByText(viewDisplayName, { exact: true })
    .click();

  // click node to open metadata drawer
  await page.getByTestId(`diagram__view-node__${viewDisplayName}`).click();

  // check metadata drawer info
  await expect(page.locator('.ant-drawer-mask')).toBeVisible();
  await expect(page.getByLabel('Close', { exact: true })).toBeVisible();
  await expect(
    page
      .locator('div.ant-drawer-title')
      .filter({ hasText: new RegExp(`^${viewDisplayName}$`) }),
  ).toBeVisible();
  await expect(page.getByRole('button', { name: 'Edit' })).toBeVisible();

  await expect(
    page.getByTestId('metadata__name').getByText(viewDisplayName),
  ).toBeVisible();
  await expect(
    page.getByTestId('metadata__description').getByText(viewDescriptionString),
  ).toBeVisible();

  // click edit metadata button
  await page.getByRole('button', { name: 'Edit' }).click();

  // check edit metadata modal
  await expect(page.locator('.ant-modal-mask')).toBeVisible();
  await expect(page.locator('div.ant-modal')).toBeVisible();
  await expect(
    page.locator('div.ant-modal-title').filter({ hasText: 'Edit metadata' }),
  ).toBeVisible();
  await expect(
    page.getByLabel('Edit metadata').getByLabel('Close', { exact: true }),
  ).toBeVisible();

  // update metadata process
  // update name (view alias name)
  await page
    .getByTestId('edit-metadata__name')
    .getByText(viewDisplayName, { exact: true })
    .click();
  await page.locator('#displayName').fill(newViewDisplayName);

  // update description
  await page
    .getByTestId('edit-metadata__description')
    .getByText(viewDescriptionString, { exact: true })
    .click();
  await page.locator('#description').fill(newViewDescription);

  await expect(page.getByRole('button', { name: 'Cancel' })).toBeVisible();
  await expect(page.getByRole('button', { name: 'Submit' })).toBeVisible();
  await page.getByRole('button', { name: 'Submit' }).click();

  // check metadata for metadata drawer
  await expect(
    page.getByText('Successfully updated view metadata.'),
  ).toBeVisible();
  await expect(
    page
      .locator('div.ant-drawer-title')
      .filter({ hasText: new RegExp(`^${newViewDisplayName}$`) }),
  ).toBeVisible();

  await expect(page.getByTestId('metadata__name').locator('div')).toHaveText(
    newViewDisplayName,
  );
  await expect(
    page.getByTestId('metadata__description').locator('div'),
  ).toHaveText(newViewDescriptionString);

  // close metadata drawer
  await page
    .locator('div.ant-drawer')
    .getByLabel('Close', { exact: true })
    .click();

  // check info for modeling page
  await expect(
    page.getByRole('complementary').getByText(newViewDisplayName),
  ).toBeVisible();
  await page.getByRole('complementary').getByText(newViewDisplayName).click();
  await expect(
    page.getByTestId(`diagram__view-node__${newViewDisplayName}`),
  ).toBeVisible();

  await checkDeployUndeployedChanges({ page, baseURL });
};

export const addCalculatedField = async (
  page: Page,
  {
    calculatedFieldName,
    expression,
    modelDisplayName,
    toFieldModelDisplayName,
    toFieldColumnDisplayName,
  }: {
    calculatedFieldName: string;
    expression: string;
    modelDisplayName: string;
    toFieldModelDisplayName: string;
    toFieldColumnDisplayName: string;
  },
) => {
  // click the model of sidebar to zoom in
  await page
    .getByRole('complementary')
    .getByText(modelDisplayName, { exact: true })
    .click();

  // add calculated field
  await page
    .getByTestId(`diagram__model-node__${modelDisplayName}`)
    .locator('div')
    .filter({ hasText: /^Calculated Fields$/ })
    .getByRole('button')
    .first()
    .click();

  await expect(page.locator('.ant-modal-mask')).toBeVisible();
  await expect(page.locator('div.ant-modal')).toBeVisible();
  await expect(
    page
      .locator('div.ant-modal-title')
      .filter({ hasText: 'Add calculated field' }),
  ).toBeVisible();
  await expect(
    page
      .getByLabel('Add calculated field')
      .getByLabel('Close', { exact: true }),
  ).toBeVisible();

  await page.getByLabel('Name').click();
  await page.getByLabel('Name').fill(calculatedFieldName);

  await page.getByTestId('common__descriptive-select').click();
  await page.getByTitle(expression).locator('div').click();

  await expect(page.getByTestId('common__lineage')).toBeVisible();

  await expect(
    page
      .getByTestId('common__lineage-field-block')
      .getByText(modelDisplayName, { exact: true }),
  ).toBeVisible();

  await page.getByTestId('common__lineage-fields-select').click();

  // for skip disabled item
  await page.getByTestId('common__lineage-fields-select').press('ArrowDown');
  await page
    .getByTestId('common__fields__select-option')
    .filter({ hasText: toFieldModelDisplayName })
    .scrollIntoViewIfNeeded();
  await page
    .getByTestId('common__fields__select-option')
    .filter({ hasText: toFieldModelDisplayName })
    .click();

  await expect(
    page
      .getByTestId('common__lineage-field-block')
      .getByText(toFieldModelDisplayName, { exact: true }),
  ).toHaveCount(2);

  await expect(page.getByText('Please select a field.')).toBeVisible();
  await page.getByTestId('common__lineage-fields-select').last().click();

  await page
    .getByTestId('common__fields__select-option')
    .filter({ hasText: toFieldColumnDisplayName })
    .scrollIntoViewIfNeeded();

  await page
    .getByTestId('common__fields__select-option')
    .filter({ hasText: toFieldColumnDisplayName })
    .click();

  await page.getByRole('button', { name: 'Save' }).click();
  await expect(
    page.getByText('Successfully created calculated field.'),
  ).toBeVisible();
};

export const deleteCalculatedField = async (
  page: Page,
  modelDisplayName: string,
) => {
  // delete calculated field
  await page
    .getByRole('complementary')
    .getByText(modelDisplayName, { exact: true })
    .click();
  await page
    .getByTestId(`diagram__model-node__${modelDisplayName}`)
    .getByRole('button', { name: 'more' })
    .nth(1)
    .click();
  await page.getByText('Delete', { exact: true }).click();
  await page.getByRole('button', { name: 'Delete' }).click();
  await expect(
    page.getByText('Successfully deleted calculated field.'),
  ).toBeVisible();
};
</file>

<file path="e2e/commonTests/onboarding.ts">
import { expect } from '@playwright/test';

export const setupModels = async ({ page }) => {
  await page.goto('/setup/models');

  // select all models
  await page.locator('th').first().click();

  await page.getByRole('button', { name: 'Next' }).click();
  await expect(page).toHaveURL('/setup/relationships', { timeout: 60000 });
};

export const saveRecommendedRelationships = async ({ page }) => {
  await page.goto('/setup/relationships');

  await page.getByRole('button', { name: 'Finish' }).click();
  await expect(page).toHaveURL('/modeling', { timeout: 60000 });
};
</file>

<file path="e2e/config.ts">
import fs from 'fs';
import path from 'path';
import { merge } from 'lodash';

export const testDbConfig = {
  client: 'better-sqlite3',
  connection: 'testdb.sqlite3',
  useNullAsDefault: true,
};

// Replace the default test config with your own e2e.config.json
const defaultTestConfig = {
  bigQuery: {
    projectId: 'wrenai',
    datasetId: 'wrenai.tpch_sf1',
    // The credential file should be under "wren-ui" folder
    credentialPath: 'bigquery-credential-path',
  },
  duckDb: {
    sqlCsvPath: 'https://duckdb.org/data/flights.csv',
  },
  postgreSql: {
    host: 'postgresql-host',
    port: '5432',
    username: 'postgresql-username',
    password: 'postgresql-password',
    database: 'postgresql-database',
    ssl: false,
  },
  mysql: {
    host: 'mysql-host',
    port: '3306',
    username: 'mysql-username',
    password: 'mysql-password',
    database: 'mysql-database',
  },
  sqlServer: {
    host: 'sqlserver-host',
    port: '1433',
    username: 'sqlserver-username',
    password: 'sqlserver-password',
    database: 'sqlserver-database',
  },
  trino: {
    host: 'trino-host',
    port: '8081',
    catalog: 'trino-catalog',
    schema: 'trino-schema',
    username: 'trino-username',
    password: 'trino-password',
  },
  clickhouse: {
    host: 'clickhouse-host',
    port: '8443',
    username: 'clickhouse-username',
    password: 'clickhouse-password',
    database: 'clickhouse-database',
    ssl: false,
  },
  snowflake: {
    username: 'snowflake-username',
    password: 'snowflake-password',
    account: 'snowflake-account',
    database: 'snowflake-database',
    schema: 'snowflake-schema',
  },
};

let userTestConfig = {};
try {
  userTestConfig =
    JSON.parse(
      fs.readFileSync(path.resolve(__dirname, 'e2e.config.json'), 'utf8'),
    ) || {};
} catch (_error: any) {
  console.log('No e2e config file found.');
}

export const getTestConfig = () => {
  return merge(defaultTestConfig, userTestConfig);
};
</file>

<file path="e2e/global.setup.ts">
import { test as setup } from '@playwright/test';
import * as helper from './helper';

setup('create new database', async () => {
  console.log('creating new database...');
  // Initialize the database
  await helper.migrateDatabase();
  console.log('created successfully.');
});
</file>

<file path="e2e/global.teardown.ts">
import { test as setup } from '@playwright/test';
import * as helper from './helper';

setup('delete database', async () => {
  console.log('deleting test database...');
  // Delete the database
  await helper.removeDatabase();
  console.log('deleted successfully.');
});
</file>

<file path="e2e/helper.ts">
import fs from 'fs';
import knex from 'knex';
import { testDbConfig } from './config';
import { Page } from '@playwright/test';

export const migrateDatabase = async () => {
  const db = knex(testDbConfig);
  await db.migrate.latest();
};

export const removeDatabase = async () => {
  const db = knex(testDbConfig);
  await db.migrate.rollback().then(() => db.destroy());
  const isDBFileExist = fs.existsSync(testDbConfig.connection);
  if (isDBFileExist) {
    fs.unlinkSync(testDbConfig.connection);
  }
};

export const resetDatabase = async () => {
  const db = knex(testDbConfig);
  await db.table('project').del();
  await db.table('model').del();
  await db.table('model_column').del();
  await db.table('model_nested_column').del();
  await db.table('relation').del();
  await db.table('thread').del();
  await db.table('thread_response').del();
  await db.table('view').del();

  // insert learning table data to skip guide
  await db.table('learning').insert({
    paths: JSON.stringify(['DATA_MODELING_GUIDE', 'SWITCH_PROJECT_LANGUAGE']),
  });
};

export const waitForGraphQLResponse = async (
  { page }: { page: Page },
  queryKey: string,
  validateResponseData = (data: any) => data !== undefined,
) => {
  await page.waitForResponse(
    async (response) => {
      try {
        const responseBody = await response.json();
        const responseData = responseBody?.data?.[queryKey];

        return (
          response.url().includes('/api/graphql') &&
          response.status() === 200 &&
          responseBody &&
          validateResponseData(responseData)
        );
      } catch (error) {
        console.error('Error fetching response body:', error);
      }
    },
    { timeout: 100000 },
  );
};
</file>

<file path="e2e/README.md">
## How to run e2e test locally

1. Make sure you have start all Wren AI services. ([How to start](https://github.com/Canner/WrenAI/blob/main/docker/README.md#how-to-start))

2. Create a `e2e.config.json` file under `wren-ui/e2e` folder and replace all data sources needed values in `./config.ts`.

   ```ts
   // Replace the default test config with your own e2e.config.json
   const defaultTestConfig = {
     bigQuery: {
       projectId: 'wrenai',
       datasetId: 'wrenai.tpch_sf1',
       // The credential file should be under "wren-ui" folder
       // For example: .tmp/credential.json
       credentialPath: 'bigquery-credential-path',
     },
     duckDb: {
       sqlCsvPath: 'https://duckdb.org/data/flights.csv',
     },
     postgreSql: {
       host: 'postgresql-host',
       port: '5432',
       username: 'postgresql-username',
       password: 'postgresql-password',
       database: 'postgresql-database',
       ssl: false,
     },
     mysql: {
       host: 'mysql-host',
       port: '3306',
       username: 'mysql-username',
       password: 'mysql-password',
       database: 'mysql-database',
     },
     sqlServer: {
       host: 'sqlServer-host',
       port: '1433',
       username: 'sqlServer-username',
       password: 'sqlServer-password',
       database: 'sqlServer-database',
     },
     trino: {
       host: 'trino-host',
       port: '8081',
       catalog: 'trino-catalog',
       schema: 'trino-schema',
       username: 'trino-username',
       password: 'trino-password',
     },
   };
   ```

3. Build UI before starting e2e server

   ```bash
   yarn build
   ```

   > Ensure port 3000 is available for E2E testing. The AI service needs WREN_UI_ENDPOINT to connect to this port for accurate and reliable test results.

4. Run test

   ```bash
   yarn test:e2e
   ```

   Run test with browser open

   ```bash
   yarn test:e2e --headed
   ```

## How to develop

- Write test with interactive UI mode

  ```bash
  yarn test:e2e --ui
  ```

- Write test with debug mode

  ```bash
  yarn test:e2e --debug
  ```

- Generate test scripts

  ```
  npx playwright codegen http://localhost:3000
  ```
</file>

<file path="e2e/specs/connectBigQuery.spec.ts">
import { test, expect } from '@playwright/test';
import { getTestConfig } from '../config';
import * as helper from '../helper';
import * as onboarding from '../commonTests/onboarding';

const testConfig = getTestConfig();

test.describe('Test BigQuery data source', async () => {
  test.beforeAll(async () => {
    await helper.resetDatabase();
  });

  test('Connect BigQuery data source successfully', async ({ page }) => {
    await page.goto('/setup/connection');

    await page.locator('button').filter({ hasText: 'BigQuery' }).click();

    await page.getByLabel('Display name').click();
    await page.getByLabel('Display name').fill('test-bigquery');
    await page.getByLabel('Project ID').click();
    await page.getByLabel('Project ID').fill(testConfig.bigQuery.projectId);
    await page.getByLabel('Dataset ID').click();
    await page.getByLabel('Dataset ID').fill(testConfig.bigQuery.datasetId);

    const fileChooserPromise = page.waitForEvent('filechooser');
    await page
      .locator('button')
      .filter({ hasText: 'Click to upload JSON key file' })
      .click();
    const fileChooser = await fileChooserPromise;
    await fileChooser.setFiles(testConfig.bigQuery.credentialPath);

    await page.getByRole('button', { name: 'Next' }).click();
    await expect(page).toHaveURL('/setup/models', { timeout: 60000 });
  });

  test('Setup all models', onboarding.setupModels);

  test(
    'Save recommended relationships',
    onboarding.saveRecommendedRelationships,
  );
});
</file>

<file path="e2e/specs/connectClickHouse.spec.ts">
import { test, expect } from '@playwright/test';
import { getTestConfig } from '../config';
import * as helper from '../helper';
import * as onboarding from '../commonTests/onboarding';

const testConfig = getTestConfig();

test.describe('Test ClickHouse data source', () => {
  test.beforeAll(async () => {
    await helper.resetDatabase();
  });

  test('Connect ClickHouse data source successfully', async ({ page }) => {
    await page.goto('/setup/connection');

    await page.locator('button').filter({ hasText: 'ClickHouse' }).click();

    await page.getByLabel('Display name').click();
    await page.getByLabel('Display name').fill('test-clickhouse');
    await page.getByLabel('Host').click();
    await page.getByLabel('Host').fill(testConfig.clickhouse.host);
    await page.getByLabel('Port').click();
    await page.getByLabel('Port').fill(testConfig.clickhouse.port);
    await page.getByLabel('Username').click();
    await page.getByLabel('Username').fill(testConfig.clickhouse.username);
    await page.getByLabel('Password').click();
    await page.getByLabel('Password').fill(testConfig.clickhouse.password);
    await page.getByLabel('Database name').click();
    await page.getByLabel('Database name').fill(testConfig.clickhouse.database);

    // Check the "Use SSL" checkbox if needed
    if (testConfig.clickhouse.ssl) {
      await page.getByLabel('Use SSL').click();
    }

    await page.getByRole('button', { name: 'Next' }).click();
    await expect(page).toHaveURL('/setup/models', { timeout: 60000 });
  });

  test('Setup all models', onboarding.setupModels);

  test(
    'Save recommended relationships',
    onboarding.saveRecommendedRelationships,
  );
});
</file>

<file path="e2e/specs/connectDuckDB.spec.ts">
import { test, expect } from '@playwright/test';
import { getTestConfig } from '../config';
import * as helper from '../helper';
import * as onboarding from '../commonTests/onboarding';

const testConfig = getTestConfig();

test.describe('Test DuckDB data source', () => {
  test.beforeAll(async () => {
    await helper.resetDatabase();
  });

  test('Connect DuckDB data source successfully', async ({ page }) => {
    await page.goto('/setup/connection');

    await page.locator('button').filter({ hasText: 'DuckDB' }).click();

    await page.getByLabel('Display name').click();
    await page.getByLabel('Display name').fill('test-duckdb');
    await page.getByLabel('Initial SQL statements').click();
    await page
      .getByLabel('Initial SQL statements')
      .fill(
        `CREATE TABLE ontime AS FROM read_csv('${testConfig.duckDb.sqlCsvPath}');`,
      );
    await page.getByRole('button', { name: 'Next' }).click();
    await expect(page).toHaveURL('/setup/models', { timeout: 60000 });
  });

  test('Setup all models', onboarding.setupModels);

  test(
    'Save recommended relationships',
    onboarding.saveRecommendedRelationships,
  );
});
</file>

<file path="e2e/specs/connectMySQL.spec.ts">
import { test, expect } from '@playwright/test';
import { getTestConfig } from '../config';
import * as helper from '../helper';
import * as onboarding from '../commonTests/onboarding';

const testConfig = getTestConfig();

test.describe('Test MySQL data source', () => {
  test.beforeAll(async () => {
    await helper.resetDatabase();
  });

  test('Connect MySQL data source successfully', async ({ page }) => {
    await page.goto('/setup/connection');

    await page.locator('button').filter({ hasText: 'MySQL' }).click();

    await page.getByLabel('Display name').click();
    await page.getByLabel('Display name').fill('test-mysql');
    await page.getByLabel('Host').click();
    await page.getByLabel('Host').fill(testConfig.mysql.host);
    await page.getByLabel('Port').click();
    await page.getByLabel('Port').fill(testConfig.mysql.port);
    await page.getByLabel('Username').click();
    await page.getByLabel('Username').fill(testConfig.mysql.username);
    await page.getByLabel('Password').click();
    await page.getByLabel('Password').fill(testConfig.mysql.password);
    await page.getByLabel('Database name').click();
    await page.getByLabel('Database name').fill(testConfig.mysql.database);

    await page.getByRole('button', { name: 'Next' }).click();
    await expect(page).toHaveURL('/setup/models', { timeout: 60000 });
  });

  test('Setup all models', onboarding.setupModels);

  test(
    'Save recommended relationships',
    onboarding.saveRecommendedRelationships,
  );
});
</file>

<file path="e2e/specs/connectPostgreSQL.spec.ts">
import { test, expect } from '@playwright/test';
import { getTestConfig } from '../config';
import * as helper from '../helper';
import * as onboarding from '../commonTests/onboarding';

const testConfig = getTestConfig();

test.describe('Test PostgreSQL data source', () => {
  test.beforeAll(async () => {
    await helper.resetDatabase();
  });

  test('Connect PostgreSQL data source successfully', async ({ page }) => {
    await page.goto('/setup/connection');

    await page.locator('button').filter({ hasText: 'PostgreSQL' }).click();

    await page.getByLabel('Display name').click();
    await page.getByLabel('Display name').fill('test-postgresql');
    await page.getByLabel('Host').click();
    await page.getByLabel('Host').fill(testConfig.postgreSql.host);
    await page.getByLabel('Port').click();
    await page.getByLabel('Port').fill(testConfig.postgreSql.port);
    await page.getByLabel('Username').click();
    await page.getByLabel('Username').fill(testConfig.postgreSql.username);
    await page.getByLabel('Password').click();
    await page.getByLabel('Password').fill(testConfig.postgreSql.password);
    await page.getByLabel('Database name').click();
    await page.getByLabel('Database name').fill(testConfig.postgreSql.database);

    // Check the "Use SSL" checkbox if needed
    if (testConfig.postgreSql.ssl) {
      await page.getByLabel('Use SSL').click();
    }

    await page.getByRole('button', { name: 'Next' }).click();
    await expect(page).toHaveURL('/setup/models', { timeout: 60000 });
  });

  test('Setup all models', onboarding.setupModels);

  test(
    'Save recommended relationships',
    onboarding.saveRecommendedRelationships,
  );
});
</file>

<file path="e2e/specs/connectSampleECommerce.spec.ts">
import { test, expect } from '@playwright/test';
import * as helper from '../helper';
import * as homeHelper from '../commonTests/home';
import * as modelingHelper from '../commonTests/modeling';
import { sampleDatasets } from '@/apollo/server/data';

const suggestedQuestions = sampleDatasets.ecommerce.questions;

test.describe('Test E-commerce sample dataset', () => {
  test.beforeAll(async () => {
    await helper.resetDatabase();
  });

  test('Starting E-commerce dataset successfully', async ({ page }) => {
    await page.goto('/setup/connection');
    await page.getByRole('button', { name: 'E-commerce' }).click();
    await expect(page).toHaveURL('/modeling', { timeout: 60000 });
  });

  test('Check suggested questions', async ({ page }) => {
    await page.goto('/home');
    for (const suggestedQuestion of suggestedQuestions) {
      await expect(page.getByText(suggestedQuestion.question)).toBeVisible();
    }
  });

  test(
    'Check deploy status should be in Synced status',
    modelingHelper.checkDeploySynced,
  );

  test('Use suggestion question', async ({ page }) => {
    // select first suggested question
    await homeHelper.askSuggestionQuestionTest({
      page,
      suggestedQuestion: suggestedQuestions[1].question,
    });
  });

  test('Follow up question', async ({ page }) => {
    await homeHelper.followUpQuestionTest({
      page,
      question: suggestedQuestions[2].question,
    });
  });

  test('Model CRUD successfully', async ({ page }) => {
    await modelingHelper.executeModelCRUD(page, {
      modelDisplayName: 'customers',
      modelReferenceName: 'olist_customers_dataset',
      primaryKeyColumn: 'customer_id',
    });
  });

  test('Update model metadata successfully', async ({ page }) => {
    await modelingHelper.updateModelMetadata(page, {
      modelDisplayName: 'olist_customers_dataset',
      modelDescription: '',
      newModelDisplayName: 'customers',
      newModelDescription: '',
    });
  });

  test('Add relationship successfully', async ({ page }) => {
    await page.goto('/modeling');
    await expect(page).toHaveURL('/modeling', { timeout: 60000 });

    // Following the previous test, we assume the customers model is created, and it's have not any relationships
    await modelingHelper.addRelationship(page, {
      fromFieldModelDisplayName: 'customers',
      fromFieldColumnDisplayName: 'customer_id',
      toFieldModelDisplayName: 'orders',
      toFieldColumnDisplayName: 'customer_id',
      relationshipType: 'One-to-many',
    });
  });

  test(
    'Check deploy status should be in Undeployed changes status',
    modelingHelper.checkDeployUndeployedChanges,
  );

  test('Relationship CRUD successfully', async ({ page }) => {
    await modelingHelper.executeRelationshipCRUD(page, {
      fromFieldModelDisplayName: 'customers',
      fromFieldColumnDisplayName: 'customer_id',
      toFieldModelDisplayName: 'orders',
      toFieldColumnDisplayName: 'customer_id',
      relationshipType: 'One-to-many',
    });
  });

  test('Trigger and check deploy MDL successfully', async ({
    page,
    baseURL,
  }) => {
    await modelingHelper.executeDeploy({ page, baseURL });
    await modelingHelper.checkDeploySynced({ page });
  });

  test('Save as view successfully', async ({ page, baseURL }) => {
    await homeHelper.saveAsView(
      { page, baseURL },
      {
        question:
          'What are the total sales values for each quarter of each year?',
        viewName: 'avg review score by city',
      },
    );
  });

  test('Update view metadata successfully', async ({ page, baseURL }) => {
    await modelingHelper.updateViewMetadata(
      { page, baseURL },
      {
        viewDisplayName: 'avg review score by city',
        viewDescription: '',
        newViewDisplayName: 'avg review score per city',
        newViewDescription:
          'Average review score for orders placed by customers in each city.',
      },
    );
  });

  test('Calculated Fields CRUD successfully', async ({ page }) => {
    await page.goto('/modeling');
    await expect(page).toHaveURL('/modeling', { timeout: 60000 });

    const modelDisplayName = 'orders';
    const calculatedFieldName = 'Sum of review scores';
    const expression = 'Sum';
    const toFieldModelDisplayName = 'order reviews';
    const toFieldColumnDisplayName = 'review_score';

    const newCfName = 'total product items';
    const newExpression = 'COUNT';
    const newToFieldModelDisplayName = 'order items';
    const newToFieldColumnDisplayName = 'order_id';

    await modelingHelper.addCalculatedField(page, {
      calculatedFieldName,
      expression,
      modelDisplayName,
      toFieldModelDisplayName,
      toFieldColumnDisplayName,
    });

    // update calculated field
    await page
      .getByTestId(`diagram__model-node__${modelDisplayName}`)
      .getByRole('button', { name: 'more' })
      .nth(1)
      .click();

    await page.getByText('Edit').click();

    await page.getByLabel('Name').click();
    await page.getByLabel('Name').fill(newCfName);

    await page.getByTestId('common__descriptive-select').click();
    await page.getByTitle(newExpression).locator('div').click();

    await page
      .getByTestId('common__lineage-field-block')
      .filter({ hasText: modelDisplayName })
      .getByText(toFieldModelDisplayName, { exact: true })
      .click();

    await page
      .getByTestId('common__fields__select-option')
      .filter({ hasText: newToFieldModelDisplayName })
      .scrollIntoViewIfNeeded();

    await page
      .getByTestId('common__fields__select-option')
      .filter({ hasText: newToFieldModelDisplayName })
      .click();

    await expect(
      page
        .getByTestId('common__lineage-field-block')
        .getByText(newToFieldModelDisplayName, { exact: true }),
    ).toHaveCount(2);
    await expect(page.getByText('Please select a field.')).toBeVisible();
    await page.getByTestId('common__lineage-fields-select').last().click();

    await page
      .getByTestId('common__fields__select-option')
      .filter({ hasText: newToFieldColumnDisplayName })
      .scrollIntoViewIfNeeded();

    await page
      .getByTestId('common__fields__select-option')
      .filter({ hasText: newToFieldColumnDisplayName })
      .click();

    await page.getByRole('button', { name: 'Save' }).click();
    await expect(
      page.getByText('Successfully updated calculated field.'),
    ).toBeVisible();

    // delete calculated field
    await modelingHelper.deleteCalculatedField(page, modelDisplayName);
  });
});
</file>

<file path="e2e/specs/connectSampleHR.spec.ts">
import { test, expect } from '@playwright/test';
import * as helper from '../helper';
import * as homeHelper from '../commonTests/home';
import * as modelingHelper from '../commonTests/modeling';
import { sampleDatasets } from '@/apollo/server/data';

const suggestedQuestions = sampleDatasets.hr.questions;

test.describe('Test HR sample dataset', () => {
  test.beforeAll(async () => {
    await helper.resetDatabase();
  });

  test('Starting HR dataset successfully', async ({ page }) => {
    await page.goto('/setup/connection');
    await page.getByRole('button', { name: 'Human Resource' }).click();
    await expect(page).toHaveURL('/modeling', { timeout: 60000 });
  });

  test('Check suggested questions', async ({ page }) => {
    await page.goto('/home');
    for (const suggestedQuestion of suggestedQuestions) {
      await expect(page.getByText(suggestedQuestion.question)).toBeVisible();
    }
  });

  test('Use suggestion question', async ({ page, baseURL }) => {
    // select first suggested question
    await homeHelper.askSuggestionQuestionTest({
      page,
      suggestedQuestion: suggestedQuestions[1].question,
    });
  });

  test(
    'Check deploy status should be in Synced status',
    modelingHelper.checkDeploySynced,
  );
});
</file>

<file path="e2e/specs/connectSnowflake.spec.ts">
import { test, expect } from '@playwright/test';
import { getTestConfig } from '../config';
import * as helper from '../helper';
import * as onboarding from '../commonTests/onboarding';

const testConfig = getTestConfig();

test.describe('Test Snowflake data source', () => {
  test.beforeAll(async () => {
    await helper.resetDatabase();
  });

  test('Connect Snowflake data source successfully', async ({ page }) => {
    await page.goto('/setup/connection');

    await page.locator('button').filter({ hasText: 'Snowflake' }).click();

    await page.getByLabel('Display name').click();
    await page.getByLabel('Display name').fill('test-snowflake');
    await page.getByLabel('Username').click();
    await page.getByLabel('Username').fill(testConfig.snowflake.username);
    await page.getByLabel('Password').click();
    await page.getByLabel('Password').fill(testConfig.snowflake.password);
    await page.getByLabel('Account').click();
    await page.getByLabel('Account').fill(testConfig.snowflake.account);
    await page.getByLabel('Database name').click();
    await page.getByLabel('Database name').fill(testConfig.snowflake.database);
    await page.getByLabel('Schema').click();
    await page.getByLabel('Schema').fill(testConfig.snowflake.schema);

    await page.getByRole('button', { name: 'Next' }).click();
    await expect(page).toHaveURL('/setup/models', { timeout: 60000 });
  });

  test('Setup all models', onboarding.setupModels);

  test(
    'Save recommended relationships',
    onboarding.saveRecommendedRelationships,
  );
});
</file>

<file path="e2e/specs/connectSQLServer.spec.ts">
import { test, expect } from '@playwright/test';
import { getTestConfig } from '../config';
import * as helper from '../helper';
import * as onboarding from '../commonTests/onboarding';

const testConfig = getTestConfig();

test.describe('Test SQL Server data source', () => {
  test.beforeAll(async () => {
    await helper.resetDatabase();
  });

  test('Connect SQL Server data source successfully', async ({ page }) => {
    await page.goto('/setup/connection');

    await page.locator('button').filter({ hasText: 'SQL Server' }).click();

    await page.getByLabel('Display name').click();
    await page.getByLabel('Display name').fill('test-sqlServer');
    await page.getByLabel('Host').click();
    await page.getByLabel('Host').fill(testConfig.sqlServer.host);
    await page.getByLabel('Port').click();
    await page.getByLabel('Port').fill(testConfig.sqlServer.port);
    await page.getByLabel('Username').click();
    await page.getByLabel('Username').fill(testConfig.sqlServer.username);
    await page.getByLabel('Password').click();
    await page.getByLabel('Password').fill(testConfig.sqlServer.password);
    await page.getByLabel('Database name').click();
    await page.getByLabel('Database name').fill(testConfig.sqlServer.database);

    await page.getByRole('button', { name: 'Next' }).click();
    await expect(page).toHaveURL('/setup/models', { timeout: 60000 });
  });

  test('Setup all models', onboarding.setupModels);

  test(
    'Save recommended relationships',
    onboarding.saveRecommendedRelationships,
  );
});
</file>

<file path="e2e/specs/connectTrino.spec.ts">
import { test, expect } from '@playwright/test';
import { getTestConfig } from '../config';
import * as helper from '../helper';
import * as onboarding from '../commonTests/onboarding';

const testConfig = getTestConfig();

test.describe('Test Trino data source', () => {
  test.beforeAll(async () => {
    await helper.resetDatabase();
  });

  test('Connect Trino data source successfully', async ({ page }) => {
    await page.goto('/setup/connection');

    await page.locator('button').filter({ hasText: 'Trino' }).click();

    await page.getByLabel('Display name').click();
    await page.getByLabel('Display name').fill('test-trino');
    await page.getByLabel('Host').click();
    await page.getByLabel('Host').fill(testConfig.trino.host);
    await page.getByLabel('Port').click();
    await page.getByLabel('Port').fill(testConfig.trino.port);
    await page.getByLabel('Catalog').click();
    await page.getByLabel('Catalog').fill(testConfig.trino.catalog);
    await page.getByLabel('Schema').click();
    await page.getByLabel('Schema').fill(testConfig.trino.schema);
    await page.getByLabel('Username').click();
    await page.getByLabel('Username').fill(testConfig.trino.username);
    await page.getByLabel('Password').click();
    await page.getByLabel('Password').fill(testConfig.trino.password);

    await page.getByRole('button', { name: 'Next' }).click();
    await expect(page).toHaveURL('/setup/models', { timeout: 60000 });
  });

  test('Setup all models', onboarding.setupModels);

  test(
    'Save recommended relationships',
    onboarding.saveRecommendedRelationships,
  );
});
</file>

<file path="jest.config.js">
/** @type {import('ts-jest').JestConfigWithTsJest} */
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  moduleNameMapper: {
    '^@server/(.*)$': '<rootDir>/src/apollo/server/$1',
  },
  modulePathIgnorePatterns: ['<rootDir>/e2e/'],
};
</file>

<file path="knexfile.js">
// Update with your config settings.

/**
 * @type { Object.<string, import("knex").Knex.Config> }
 */
if (process.env.DB_TYPE === 'pg') {
  console.log('Using Postgres');
  module.exports = {
    client: 'pg',
    connection: process.env.PG_URL,
  };
} else {
  console.log('Using SQLite');
  module.exports = {
    client: 'better-sqlite3',
    connection: process.env.SQLITE_FILE || './db.sqlite3',
    useNullAsDefault: true,
  };
}
</file>

<file path="migrations/20240125070643_create_project_table.js">
/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.up = function (knex) {
  return knex.schema.createTable('project', (table) => {
    table.increments('id').comment('ID');
    table
      .string('type')
      .comment(
        'project datasource type. ex: bigquery, mysql, postgresql, mongodb, etc',
      );
    table.string('display_name').comment('project display name');
    table
      .text('credentials')
      .nullable()
      .comment('database connection credentials');

    // bq
    table
      .string('project_id')
      .nullable()
      .comment('gcp project id, big query specific');
    table.string('dataset_id').nullable().comment('big query datasetId');

    // duckdb
    table
      .jsonb('init_sql')
      .nullable()
      .comment('init sql for establishing duckdb environment');
    // knex jsonb ref: https://knexjs.org/guide/schema-builder.html#json
    table
      .jsonb('extensions')
      .nullable()
      .comment(
        'duckdb extensions, will be a array-like string like, eg: ["extension1", "extension2"]',
      );
    table
      .jsonb('configurations')
      .nullable()
      .comment(
        'duckdb configurations that can be set in session, eg: { "key1": "value1", "key2": "value2" }',
      );

    // not sure to store or not, the catalog & schema in the manifest
    table.string('catalog').comment('catalog name');
    table.string('schema').comment('');

    // sample datset
    table.string('sample_dataset').nullable().comment('sample dataset name');

    table.timestamps(true, true);
  });
};

/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.down = function (knex) {
  return knex.schema.dropTable('project');
};
</file>

<file path="migrations/20240125071855_create_model_table.js">
/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.up = function (knex) {
  return knex.schema
    .createTable('model', (table) => {
      table.increments('id').comment('ID');
      table.integer('project_id').comment('Reference to project.id');

      // basic info
      table.string('display_name').comment('the model display name');
      table
        .string('source_table_name')
        .comment(
          'referenced table name in the datasource, can not be duplicated in the same project',
        );
      table
        .string('reference_name')
        .comment(
          'the name used in MDL structure, should be unique between models in the same project',
        );
      table.text('ref_sql').comment('Reference SQL');

      // cache setting
      table.boolean('cached').comment('model is cached or not');
      table
        .string('refresh_time')
        .comment(
          'contain a number followed by a time unit (ns, us, ms, s, m, h, d). For example, "2h"',
        )
        .nullable();

      // model properties
      table
        .text('properties')
        .comment(
          'model properties, a json string, the description and displayName should be stored here',
        )
        .nullable();

      table.timestamps(true, true);
    })
    .then(() =>
      knex.schema.table('model', (table) => {
        // Explicitly add unique constraint to avoid using the deprecated signature
        table.unique(['project_id', 'source_table_name'], {
          indexName: 'project_id_source_table_name_unique',
          storageEngineIndexType: 'BTREE', // This line is optional and can be adjusted based on your DB's engine
        });
        table.unique(['project_id', 'reference_name'], {
          indexName: 'project_id_reference_name_unique',
          storageEngineIndexType: 'BTREE', // This line is optional and can be adjusted based on your DB's engine
        });
      }),
    );
};

/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.down = function (knex) {
  return knex.schema.dropTable('model');
};
</file>

<file path="migrations/20240125081244_create_model_column_table.js">
/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.up = function (knex) {
  return knex.schema
    .createTable('model_column', (table) => {
      table.increments('id').comment('ID');
      table.integer('model_id').comment('Reference to model ID');
      // column name
      table.boolean('is_calculated').comment('Is calculated field');

      table.string('display_name').comment('Display name of the column');
      table
        .string('source_column_name')
        .comment('the column name in the datasource');
      table
        .string('reference_name')
        .comment('The name used in the MDL structure and query');

      // aggregation
      table
        .text('aggregation')
        .comment(
          'Expression for the column, could be custom field or calculated field expression, eg: sum, aggregate',
        )
        .nullable();
      table
        .text('lineage')
        .comment(
          'the selected field in calculated field, array of ids, [relationId 1, relationId 2, columnId], last one should be columnId, while others are relationId',
        )
        .nullable();
      table
        .text('diagram')
        .comment('for FE to store the calculated field diagram')
        .nullable();

      table
        .string('type')
        .comment('Data type, refer to the column type in the datasource')
        .nullable();
      table.boolean('not_null').comment('Is not null');
      // is primary key
      table.boolean('is_pk').comment('Is primary key of the table');
      table
        .text('properties')
        .comment(
          'column properties, a json string, the description and displayName should be stored here',
        )
        .nullable();

      table.timestamps(true, true);
    })
    .then(() =>
      knex.schema.table('model_column', (table) => {
        // Explicitly add unique constraint to avoid using the deprecated signature
        table.unique(['model_id', 'source_column_name'], {
          indexName: 'model_id_source_column_name_unique',
          storageEngineIndexType: 'BTREE', // This line is optional and can be adjusted based on your DB's engine
        });
        table.unique(['model_id', 'reference_name'], {
          indexName: 'model_id_reference_name_unique',
          storageEngineIndexType: 'BTREE', // This line is optional and can be adjusted based on your DB's engine
        });
      }),
    );
};

/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.down = function (knex) {
  return knex.schema.dropTable('model_column');
};
</file>

<file path="migrations/20240125083821_create_relation_table.js">
/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.up = function (knex) {
  return knex.schema.createTable('relation', (table) => {
    table.increments('id').comment('ID');
    table.integer('project_id').comment('Reference to project.id');
    table.string('name').comment('relation name').unique();
    table
      .string('join_type')
      .comment('join type, eg:"ONE_TO_ONE", "ONE_TO_MANY", "MANY_TO_ONE"');
    table
      .integer('from_column_id')
      .comment('from column id, "{fromColumn} {joinType} {toSideColumn}"');
    table
      .integer('to_column_id')
      .comment('to column id, "{fromColumn} {joinType} {toSideColumn}"');
    table.timestamps(true, true);
  });
};

/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.down = function (knex) {
  return knex.schema.dropTable('relation');
};
</file>

<file path="migrations/20240125085655_create_metrics_table.js">
/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.up = function (knex) {
  return knex.schema.createTable('metric', (table) => {
    table.increments('id').comment('ID');
    table.integer('project_id').comment('Reference to project.id');
    table.string('name').comment('metric name');
    table.string('type').comment('metric type, ex: "simple" or "cumulative"');

    // cache setting
    table.boolean('cached').comment('model is cached or not');
    table
      .string('refresh_time')
      .comment(
        'contain a number followed by a time unit (ns, us, ms, s, m, h, d). For example, "2h"',
      )
      .nullable();

    // metric can based on model or another metric
    table.integer('model_id').comment('Reference to model.id').nullable();
    table.integer('metric_id').comment('Reference to metric.id').nullable();
    table
      .text('properties')
      .comment(
        'metric properties, a json string, the description and displayName should be stored here',
      )
      .nullable();
    table.timestamps(true, true);
  });
};

/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.down = function (knex) {
  return knex.schema.dropTable('metric');
};
</file>

<file path="migrations/20240126100753_create_metrics_measure_table.js">
/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.up = function (knex) {
  // name string
  // expression string
  // granularity string, nullable

  return knex.schema.createTable('metric_measure', (table) => {
    table.increments('id').comment('ID');
    table.integer('metric_id').comment('Reference to metric ID');
    table.string('name').comment('Measure name');
    table
      .text('expression')
      .comment('Expression for the measure')
      .comment(
        'the expression of measure, eg: "Sum", "Everage", or customize expression',
      );
    table
      .string('granularity')
      .comment(
        'Granularity for the measure, eg: "day", "hour", "minute", "year"',
      )
      .nullable();
    table.timestamps(true, true);
  });
};

/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.down = function (knex) {
  return knex.schema.dropTable('metric_measure');
};
</file>

<file path="migrations/20240129021453_create_view_table.js">
/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.up = function (knex) {
  return knex.schema.createTable('view', (table) => {
    table.increments('id').comment('ID');
    table.integer('project_id').comment('Reference to project.id');

    // basic info
    table.string('name').comment('the view name');
    table.text('statement').comment('the sql statement of this view');

    // cache setting
    table.boolean('cached').comment('view is cached or not');
    table
      .string('refresh_time')
      .comment(
        'contain a number followed by a time unit (ns, us, ms, s, m, h, d). For example, "2h"',
      )
      .nullable();

    // view properties
    table
      .text('properties')
      .comment(
        'view properties, a json string, the description and displayName should be stored here',
      )
      .nullable();
    table.timestamps(true, true);
  });
};

/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.down = function (knex) {
  return knex.schema.dropTable('view');
};
</file>

<file path="migrations/20240319083758_create_deploy_table.js">
/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.up = function (knex) {
  return knex.schema.createTable('deploy_log', (table) => {
    table.increments('id').comment('ID');
    table.integer('project_id').comment('Reference to project.id');

    // basic info
    table.jsonb('manifest').comment('the deployed manifest');
    table.string('hash').comment('the hash of the manifest');

    // status
    table.string('status').nullable().comment('deploy status');
    table.string('error').nullable().comment('deploy error message');

    // timestamps
    table.timestamps(true, true);
  });
};

/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.down = function (knex) {
  return knex.schema.dropTable('deploy_log');
};
</file>

<file path="migrations/20240327030000_create_ask_table.js">
/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.up = function (knex) {
  return knex.schema
    .createTable('thread', (table) => {
      table.increments('id').comment('ID');
      table.integer('project_id').comment('Reference to project.id');
      table.string('sql').comment('the sql statement of this thread');
      table.text('summary').comment('the summary of the thread');

      // timestamps
      table.timestamps(true, true);
    })
    .createTable('thread_response', (table) => {
      table.increments('id').comment('ID');
      table.integer('thread_id').comment('Reference to thread.id');
      table.foreign('thread_id').references('thread.id').onDelete('CASCADE');

      // query id from AI service
      table.string('query_id').comment('the query id generated by AI service');

      // response from AI service
      table.text('question').comment('the question of the response');
      table.string('status').comment('the status of the response');
      table.jsonb('detail').nullable().comment('the detail of the response');
      table.jsonb('error').nullable().comment('the error message if any');

      // timestamps
      table.timestamps(true, true);
    });
};

/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.down = function (knex) {
  return knex.schema.dropTable('thread_response').dropTable('thread');
};
</file>

<file path="migrations/20240418000000_update_project_table_pg.js">
/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
// add pg related columns to project table
exports.up = function (knex) {
  return knex.schema.alterTable('project', (table) => {
    // pg
    table
      .string('host')
      .nullable()
      .comment('postgresql host, postgresql specific');
    table
      .integer('port')
      .nullable()
      .comment('postgresql port, postgresql specific');
    table
      .string('database')
      .nullable()
      .comment('postgresql database, postgresql specific');
    table
      .string('user')
      .nullable()
      .comment('postgresql user, postgresql specific');
  });
};

/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.down = function (knex) {
  return knex.schema.alterTable('project', (table) => {
    table.dropColumns('host', 'port', 'database', 'user');
  });
};
</file>

<file path="migrations/20240419090558_add_foreign_key_to_model_column_and_metric_measure.js">
/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.up = function (knex) {
  return knex.schema
    .alterTable('model_column', (table) => {
      table.foreign('model_id').references('model.id').onDelete('CASCADE');
    })
    .alterTable('metric_measure', (table) => {
      table.foreign('metric_id').references('metric.id').onDelete('CASCADE');
    });
};

/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.down = function (knex) {
  return knex.schema
    .alterTable('model_column', (table) => {
      table.dropForeign('model_id');
    })
    .alterTable('metric_measure', (table) => {
      table.dropForeign('metric_id');
    });
};
</file>

<file path="migrations/20240425000000_add_thread_response_summary.js">
/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
// add summary column to thread_response table
exports.up = function (knex) {
  return knex.schema.alterTable('thread_response', (table) => {
    table
      .string('summary')
      .nullable()
      .comment('the summary of the thread response');
  });
};

/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.down = function (knex) {
  return knex.schema.alterTable('thread_response', (table) => {
    table.dropColumns('summary');
  });
};
</file>

<file path="migrations/20240430033014_update_model_column_table.js">
/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.up = function (knex) {
  // Drop this column FE is no longer using it.
  return knex.schema.table('model_column', function (table) {
    table.dropColumn('diagram');
  });
};

/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.down = function (knex) {
  return knex.schema.table('model_column', function (table) {
    table
      .text('diagram')
      .comment('for FE to store the calculated field diagram')
      .nullable();
  });
};
</file>

<file path="migrations/20240446090560_update_relationship_table.js">
/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.up = function (knex) {
  return knex.schema
    .alterTable('relation', (table) => {
      table
        .foreign('from_column_id')
        .references('model_column.id')
        .onDelete('CASCADE');
    })
    .alterTable('relation', (table) => {
      table
        .foreign('to_column_id')
        .references('model_column.id')
        .onDelete('CASCADE');
    });
};

/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.down = function (knex) {
  return knex.schema
    .alterTable('relation', (table) => {
      table.dropForeign('from_column_id');
    })
    .alterTable('relation', (table) => {
      table.dropForeign('to_column_id');
    });
};
</file>

<file path="migrations/20240502000000_add_properties_to_relationship.js">
/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
// add properties column to relation table
exports.up = function (knex) {
  return knex.schema.alterTable('relation', (table) => {
    table
      .text('properties')
      .comment(
        'column properties, a json string, the description of relationships should be stored here',
      )
      .nullable();
  });
};

/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.down = function (knex) {
  return knex.schema.alterTable('relation', (table) => {
    table.dropColumns('properties');
  });
};
</file>

<file path="migrations/20240524044348_update_project_table.js">
/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.up = async function (knex, Promise) {
  await knex.schema.alterTable('project', (table) => {
    table.text('init_sql').alter();
  });
};

/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.down = async function (knex, Promise) {
  // without rollback script, can not revert text to jsonb in postgres
  // init sql should be string, not jsonb
};
</file>

<file path="migrations/20240524071859_update_thread_table.js">
/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.up = async function (knex, promise) {
  // drop foreign key constraint before altering column type to prevent data loss
  await knex.schema.alterTable('thread_response', (table) => {
    table.dropForeign('thread_id');
  });
  await knex.schema.alterTable('thread', (table) => {
    table.text('sql').alter();
  });
  await knex.schema.alterTable('thread_response', (table) => {
    table.foreign('thread_id').references('thread.id').onDelete('CASCADE');
  });
};

/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.down = async function (knex, promise) {
  await knex.schema.alterTable('thread_response', (table) => {
    table.dropForeign('thread_id');
  });
  await knex.schema.alterTable('thread', (table) => {
    table.string('sql').alter();
  });
  await knex.schema.alterTable('thread_response', (table) => {
    table.foreign('thread_id').references('thread.id').onDelete('CASCADE');
  });
};
</file>

<file path="migrations/20240530062133_update_project_table.js">
/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */

// create connectionInfo column in project table
exports.up = function (knex) {
  return knex.schema.table('project', (table) => {
    table
      .jsonb('connection_info')
      .nullable()
      .comment('Connection information for the project');
  });
};

/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.down = function (knex) {
  return knex.schema.table('project', (table) => {
    table.dropColumn('connection_info');
  });
};
</file>

<file path="migrations/20240530062809_transfer_project_table_data.js">
/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.up = async function (knex) {
  const projects = await knex('project').select('*');

  // bigquery data
  const bigqueryConnectionInfo = projects
    .filter((project) => project.type === 'BIG_QUERY')
    .map((project) => {
      return {
        id: project.id,
        connectionInfo: {
          projectId: project.project_id,
          datasetId: project.dataset_id,
          credentials: project.credentials,
        },
      };
    });

  // duckdb data
  const duckdbConnectionInfo = projects
    .filter((project) => project.type === 'DUCKDB')
    .map((project) => {
      return {
        id: project.id,
        connectionInfo: {
          initSql: project.init_sql || '',
          configurations: project.configurations || {},
          extensions: project.extensions || [],
        },
      };
    });

  // postgres data
  const postgresConnectionInfo = projects
    .filter((project) => project.type === 'POSTGRES')
    .map((project) => {
      const ssl =
        project.configurations && project.configurations.ssl ? true : false;
      return {
        id: project.id,
        connectionInfo: {
          host: project.host,
          port: project.port,
          database: project.database,
          user: project.user,
          password: project.credentials,
          ssl,
        },
      };
    });

  // update project table
  for (const project of [
    ...bigqueryConnectionInfo,
    ...duckdbConnectionInfo,
    ...postgresConnectionInfo,
  ]) {
    const { id, connectionInfo } = project;
    if (process.env.DB_TYPE === 'pg') {
      // postgres
      await knex('project')
        .where({ id })
        .update({ connection_info: connectionInfo });
    } else {
      // sqlite
      await knex('project')
        .where({ id })
        .update({ connection_info: JSON.stringify(connectionInfo) });
    }
  }
};

/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.down = async function (knex) {
  await knex('project').update({ connection_info: null });
};
</file>

<file path="migrations/20240530105955_drop_project_table_columns.js">
/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.up = function (knex) {
  return knex.schema.table('project', (table) => {
    table.dropColumn('configurations');
    table.dropColumn('credentials');
    table.dropColumn('project_id');
    table.dropColumn('dataset_id');
    table.dropColumn('init_sql');
    table.dropColumn('extensions');
    table.dropColumn('host');
    table.dropColumn('port');
    table.dropColumn('database');
    table.dropColumn('user');
  });
};

/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.down = function (knex) {
  return knex.schema.table('project', (table) => {
    table
      .jsonb('configurations')
      .nullable()
      .comment(
        'duckdb configurations that can be set in session, eg: { "key1": "value1", "key2": "value2" }',
      );
    table
      .text('credentials')
      .nullable()
      .comment('database connection credentials');
    table
      .string('project_id')
      .nullable()
      .comment('gcp project id, big query specific');
    table.string('dataset_id').nullable().comment('big query datasetId');
    table.text('init_sql');
    table
      .jsonb('extensions')
      .nullable()
      .comment(
        'duckdb extensions, will be a array-like string like, eg: ["extension1", "extension2"]',
      );
    table
      .string('host')
      .nullable()
      .comment('postgresql host, postgresql specific');
    table
      .integer('port')
      .nullable()
      .comment('postgresql port, postgresql specific');
    table
      .string('database')
      .nullable()
      .comment('postgresql database, postgresql specific');
    table
      .string('user')
      .nullable()
      .comment('postgresql user, postgresql specific');
  });
};
</file>

<file path="migrations/20240531085916_transfer_model_properties.js">
/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.up = async function (knex) {
  const projects = await knex('project').select('*');
  const models = await knex('model').select('*');
  console.log(`model len:${models.length}`);
  for (const model of models) {
    const project = projects.find((p) => p.id === model.project_id);
    const dataSourceType = project.type;
    // get schema & catalog if its available
    let schema = null;
    let catalog = null;
    let table = null;
    switch (dataSourceType) {
      case 'BIG_QUERY': {
        const connectionInfo =
          typeof project.connection_info === 'string'
            ? JSON.parse(project.connection_info)
            : project.connection_info;
        const datasetId = connectionInfo.datasetId;
        if (!datasetId) continue;
        const splitDataSetId = datasetId.split('.');
        schema = splitDataSetId[1];
        catalog = splitDataSetId[0];
        table = model.source_table_name;
        break;
      }
      case 'POSTGRES': {
        const connectionInfo =
          typeof project.connection_info === 'string'
            ? JSON.parse(project.connection_info)
            : project.connection_info;
        catalog = connectionInfo.database;
        schema = model.source_table_name.split('.')[0];
        table = model.source_table_name.split('.')[1];
        break;
      }
      case 'DUCKDB': {
        // already have schema & catalog in properties
        table = model.source_table_name;
        break;
      }
    }
    const oldProperties = model.properties ? JSON.parse(model.properties) : {};
    const newProperties = {
      schema,
      catalog,
      table,
      ...oldProperties,
    };
    await knex('model')
      .where({ id: model.id })
      .update({ properties: JSON.stringify(newProperties) });
  }
};

/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.down = function () {
  return Promise.resolve();
};
</file>

<file path="migrations/20240610070534_create_schema_change_table.js">
/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.up = function (knex) {
  return knex.schema.createTable('schema_change', (table) => {
    table.increments('id').comment('ID');
    table.integer('project_id').comment('Reference to project.id');

    // schema change info
    table.jsonb('change').nullable();
    table.jsonb('resolve').nullable();

    // timestamps
    table.timestamps(true, true);
  });
};

/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.down = function (knex) {
  return knex.schema.dropTable('schema_change');
};
</file>

<file path="migrations/20240928165009_create_model_nested_column.js">
/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.up = function (knex) {
  return knex.schema.createTable('model_nested_column', (table) => {
    table.increments('id').comment('ID');
    table.integer('model_id').comment('Reference to model ID');
    table.integer('column_id').comment('Reference to column ID');
    table
      .string('column_path')
      .comment(
        'The path of the nested column, array of strings, [sourceColumnName..sourceColumnName(n)]',
      );

    table.string('display_name').comment('Display name of the nested column');
    table
      .string('source_column_name')
      .comment('the nested column name in the datasource');
    table
      .string('reference_name')
      .comment('The name used in the MDL structure and query');
    table
      .string('type')
      .comment('Data type, refer to the nested column type in the datasource')
      .nullable();
    table
      .text('properties')
      .comment(
        'nested column properties, a json string, the description should be stored here',
      )
      .nullable();

    table
      .foreign('column_id')
      .references('model_column.id')
      .onDelete('CASCADE');
    table.timestamps(true, true);
  });
};

/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.down = function (knex) {
  return knex.schema.dropTable('model_nested_column');
};
</file>

<file path="migrations/20241021073019_update_project_language.js">
/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.up = function (knex) {
  return knex.schema.alterTable('project', (table) => {
    table
      .string('language')
      .comment('The project language applied to AI')
      .defaultTo('EN');
  });
};

/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.down = function (knex) {
  return knex.schema.alterTable('project', (table) => {
    table.dropColumn('language');
  });
};
</file>

<file path="migrations/20241029092204_create_learning_table.js">
/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.up = function (knex) {
  return knex.schema.createTable('learning', (table) => {
    table.increments('id').comment('ID');
    table.string('user_id').comment('The user uuid.');
    table
      .text('paths')
      .comment(
        'The learning paths of user, array of learning stories, [enum1, enum2, ..enum(n)].',
      );
  });
};

/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.down = function (knex) {
  return knex.schema.dropTable('learning');
};
</file>

<file path="migrations/20241106232204_update_project_table.js">
/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.up = function (knex) {
  return knex.schema.alterTable('project', (table) => {
    table
      .jsonb('questions')
      .nullable()
      .comment('The recommended questions generated by AI');
    table
      .string('query_id')
      .nullable()
      .comment('The query id of the recommended question pipeline');
    table
      .string('questions_status')
      .nullable()
      .comment('The status of the recommended question pipeline');
    table
      .jsonb('questions_error')
      .nullable()
      .comment('The error of the recommended question pipeline');
  });
};

/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.down = function (knex) {
  return knex.schema.alterTable('project', (table) => {
    table.dropColumn('questions');
    table.dropColumn('query_id');
    table.dropColumn('questions_status');
    table.dropColumn('questions_error');
  });
};
</file>

<file path="migrations/20241107171828_update_thread_table.js">
/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.up = function (knex) {
  return knex.schema.alterTable('thread', (table) => {
    table
      .jsonb('questions')
      .nullable()
      .comment('The recommended questions generated by AI');
    table
      .string('query_id')
      .nullable()
      .comment('The query id of the recommended question pipeline');
    table
      .string('questions_status')
      .nullable()
      .comment('The status of the recommended question pipeline');
    table
      .jsonb('questions_error')
      .nullable()
      .comment('The error of the recommended question pipeline');
  });
};

/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.down = function (knex) {
  return knex.schema.alterTable('thread', (table) => {
    table.dropColumn('questions');
    table.dropColumn('query_id');
    table.dropColumn('questions_status');
    table.dropColumn('questions_error');
  });
};
</file>

<file path="migrations/20241115031024_drop_thread_response_table_column.js">
/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.up = function (knex) {
  return knex.schema.alterTable('thread_response', function (table) {
    table.dropColumn('summary');
  });
};

/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.down = function (knex) {
  return knex.schema.alterTable('thread_response', function (table) {
    table
      .string('summary')
      .nullable()
      .comment('the summary of the thread response');
  });
};
</file>

<file path="migrations/20241207000000_update_thread_response_for_answer.js">
const constructCteSql = (steps) => {
  // if empty, return empty string
  if (steps.length === 0) {
    return '';
  }

  // if there's only one step, return the sql directly
  if (steps.length === 1) {
    return steps[0].sql;
  }

  let sql = 'WITH ';
  steps.forEach((step, index) => {
    if (index === steps.length - 1) {
      // if it's the last step, remove the trailing comma.
      // no need to wrap with WITH
      sql += `${step.sql}`;
    } else if (index === steps.length - 2) {
      // if it's the last two steps, remove the trailing comma.
      // wrap with CTE
      sql += `${step.cteName} AS`;
      sql += `(${step.sql})`;
    } else {
      // if it's not the last step, wrap with CTE
      sql += `${step.cteName} AS`;
      sql += `(${step.sql}),`;
    }
  });

  return sql;
};

/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.up = async function (knex) {
  await knex.schema.alterTable('thread_response', (table) => {
    table.renameColumn('detail', 'breakdown_detail');
    table
      .text('sql')
      .nullable()
      .comment('the SQL query generated by AI service');
    table
      .jsonb('answer_detail')
      .defaultTo('{}')
      .comment('AI generated text-based answer detail');
    table
      .integer('view_id')
      .nullable()
      .comment('the view ID associated with the response');
  });

  const threadResponses = await knex('thread_response').select(
    'id',
    'query_id',
    'status',
    'breakdown_detail',
    'error',
  );

  for (const response of threadResponses) {
    let errorDetail;
    try {
      errorDetail = JSON.parse(response.error);
    } catch (_e) {
      errorDetail = null;
    }

    let breakdownDetail;
    try {
      breakdownDetail = JSON.parse(response.breakdown_detail);
    } catch (_e) {
      breakdownDetail = {};
    }

    const updatedDetail = {
      queryId: response.query_id,
      status: response.status,
      error: errorDetail,
      ...breakdownDetail,
    };

    await knex('thread_response')
      .where('id', response.id)
      .update({
        sql: constructCteSql(breakdownDetail?.steps || []),
        breakdown_detail: JSON.stringify(updatedDetail),
        answer_detail: null,
        view_id: breakdownDetail.viewId || null,
      });
  }

  await knex.schema.alterTable('thread_response', (table) => {
    table.dropColumn('query_id');
    table.dropColumn('status');
    table.dropColumn('error');
  });
};

/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.down = async function (knex) {
  await knex.schema.alterTable('thread_response', (table) => {
    table.string('query_id').comment('the query id generated by AI service');
    table.string('status').comment('the status of the response');
    table.jsonb('error').nullable().comment('the error message if any');
    table.dropColumn('sql');
    table.dropColumn('answer_detail');
  });

  const threadResponses = await knex('thread_response')
    .select('id', 'breakdown_detail', 'view_id')
    .whereNotNull('breakdown_detail');

  for (const response of threadResponses) {
    // Parse the breakdown_detail field from the response
    let detail;
    try {
      detail = JSON.parse(response.breakdown_detail);
    } catch (_e) {
      detail = {};
    }

    // Convert the error detail to a string
    let errorString;
    try {
      errorString = JSON.stringify(detail.error);
    } catch (_e) {
      errorString = null;
    }

    // Update the thread_response table with the parsed details
    await knex('thread_response')
      .where('id', response.id)
      .update({
        query_id: detail.queryId,
        status: detail.status,
        error: errorString,
        breakdown_detail: JSON.stringify({
          ...detail,
          viewId: response.view_id,
          queryId: undefined,
          status: undefined,
          error: undefined,
        }),
      });
  }

  await knex.schema.alterTable('thread_response', (table) => {
    table.dropColumn('view_id');
    table.renameColumn('breakdown_detail', 'detail');
  });
};
</file>

<file path="migrations/20241210072534_update_thread_response_table.js">
/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.up = function (knex) {
  return knex.schema.alterTable('thread_response', (table) => {
    table.jsonb('chart_detail').nullable();
  });
};

/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.down = function (knex) {
  return knex.schema.alterTable('thread_response', (table) => {
    table.dropColumn('chart_detail');
  });
};
</file>

<file path="migrations/20241226135712_remove_thread_sql.js">
/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.up = async function (knex) {
  // drop foreign key constraint before altering column type to prevent data loss
  await knex.schema.alterTable('thread_response', (table) => {
    table.dropForeign('thread_id');
  });
  await knex.schema.alterTable('thread', (table) => {
    table.dropColumn('sql');
  });
  await knex.schema.alterTable('thread_response', (table) => {
    table.foreign('thread_id').references('thread.id').onDelete('CASCADE');
  });
};

/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.down = async function (knex) {
  await knex.schema.alterTable('thread', (table) => {
    table.text('sql').nullable();
  });
};
</file>

<file path="migrations/20250102074255_create_dashboard_table.js">
/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.up = async function (knex) {
  await knex.schema.createTable('dashboard', (table) => {
    table.increments('id').primary();
    table
      .integer('project_id')
      .notNullable()
      .comment('Reference to project.id');
    table.string('name').notNullable().comment('The dashboard name');

    table.foreign('project_id').references('project.id').onDelete('CASCADE');
    table.index(['project_id']);
    table.timestamps(true, true);
  });

  await knex.transaction(async (trx) => {
    // select all existing projects, should be only one project though
    const projects = await knex('project').forUpdate();
    if (projects.length > 0) {
      const dashboards = projects.map((project) => ({
        project_id: project.id,
        name: 'Dashboard',
      }));
      await trx('dashboard').insert(dashboards);
    }
  });
};

/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.down = function (knex) {
  return knex.schema.dropTable('dashboard');
};
</file>

<file path="migrations/20250102074256_create_dashboard_item_table.js">
/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.up = function (knex) {
  return knex.schema.createTable('dashboard_item', (table) => {
    table.increments('id').primary();
    table
      .integer('dashboard_id')
      .notNullable()
      .comment('Reference to dashboard.id');
    table
      .string('type')
      .notNullable()
      .comment(
        'The chart type of the dashboard item, such as: bar, table, number, etc',
      );
    table
      .jsonb('layout')
      .notNullable()
      .comment(
        'The layout of the dashboard item, according to which library it is, such as: { x: 0, y: 0, w: 6, h: 6 }',
      );
    table
      .jsonb('detail')
      .notNullable()
      .comment(
        'The detail of the dashboard item, such as: { chartSchema: {...}, sql: "..." } ',
      );

    table
      .foreign('dashboard_id')
      .references('dashboard.id')
      .onDelete('CASCADE');
    table.index(['dashboard_id', 'type']);
    table.timestamps(true, true);
  });
};

/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.down = function (knex) {
  return knex.schema.dropTable('dashboard_item');
};
</file>

<file path="migrations/20250102074256_create_sql_pair_table.js">
/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.up = function (knex) {
  return knex.schema.createTable('sql_pair', (table) => {
    table.increments('id').primary();
    table
      .integer('project_id')
      .notNullable()
      .comment('Reference to project.id');
    table.text('sql').notNullable();
    table.string('question', 1000).notNullable();
    table.timestamps(true, true);

    table.foreign('project_id').references('id').inTable('project');
  });
};

/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.down = function (knex) {
  return knex.schema.dropTable('sql_pair');
};
</file>

<file path="migrations/20250311046282_create_instruction_table.js">
/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.up = function (knex) {
  return knex.schema.createTable('instruction', (table) => {
    table.increments('id').primary();
    table
      .integer('project_id')
      .notNullable()
      .comment('Reference to project.id');
    table.text('instruction').notNullable().comment('The instruction text');
    table.jsonb('questions').notNullable().comment('The questions array');
    table
      .boolean('is_default')
      .notNullable()
      .comment('Whether this instruction should be used in each asking');
    table.timestamps(true, true);

    table.foreign('project_id').references('project.id').onDelete('CASCADE');
  });
};

/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.down = function (knex) {
  return knex.schema.dropTable('instruction');
};
</file>

<file path="migrations/20250320074256_alter_sql_pair_table.js">
/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.up = function (knex) {
  return knex.schema.alterTable('sql_pair', (table) => {
    // Drop the existing foreign key constraint
    table.dropForeign('project_id');

    // Add the foreign key constraint with onDelete CASCADE
    table
      .foreign('project_id')
      .references('id')
      .inTable('project')
      .onDelete('CASCADE');
  });
};

/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.down = function (knex) {
  return knex.schema.alterTable('sql_pair', (table) => {
    // Drop the foreign key constraint with CASCADE
    table.dropForeign('project_id');

    // Restore the original foreign key constraint without CASCADE
    table.foreign('project_id').references('id').inTable('project');
  });
};
</file>

<file path="migrations/20250422000000_alter_dashboard_table.js">
/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.up = function (knex) {
  return knex.schema.alterTable('dashboard', function (table) {
    table.boolean('cache_enabled').defaultTo(true);
    table.string('schedule_frequency').nullable().defaultTo('NEVER'); // Weekly, Daily, Custom, Never
    table.string('schedule_cron').nullable().defaultTo(null); // cron expression string
    table.string('schedule_timezone').nullable().defaultTo(null);
    table.timestamp('next_scheduled_at').nullable().defaultTo(null); // Next scheduled run timestamp
  });
};

/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.down = function (knex) {
  return knex.schema.alterTable('dashboard', function (table) {
    table.dropColumn('cache_enabled');
    table.dropColumn('schedule_frequency');
    table.dropColumn('schedule_cron');
    table.dropColumn('schedule_timezone');
    table.dropColumn('next_scheduled_at');
  });
};
</file>

<file path="migrations/20250423000000_create_dashboard_cache_refresh_table.js">
exports.up = function (knex) {
  return knex.schema.createTable('dashboard_item_refresh_job', (table) => {
    table.increments('id').primary();
    table.string('hash').notNullable().comment('uuid for the refresh job');
    table.integer('dashboard_id').notNullable();
    table.integer('dashboard_item_id').notNullable();
    table.timestamp('started_at').notNullable();
    table.timestamp('finished_at');
    table.string('status').notNullable(); // 'success', 'failed', 'in_progress'
    table.text('error_message');
    table.timestamps(true, true);

    // Foreign keys
    table
      .foreign('dashboard_id')
      .references('id')
      .inTable('dashboard')
      .onDelete('CASCADE');
    table
      .foreign('dashboard_item_id')
      .references('id')
      .inTable('dashboard_item')
      .onDelete('CASCADE');

    // Indexes
    table.index(['dashboard_id', 'created_at']);
    table.index(['dashboard_item_id', 'created_at']);
    table.index('status');
    table.index('hash');
  });
};

exports.down = function (knex) {
  return knex.schema.dropTable('dashboard_item_refresh_job');
};
</file>

<file path="migrations/20250509000000_create_asking_task.js">
/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.up = function (knex) {
  return knex.schema.createTable('asking_task', (table) => {
    table.increments('id').primary();
    table.string('query_id').notNullable().unique();
    table.text('question');
    table.jsonb('detail').defaultTo('{}');

    table
      .integer('thread_id')
      .references('id')
      .inTable('thread')
      .onDelete('CASCADE');

    table
      .integer('thread_response_id')
      .references('id')
      .inTable('thread_response')
      .onDelete('CASCADE');

    table.timestamps(true, true);
  });
};

/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.down = function (knex) {
  return knex.schema.dropTable('asking_task');
};
</file>

<file path="migrations/20250509000001_add_task_id_to_thread.js">
/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.up = function (knex) {
  return knex.schema.alterTable('thread_response', (table) => {
    table
      .integer('asking_task_id')
      .nullable()
      .references('id')
      .inTable('asking_task')
      .onDelete('SET NULL');
  });
};

/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.down = function (knex) {
  return knex.schema.alterTable('thread_response', (table) => {
    table.dropForeign('asking_task_id');
    table.dropColumn('asking_task_id');
  });
};
</file>

<file path="migrations/20250510000000_add_adjustment_to_thread_response.js">
/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.up = function (knex) {
  return knex.schema.alterTable('thread_response', (table) => {
    table
      .jsonb('adjustment')
      .nullable()
      .comment(
        'Adjustment data for thread response, including type and payload',
      );
  });
};

/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.down = function (knex) {
  return knex.schema.alterTable('thread_response', (table) => {
    table.dropColumn('adjustment');
  });
};
</file>

<file path="migrations/20250510000001_alter_dashboard_item_table.js">
/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.up = function (knex) {
  return knex.schema.alterTable('dashboard_item', (table) => {
    table
      .string('display_name')
      .comment('Display name of the dashboard item')
      .nullable();
  });
};

/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.down = function (knex) {
  return knex.schema.alterTable('dashboard_item', (table) => {
    table.dropColumn('display_name');
  });
};
</file>

<file path="migrations/20250510000002_add_version_to_project.js">
/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.up = function (knex) {
  return knex.schema.alterTable('project', (table) => {
    table
      .string('version')
      .nullable()
      .comment('data source version information');
  });
};

/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.down = function (knex) {
  return knex.schema.alterTable('project', (table) => {
    table.dropColumn('version');
  });
};
</file>

<file path="migrations/20250511000000-create-api-history.js">
/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.up = function (knex) {
  return knex.schema.createTable('api_history', (table) => {
    table.string('id').primary();

    // Project
    table.integer('project_id').notNullable();
    table
      .foreign('project_id')
      .references('id')
      .inTable('project')
      .onDelete('CASCADE');

    // Thread
    table.string('thread_id');

    // API Type
    table.string('api_type').notNullable();

    // Request
    table.jsonb('headers');
    table.jsonb('request_payload');

    // Response
    table.jsonb('response_payload');

    // Result
    table.integer('status_code').notNullable();
    table.integer('duration_ms').notNullable();
    table.timestamps(true, true);
  });
};

/**
 * @param { import("knex").Knex } knex
 * @returns { Promise<void> }
 */
exports.down = function (knex) {
  return knex.schema.dropTable('api_history');
};
</file>

<file path="next-env.d.ts">
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/pages/building-your-application/configuring/typescript for more information.
</file>

<file path="next.config.js">
/* eslint-disable @typescript-eslint/no-var-requires */
const path = require('path');
const withLess = require('next-with-less');
const withBundleAnalyzer = require('@next/bundle-analyzer')({
  enabled: process.env.ANALYZE === 'true',
});

const resolveAlias = {
  antd$: path.resolve(__dirname, 'src/import/antd'),
};

/** @type {import('next').NextConfig} */
const nextConfig = withLess({
  output: 'standalone',
  staticPageGenerationTimeout: 1000,
  compiler: {
    // Enables the styled-components SWC transform
    styledComponents: {
      displayName: true,
      ssr: true,
    },
  },
  lessLoaderOptions: {
    additionalData: `@import "@/styles/antd-variables.less";`,
  },
  webpack: (config) => {
    config.resolve.alias = {
      ...config.resolve.alias,
      ...resolveAlias,
    };
    return config;
  },
  // routes redirect
  async redirects() {
    return [
      {
        source: '/setup',
        destination: '/setup/connection',
        permanent: true,
      },
    ];
  },
});

module.exports = withBundleAnalyzer(nextConfig);
</file>

<file path="openapi.yaml">
openapi: 3.0.0
info:
  title: WrenAI API
  description: Restful API for interacting with Wren AI
  version: 1.0.0
servers:
  - url: /api/v1
    description: WrenAI API v1
paths:
  /generate_sql:
    post:
      summary: Generate SQL from natural language
      description: Converts a natural language question into a SQL query
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required:
                - question
              properties:
                question:
                  type: string
                  description: The natural language question to convert to SQL
                threadId:
                  type: string
                  description: Optional thread ID to maintain conversation context
                language:
                  type: string
                  description: Optional language override for AI responses. If not provided, will use the project's default language. Affects error messages and explanation responses. The format is not strictly enforced, but it is recommended to follow the language list in RFC 5646 (check https://gist.github.com/msikma/8912e62ed866778ff8cd for reference).
                returnSqlDialect:
                  type: boolean
                  description: Whether to return the SQL dialect in the response. If true, the SQL returned will be in the dialect of the database.
                  default: false
      responses:
        '200':
          description: Successfully generated SQL
          content:
            application/json:
              schema:
                type: object
                properties:
                  id:
                    type: string
                    description: The unique identifier for the response
                  sql:
                    type: string
                    description: The generated SQL statement
                  threadId:
                    type: string
                    description: ID of the thread (existing or newly created)
                example:
                  id: "1fbc0d64-1c58-45b2-a990-9183bbbcf913"
                  sql: "SELECT * FROM \"olist_customers_dataset\""
                  threadId: "9c537507-9cec-46ed-b877-07bfa6322bed"
        '400':
          description: Bad request or unable to generate SQL
          content:
            application/json:
              schema:
                allOf:
                  - $ref: '#/components/schemas/ErrorResponse'
                  - type: object
                    properties:
                      explanationQueryId:
                        type: string
                        description: ID that can be used with the /stream_explanation endpoint to get a detailed explanation for non-SQL queries
                example:
                  id: "75c13d09-6f86-4e79-a00e-a4f85f73f2d7"
                  code: "NON_SQL_QUERY"
                  error: "User asks about Wren AI's features and capabilities, unrelated to database schema."
                  explanationQueryId: "71b016c5-42bb-4897-82d6-46f9b0bf7d94"
  /run_sql:
    post:
      summary: Execute SQL and return results
      description: Runs a SQL query and returns the results as structured data
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required:
                - sql
              properties:
                sql:
                  type: string
                  description: The SQL query to execute
                threadId:
                  type: string
                  description: Optional thread ID for conversation context
                limit:
                  type: integer
                  description: Maximum number of rows to return
                  default: 1000
      responses:
        '200':
          description: Successfully executed SQL
          content:
            application/json:
              schema:
                type: object
                properties:
                  records:
                    type: array
                    description: Array of records, each represented as an object
                    items:
                      type: object
                  columns:
                    type: array
                    description: Metadata about the result columns
                    items:
                      $ref: '#/components/schemas/ColumnMetadata'
                  threadId:
                    type: string
                    description: ID of the thread (existing or newly created)
                  totalRows:
                    type: integer
                    description: The total number of rows returned
                example:
                  id: "09d46224-0068-4ca3-bce4-f1fc85093eb6"
                  records: [
                    {
                      "customer_id": "00012a2ce6f8dcda20d059ce98491703",
                      "customer_unique_id": "248ffe10d632bebe4f7267f1f44844c9",
                      "customer_zip_code_prefix": "06273",
                      "customer_city": "osasco",
                      "customer_state": "SP"
                    },
                    {
                      "customer_id": "000161a058600d5901f007fab4c27140",
                      "customer_unique_id": "b0015e09bb4b6e47c52844fab5fb6638",
                      "customer_zip_code_prefix": "35550",
                      "customer_city": "itapecerica",
                      "customer_state": "MG"
                    },
                    "... additional records truncated for brevity ..."
                  ]
                  columns: [
                    {
                      "name": "customer_id",
                      "type": "VARCHAR"
                    },
                    {
                      "name": "customer_unique_id",
                      "type": "VARCHAR"
                    },
                    {
                      "name": "customer_zip_code_prefix",
                      "type": "VARCHAR"
                    },
                    {
                      "name": "customer_city",
                      "type": "VARCHAR"
                    },
                    {
                      "name": "customer_state",
                      "type": "VARCHAR"
                    }
                  ]
                  threadId: "503a8ca5-8171-43b5-b45b-86de2849467b"
                  totalRows: 10
        '400':
          description: Bad request or SQL execution error
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ErrorResponse'
        '405':
          description: Method not allowed
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ErrorResponse'
  /generate_vega_chart:
    post:
      summary: Generate Vega visualization chart spec
      description: Generates a Vega chart spec for data visualization from a question and SQL query
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required:
                - question
                - sql
              properties:
                question:
                  type: string
                  description: The natural language question
                sql:
                  type: string
                  description: The SQL query that produces the data to visualize
                threadId:
                  type: string
                  description: Optional thread ID for conversation context
                sampleSize:
                  type: integer
                  description: Maximum number of rows to include in the visualization
                  default: 10000
      responses:
        '200':
          description: Successfully generated Vega specification
          content:
            application/json:
              schema:
                type: object
                properties:
                  vegaSpec:
                    type: object
                    description: The Vega specification with embedded data
                  threadId:
                    type: string
                    description: ID of the thread (existing or newly created)
                example:
                  threadId: "75ab23c8-9124-4560-a125-fbe7e321dcba"
                  vegaSpec: {
                    "$schema": "https://vega.github.io/schema/vega-lite/v5.json",
                    "config": {
                      "mark": {
                        "tooltip": true
                      },
                      "font": "Roboto, Arial, Noto Sans, sans-serif",
                      "padding": {
                        "top": 30,
                        "bottom": 20,
                        "left": 0,
                        "right": 0
                      },
                      "title": {
                        "color": "#262626",
                        "fontSize": 14
                      },
                      "axis": {
                        "labelFontSize": 10,
                        "gridColor": "#d9d9d9",
                        "titleColor": "#434343",
                        "labelColor": "#65676c"
                      },
                      "axisX": {
                        "labelAngle": -45
                      },
                      "bar": {
                        "color": "#1570EF"
                      }
                    },
                    "title": "Total Payments by Customer State",
                    "data": {
                      "values": [
                        {
                          "customer_state": "PR",
                          "total_payment_value": 811156.38
                        },
                        {
                          "customer_state": "BA",
                          "total_payment_value": 616645.82
                        }
                      ]
                    },
                    "mark": {
                      "type": "bar"
                    },
                    "width": "container",
                    "height": "container",
                    "encoding": {
                      "x": {
                        "field": "customer_state",
                        "type": "nominal",
                        "title": "Customer State"
                      },
                      "y": {
                        "field": "total_payment_value",
                        "type": "quantitative",
                        "title": "Total Payment Value"
                      },
                      "color": {
                        "field": "customer_state",
                        "type": "nominal",
                        "title": "Customer State"
                      }
                    }
                  }
        '400':
          description: Bad request or specification generation error
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ErrorResponse'
  /stream_explanation:
    get:
      summary: Stream an explanation
      description: Streams an explanation for a non-SQL query using server-sent events
      parameters:
        - name: queryId
          in: query
          description: The query ID to stream results from
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Stream of explanation events
          content:
            text/event-stream:
              schema:
                type: string
                description: Server-sent events stream with explanation chunks
              example: |
                data: {"message":"Wren AI is "}

                data: {"message":"designed to "}

                data: {"message":"help you analyze "}

                data: {"message":"your data with "}

                data: {"message":"natural language queries. I can "}

                data: {"message":"provide insights about "}

                data: {"message":"your business data and "}

                data: {"message":"create visualizations."}

                data: {"done":true}
        '500':
          description: Internal server error
components:
  schemas:
    ErrorResponse:
      type: object
      properties:
        id:
          type: string
          description: Unique identifier for the error response
        error:
          type: string
          description: Error message
        code:
          type: string
          description: Error code
    ColumnMetadata:
      type: object
      properties:
        name:
          type: string
          description: Column name
        type:
          type: string
          description: Data type of the column
        notNull:
          type: boolean
          description: Whether the column allows null values
        properties:
          type: object
          description: Additional column properties
</file>

<file path="package.json">
{
  "name": "wren-ui",
  "version": "0.29.2",
  "private": true,
  "scripts": {
    "dev": "TZ=UTC next dev",
    "build": "NODE_OPTIONS=--max-old-space-size=8192 next build",
    "start": "TZ=UTC next start",
    "lint": "yarn check-types && next lint",
    "test": "jest",
    "test:e2e": "npx playwright install chromium && npx playwright test",
    "check-types": "tsc --noEmit",
    "migrate": "yarn knex migrate:latest",
    "rollback": "yarn knex migrate:rollback",
    "generate-gql": "yarn graphql-codegen --config codegen.yaml"
  },
  "dependencies": {
    "@google-cloud/bigquery": "^6.0.3",
    "@google-cloud/storage": "^6.10.1",
    "apollo-server-micro": "^3.10.2",
    "axios": "^1.8.4",
    "bcryptjs": "^2.4.3",
    "better-sqlite3": "^9.4.3",
    "cron-parser": "^5.1.1",
    "graphql": "^16.6.0",
    "graphql-type-json": "^0.3.2",
    "knex": "^3.1.0",
    "lodash": "^4.17.21",
    "log4js": "^6.9.1",
    "micro": "^9.4.1",
    "micro-cors": "^0.1.1",
    "next": "14.2.26",
    "pg": "^8.8.0",
    "pg-cursor": "^2.7.4",
    "posthog-node": "^4.3.2",
    "sql-formatter": "^15.3.0",
    "uuid": "^11.1.0"
  },
  "devDependencies": {
    "@apollo/client": "^3.6.9",
    "@graphql-codegen/cli": "2.12.0",
    "@graphql-codegen/introspection": "2.2.1",
    "@graphql-codegen/near-operation-file-preset": "^2.4.1",
    "@graphql-codegen/typescript": "2.7.3",
    "@graphql-codegen/typescript-operations": "^2.5.3",
    "@graphql-codegen/typescript-react-apollo": "3.3.3",
    "@next/bundle-analyzer": "^15.3.0",
    "@playwright/test": "^1.44.0",
    "@testing-library/react": "14.0.0",
    "@types/jest": "29.4.4",
    "@types/lodash": "^4.14.202",
    "@types/micro-cors": "^0.1.5",
    "@types/node": "18.16.9",
    "@types/pg": "^8.6.5",
    "@types/pg-cursor": "^2.7.0",
    "@types/react": "18.2.0",
    "@types/react-dom": "18.2.0",
    "@types/react-grid-layout": "^1.3.5",
    "@types/styled-components": "5.1.26",
    "@typescript-eslint/eslint-plugin": "6.18.0",
    "@typescript-eslint/parser": "6.18.0",
    "ace-builds": "^1.32.3",
    "antd": "4.20.4",
    "clsx": "^2.1.1",
    "cron-parser": "^5.1.1",
    "dayjs": "^1.11.11",
    "driver.js": "^1.3.1",
    "duckdb": "^0.10.1",
    "duckdb-async": "^0.10.0",
    "eslint": "^8",
    "eslint-config-next": "14.2.21",
    "eslint-config-prettier": "^9.1.0",
    "eslint-plugin-prettier": "^5.1.3",
    "jest": "29.4.3",
    "less": "^4.2.0",
    "less-loader": "^12.2.0",
    "next-with-less": "^3.0.1",
    "posthog-js": "^1.205.0",
    "prettier": "^3.2.5",
    "react": "18.2.0",
    "react-ace": "^10.1.0",
    "react-dom": "18.2.0",
    "react-grid-layout": "^1.5.0",
    "react-markdown": "^9.0.1",
    "reactflow": "11.10.3",
    "remark-gfm": "^4.0.0",
    "styled-components": "5.3.6",
    "styled-icons": "^10.47.0",
    "ts-essentials": "^9.1.2",
    "ts-jest": "29.1.1",
    "ts-node": "9.1.1",
    "typescript": "5.2.2",
    "vega": "^5.31.0",
    "vega-embed": "^6.29.0",
    "vega-lite": "^5.21.0"
  },
  "resolutions": {
    "ws": "8.17.1",
    "axios": "1.8.4"
  },
  "_moduleAliases": {
    "@server": "src/apollo/server"
  },
  "packageManager": "yarn@4.5.3"
}
</file>

<file path="playwright.config.ts">
import { defineConfig, devices } from '@playwright/test';

export default defineConfig({
  // Look for test files in the "tests" directory, relative to this configuration file.
  testDir: 'e2e',

  // Each test is given 60 seconds.
  timeout: 1 * 60 * 1000,

  // Fail the build on CI if you accidentally left test.only in the source code.
  forbidOnly: false,

  // Retry on CI only.
  retries: 0,

  // Opt out of parallel tests on CI.
  workers: 1,

  // Reporter to use
  reporter: 'html',

  use: {
    // Base URL to use in actions like `await page.goto('/')`.
    baseURL: 'http://127.0.0.1:3000',

    // Collect trace when retrying the failed test.
    trace: 'on-first-retry',
  },
  // Configure projects for major browsers.
  projects: [
    {
      name: 'setup db',
      testMatch: /global\.setup\.ts/,
      teardown: 'cleanup db',
    },
    {
      name: 'cleanup db',
      testMatch: /global\.teardown\.ts/,
    },
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
      dependencies: ['setup db'],
    },
  ],
  // Run your local dev server before starting the tests.
  webServer: {
    command: 'NODE_ENV=test yarn start -p 3000',
    url: 'http://127.0.0.1:3000',
    reuseExistingServer: true,
  },
});
</file>

<file path="public/images/dataSource/athena.svg">
<svg width="40" height="40" viewBox="0 0 40 40" fill="none" xmlns="http://www.w3.org/2000/svg">
<g clip-path="url(#clip0_418_361)">
<path d="M35 5H5V35H35V5Z" fill="url(#paint0_linear_418_361)"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M19.3606 15.21C21.0452 15.21 21.9679 15.5874 22.1362 15.7767C21.9679 15.966 21.0452 16.3434 19.3606 16.3434C17.676 16.3434 16.7533 15.966 16.5851 15.7767C16.7533 15.5874 17.676 15.21 19.3606 15.21ZM19.169 18.2309C19.1072 18.1992 19.0636 18.1361 19.0636 18.0613C19.0636 17.9562 19.1485 17.8705 19.2523 17.8705C19.2825 17.8705 19.31 17.8792 19.3357 17.8924L19.169 18.2309ZM21.3378 21.3466C21.3099 21.3692 21.2459 21.4131 21.1141 21.466C20.9969 21.5128 20.858 21.5551 20.7006 21.5921C20.2822 21.6904 19.7678 21.7444 19.252 21.7444C18.1238 21.7444 17.3377 21.5007 17.1684 21.3496L16.6685 16.6815C17.4349 16.9951 18.5638 17.099 19.3606 17.099C20.1441 17.099 21.2485 16.9981 22.0145 16.6967L21.7156 18.7496C21.1524 18.5373 20.4497 18.229 19.7838 17.9049C19.7161 17.6699 19.5051 17.4968 19.2523 17.4968C18.9456 17.4968 18.6963 17.7503 18.6963 18.0613C18.6963 18.3729 18.9456 18.6261 19.2523 18.6261C19.3249 18.6261 19.3941 18.611 19.4574 18.5853C20.3879 19.0447 21.0813 19.3393 21.6032 19.5211L21.3378 21.3466ZM15.8269 15.8175L16.4295 21.4437C16.472 22.4879 19.1373 22.5 19.252 22.5C19.8226 22.5 20.3965 22.4388 20.8681 22.3285C21.0612 22.2831 21.2362 22.2295 21.3877 22.1687C21.8276 21.9919 22.0584 21.7508 22.0744 21.4527L22.3253 19.7285C22.4961 19.7636 22.6357 19.7791 22.747 19.7791C23.0972 19.7791 23.1895 19.6355 23.2532 19.5366C23.3202 19.4323 23.3395 19.3042 23.3083 19.1754C23.2368 18.8792 22.8188 18.4893 22.5396 18.2577L22.8925 15.8319L22.8891 15.8315C22.8906 15.813 22.8966 15.7956 22.8966 15.7767C22.8966 14.7329 20.6738 14.4544 19.3606 14.4544C18.0475 14.4544 15.8247 14.7329 15.8247 15.7767C15.8247 15.7907 15.8295 15.8032 15.8303 15.8171L15.8269 15.8175ZM19.1883 12.5224C22.4325 12.5224 25.0718 15.2013 25.0718 18.4942C25.0718 21.7871 22.4325 24.4661 19.1883 24.4661C15.9438 24.4661 13.3045 21.7871 13.3045 18.4942C13.3045 15.2013 15.9438 12.5224 19.1883 12.5224ZM9.86941 20.6881V21.4437H13.2193V21.3991C14.2901 23.6561 16.5598 25.2216 19.1883 25.2216C22.8426 25.2216 25.8162 22.2038 25.8162 18.4942C25.8162 14.7846 22.8426 11.7668 19.1883 11.7668C16.345 11.7668 13.9216 13.5968 12.9822 16.1545H9.86941V16.9101H12.7536C12.6375 17.3963 12.5694 17.9007 12.5638 18.4213H9.125V19.1769H12.5943C12.6468 19.7017 12.7648 20.2056 12.9293 20.6881H9.86941ZM30.155 29.7631C29.7046 30.221 28.9237 30.2237 28.4737 29.7673L24.4747 25.7079C25.1183 25.2209 25.6926 24.6463 26.185 24.0036L30.1594 28.057C30.3831 28.2844 30.5063 28.5874 30.5056 28.9097C30.5052 29.2327 30.3809 29.5353 30.155 29.7631ZM30.6865 27.5236L26.6231 23.3788C27.5238 21.9711 28.0494 20.2944 28.0494 18.4942C28.0494 13.5345 24.0743 9.5 19.1883 9.5C15.6773 9.5 12.4935 11.6074 11.0765 14.8689L11.7576 15.1734C13.0555 12.1861 15.9721 10.2556 19.1883 10.2556C23.6641 10.2556 27.305 13.9512 27.305 18.4942C27.305 23.0368 23.6641 26.7328 19.1883 26.7328C16.1984 26.7328 13.459 25.0717 12.0383 22.3976L11.3832 22.7565C12.9334 25.6754 15.9244 27.4884 19.1883 27.4884C20.8967 27.4884 22.4931 26.9939 23.8476 26.1401L27.9478 30.3019C28.3118 30.6714 28.796 30.875 29.3104 30.875C29.8278 30.875 30.315 30.6699 30.6805 30.2985C31.0468 29.929 31.2493 29.4363 31.25 28.9108C31.2511 28.3861 31.0505 27.8934 30.6865 27.5236Z" fill="white"/>
</g>
<defs>
<linearGradient id="paint0_linear_418_361" x1="5" y1="3005" x2="3005" y2="5" gradientUnits="userSpaceOnUse">
<stop stop-color="#4D27A8"/>
<stop offset="1" stop-color="#A166FF"/>
</linearGradient>
<clipPath id="clip0_418_361">
<rect width="30" height="30" fill="white" transform="translate(5 5)"/>
</clipPath>
</defs>
</svg>
</file>

<file path="public/images/dataSource/bigQuery.svg">
<svg width="40" height="40" viewBox="0 0 40 40" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M26.9098 25.8489L24.6874 23.6213C24.6632 23.5965 24.6355 23.5755 24.6051 23.5588C25.5504 22.3412 25.9959 20.809 25.8509 19.2743C25.7058 17.7396 24.9811 16.318 23.8244 15.299C22.6677 14.2801 21.166 13.7405 19.6253 13.7901C18.0846 13.8398 16.6207 14.475 15.5321 15.5664C14.4434 16.6578 13.8118 18.1231 13.7659 19.664C13.72 21.2048 14.2633 22.7051 15.2851 23.8594C16.3069 25.0136 17.7303 25.7348 19.2653 25.8761C20.8003 26.0174 22.3315 25.5681 23.5468 24.6198C23.5626 24.6485 23.5825 24.6748 23.6056 24.6979L25.8332 26.9255C25.8987 26.9909 25.9874 27.0276 26.0799 27.0276C26.1723 27.0276 26.261 26.9909 26.3265 26.9255L26.9098 26.3422C26.9752 26.2767 27.0119 26.188 27.0119 26.0956C27.0119 26.0031 26.9752 25.9144 26.9098 25.8489ZM19.8124 24.4083C18.911 24.4084 18.0298 24.1412 17.2803 23.6405C16.5308 23.1398 15.9466 22.428 15.6016 21.5953C15.2566 20.7625 15.1663 19.8462 15.3421 18.9621C15.518 18.078 15.952 17.2659 16.5894 16.6285C17.2268 15.9912 18.0389 15.5571 18.9229 15.3813C19.807 15.2055 20.7234 15.2957 21.5561 15.6407C22.3889 15.9857 23.1006 16.5699 23.6014 17.3195C24.1021 18.069 24.3693 18.9502 24.3692 19.8516C24.369 21.06 23.8889 22.219 23.0344 23.0735C22.1799 23.9281 21.0209 24.4082 19.8124 24.4083ZM16.8994 19.6083V21.4917C17.1895 22.0036 17.6093 22.4307 18.1171 22.7286V19.5969L16.8994 19.6083ZM19.178 18.0469V23.1364C19.5806 23.2106 19.9932 23.2106 20.3957 23.1364V18.0469H19.178ZM22.701 21.4875V20.3719H21.4843V22.7156C21.9914 22.4185 22.4113 21.9931 22.702 21.4823L22.701 21.4875Z" fill="white"/>
<g clip-path="url(#clip0_731_3720)">
<path d="M10.8749 33.6438L3.62388 21.0844C3.23638 20.4135 3.23638 19.5865 3.62388 18.9156L10.8749 6.35677C11.2619 5.68646 11.9765 5.27344 12.7499 5.2724H27.2588C28.0296 5.27605 28.7405 5.68907 29.126 6.35677L36.376 18.9156C36.7635 19.5865 36.7635 20.4135 36.376 21.0844L29.1249 33.6438C28.7379 34.3141 28.0234 34.7271 27.2499 34.7281H12.7447C11.9723 34.7255 11.2603 34.3125 10.8734 33.6438H10.8749Z" fill="#4386FA"/>
<path opacity="0.1" d="M24.5295 15.9557C24.5295 15.9557 26.5451 20.7906 23.7972 23.5312C21.0493 26.2718 16.0457 24.5177 16.0457 24.5177L26.2238 34.7239H27.2571C28.0311 34.7229 28.7457 34.3093 29.1321 33.6395L33.9321 25.3281L24.5295 15.9557Z" fill="black"/>
<path d="M26.9098 25.8489L24.6874 23.6213C24.6632 23.5965 24.6355 23.5755 24.6051 23.5588C25.5504 22.3412 25.996 20.809 25.8509 19.2743C25.7058 17.7396 24.9811 16.318 23.8244 15.299C22.6677 14.2801 21.166 13.7405 19.6253 13.7901C18.0846 13.8398 16.6207 14.475 15.5321 15.5664C14.4434 16.6578 13.8118 18.1231 13.7659 19.664C13.72 21.2048 14.2633 22.7051 15.2851 23.8594C16.3069 25.0136 17.7303 25.7348 19.2653 25.8761C20.8003 26.0174 22.3315 25.5681 23.5468 24.6198C23.5626 24.6485 23.5825 24.6748 23.6056 24.6979L25.8332 26.9255C25.8987 26.9909 25.9874 27.0276 26.0799 27.0276C26.1723 27.0276 26.261 26.9909 26.3265 26.9255L26.9098 26.3422C26.9752 26.2767 27.0119 26.188 27.0119 26.0956C27.0119 26.0031 26.9752 25.9144 26.9098 25.8489ZM19.8124 24.4083C18.911 24.4084 18.0298 24.1412 17.2803 23.6405C16.5308 23.1398 15.9466 22.428 15.6016 21.5953C15.2566 20.7625 15.1663 19.8462 15.3421 18.9621C15.518 18.078 15.952 17.2659 16.5894 16.6285C17.2268 15.9912 18.0389 15.5571 18.9229 15.3813C19.807 15.2055 20.7234 15.2957 21.5561 15.6407C22.3889 15.9857 23.1006 16.5699 23.6014 17.3195C24.1021 18.069 24.3693 18.9502 24.3692 19.8516C24.369 21.06 23.8889 22.219 23.0344 23.0735C22.1799 23.9281 21.0209 24.4082 19.8124 24.4083ZM16.8994 19.6083V21.4917C17.1895 22.0036 17.6093 22.4307 18.1171 22.7286V19.5969L16.8994 19.6083ZM19.178 18.0469V23.1364C19.5806 23.2106 19.9932 23.2106 20.3957 23.1364V18.0469H19.178ZM22.701 21.4875V20.3719H21.4843V22.7156C21.9914 22.4185 22.4114 21.9931 22.702 21.4823L22.701 21.4875Z" fill="white"/>
</g>
<defs>
<clipPath id="clip0_731_3720">
<rect width="33.3333" height="33.3333" fill="white" transform="translate(3.33325 3.33331)"/>
</clipPath>
</defs>
</svg>
</file>

<file path="public/images/dataSource/clickhouse.svg">
<svg width="40" height="40" viewBox="0 0 40 40" fill="none" xmlns="http://www.w3.org/2000/svg">
<g clip-path="url(#clip0_102_61)">
<path d="M5.00146 30.1818H8.33446V33.4935H5.00146V30.1818Z" fill="#FF0000"/>
<path d="M5.00146 7H8.33446V30.1818H5.00146V7ZM11.6675 7H15.0005V33.4935H11.6675V7ZM18.3335 7H21.6665V33.4935H18.3335V7ZM24.9995 7H28.3325V33.4935H24.9995V7ZM31.6655 17.763H34.9985V22.7305H31.6655V17.763Z" fill="#FFCC00"/>
</g>
<defs>
<clipPath id="clip0_102_61">
<rect width="30" height="26.4935" fill="white" transform="translate(5 7)"/>
</clipPath>
</defs>
</svg>
</file>

<file path="public/images/dataSource/duckDb.svg">
<svg width="40" height="40" viewBox="0 0 40 40" fill="none" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<rect x="5" y="5" width="30" height="30" fill="url(#pattern0)"/>
<defs>
<pattern id="pattern0" patternContentUnits="objectBoundingBox" width="1" height="1">
<use xlink:href="#image0_3353_29922" transform="scale(0.00333333)"/>
</pattern>
<image id="image0_3353_29922" width="300" height="300" xlink:href="data:image/png;base64,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"/>
</defs>
</svg>
</file>

<file path="public/images/dataSource/mysql.svg">
<svg width="40" height="40" viewBox="0 0 40 40" fill="none" xmlns="http://www.w3.org/2000/svg">
<g clip-path="url(#clip0_79_48)">
<path fill-rule="evenodd" clip-rule="evenodd" d="M32.6337 28.3684C31.0021 28.3229 29.7363 28.4902 28.6753 28.9365C28.3699 29.0592 27.8796 29.0592 27.8394 29.4436C28.0027 29.605 28.0223 29.869 28.1655 30.0926C28.4101 30.4985 28.8391 31.0452 29.2264 31.3288L30.532 32.2618C31.3277 32.7481 32.2254 33.0321 33.0005 33.5188C33.4496 33.8029 33.8982 34.1678 34.3472 34.4723C34.5759 34.6345 34.7144 34.8986 35.0003 34.9995V34.9381C34.8576 34.7563 34.8164 34.4927 34.6742 34.2891L34.0614 33.7015C33.4701 32.9108 32.7353 32.2209 31.9396 31.6537C31.2865 31.2074 29.8588 30.5993 29.5936 29.8495L29.5534 29.804C30.0015 29.7586 30.532 29.6009 30.9609 29.4791C31.6551 29.2973 32.2871 29.3373 33.0005 29.1551L33.9805 28.871V28.6892C33.6133 28.3243 33.348 27.8376 32.9607 27.4931C31.9203 26.601 30.7771 25.7288 29.5936 24.999C28.9612 24.5936 28.1449 24.3295 27.4717 23.9855C27.2262 23.8637 26.8187 23.8028 26.676 23.6001C26.3079 23.1548 26.1044 22.5662 25.8392 22.0386L24.1664 18.5106C23.7992 17.7198 23.5742 16.929 23.126 16.1992C21.0243 12.7521 18.7387 10.6638 15.2294 8.61552C14.4748 8.18968 13.5771 8.00653 12.6228 7.78384L11.0926 7.70204C10.7657 7.56025 10.4396 7.17486 10.1538 6.99217C8.99089 6.26229 5.99146 4.68076 5.13402 6.76493C4.58298 8.08288 5.9503 9.38038 6.41446 10.0498C6.76201 10.5161 7.21016 11.0433 7.45573 11.5704C7.59292 11.9149 7.63865 12.2803 7.78179 12.6453C8.10784 13.5374 8.41423 14.5313 8.84272 15.363C9.07137 15.7888 9.31145 16.2355 9.59727 16.6205C9.76052 16.8477 10.0463 16.9449 10.1072 17.3099C9.82134 17.7157 9.80168 18.3233 9.63842 18.831C8.90354 21.1224 9.18935 23.961 10.2297 25.648C10.5567 26.1547 11.3272 27.2704 12.3726 26.8441C13.2909 26.4792 13.086 25.3235 13.3512 24.3096C13.413 24.0664 13.3718 23.9042 13.4939 23.7415V23.7869L14.3308 25.4698C14.9632 26.4633 16.0653 27.4976 16.9831 28.1875C17.4724 28.5524 17.8602 29.1814 18.4721 29.4041V29.3427H18.4318C18.3093 29.161 18.1254 29.0792 17.9622 28.9374C17.595 28.5724 17.1871 28.1261 16.9013 27.7208C16.0447 26.5855 15.2902 25.328 14.6166 24.0305C14.2896 23.402 14.0038 22.7126 13.7395 22.084C13.616 21.8404 13.616 21.4751 13.4125 21.3542C13.1061 21.7995 12.658 22.1858 12.4325 22.733C12.0447 23.6047 12.0045 24.6795 11.8618 25.7947C11.7795 25.8152 11.8161 25.7947 11.7795 25.8402C11.1274 25.6784 10.9024 25.0085 10.6577 24.4413C10.0459 23.0016 9.94344 20.6902 10.4739 19.0273C10.6166 18.6015 11.2294 17.2631 10.9847 16.8577C10.8612 16.4723 10.4542 16.2496 10.2292 15.9451C9.96402 15.5597 9.67912 15.0735 9.49529 14.6476C9.00598 13.5115 8.76132 12.2549 8.2304 11.1192C7.98483 10.592 7.5568 10.0444 7.20971 9.55807C6.82192 9.01044 6.39434 8.62506 6.08795 7.97654C5.98597 7.7493 5.84329 7.38846 6.00655 7.14487C6.04679 6.98262 6.12911 6.91763 6.29145 6.88128C6.55668 6.65404 7.31214 6.94217 7.57737 7.06306C8.33192 7.36755 8.96436 7.65114 9.59681 8.07652C9.88262 8.27921 10.189 8.6646 10.5562 8.7664H10.9852C11.6382 8.90819 12.3722 8.81184 12.9836 8.99363C14.0651 9.33902 15.0442 9.8453 15.9222 10.3934C18.5946 12.0763 20.7988 14.469 22.2878 17.3285C22.5324 17.7948 22.6344 18.2206 22.8594 18.7074C23.2884 19.7013 23.8188 20.7147 24.2464 21.6887C24.6753 22.6417 25.0833 23.6156 25.6951 24.4064C26.0015 24.8322 27.2253 25.0549 27.7758 25.278C28.1842 25.4598 28.8162 25.6234 29.1843 25.8461C29.8776 26.2719 30.5713 26.7587 31.2239 27.2249C31.5499 27.4676 32.5706 27.9748 32.6314 28.3793L32.6337 28.3684ZM11.8266 10.7479C11.5447 10.7454 11.2637 10.7795 10.9907 10.8492V10.8947H11.0309C11.1942 11.2191 11.48 11.4423 11.6839 11.7263L12.1536 12.6998L12.1938 12.6543C12.4796 12.4517 12.6228 12.1272 12.6228 11.6409C12.5002 11.4991 12.4801 11.3568 12.3781 11.2151C12.2555 11.0124 11.9903 10.9106 11.8266 10.7488V10.7479Z" fill="#00678C"/>
</g>
<defs>
<clipPath id="clip0_79_48">
<rect width="30" height="30" fill="white" transform="translate(5 5)"/>
</clipPath>
</defs>
</svg>
</file>

<file path="public/images/dataSource/oracle.svg">
<svg width="40" height="40" xmlns="http://www.w3.org/2000/svg">

 <g>
  <title>Layer 1</title>
  <path id="svg_1" d="m13.37838,12.58559a8,8 0 1 0 0,16l12,0a8,8 0 1 0 0,-16l-12,0z" stroke-width="4" stroke="#C74634" fill="none"/>
 </g>
</svg>
</file>

<file path="public/images/dataSource/postgreSql.svg">
<svg width="40" height="40" viewBox="0 0 40 40" fill="none" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<rect x="5" y="4" width="30" height="31.1538" fill="url(#pattern0)"/>
<defs>
<pattern id="pattern0" patternContentUnits="objectBoundingBox" width="1" height="1">
<use xlink:href="#image0_3353_29923" transform="matrix(0.000932192 0 0 0.000897666 -0.00338352 0)"/>
</pattern>
<image id="image0_3353_29923" width="1080" height="1114" xlink:href="data:image/png;base64,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"/>
</defs>
</svg>
</file>

<file path="public/images/dataSource/redshift.svg">
<svg width="40" height="40" viewBox="0 0 40 40" fill="none" xmlns="http://www.w3.org/2000/svg">
<g clip-path="url(#clip0_418_354)">
<path d="M35 5H5V35H35V5Z" fill="url(#paint0_linear_418_354)"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M24.0594 18.1889C23.662 18.1889 23.3391 17.8667 23.3391 17.4703C23.3391 17.074 23.662 16.7514 24.0594 16.7514C24.4564 16.7514 24.7793 17.074 24.7793 17.4703C24.7793 17.8667 24.4564 18.1889 24.0594 18.1889ZM22.2348 22.5592C21.8377 22.5592 21.5148 22.2369 21.5148 21.8406C21.5148 21.4443 21.8377 21.122 22.2348 21.122C22.6318 21.122 22.9551 21.4443 22.9551 21.8406C22.9551 22.2369 22.6318 22.5592 22.2348 22.5592ZM17.8559 21.8309C17.4592 21.8309 17.1363 21.5086 17.1363 21.1123C17.1363 20.716 17.4592 20.3933 17.8559 20.3933C18.2533 20.3933 18.5762 20.716 18.5762 21.1123C18.5762 21.5086 18.2533 21.8309 17.8559 21.8309ZM16.0316 25.837C15.6349 25.837 15.3117 25.5147 15.3117 25.1184C15.3117 24.7221 15.6349 24.3998 16.0316 24.3998C16.4291 24.3998 16.752 24.7221 16.752 25.1184C16.752 25.5147 16.4291 25.837 16.0316 25.837ZM24.0594 16.0036C23.2492 16.0036 22.5899 16.6616 22.5899 17.4703C22.5899 17.9661 22.839 18.4032 23.2177 18.669L22.5322 20.4045C22.4359 20.3847 22.3363 20.3743 22.2348 20.3743C21.5905 20.3743 21.0477 20.793 20.8503 21.3706L19.3164 21.0226C19.2688 20.2565 18.6358 19.6456 17.8559 19.6456C17.046 19.6456 16.3871 20.3036 16.3871 21.1123C16.3871 21.4903 16.5347 21.832 16.7711 22.0922L16.1017 23.6591C16.0777 23.6577 16.0556 23.652 16.0316 23.652C15.2218 23.652 14.5625 24.3097 14.5625 25.1184C14.5625 25.9267 15.2218 26.5847 16.0316 26.5847C16.8419 26.5847 17.5011 25.9267 17.5011 25.1184C17.5011 24.5995 17.2284 24.1456 16.8198 23.8846L17.4105 22.5024C17.5521 22.5476 17.6997 22.5786 17.8559 22.5786C18.4339 22.5786 18.9302 22.241 19.1695 21.7561L20.7945 22.1248C20.9275 22.7977 21.5223 23.307 22.2348 23.307C23.045 23.307 23.7043 22.6493 23.7043 21.8406C23.7043 21.4035 23.5076 21.0151 23.2027 20.7459L23.923 18.9229C23.9687 18.9273 24.0126 18.9367 24.0594 18.9367C24.8692 18.9367 25.5285 18.2787 25.5285 17.4703C25.5285 16.6616 24.8692 16.0036 24.0594 16.0036ZM20 29.7522C16.3508 29.7522 13.6242 28.6568 13.6242 27.6772V13.6818C14.8655 14.6906 17.4933 15.2237 20.0079 15.2237C22.5112 15.2237 25.1277 14.695 26.3758 13.6949V27.6772C26.3758 28.6568 23.6488 29.7522 20 29.7522ZM20.0079 10.2478C23.7605 10.2478 26.3758 11.3619 26.3758 12.362C26.3758 13.3618 23.7605 14.4759 20.0079 14.4759C16.2549 14.4759 13.6399 13.3618 13.6399 12.362C13.6399 11.3619 16.2549 10.2478 20.0079 10.2478ZM27.125 12.362C27.125 10.5031 23.4582 9.5 20.0079 9.5C16.5576 9.5 12.8907 10.5031 12.8907 12.362C12.8907 12.365 12.8915 12.3684 12.8915 12.3714H12.875V27.6772C12.875 29.5107 16.5459 30.5 20 30.5C23.4541 30.5 27.125 29.5107 27.125 27.6772V12.3714H27.1243C27.1243 12.3684 27.125 12.365 27.125 12.362Z" fill="white"/>
</g>
<defs>
<linearGradient id="paint0_linear_418_354" x1="5" y1="3005" x2="3005" y2="5" gradientUnits="userSpaceOnUse">
<stop stop-color="#4D27A8"/>
<stop offset="1" stop-color="#A166FF"/>
</linearGradient>
<clipPath id="clip0_418_354">
<rect width="30" height="30" fill="white" transform="translate(5 5)"/>
</clipPath>
</defs>
</svg>
</file>

<file path="public/images/dataSource/snowflake.svg">
<svg xmlns="http://www.w3.org/2000/svg" width="40" height="40" viewBox="0 0 200 200" fill="none"><g clip-path="url(#clip0_459_8250)"><g clip-path="url(#clip1_459_8250)"><path d="M51.3684 63.4643L79.8234 80.5268C81.3991 81.4739 83.2491 81.8594 85.0719 81.6207C86.8948 81.3819 88.5831 80.533 89.8618 79.2121C90.7162 78.3885 91.3947 77.4001 91.856 76.3067C92.3174 75.2133 92.5521 74.0376 92.5459 72.8509V38.6537C92.6028 37.1559 92.2547 35.6704 91.5382 34.3538C90.8218 33.0372 89.7635 31.9381 88.4749 31.1725C87.1866 30.4068 85.7156 30.0027 84.217 30.0027C82.7183 30.0027 81.2473 30.4068 79.959 31.1725C78.6704 31.9381 77.6122 33.0372 76.8957 34.3538C76.1793 35.6704 75.8312 37.1559 75.8881 38.6537V58.1137L59.729 48.4231C58.7761 47.8575 57.7195 47.4886 56.6217 47.3383C55.5238 47.188 54.407 47.2594 53.3371 47.5481C51.1803 48.1278 49.3603 49.6043 48.3059 51.5818C45.9937 55.7381 47.3434 60.9443 51.3684 63.4425V63.4643ZM119.771 80.505L148.226 63.4425C152.251 60.9421 153.603 55.714 151.289 51.5775C150.766 50.6014 150.05 49.7415 149.185 49.0494C148.321 48.3574 147.325 47.8476 146.258 47.5508C145.191 47.254 144.075 47.1764 142.977 47.3225C141.879 47.4687 140.822 47.8356 139.87 48.4012L123.901 57.9606V38.6231C123.942 37.5039 123.757 36.3881 123.356 35.3421C122.956 34.2962 122.349 33.3417 121.572 32.5356C120.794 31.7295 119.862 31.0884 118.832 30.6505C117.801 30.2125 116.692 29.9868 115.573 29.9868C114.453 29.9868 113.344 30.2125 112.314 30.6505C111.283 31.0884 110.351 31.7295 109.574 32.5356C108.796 33.3417 108.189 34.2962 107.789 35.3421C107.389 36.3881 107.203 37.5039 107.244 38.6231V72.1421C107.072 73.9376 107.449 75.7429 108.324 77.32C109.379 79.2953 111.199 80.7543 113.356 81.3537C114.424 81.6526 115.543 81.7291 116.642 81.5786C117.742 81.4281 118.798 81.0538 119.747 80.4787L119.771 80.505ZM94.4446 99.9343C94.4731 99.3875 94.6809 98.8406 95.0396 98.4468L98.3646 94.9906C98.7584 94.6243 99.2672 94.4062 99.804 94.3737H99.9287C100.464 94.4054 100.972 94.6236 101.364 94.9906L104.689 98.4468C105.049 98.8626 105.258 99.3873 105.284 99.9365V100.068C105.257 100.618 105.048 101.144 104.689 101.562L101.364 105.018C100.974 105.388 100.465 105.608 99.9287 105.639H99.804C99.2659 105.609 98.754 105.388 98.3646 105.018L95.0396 101.562C94.6803 101.144 94.4709 100.618 94.4446 100.068V99.9343ZM84.3734 98.5125V101.496C84.4104 102.246 84.6968 102.962 85.1871 103.531L96.4746 115.249C97.0072 115.753 97.7006 116.052 98.4324 116.093H101.302C102.034 116.052 102.728 115.753 103.26 115.249L114.548 103.531C115.038 102.962 115.325 102.246 115.361 101.496V98.5125C115.325 97.7626 115.038 97.0466 114.548 96.4781L103.26 84.7596C102.728 84.256 102.034 83.9569 101.302 83.9153H98.4324C97.7006 83.9569 97.0072 84.256 96.4746 84.7596L85.1871 96.5C84.6982 97.0693 84.412 97.7848 84.3734 98.5343V98.5125ZM36.6465 90.4187L52.7574 100.081L36.6465 109.734C34.7102 110.941 33.3122 112.846 32.7425 115.055C32.1727 117.264 32.4748 119.607 33.5862 121.599C34.1088 122.577 34.8241 123.438 35.6888 124.131C36.5536 124.825 37.5498 125.335 38.6174 125.633C40.7743 126.232 43.0843 125.924 45.0093 124.776L73.4643 107.713C76.0893 106.046 77.6206 103.167 77.6206 100.074C77.6204 98.5554 77.2399 97.0606 76.514 95.7263C75.788 94.3921 74.7396 93.2608 73.4643 92.4356L45.0093 75.3731C44.0564 74.8075 42.9998 74.4386 41.902 74.2883C40.8041 74.138 39.6873 74.2094 38.6174 74.4981C36.4606 75.0778 34.6406 76.5543 33.5862 78.5318C31.274 82.6881 32.6237 87.89 36.6487 90.3925L36.6465 90.4187ZM121.95 100.109C121.925 101.631 122.297 103.133 123.03 104.467C123.763 105.801 124.831 106.92 126.128 107.715L154.566 124.778C156.491 125.924 158.796 126.235 160.953 125.635C163.11 125.036 164.928 123.579 165.985 121.604C167.101 119.612 167.406 117.267 166.836 115.056C166.265 112.846 164.863 110.941 162.922 109.739L146.831 100.083L162.942 90.4209C166.967 87.9206 168.316 82.699 166.004 78.5603C165.483 77.5821 164.768 76.7202 163.903 76.0268C163.038 75.3334 162.041 74.8229 160.973 74.5265C158.814 73.9271 156.506 74.2334 154.586 75.4015L126.148 92.464C124.841 93.2646 123.766 94.3947 123.033 95.7411C122.3 97.0875 121.933 98.6029 121.97 100.136L121.95 100.109ZM85.5371 118.611C83.5732 118.232 81.5386 118.594 79.8256 119.626L51.3706 136.689C47.3456 139.189 45.9981 144.411 48.3081 148.549C49.3646 150.525 51.1824 151.984 53.3393 152.581C54.4074 152.877 55.5245 152.954 56.6231 152.807C57.7216 152.659 58.779 152.291 59.7312 151.723L75.8902 142.033V161.348C75.8457 162.47 76.0281 163.589 76.4266 164.638C76.825 165.687 77.4313 166.645 78.209 167.454C78.9867 168.263 79.9198 168.907 80.9524 169.347C81.985 169.787 83.0957 170.013 84.2181 170.013C85.3404 170.013 86.4511 169.787 87.4837 169.347C88.5163 168.907 89.4494 168.263 90.2271 167.454C91.0048 166.645 91.6111 165.687 92.0095 164.638C92.408 163.589 92.5904 162.47 92.5459 161.348V127.125C92.5754 125.103 91.8873 123.135 90.6037 121.572C89.3202 120.009 87.5243 118.952 85.5349 118.587L85.5371 118.611ZM148.229 136.691L119.774 119.628C118.821 119.061 117.764 118.693 116.666 118.545C115.567 118.398 114.45 118.475 113.382 118.771C112.314 119.067 111.317 119.577 110.452 120.27C109.587 120.963 108.872 121.825 108.351 122.802C107.475 124.382 107.099 126.189 107.27 127.987V161.346C107.225 162.468 107.408 163.587 107.806 164.636C108.205 165.685 108.811 166.643 109.589 167.452C110.366 168.261 111.299 168.905 112.332 169.345C113.365 169.785 114.475 170.011 115.598 170.011C116.72 170.011 117.831 169.785 118.863 169.345C119.896 168.905 120.829 168.261 121.607 167.452C122.385 166.643 122.991 165.685 123.389 164.636C123.788 163.587 123.97 162.468 123.926 161.346V142.175L139.866 151.734C140.819 152.3 141.875 152.669 142.973 152.819C144.071 152.969 145.188 152.898 146.258 152.609C148.415 152.03 150.235 150.553 151.289 148.576C153.601 144.419 152.251 139.213 148.226 136.715" fill="#29B5E8"></path></g></g><defs><clipPath id="clip0_459_8250"><rect width="200" height="200" fill="white"></rect></clipPath><clipPath id="clip1_459_8250"><rect width="140" height="140" fill="white" transform="translate(29.7998 30)"></rect></clipPath></defs></svg>
</file>

<file path="public/images/dataSource/sqlserver.svg">
<svg width="40" height="40" viewBox="0 0 40 40" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M23.9409 19.3287L17.3652 21.476L11.6443 24.0009L10.0438 24.4234C9.63622 24.8111 9.20883 25.2038 8.74658 25.6014C8.23961 26.0388 7.76743 26.4365 7.40454 26.7247C7.00197 27.0428 6.40552 27.6392 6.10236 28.0169C5.65003 28.5835 5.29218 29.1849 5.13808 29.6472C4.86469 30.4823 4.99896 31.3272 5.5258 32.1076C6.20176 33.1016 7.54875 34.1155 9.11933 34.8064C9.91961 35.1594 11.2666 35.6117 12.2805 35.8651C13.9654 36.2926 17.226 36.7548 19.0202 36.8245C19.383 36.8394 19.8701 36.8394 19.89 36.8245C19.9298 36.7995 20.2081 36.2678 20.5312 35.6068C21.6347 33.3551 22.4299 31.2427 22.8623 29.4385C23.1207 28.3451 23.3245 26.8887 23.4586 25.1641C23.4935 24.682 23.5084 23.0666 23.4785 22.5198C23.4338 21.6252 23.3542 20.8995 23.2301 20.1888C23.2102 20.0844 23.2052 19.9899 23.2151 19.985C23.235 19.9701 23.2946 19.9502 24.1048 19.7165L23.9408 19.3289V19.3288H23.9409V19.3287ZM22.4399 20.2085C22.4995 20.2085 22.6585 21.7344 22.6983 22.6987C22.7083 22.9025 22.7032 23.0367 22.6933 23.0367C22.6536 23.0367 21.8533 22.5645 21.2818 22.2067C20.7848 21.8935 19.8404 21.2672 19.6913 21.148C19.6415 21.1132 19.6465 21.1083 20.0541 20.969C20.7449 20.7354 22.3852 20.2085 22.4399 20.2085ZM19.0899 21.312C19.1346 21.312 19.2489 21.3765 19.5223 21.5456C20.5461 22.1867 21.9379 22.9621 22.5343 23.2206C22.7182 23.3001 22.738 23.2703 22.3156 23.5586C21.411 24.1749 20.2827 24.7813 18.9009 25.3926C18.6574 25.502 18.4536 25.5865 18.4487 25.5865C18.4388 25.5865 18.4685 25.4623 18.5082 25.3131C18.8413 24.0754 19.0302 22.8229 19.0402 21.8189C19.0451 21.3218 19.0451 21.3218 19.0899 21.307C19.0799 21.312 19.0848 21.312 19.0899 21.312ZM18.399 21.5754C18.4287 21.6052 18.4089 22.7186 18.3691 23.0217C18.2797 23.7474 18.1405 24.4234 17.9119 25.1839C17.8573 25.3677 17.8075 25.5219 17.7976 25.5318C17.7776 25.5566 17.0967 24.8906 16.8731 24.6321C16.4853 24.1848 16.1822 23.7374 15.9586 23.3001C15.8442 23.0764 15.6653 22.6391 15.6802 22.6241C15.7597 22.5695 18.3791 21.5555 18.399 21.5754ZM15.1483 22.8527C15.1533 22.8527 15.1582 22.8527 15.1633 22.8577C15.1732 22.8676 15.2081 22.9472 15.2379 23.0366C15.3969 23.4691 15.7547 24.1053 16.0629 24.5128C16.4009 24.9602 16.8433 25.4373 17.211 25.7504C17.3304 25.8498 17.4396 25.9443 17.4545 25.9592C17.4844 25.989 17.4943 25.984 16.6841 26.2922C15.7448 26.6501 14.7209 27.0079 13.5479 27.3857C13.2676 27.476 12.9877 27.5671 12.708 27.659C12.6632 27.674 12.6781 27.6491 12.8074 27.4454C13.3889 26.5358 14.2736 24.7514 14.7706 23.4889C14.8551 23.2702 14.9396 23.0516 14.9546 23.0019C14.9745 22.9322 14.9993 22.9074 15.0638 22.8726C15.0986 22.8627 15.1335 22.8527 15.1483 22.8527ZM14.1544 23.2653C14.1692 23.2753 13.9157 23.807 13.6672 24.2941C13.1851 25.2335 12.6582 26.1581 11.9525 27.2813C11.8332 27.4752 11.7189 27.6541 11.704 27.674C11.6791 27.7088 11.6691 27.6988 11.5896 27.5448C11.4206 27.2118 11.2814 26.7843 11.2069 26.3916C11.1323 26.0039 11.1473 25.328 11.2318 24.9105C11.2963 24.6024 11.2914 24.6073 11.4405 24.5327C12.0767 24.2097 14.1345 23.2454 14.1544 23.2653ZM22.7282 23.6133V23.822C22.7282 24.9304 22.6089 26.4513 22.4349 27.5597C22.405 27.7535 22.3801 27.9125 22.3752 27.9176C22.3752 27.9176 22.2311 27.8779 22.0621 27.8281C21.3166 27.5945 20.5064 27.2515 19.7757 26.849C19.2935 26.5855 18.5928 26.1531 18.6127 26.1332C18.6176 26.1282 18.8264 26.0189 19.0699 25.8896C20.0442 25.3827 20.9785 24.836 21.7887 24.2942C22.0919 24.0904 22.5491 23.7624 22.6486 23.6729L22.7282 23.6133ZM10.4017 25.0844C10.4216 25.0844 10.4166 25.1242 10.3868 25.3031C10.3669 25.4324 10.342 25.6709 10.3322 25.8349C10.2923 26.5606 10.4117 27.0974 10.7695 27.833C10.8689 28.0368 10.9485 28.2058 10.9435 28.2107C10.9087 28.2406 7.61836 29.2049 6.58446 29.4881C6.27632 29.5726 6.00797 29.6472 5.98798 29.6521C5.95326 29.6621 5.94826 29.6571 5.96316 29.5726C6.07746 28.842 6.63417 27.8877 7.40951 27.0824C7.92645 26.5457 8.33901 26.2325 9.04479 25.8299C9.55176 25.5417 10.3321 25.1093 10.3917 25.0894C10.3918 25.0844 10.3967 25.0844 10.4017 25.0844ZM18.1554 26.4711C18.1604 26.4662 18.2797 26.5308 18.4238 26.6153C19.4875 27.2316 20.9686 27.8032 22.231 28.0965L22.3454 28.1213L22.1863 28.2107C21.5253 28.5786 19.3532 29.4831 17.1316 30.3132C16.8084 30.4324 16.4904 30.5518 16.4306 30.5766C16.371 30.6014 16.3163 30.6164 16.3163 30.6114C16.3163 30.6064 16.4058 30.4324 16.5201 30.2188C17.1414 29.0557 17.7677 27.6392 18.0858 26.655C18.1256 26.5606 18.1504 26.4761 18.1554 26.4711ZM17.3652 26.7296C17.3702 26.7347 17.3304 26.839 17.2807 26.9582C16.8483 28.007 16.2816 29.1502 15.5559 30.4325C15.3721 30.7606 15.218 31.0241 15.2129 31.0241C15.208 31.0241 15.0589 30.9345 14.88 30.8252C13.8262 30.179 12.8918 29.3838 12.2805 28.6134L12.191 28.504L12.6432 28.3798C14.2636 27.9375 15.6403 27.4603 17.0072 26.8738C17.2011 26.7943 17.3602 26.7296 17.3652 26.7296ZM22.2759 28.4444C22.2808 28.5587 22.0273 29.5826 21.8185 30.3231C21.6446 30.9444 21.4954 31.4316 21.2221 32.2914C21.1028 32.6692 20.9985 32.9822 20.9935 32.9822C20.9885 32.9822 20.9587 32.9773 20.9289 32.9674C19.4527 32.6989 18.1306 32.3262 16.888 31.8292C16.54 31.69 16.043 31.4663 16.0132 31.4415C16.0033 31.4314 16.3015 31.2923 16.6793 31.1283C18.9408 30.1392 21.2868 29.0159 22.0919 28.5338C22.1863 28.4742 22.2609 28.4444 22.2759 28.4444ZM10.9385 28.8321C10.9485 28.842 10.3172 29.7516 9.43246 30.9892C9.12433 31.4216 8.76647 31.9286 8.6323 32.1174C8.49808 32.3063 8.29432 32.6046 8.17999 32.7835L7.97115 33.1066L7.74747 32.9177C7.48403 32.699 7.02681 32.2318 6.82303 31.9733C6.39555 31.4416 6.10733 30.8799 5.993 30.368C5.93832 30.1294 5.93832 30.01 5.98796 29.9952C6.0625 29.9753 7.38959 29.6622 8.63225 29.3738C9.32313 29.2148 10.1233 29.026 10.4116 28.9564C10.6999 28.8867 10.9336 28.8321 10.9385 28.8321ZM11.5747 29.0756L11.7337 29.2546C12.4495 30.0548 13.1801 30.6464 14.0648 31.1632C14.2239 31.2527 14.3432 31.3322 14.3332 31.3372C14.2985 31.362 11.2615 32.4405 9.85495 32.9276C9.06471 33.2059 8.41355 33.4296 8.40864 33.4296C8.40369 33.4296 8.35893 33.3998 8.30915 33.365L8.21974 33.3004L8.36386 33.0917C8.83104 32.4157 9.41763 31.6751 10.695 30.1343L11.5747 29.0756ZM15.5411 31.9137C15.546 31.9087 15.7647 31.9882 16.033 32.0877C16.6793 32.3312 17.1911 32.4853 17.8771 32.6593C18.7221 32.873 19.9447 33.0818 20.6655 33.1414C20.7748 33.1513 20.8345 33.1613 20.8146 33.1762C20.7797 33.1961 20.0492 33.4396 19.5124 33.6086C18.6574 33.877 16.048 34.6474 13.9207 35.2588C13.5281 35.3731 13.1901 35.4675 13.1702 35.4724C13.1205 35.4824 12.9565 35.4376 12.9565 35.4178C12.9565 35.4079 13.0757 35.2538 13.2199 35.0848C13.9356 34.2299 14.6464 33.2756 15.2379 32.371C15.4018 32.1224 15.5411 31.9186 15.5411 31.9137ZM14.6662 31.9386C14.6712 31.9435 14.3183 32.5101 13.7021 33.4843C13.4386 33.8968 13.1453 34.364 13.0409 34.5281C12.9415 34.6871 12.7924 34.9357 12.708 35.0748L12.5638 35.3283L12.4892 35.3084C12.3103 35.2587 11.0528 34.8163 10.7198 34.6821C10.3072 34.5181 9.87977 34.3193 9.56164 34.1503C9.16407 33.9366 8.66707 33.6185 8.70679 33.6086C8.71671 33.6036 9.39767 33.4196 10.2177 33.196C12.3948 32.6045 13.6025 32.2616 14.3929 32.0131C14.537 31.9683 14.6613 31.9335 14.6662 31.9386ZM20.8543 33.3898H20.8593C20.8792 33.4396 20.074 35.6762 19.7806 36.382C19.7161 36.541 19.6913 36.5809 19.6565 36.5758C19.572 36.5709 18.404 36.4069 17.6931 36.3025C16.4556 36.1136 14.378 35.7507 13.8561 35.6315L13.7368 35.6067L14.4773 35.4376C16.0679 35.0797 16.8333 34.8859 17.6086 34.6473C18.5878 34.3491 19.5571 33.9763 20.5362 33.5191C20.6903 33.4495 20.8195 33.3948 20.8543 33.3898Z" fill="url(#paint0_linear_92_48)"/>
<path d="M17.1616 4.00025C17.0522 3.98543 15.2877 4.62162 14.1495 5.0838C12.6136 5.71014 11.4208 6.30661 10.6852 6.82342C10.4119 7.01734 10.0688 7.36025 10.0142 7.49442C9.99437 7.54414 9.98438 7.60378 9.98438 7.66341L10.6504 8.29466L12.2359 8.80163L16.0084 9.47761L20.3226 10.2182L20.3674 9.84543C20.3525 9.84543 20.3425 9.84048 20.3278 9.84048L19.761 9.75098L19.6468 9.54722C19.0602 8.51336 18.4141 7.231 18.0364 6.36616C17.7431 5.69515 17.4648 4.91985 17.3107 4.36315C17.2262 4.02517 17.2163 4.0053 17.1617 4.00035V4.00023H17.1616V4.00025ZM17.0819 4.25382H17.087C17.0919 4.25872 17.1118 4.39799 17.1317 4.56191C17.2161 5.25786 17.3704 5.92875 17.6139 6.65445C17.7977 7.20121 17.7977 7.17141 17.584 7.10675C17.0771 6.96763 14.8056 6.57496 13.1605 6.34633C12.897 6.31152 12.6733 6.27675 12.6733 6.2718C12.6535 6.25192 13.8612 5.62064 14.3931 5.37218C15.074 5.05898 16.9428 4.27864 17.0819 4.25382ZM12.2905 6.48051L12.4845 6.54505C13.5381 6.90297 16.1872 7.40996 17.6486 7.52924C17.8126 7.54416 17.9518 7.5591 17.9567 7.5591C17.9616 7.56405 17.8226 7.63861 17.6436 7.72307C16.9379 8.07598 16.1625 8.50841 15.6257 8.84144C15.4667 8.9408 15.3224 9.02038 15.3026 9.02038C15.2827 9.02038 15.1784 9.00048 15.069 8.98556L14.8702 8.95569L14.3733 8.46857C13.4985 7.6187 12.8125 6.96263 12.5491 6.71406L12.2905 6.48051ZM12.0918 6.63455L12.7926 7.50937C13.1753 7.99149 13.563 8.46365 13.6476 8.56798C13.732 8.67242 13.8016 8.75695 13.7967 8.7619C13.7768 8.7768 12.7828 8.58292 12.2558 8.46369C11.7141 8.3394 11.4904 8.27976 11.1574 8.17543L10.884 8.08592V8.01629C10.889 7.68326 11.3115 7.18626 12.0272 6.67934L12.0918 6.63455ZM18.0462 7.82745C18.0662 7.82745 18.0909 7.87217 18.1506 8.00637C18.3196 8.37912 18.8465 9.38318 18.9756 9.57699C19.0155 9.64167 19.085 9.64662 18.3842 9.5323C16.6993 9.25886 16.1575 9.16949 16.1575 9.15955C16.1575 9.1546 16.2072 9.11978 16.2718 9.08496C16.7938 8.79674 17.3206 8.4289 17.7878 8.03623C17.9021 7.94178 18.0065 7.85232 18.0263 7.83738C18.0313 7.82745 18.0413 7.8225 18.0462 7.82745Z" fill="url(#paint1_linear_92_48)"/>
<path d="M10.0489 7.4248C10.0489 7.4248 9.93966 7.59884 10.044 7.85731C10.1087 8.0163 10.2975 8.21012 10.5112 8.40897C10.5112 8.40897 12.723 10.5661 12.9914 10.8743C14.2141 12.2858 14.7459 13.6775 14.7956 15.5961C14.8255 16.8287 14.5918 17.9123 14.0103 19.1698C12.9765 21.4263 10.7945 23.9165 7.42957 26.68L7.92171 26.516C8.23979 26.2773 8.67222 26.0239 9.68614 25.4672C12.0271 24.1848 14.6614 23.0069 17.8922 21.7941C22.5443 20.0445 30.1937 17.9967 34.5477 17.3307L35 17.2611L34.9304 17.1518C34.5329 16.5354 34.2594 16.1527 33.9313 15.7452C32.9771 14.5622 31.8191 13.603 30.4024 12.8077C28.4541 11.7193 25.934 10.8693 22.7432 10.2381C22.1418 10.1187 20.8196 9.89014 19.7461 9.72612C17.4696 9.37331 15.9984 9.12972 14.3781 8.85137C13.7966 8.75192 12.9267 8.60285 12.3502 8.47863C12.052 8.41394 11.4804 8.27977 11.0331 8.1257C10.6753 7.98646 10.1583 7.84729 10.0489 7.4248ZM11.3314 8.66744C11.3363 8.66254 11.4158 8.69226 11.5202 8.72708C11.7091 8.79162 11.9526 8.8662 12.241 8.94578C12.4591 9.00579 12.6778 9.06377 12.897 9.11972C13.1953 9.19424 13.4437 9.26384 13.4487 9.26384C13.4835 9.29866 13.9856 10.904 14.1546 11.5203C14.2191 11.754 14.2689 11.9527 14.2639 11.9527C14.2588 11.9578 14.2042 11.8732 14.1396 11.7589C13.5581 10.735 12.6385 9.69623 11.5749 8.86118C11.4358 8.76187 11.3314 8.67239 11.3314 8.66744ZM13.7768 9.3434C13.8016 9.3434 13.911 9.35832 14.0451 9.38812C14.8901 9.57698 16.4061 9.86527 17.3752 10.0293C17.5393 10.0541 17.6685 10.084 17.6685 10.0939C17.6685 10.1039 17.6088 10.1386 17.5343 10.1784C17.3703 10.2629 16.7092 10.6555 16.4906 10.8046C15.9388 11.1724 15.4418 11.5701 15.0839 11.9279C14.9398 12.0721 14.8155 12.1914 14.8155 12.1914C14.8155 12.1914 14.7858 12.1069 14.7608 12.0025C14.582 11.3116 14.2091 10.2877 13.8712 9.56701C13.8165 9.45273 13.7717 9.34833 13.7717 9.33843C13.7717 9.34835 13.7717 9.3434 13.7768 9.3434ZM18.081 10.1635C18.1109 10.1734 18.1606 10.3424 18.26 10.7152C18.4439 11.4359 18.5284 12.2411 18.4986 12.9916C18.4886 13.2004 18.4787 13.3942 18.4687 13.4191L18.4538 13.4687L18.1954 13.3843C17.6635 13.2153 16.7987 12.9618 16.0582 12.753C15.6356 12.6387 15.2928 12.5343 15.2928 12.5244C15.2928 12.4945 15.9091 11.8782 16.1725 11.6447C16.6744 11.2022 18.0363 10.1486 18.081 10.1635ZM18.424 10.2131C18.4389 10.1983 20.4817 10.5511 21.4112 10.7301C22.1021 10.8643 23.1061 11.073 23.1657 11.0979C23.1955 11.1078 23.0911 11.1675 22.7581 11.3166C21.446 11.9081 20.4717 12.4398 19.5026 13.086C19.2491 13.255 19.0354 13.3942 19.0304 13.3942C19.0255 13.3942 19.0205 13.2501 19.0205 13.0761C19.0205 12.1318 18.8316 11.1774 18.4836 10.3723C18.4488 10.2927 18.419 10.2182 18.424 10.2131ZM23.7074 11.257C23.7224 11.2719 23.6577 11.6745 23.5981 11.913C23.4192 12.6536 22.9371 13.7522 22.3457 14.7859C22.2412 14.9698 22.1468 15.1189 22.1368 15.1239C22.1269 15.1288 21.9927 15.0543 21.8386 14.9648C21.2621 14.6268 20.606 14.3087 19.8902 14.0105C19.6915 13.926 19.5175 13.8564 19.5125 13.8465C19.4777 13.8167 21.0781 12.758 21.9231 12.251C22.5941 11.8435 23.6875 11.2371 23.7074 11.257ZM24.0852 11.3166C24.1299 11.3166 25.0345 11.5651 25.5066 11.7043C26.6747 12.0523 28.0167 12.5443 28.8915 12.9419L29.2542 13.106L29.0008 13.1656C26.8637 13.6576 25.0345 14.2243 23.27 14.94C23.1259 14.9996 22.9966 15.0494 22.9868 15.0494C22.9768 15.0494 23.0265 14.9351 23.0911 14.7958C23.623 13.6676 23.9659 12.4896 24.0503 11.4856C24.0554 11.3911 24.0702 11.3166 24.0852 11.3166ZM15.079 13.3843C15.0939 13.3693 15.7848 13.5334 16.1575 13.6377C16.7241 13.7968 17.9269 14.1993 17.9269 14.2292C17.9269 14.2342 17.7928 14.3485 17.6338 14.4877C16.9827 15.0295 16.3563 15.601 15.6058 16.3267C15.3821 16.5405 15.1933 16.7144 15.1834 16.7144C15.1734 16.7144 15.1685 16.6845 15.1734 16.6448C15.2877 15.8097 15.2629 14.7362 15.1039 13.6477C15.0889 13.5085 15.074 13.3892 15.079 13.3843ZM29.5973 13.3992C29.6072 13.4091 29.2792 13.926 29.0704 14.2192C28.7723 14.6467 28.3348 15.2134 27.3457 16.456C26.8239 17.112 26.2373 17.8526 26.0435 18.1011C25.8446 18.3496 25.6807 18.5583 25.6756 18.5583C25.6707 18.5583 25.6062 18.4689 25.5365 18.3596C24.9798 17.5245 24.3138 16.7939 23.5235 16.1378C23.3744 16.0135 23.2104 15.8793 23.1558 15.8396C23.1011 15.7998 23.0563 15.7601 23.0563 15.7551C23.0563 15.7402 23.9012 15.3773 24.5425 15.1189C25.6658 14.6616 27.1965 14.1149 28.3447 13.762C28.9461 13.5731 29.5873 13.3892 29.5973 13.3992ZM29.98 13.4986C29.9998 13.4936 30.1192 13.5533 30.2633 13.6377C31.4711 14.3286 32.654 15.2183 33.5885 16.1329C33.8519 16.3914 34.503 17.0673 34.493 17.0723C34.493 17.0723 34.2644 17.0921 33.996 17.112C31.9035 17.2711 29.2246 17.7134 26.6499 18.3347C26.476 18.3744 26.3219 18.4092 26.3119 18.4092C26.3021 18.4092 26.4959 18.2154 26.7395 17.9818C28.2504 16.5255 28.9413 15.606 29.7564 13.9657C29.8707 13.7223 29.9701 13.5135 29.98 13.4986C29.9751 13.4986 29.9751 13.4986 29.98 13.4986ZM18.9111 14.6319C18.9807 14.6467 19.6268 14.95 20.1139 15.1935C20.5612 15.4171 21.2323 15.775 21.267 15.8048C21.272 15.8097 21.0334 15.934 20.7403 16.0782C19.8058 16.5454 19.0056 16.9877 18.1705 17.4947C17.9319 17.6388 17.7331 17.7582 17.7282 17.7582C17.7083 17.7582 17.7132 17.7382 17.8475 17.4947C18.2948 16.6796 18.6526 15.7054 18.8565 14.7561C18.8763 14.6815 18.8962 14.6319 18.9111 14.6319ZM18.2649 14.7511C18.2798 14.766 18.1109 15.3773 18.0065 15.7104C17.8027 16.3416 17.4597 17.1319 17.1268 17.7283C17.0472 17.8674 16.9279 18.0712 16.8633 18.1855L16.7391 18.3843L16.4607 18.116C16.1377 17.8029 15.8742 17.609 15.5363 17.435C15.402 17.3655 15.2977 17.3058 15.2977 17.2959C15.2977 17.2562 16.1476 16.4858 16.7987 15.9291C17.2659 15.5265 18.25 14.7362 18.2649 14.7511ZM22.2164 16.3764L22.46 16.5354C23.0165 16.8983 23.6726 17.3804 24.1747 17.8029C24.4579 18.0364 25.0047 18.5286 25.1141 18.6478L25.1736 18.7125L24.7711 18.8268C22.4947 19.458 20.7352 20.0196 18.6824 20.7752C18.4538 20.8596 18.26 20.9292 18.245 20.9292C18.2153 20.9292 18.1903 20.954 18.7024 20.4818C20.0146 19.2742 21.1775 17.942 22.0424 16.6448L22.2164 16.3764ZM21.1776 16.6349C21.1875 16.6448 20.5066 17.604 20.099 18.1458C19.6119 18.792 18.747 19.8755 18.1506 20.5812C17.9021 20.8745 17.6885 21.1181 17.6785 21.123C17.6635 21.128 17.6586 21.0535 17.6586 20.9391C17.6586 20.3377 17.5045 19.6965 17.2361 19.1498C17.1218 18.9212 17.1019 18.8665 17.1268 18.8417C17.2212 18.7571 18.6676 17.9321 19.5821 17.44C20.1984 17.112 21.1626 16.6249 21.1776 16.6349ZM14.895 18.1757C14.91 18.1757 15.0243 18.2353 15.1535 18.3049C15.4716 18.4788 15.7549 18.6727 16.0084 18.8815C16.0183 18.8914 15.8891 18.9958 15.7202 19.12C15.248 19.458 14.5323 19.9998 14.1148 20.3328C13.6773 20.6807 13.6625 20.6907 13.7121 20.6161C14.0402 20.1141 14.2042 19.8308 14.3782 19.468C14.5323 19.145 14.6863 18.7622 14.7956 18.4292C14.8354 18.285 14.8851 18.1757 14.895 18.1757ZM16.5701 19.4878C16.5949 19.4829 16.6248 19.5276 16.7589 19.7264C17.0422 20.1488 17.2609 20.7155 17.3157 21.1728L17.3255 21.2722L16.6447 21.5357C15.4269 22.0078 14.3036 22.4751 13.5431 22.8229C13.3294 22.9224 12.9566 23.1013 12.7131 23.2206C12.4696 23.3448 12.2707 23.4393 12.2707 23.4343C12.2707 23.4294 12.4248 23.315 12.6137 23.1758C14.0999 22.0973 15.3871 20.9143 16.3514 19.7314C16.4558 19.6071 16.5503 19.4928 16.5601 19.4878L16.5701 19.4878ZM15.7997 19.6767C15.8196 19.6966 15.253 20.3377 14.8653 20.7304C13.906 21.7096 12.9567 22.4751 11.7787 23.2206C11.6296 23.315 11.4954 23.3995 11.4805 23.4095C11.4456 23.4294 11.4904 23.3796 12.0073 22.818C12.3354 22.4651 12.5839 22.1669 12.8672 21.7991C13.056 21.5556 13.0909 21.5208 13.3643 21.3269C14.0949 20.8 15.7798 19.6568 15.7997 19.6767Z" fill="url(#paint2_radial_92_48)"/>
<defs>
<linearGradient id="paint0_linear_92_48" x1="9.9472" y1="33.5875" x2="24.9004" y2="22.4078" gradientUnits="userSpaceOnUse">
<stop offset="0.06" stop-color="#909CA9"/>
<stop offset="1" stop-color="#EDEDEE"/>
</linearGradient>
<linearGradient id="paint1_linear_92_48" x1="10.4727" y1="7.48257" x2="18.4328" y2="7.48257" gradientUnits="userSpaceOnUse">
<stop stop-color="#939FAB"/>
<stop offset="1" stop-color="#DCDEE1"/>
</linearGradient>
<radialGradient id="paint2_radial_92_48" cx="0" cy="0" r="1" gradientUnits="userSpaceOnUse" gradientTransform="translate(25 16) rotate(-172.942) scale(12.6329 25.2721)">
<stop offset="0.405" stop-color="#EE352C"/>
<stop offset="1" stop-color="#A91D22"/>
</radialGradient>
</defs>
</svg>
</file>

<file path="public/images/dataSource/trino.svg">
<svg width="40" height="40" viewBox="0 0 40 40" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M30.5066 19.4442C30.5066 18.9658 30.3165 18.5069 29.9782 18.1686C29.6399 17.8303 29.181 17.6402 28.7026 17.6402C28.2241 17.6402 27.7653 17.8303 27.4269 18.1686C27.0886 18.5069 26.8985 18.9658 26.8985 19.4442C26.908 19.7872 27.0235 20.1188 27.2292 20.3934C27.4349 20.668 27.7206 20.8721 28.0471 20.9777V23.7258C27.2608 21.7122 25.7894 20.0406 23.8918 19.0052C24.1684 18.4039 24.4511 17.8867 24.7217 17.4117C25.7553 15.8827 26.8947 14.4279 28.1313 13.0579C28.8108 12.2521 29.4543 11.4944 29.9774 10.833C31.4447 8.99283 33.0563 6.27475 32.7557 4.66314C32.7191 4.43726 32.6327 4.22235 32.5027 4.03407C32.3726 3.84579 32.2023 3.68886 32.004 3.5747C29.9654 2.37201 27.1932 6.28076 24.4691 10.0512C22.6651 12.5408 21.733 16.0647 21.306 18.0431C20.4705 17.8601 19.6177 17.7673 18.7623 17.7665C17.5187 17.7626 16.283 17.9658 15.1061 18.3678C15.0296 16.1609 15.0959 13.9514 15.3046 11.753C15.9059 6.03421 15.6413 2.6787 14.5289 1.53013C14.3861 1.35747 14.2056 1.21996 14.0012 1.1282C13.7968 1.03644 13.5741 0.9929 13.3502 1.00094C10.0669 1.16331 10.4397 10.9713 10.4938 12.0898C10.6261 14.7718 11.6965 18.0311 12.346 19.8351C10.8305 21.034 9.72691 22.6757 9.1889 24.5316H8.95437C8.70726 24.5203 8.46036 24.5582 8.22798 24.643C7.9956 24.7278 7.78234 24.8578 7.60057 25.0256C7.4188 25.1934 7.27213 25.3956 7.16904 25.6205C7.06595 25.8453 7.00849 26.0884 7 26.3357V29.4446C7.00928 29.6916 7.06727 29.9343 7.17063 30.1588C7.27399 30.3833 7.42068 30.5851 7.60229 30.7528C7.78389 30.9204 7.99682 31.0505 8.22886 31.1356C8.46089 31.2207 8.70745 31.2591 8.95437 31.2486H9.35126C9.80322 32.308 10.478 33.2576 11.3297 34.0329L10.7283 34.5621C10.5881 34.6831 10.5013 34.8545 10.4867 35.0391C10.472 35.2237 10.5308 35.4067 10.6502 35.5483C12.4542 37.7432 15.4068 39 18.7202 39C22.0337 39 24.9983 37.7432 26.7903 35.5483C26.9097 35.4067 26.9684 35.2237 26.9538 35.0391C26.9392 34.8545 26.8523 34.6831 26.7121 34.5621L26.1108 34.0329C26.965 33.2409 27.6396 32.2751 28.0892 31.2005H28.5402C28.7871 31.211 29.0337 31.1726 29.2657 31.0875C29.4978 31.0024 29.7107 30.8723 29.8923 30.7047C30.0739 30.537 30.2206 30.3352 30.324 30.1107C30.4273 29.8862 30.4853 29.6435 30.4946 29.3965V26.3116C30.4857 25.9591 30.3716 25.6172 30.1669 25.33C29.9623 25.0428 29.6764 24.8234 29.346 24.7V20.9777C29.6752 20.875 29.964 20.6719 30.1721 20.397C30.3802 20.122 30.4972 19.7889 30.5066 19.4442Z" fill="#CDCCCC"/>
<path d="M15.7916 34.5198C16.3448 34.153 14.8895 34.2913 14.7693 34.0448C14.1881 33.9933 13.6126 33.8907 13.0494 33.7381C12.0271 33.4675 9.57363 31.8198 9.30904 30.2383C9.04445 28.6567 9.30904 25.656 10.4155 23.852C11.1083 22.7529 12.0018 21.7941 13.0494 21.0256C13.0494 21.0256 10.9026 15.9202 10.7222 12.0656C10.5418 8.21095 10.8425 1.3496 13.3561 1.22933C15.8697 1.10906 15.5029 7.53143 15.076 11.7108C14.8224 14.4858 14.7822 17.2763 14.9557 20.0575C16.0264 19.7174 17.14 19.5311 18.2631 19.5042C19.2527 19.4813 20.2416 19.5741 21.2097 19.7809C21.2097 19.7809 22.0095 13.8636 24.6434 10.1593C27.2773 6.45502 30.0555 2.67256 31.8595 3.74897C33.6636 4.82538 31.3664 8.66798 29.7728 10.6705C28.1793 12.6729 25.4191 15.6797 24.499 17.2853C23.8959 18.3537 23.3635 19.4605 22.9055 20.5987C24.5463 21.4408 25.888 22.7677 26.7481 24.3992C28.047 26.991 28.1432 30.1781 27.4456 31.5312C27.0954 32.156 26.6113 32.6956 26.0281 33.1115C25.4449 33.5273 24.7769 33.809 24.0721 33.9365C23.2723 33.9726 19.9108 34.8085 19.9108 34.8085L15.7916 34.5198Z" fill="white"/>
<path d="M21.6787 19.8349C21.6787 19.8349 23.6872 14.5972 25.4852 11.6566C27.2833 8.716 29.6947 6.49102 30.4523 6.94203C31.21 7.39304 28.9069 10.1412 26.8864 12.8412C25.2405 15.2254 23.7481 17.712 22.4184 20.2859L21.6787 19.8349Z" fill="#DD00A1"/>
<path d="M13.6148 20.731L14.2161 20.286C14.2161 20.286 14.1319 15.0482 14.2161 11.8671C14.3003 8.68601 14.4626 4.71111 13.3983 4.74719C12.3339 4.78327 11.5942 7.85615 12.0092 12.1919C12.3079 15.0776 12.845 17.9337 13.6148 20.731Z" fill="#DD00A1"/>
<path d="M11.8227 31.9583C12.467 31.9583 12.9894 31.436 12.9894 30.7917C12.9894 30.1474 12.467 29.6251 11.8227 29.6251C11.1784 29.6251 10.6561 30.1474 10.6561 30.7917C10.6561 31.436 11.1784 31.9583 11.8227 31.9583Z" fill="#F9D8D2"/>
<path d="M25.6117 31.9583C26.256 31.9583 26.7783 31.436 26.7783 30.7917C26.7783 30.1474 26.256 29.6251 25.6117 29.6251C24.9674 29.6251 24.4451 30.1474 24.4451 30.7917C24.4451 31.436 24.9674 31.9583 25.6117 31.9583Z" fill="#F9D8D2"/>
<path d="M20.6503 30.6953C20.6378 30.6879 20.6238 30.6831 20.6094 30.6813C20.5949 30.6794 20.5802 30.6804 20.5662 30.6844C20.5521 30.6883 20.539 30.695 20.5277 30.7041C20.5163 30.7133 20.5069 30.7246 20.5 30.7374C20.5 30.7374 20.1512 31.3388 19.6461 31.3749C19.475 31.3698 19.3067 31.3299 19.1516 31.2575C18.9965 31.1851 18.8578 31.0818 18.744 30.9539V30.0639C19.0688 29.8835 19.5919 29.3423 19.5919 29.1559C19.5464 28.9572 19.4307 28.7815 19.2661 28.6611C19.1016 28.5407 18.8991 28.4837 18.6959 28.5004C18.0946 28.5004 17.6737 28.8913 17.6737 29.216C17.6737 29.5407 18.3351 29.9617 18.5215 30.082V30.9599C18.4266 31.0804 18.3075 31.1796 18.1718 31.2511C18.0361 31.3226 17.8868 31.3648 17.7338 31.3749C17.2587 31.3749 16.8979 30.7254 16.8919 30.7194C16.8778 30.6936 16.8544 30.6742 16.8264 30.6652C16.7984 30.6562 16.768 30.6584 16.7416 30.6713C16.7153 30.6865 16.6958 30.711 16.6868 30.74C16.6779 30.769 16.6803 30.8003 16.6935 30.8276C16.6935 30.8276 17.1204 31.6034 17.7338 31.6034C17.907 31.5958 18.0769 31.553 18.2331 31.4775C18.3892 31.402 18.5283 31.2955 18.6418 31.1644C18.8914 31.4259 19.231 31.5828 19.5919 31.6034H19.6641C19.8808 31.5607 20.0853 31.4707 20.2631 31.3397C20.4409 31.2087 20.5875 31.04 20.6924 30.8457C20.6998 30.8331 20.7046 30.8192 20.7065 30.8047C20.7084 30.7903 20.7073 30.7756 20.7034 30.7615C20.6995 30.7475 20.6927 30.7344 20.6836 30.723C20.6745 30.7116 20.6632 30.7022 20.6503 30.6953Z" fill="#10110E"/>
<path d="M13.0498 21.038C13.0498 21.038 11.3841 16.8286 11.0653 14.6277C10.7466 12.4267 10.464 8.75251 10.8849 6.30503C11.0658 5.17751 11.3107 4.06121 11.6186 2.96155C11.6186 2.96155 10.8428 8.66832 11.1315 11.1639C11.4201 13.6595 13.0498 21.038 13.0498 21.038Z" fill="#E5E5E5"/>
<path d="M21.2098 19.7808C21.2098 19.7808 22.4125 13.4125 24.1624 10.9109C25.9124 8.40934 28.0832 5.37254 29.1837 4.60883L30.2842 3.83911C30.2842 3.83911 25.8703 8.46948 24.1624 12.258C22.4546 16.0464 21.2098 19.7808 21.2098 19.7808Z" fill="#E5E5E5"/>
<path d="M14.2161 26.9968C14.035 26.9957 13.8577 27.0482 13.7066 27.148C13.5555 27.2477 13.4374 27.39 13.3673 27.5569C13.2972 27.7238 13.2783 27.9078 13.3129 28.0855C13.3474 28.2632 13.434 28.4266 13.5616 28.5551C13.6892 28.6835 13.8521 28.7712 14.0295 28.8069C14.207 28.8427 14.3911 28.8249 14.5585 28.7559C14.7258 28.6869 14.8689 28.5698 14.9696 28.4193C15.0703 28.2689 15.1241 28.0919 15.1241 27.9109C15.1241 27.6695 15.0286 27.4379 14.8585 27.2667C14.6884 27.0954 14.4575 26.9984 14.2161 26.9968ZM14.4747 27.8447C14.4093 27.8447 14.3466 27.8188 14.3003 27.7725C14.2541 27.7263 14.2281 27.6636 14.2281 27.5982C14.2281 27.5328 14.2541 27.4701 14.3003 27.4239C14.3466 27.3776 14.4093 27.3516 14.4747 27.3516C14.54 27.3516 14.6028 27.3776 14.649 27.4239C14.6952 27.4701 14.7212 27.5328 14.7212 27.5982C14.7213 27.6316 14.7145 27.6647 14.7014 27.6954C14.6882 27.7261 14.669 27.7539 14.6448 27.7769C14.6206 27.8 14.592 27.8179 14.5607 27.8295C14.5294 27.8412 14.496 27.8464 14.4626 27.8447H14.4747Z" fill="#10110E"/>
<path d="M23.1882 26.9968C23.0074 26.9968 22.8307 27.0504 22.6804 27.1509C22.5301 27.2513 22.4129 27.3941 22.3437 27.5611C22.2746 27.7281 22.2565 27.9119 22.2917 28.0892C22.327 28.2665 22.4141 28.4294 22.5419 28.5572C22.6697 28.685 22.8326 28.7721 23.0099 28.8074C23.1872 28.8426 23.371 28.8245 23.538 28.7553C23.705 28.6862 23.8478 28.569 23.9482 28.4187C24.0487 28.2684 24.1023 28.0917 24.1023 27.9109C24.1023 27.6685 24.006 27.436 23.8345 27.2645C23.6631 27.0931 23.4306 26.9968 23.1882 26.9968ZM23.4468 27.8447C23.3819 27.8432 23.3201 27.8167 23.2741 27.7708C23.2282 27.7249 23.2018 27.6631 23.2002 27.5982C23.2095 27.5386 23.2398 27.4844 23.2855 27.4452C23.3313 27.406 23.3896 27.3845 23.4498 27.3845C23.5101 27.3845 23.5683 27.406 23.6141 27.4452C23.6598 27.4844 23.6901 27.5386 23.6994 27.5982C23.6978 27.6641 23.6705 27.7268 23.6233 27.7729C23.5761 27.819 23.5128 27.8447 23.4468 27.8447Z" fill="#10110E"/>
<path opacity="0.2" d="M18.8644 34.3635C23.5472 34.3635 27.3433 31.6281 27.3433 28.2538C27.3433 24.8796 23.5472 22.1442 18.8644 22.1442C14.1815 22.1442 10.3854 24.8796 10.3854 28.2538C10.3854 31.6281 14.1815 34.3635 18.8644 34.3635Z" fill="#8ACCCE"/>
<path d="M29.1295 24.8561V20.8452C29.4459 20.7754 29.7305 20.6033 29.9392 20.3554C30.148 20.1076 30.2692 19.7978 30.284 19.4741C30.2422 19.083 30.0573 18.7212 29.7648 18.4582C29.4722 18.1953 29.0928 18.0498 28.6995 18.0498C28.3062 18.0498 27.9267 18.1953 27.6342 18.4582C27.3417 18.7212 27.1567 19.083 27.1149 19.4741C27.1285 19.7973 27.2485 20.1069 27.4562 20.3549C27.6639 20.6028 27.9477 20.7752 28.2635 20.8452V24.7539H28.1493C26.9466 20.5806 23.3926 17.9888 18.7562 17.9888C14.1199 17.9888 10.5418 20.5565 9.35719 24.7539H8.95429C8.51854 24.7326 8.09202 24.8843 7.76763 25.176C7.44324 25.4677 7.24727 25.8758 7.22241 26.3114V29.4204C7.2488 29.8548 7.44542 30.2614 7.76964 30.5519C8.09386 30.8423 8.51952 30.9932 8.95429 30.9718H9.50151C9.9665 32.1513 10.7091 33.2013 11.6664 34.0327L10.8846 34.7302C10.8365 34.7707 10.7969 34.8203 10.7682 34.8762C10.7394 34.932 10.722 34.9931 10.7169 35.0557C10.7119 35.1183 10.7193 35.1814 10.7388 35.2411C10.7583 35.3008 10.7895 35.3561 10.8305 35.4038C12.5864 37.5265 15.4669 38.7713 18.7262 38.7713C21.9855 38.7713 24.8659 37.5686 26.6218 35.4038C26.6628 35.3561 26.694 35.3008 26.7135 35.2411C26.733 35.1814 26.7404 35.1183 26.7354 35.0557C26.7304 34.9931 26.713 34.932 26.6842 34.8762C26.6554 34.8203 26.6158 34.7707 26.5677 34.7302L25.786 34.0327C26.7392 33.1977 27.4811 32.1488 27.9508 30.9718H28.5522C28.9869 30.9932 29.4126 30.8423 29.7368 30.5519C30.061 30.2614 30.2577 29.8548 30.284 29.4204V26.3114C30.2706 25.9778 30.1516 25.6571 29.944 25.3955C29.7365 25.1339 29.4513 24.9451 29.1295 24.8561ZM18.7562 22.4207C23.0498 22.4207 26.5377 25.247 26.5377 28.7168C26.5377 32.4752 22.6169 34.1289 18.7562 34.1289C14.8956 34.1289 10.9748 32.4451 10.9748 28.7168C10.9748 25.247 14.4626 22.4207 18.7562 22.4207Z" fill="white"/>
<path d="M29.4181 28.3804H28.2635C28.2635 28.2 28.2635 28.0196 28.2635 27.8152C28.2629 27.0478 28.1864 26.2823 28.035 25.53H28.5221C28.6307 25.5227 28.7397 25.5373 28.8425 25.5729C28.9453 25.6086 29.04 25.6645 29.1207 25.7374C29.2015 25.8104 29.2668 25.8988 29.3127 25.9975C29.3587 26.0961 29.3843 26.203 29.3881 26.3118L29.4181 28.3804Z" fill="#515151"/>
<path d="M28.5524 30.1961H27.951C28.0655 29.7713 28.1519 29.3394 28.2096 28.9032H29.4123V29.4204C29.4085 29.5283 29.3831 29.6344 29.3375 29.7324C29.2918 29.8303 29.227 29.9181 29.1468 29.9905C29.0665 30.0628 28.9726 30.1183 28.8705 30.1537C28.7684 30.189 28.6602 30.2034 28.5524 30.1961Z" fill="#515151"/>
<path d="M18.7561 37.9716C15.8697 37.9716 13.3079 36.9312 11.6903 35.0911L12.5021 34.3695C14.35 35.6033 16.535 36.2336 18.7561 36.1735C20.9771 36.2324 23.1618 35.6022 25.0101 34.3695L25.8159 35.0911C24.2043 36.9312 21.6366 37.9716 18.7561 37.9716Z" fill="#515151"/>
<path d="M8.9543 25.5296H9.47146C9.32131 26.2821 9.24478 27.0474 9.24295 27.8147C9.2286 28.0029 9.2286 28.1918 9.24295 28.38H8.11843V26.3113C8.11634 26.2034 8.13697 26.0963 8.17897 25.9969C8.22098 25.8975 8.28341 25.808 8.36224 25.7343C8.44106 25.6606 8.5345 25.6042 8.6365 25.569C8.7385 25.5337 8.84678 25.5203 8.9543 25.5296Z" fill="#515151"/>
<path d="M18.7561 21.9037C17.7793 21.9066 16.8077 22.0462 15.8696 22.3186V19.1856C16.8084 18.9193 17.7803 18.7877 18.7561 18.7947C19.7299 18.7881 20.6997 18.9197 21.6365 19.1856V22.3426C20.7042 22.0509 19.733 21.9029 18.7561 21.9037Z" fill="black"/>
<path d="M15.2986 19.3661V22.5292C12.4121 23.5875 10.3976 25.9749 10.3976 28.717C10.3976 32.271 13.7712 34.6764 18.7563 34.6764C23.7415 34.6764 27.115 32.271 27.115 28.717C27.115 25.9749 25.0945 23.5875 22.2141 22.5292V19.3661C25.5876 20.5688 27.6923 23.6898 27.6923 27.8391C27.6923 32.5055 24.1143 35.6566 18.7563 35.6566C13.3983 35.6566 9.82031 32.5235 9.82031 27.8391C9.82031 23.6898 11.925 20.5808 15.2986 19.3661Z" fill="#515151"/>
<path d="M8.08841 28.9032H9.2911C9.34596 29.3398 9.43238 29.7719 9.54968 30.1961H8.94834C8.84024 30.2034 8.73177 30.189 8.62932 30.1538C8.52687 30.1185 8.43251 30.0631 8.35181 29.9908C8.27111 29.9185 8.2057 29.8308 8.15943 29.7328C8.11316 29.6348 8.08697 29.5286 8.0824 29.4204L8.08841 28.9032Z" fill="#515151"/>
<path d="M28.6966 20.0933C29.0951 20.0933 29.4182 19.8026 29.4182 19.4439C29.4182 19.0852 29.0951 18.7944 28.6966 18.7944C28.2981 18.7944 27.975 19.0852 27.975 19.4439C27.975 19.8026 28.2981 20.0933 28.6966 20.0933Z" fill="#515151"/>
</svg>
</file>

<file path="public/images/icon/message-ai.svg">
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M20.25 13.5139V13.5139C20.25 14.9505 20.25 15.6689 20.0153 16.2355C19.7024 16.991 19.1021 17.5912 18.3466 17.9042C17.78 18.1389 17.0617 18.1389 15.625 18.1389H12.8543C12.3073 18.1389 11.7827 18.3555 11.3959 18.7409L9.93258 20.1993C9.17217 20.9572 7.875 20.4186 7.875 19.345V19.345C7.875 18.6789 7.33499 18.1389 6.66885 18.1389H5.8125C4.67341 18.1389 3.75 17.2155 3.75 16.0764V8.68333C3.75 6.95651 3.75 6.09309 4.08606 5.43353C4.38167 4.85336 4.85336 4.38167 5.43353 4.08606C6.09309 3.75 6.95651 3.75 8.68334 3.75H11.3959" stroke="#65676C" stroke-width="1.54167" stroke-linecap="round"/>
<path d="M18.3369 8.68764L17.6721 10.7136C17.5383 11.1213 16.9617 11.1213 16.8279 10.7136L16.1631 8.68764C16.031 8.28489 15.7151 7.96902 15.3124 7.83687L13.2864 7.17209C12.8787 7.03833 12.8787 6.46167 13.2864 6.32791L15.3124 5.66313C15.7151 5.53098 16.031 5.21511 16.1631 4.81236L16.8279 2.78637C16.9617 2.37872 17.5383 2.37872 17.6721 2.78637L18.3369 4.81236C18.469 5.21511 18.7849 5.53098 19.1876 5.66313L21.2136 6.32791C21.6213 6.46167 21.6213 7.03833 21.2136 7.17209L19.1876 7.83687C18.7849 7.96902 18.469 8.28489 18.3369 8.68764Z" fill="#B342FF"/>
<path d="M14 13H8" stroke="#65676C" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
<path d="M11 10H8" stroke="#65676C" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
</file>

<file path="public/images/logo-white-with-text.svg">
<svg width="268" height="64" viewBox="0 0 268 64" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <!-- Gradient for subtle depth -->
    <linearGradient id="textGradient" x1="0%" y1="0%" x2="100%" y2="0%">
      <stop offset="0%" style="stop-color:#FFFFFF;stop-opacity:1" />
      <stop offset="50%" style="stop-color:#F0F0F0;stop-opacity:1" />
      <stop offset="100%" style="stop-color:#FFFFFF;stop-opacity:1" />
    </linearGradient>
    
    <!-- Subtle shadow filter -->
    <filter id="dropShadow" x="-20%" y="-20%" width="140%" height="140%">
      <feDropShadow dx="1" dy="1" stdDeviation="0.5" flood-color="#000000" flood-opacity="0.2"/>
    </filter>
  </defs>
  
  <!-- Background decorative elements -->
  <circle cx="24" cy="32" r="2" fill="#CCCCCC" opacity="0.6"/>
  <circle cx="244" cy="32" r="2" fill="#CCCCCC" opacity="0.6"/>
  
  <!-- Decorative lines -->
  <line x1="40" y1="32" x2="60" y2="32" stroke="#CCCCCC" stroke-width="1" opacity="0.8"/>
  <line x1="208" y1="32" x2="228" y2="32" stroke="#CCCCCC" stroke-width="1" opacity="0.8"/>
  
  <!-- Main text "VISI" -->
  <text x="134" y="42" 
        font-family="serif" 
        font-size="36" 
        font-weight="bold" 
        text-anchor="middle" 
        fill="url(#textGradient)"
        filter="url(#dropShadow)"
        letter-spacing="4px">VISI</text>
  
  <!-- Decorative underline -->
  <line x1="84" y1="50" x2="184" y2="50" stroke="#FFFFFF" stroke-width="2" opacity="0.8"/>
  
  <!-- Small decorative dots -->
  <circle cx="80" cy="50" r="1.5" fill="#FFFFFF"/>
  <circle cx="188" cy="50" r="1.5" fill="#FFFFFF"/>
  
  <!-- Elegant corner accents -->
  <path d="M 10 10 L 25 10 L 25 12 L 12 12 L 12 25 L 10 25 Z" fill="#FFFFFF" opacity="0.6"/>
  <path d="M 258 10 L 243 10 L 243 12 L 256 12 L 256 25 L 258 25 Z" fill="#FFFFFF" opacity="0.6"/>
  <path d="M 10 54 L 25 54 L 25 52 L 12 52 L 12 39 L 10 39 Z" fill="#FFFFFF" opacity="0.6"/>
  <path d="M 258 54 L 243 54 L 243 52 L 256 52 L 256 39 L 258 39 Z" fill="#FFFFFF" opacity="0.6"/>
</svg>
</file>

<file path="public/images/logo.svg">
<svg width="30" height="30" viewBox="0 0 30 30" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M15.8023 7.82981C16.2779 8.98701 16.0102 10.1784 15.2043 10.491C14.3983 10.8035 13.3594 10.1187 12.8838 8.96153C12.4082 7.80433 12.676 6.61289 13.4819 6.30038C14.2878 5.98786 15.3267 6.67261 15.8023 7.82981Z" fill="#262626"/>
<path d="M29.2498 21.952C29.6972 22.4662 30.06 23.0215 29.9917 23.685C29.9234 24.3486 29.3086 24.614 28.8987 24.6804C28.4888 24.7467 20.4276 25.8084 19.5396 25.8748C18.7537 25.9335 18.6097 25.8363 18.303 25.6293C18.1647 25.5398 15.0158 22.5446 13.4586 21.0582C12.69 20.502 11.9941 20.0605 11.5031 19.8762C11.0511 19.7065 10.8708 19.0927 11.2918 18.7366L12.3395 17.8503C12.6148 17.6175 13.0379 17.6319 13.2922 17.9027C13.5897 18.1624 14.5664 19.2307 15.0176 19.7324C16.4453 21.0988 18.1849 22.7674 19.1297 23.685C19.8811 23.9504 21.6801 23.6187 22.0672 23.486C22.0672 23.486 19.4312 20.2141 18.8919 19.8065C18.3525 19.3989 17.8676 19.0849 17.4905 18.9339C16.7022 18.5185 17.059 17.9764 17.336 17.7573L18.4758 16.9463C18.7522 16.7496 19.1457 16.7781 19.3852 17.0359C20.803 18.8099 23.7888 22.4906 24.3899 23.0215C25.1414 23.2869 26.8948 22.9994 27.3274 22.8224L21.8995 16.0762C21.0284 15.3386 20.2227 14.7346 19.6677 14.5037C19.2263 14.3201 19.0551 13.6941 19.5023 13.3497L20.6563 12.4606C20.8517 12.3422 21.3174 12.1979 21.6163 12.5686L22.4088 13.5326L29.2498 21.952Z" fill="#262626"/>
<path d="M11.8478 1.99067C10.5707 1.99067 9.16387 2.29138 7.65774 3.03904C4.50493 4.60413 2.85603 7.82981 2.33475 10.202C1.60286 13.5326 2.02008 17.0359 3.22442 19.2504C4.07463 20.8137 4.76646 21.6232 6.14326 22.773C8.22894 24.5149 9.81294 25.2866 12.5342 25.6205C13.3997 25.7267 14.7668 25.6858 14.7668 25.6858C15.0555 25.6943 15.3305 25.807 15.5383 26.0018L16.946 27.322L18.5323 28.7087C18.8115 28.9528 18.6338 29.4028 18.2581 29.4028H16.4788C16.1959 29.4028 15.9415 29.1595 15.8496 29.0378C15.2849 28.4856 14.3617 27.6654 14.3617 27.6654L12.5949 27.6134L12.0702 29.601C12.0082 29.8358 11.7904 30 11.5408 30H10.8359C10.4826 30 10.2222 29.6793 10.3044 29.3456L10.7754 27.4341C10.4111 27.3614 10.0218 27.2603 9.62389 27.1204L8.89011 29.615C8.82307 29.8429 8.60863 30 8.36462 30H7.57716C7.21754 30 6.95595 29.6684 7.04944 29.3312L7.88561 26.3144C6.21075 25.5469 4.73704 24.2212 4.73704 24.2212C3.61206 23.3518 2.40208 21.6625 1.93772 20.9265C0.758197 18.9403 0.394862 17.7438 0.0906286 15.4688C-0.12877 13.8281 0.0906362 11.06 0.319969 9.83744C1.19531 6.30038 2.88436 3.2418 6.58906 1.34044C8.46832 0.375947 10.2771 0 11.8478 0C13.447 0 15.5446 0.508003 17.1081 1.30947C18.6578 2.10386 19.4247 2.82829 20.4677 3.84627C20.795 4.1666 21.6271 4.79496 22.3369 4.74577C22.7866 4.80486 24.0471 4.75887 25.4919 4.10215C26.2394 3.83912 26.7594 4.35638 26.9213 4.63196C27.103 4.91761 27.3006 5.6137 26.6372 6.11287L21.7843 9.76476C21.5609 10.1265 21.3962 10.4625 21.3325 10.7478C21.1055 11.6585 20.3487 11.25 20.057 11.06C19.7653 10.87 19.0996 9.90218 19.0996 9.90218C18.8562 9.60785 18.9128 9.17176 19.2335 8.94832C19.5878 8.70146 20.7613 7.88917 21.6518 7.34629L22.4617 6.73683C21.868 6.78175 20.3598 6.55944 19.0768 5.3108C19.0768 5.3108 17.441 3.72084 16.1516 3.07001C14.6097 2.29178 13.0964 1.99067 11.8478 1.99067Z" fill="#262626"/>
</svg>
</file>

<file path="README.md">
This is a [Next.js](https://nextjs.org/) project bootstrapped with [`create-next-app`](https://github.com/vercel/next.js/tree/canary/packages/create-next-app).

## Start wren-ui from source code

Step 1. Make sure your node version is 18
```bash
node -v
```

Step 2. Install dependencies:

```bash
yarn 
```

Step 3(Optional). Switching database

Wren-ui uses SQLite as our default database. To use Postgres as the database of wren-ui, you need to set the two environment variable below.

```bash
# windows
SET DB_TYPE=pg
SET PG_URL=postgres://user:password@localhost:5432/dbname 

# linux or mac
export DB_TYPE=pg
export PG_URL=postgres://user:password@localhost:5432/dbname
```
-  `PG_URL` is the connection string of your postgres database.

To switch back to using SQLite, you can reassign the `DB_TYPE` to `sqlite`.
```
# windows
SET DB_TYPE=sqlite
SET SQLITE_FILE={your_sqlite_file_path} # default is ./db.sqlite3

# linux or mac
export DB_TYPE=sqlite
export SQLITE_FILE={your_sqlite_file_path}
```

Step 4. Run migrations:

```bash
yarn migrate
# or
npm run migrate
```


Step 5. Run the development server:

```bash
# Execute this if you start wren-engine and ibis-server via docker
# Linux or MacOS
export OTHER_SERVICE_USING_DOCKER=true
export EXPERIMENTAL_ENGINE_RUST_VERSION=false # set to true if you want to use the experimental Rust version of the Wren Engine
# Windows
SET OTHER_SERVICE_USING_DOCKER=true
SET EXPERIMENTAL_ENGINE_RUST_VERSION=false # set to true if you want to use the experimental Rust version of the Wren Engine

# Run the development server
yarn dev
# or
npm run dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.


## Development wren-ui module on local
There are many modules in Wren AI, to develop wren-ui, you can start other modules(services) via docker-compose.
In the [Start wren-ui from source code](#Start-wren-ui-from-source-code) section, you've know how to start wren-ui from the source code to develop.
To start other modules via docker-compose, you can follow the steps below.

Step 1. Prepare you .env file
In the WrenAI/docker folder, you can find the .env.example file. You can copy this file to .env.local file.

```bash
# assume current directory is wren-ui
cd ../docker
cp .env.example .env.local
```
Step 2. Modify your .env.local file
You need to fill the `OPENAI_API_KEY` with your OPENAI api key before starting.

You can also change the `WREN_ENGINE_VERSION`, `WREN_AI_SERVICE_VERSION`, `IBIS_SERVER_VERSION` to the version you want to use.


Step 3. Start the services via docker-compose
```bash
# current directory is WrenAI/docker
docker-compose -f docker-compose-dev.yaml --env-file .env.example up

# you can add a -d flag to run the services in the background
docker-compose -f docker-compose-dev.yaml --env-file .env.example up -d
# then stop the services via
docker-compose -f docker-compose-dev.yaml --env-file .env.example down
```

Step 4. Start wren-ui from source code
refer to [Start wren-ui from source code](#Start-wren-ui-from-source-code) section to start wren-ui from source code.

Step 5. (Optional) Develop other modules along with wren-ui

As mentioned above, you can use docker-compose to start other modules. The same applies when developing other modules.
From the perspective of wren-ui, if you want to develop other modules at the same time, you can stop the container then spin up the module from the source code.

eg: If you want to develop ai-service module, you can stop the ai-service container then start the ai-service from the source code.
```yaml
# docker/docker-compose-dev.yaml
wren-engine:
    image: ghcr.io/canner/wren-engine:${WREN_ENGINE_VERSION}
    pull_policy: always
    platform: ${PLATFORM}
    expose:
      - ${WREN_ENGINE_SQL_PORT}
    ports:
      - ${WREN_ENGINE_PORT}:${WREN_ENGINE_PORT}
    volumes:
      - data:/usr/src/app/etc
    networks:
      - wren
    depends_on:
      - bootstrap
    ...
# comment out the ai-service service
wren-ai-service:
    image: ghcr.io/canner/wren-ai-service:${WREN_AI_SERVICE_VERSION}
    pull_policy: always
    platform: ${PLATFORM}
    ports:
      - ${AI_SERVICE_FORWARD_PORT}:${WREN_AI_SERVICE_PORT}
    environment:
      WREN_UI_ENDPOINT: http://host.docker.internal:${WREN_UI_PORT}
      # sometimes the console won't show print messages,
      # using PYTHONUNBUFFERED: 1 can fix this
      PYTHONUNBUFFERED: 1
      CONFIG_PATH: /app/data/config.yaml
    env_file:
      - ${PROJECT_DIR}/.env
    volumes:
      - ${PROJECT_DIR}/config.yaml:/app/data/config.yaml
    networks:
      - wren
    depends_on:
      - qdrant

ibis-server:
    image: ghcr.io/canner/wren-engine-ibis:${IBIS_SERVER_VERSION}
    ...
```
Then refer to the README.md or CONTRIBUTION.md file the module for starting the module from the source code. 

eg: refer to the [ai-service README](https://github.com/Canner/WrenAI/blob/main/wren-ai-service/README.md#start-the-service-for-development) to start the ai-service from the source code.



## FAQ
### Can I have multiple project at the same time in Wren AI?
We currently do not support multiple projects in Wren AI. You can only have one project at a time.
But there is a workaround for this. Since Wren Engine is stateless and we store your semantic model in the database(Sqlite or Postgres), 
you can switch between projects by switching the database and make sure you deploying after server started.

> Tip: Define the `DB_TYPE` and `SQLITE_FILE` or `PG_URL` variable to specify which database you intend to use.

eg: 
```bash
# start your first project using default database(sqlite by defulat)
yarn migrate
yarn dev

# ... after onboarding and lots of hard work, you want to switch to another project 
# stop the server

# set another sqlite file
export SQLITE_FILE=./new_project.sqlite
yarn migrate
yarn dev

# In the Browser, ... after another onboarding process and hard work
# you can switch back to the first project by setting the first sqlite file
export SQLITE_FILE=./first_project.sqlite

yarn dev  # no need to do migration again

# in the modeling page, click the deploy button to deploy the project to the wren-ai-service.
# your Wren AI is ready to answer your question.
```

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js/) - your feedback and contributions are welcome!
</file>

<file path="src/apollo/client/graphql/__types__.ts">
import { gql } from '@apollo/client';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  DialectSQL: any;
  JSON: any;
};

export type AdjustThreadResponseChartInput = {
  chartType: ChartType;
  color?: InputMaybe<Scalars['String']>;
  theta?: InputMaybe<Scalars['String']>;
  xAxis?: InputMaybe<Scalars['String']>;
  xOffset?: InputMaybe<Scalars['String']>;
  yAxis?: InputMaybe<Scalars['String']>;
};

export type AdjustThreadResponseInput = {
  sql?: InputMaybe<Scalars['String']>;
  sqlGenerationReasoning?: InputMaybe<Scalars['String']>;
  tables?: InputMaybe<Array<Scalars['String']>>;
};

export type AdjustmentTask = {
  __typename?: 'AdjustmentTask';
  error?: Maybe<Error>;
  invalidSql?: Maybe<Scalars['String']>;
  queryId?: Maybe<Scalars['String']>;
  sql?: Maybe<Scalars['String']>;
  status?: Maybe<AskingTaskStatus>;
  traceId?: Maybe<Scalars['String']>;
};

export type ApiHistoryFilterInput = {
  apiType?: InputMaybe<ApiType>;
  endDate?: InputMaybe<Scalars['String']>;
  projectId?: InputMaybe<Scalars['Int']>;
  startDate?: InputMaybe<Scalars['String']>;
  statusCode?: InputMaybe<Scalars['Int']>;
  threadId?: InputMaybe<Scalars['String']>;
};

export type ApiHistoryPaginatedResponse = {
  __typename?: 'ApiHistoryPaginatedResponse';
  hasMore: Scalars['Boolean'];
  items: Array<ApiHistoryResponse>;
  total: Scalars['Int'];
};

export type ApiHistoryPaginationInput = {
  limit: Scalars['Int'];
  offset: Scalars['Int'];
};

export type ApiHistoryResponse = {
  __typename?: 'ApiHistoryResponse';
  apiType: ApiType;
  createdAt: Scalars['String'];
  durationMs?: Maybe<Scalars['Int']>;
  headers?: Maybe<Scalars['JSON']>;
  id: Scalars['String'];
  projectId: Scalars['Int'];
  requestPayload?: Maybe<Scalars['JSON']>;
  responsePayload?: Maybe<Scalars['JSON']>;
  statusCode?: Maybe<Scalars['Int']>;
  threadId?: Maybe<Scalars['String']>;
  updatedAt: Scalars['String'];
};

export enum ApiType {
  GENERATE_SQL = 'GENERATE_SQL',
  GENERATE_VEGA_CHART = 'GENERATE_VEGA_CHART',
  RUN_SQL = 'RUN_SQL'
}

export type AskingTask = {
  __typename?: 'AskingTask';
  candidates: Array<ResultCandidate>;
  error?: Maybe<Error>;
  intentReasoning?: Maybe<Scalars['String']>;
  invalidSql?: Maybe<Scalars['String']>;
  queryId?: Maybe<Scalars['String']>;
  rephrasedQuestion?: Maybe<Scalars['String']>;
  retrievedTables?: Maybe<Array<Scalars['String']>>;
  sqlGenerationReasoning?: Maybe<Scalars['String']>;
  status: AskingTaskStatus;
  traceId?: Maybe<Scalars['String']>;
  type?: Maybe<AskingTaskType>;
};

export type AskingTaskInput = {
  question: Scalars['String'];
  threadId?: InputMaybe<Scalars['Int']>;
};

export enum AskingTaskStatus {
  CORRECTING = 'CORRECTING',
  FAILED = 'FAILED',
  FINISHED = 'FINISHED',
  GENERATING = 'GENERATING',
  PLANNING = 'PLANNING',
  SEARCHING = 'SEARCHING',
  STOPPED = 'STOPPED',
  UNDERSTANDING = 'UNDERSTANDING'
}

export enum AskingTaskType {
  GENERAL = 'GENERAL',
  MISLEADING_QUERY = 'MISLEADING_QUERY',
  TEXT_TO_SQL = 'TEXT_TO_SQL'
}

export enum CacheScheduleDayEnum {
  FRI = 'FRI',
  MON = 'MON',
  SAT = 'SAT',
  SUN = 'SUN',
  THU = 'THU',
  TUE = 'TUE',
  WED = 'WED'
}

export type CalculatedFieldInput = {
  diagram?: InputMaybe<Scalars['JSON']>;
  expression: Scalars['String'];
  lineage: Array<Scalars['Int']>;
  name: Scalars['String'];
};

export type CalculatedFieldValidationResponse = {
  __typename?: 'CalculatedFieldValidationResponse';
  message?: Maybe<Scalars['String']>;
  valid: Scalars['Boolean'];
};

export enum ChartTaskStatus {
  FAILED = 'FAILED',
  FETCHING = 'FETCHING',
  FINISHED = 'FINISHED',
  GENERATING = 'GENERATING',
  STOPPED = 'STOPPED'
}

export enum ChartType {
  AREA = 'AREA',
  BAR = 'BAR',
  GROUPED_BAR = 'GROUPED_BAR',
  LINE = 'LINE',
  MULTI_LINE = 'MULTI_LINE',
  PIE = 'PIE',
  STACKED_BAR = 'STACKED_BAR'
}

export type CompactColumn = {
  __typename?: 'CompactColumn';
  name: Scalars['String'];
  properties?: Maybe<Scalars['JSON']>;
  type: Scalars['String'];
};

export type CompactTable = {
  __typename?: 'CompactTable';
  columns: Array<CompactColumn>;
  name: Scalars['String'];
  properties?: Maybe<Scalars['JSON']>;
};

export type CreateCalculatedFieldInput = {
  expression: ExpressionName;
  lineage: Array<Scalars['Int']>;
  modelId: Scalars['Int'];
  name: Scalars['String'];
};

export type CreateDashboardItemInput = {
  itemType: DashboardItemType;
  responseId: Scalars['Int'];
};

export type CreateInstructionInput = {
  instruction: Scalars['String'];
  isDefault: Scalars['Boolean'];
  questions: Array<Scalars['String']>;
};

export type CreateModelInput = {
  fields: Array<Scalars['String']>;
  primaryKey?: InputMaybe<Scalars['String']>;
  sourceTableName: Scalars['String'];
};

export type CreateSimpleMetricInput = {
  cached: Scalars['Boolean'];
  description?: InputMaybe<Scalars['String']>;
  dimension: Array<DimensionInput>;
  displayName: Scalars['String'];
  measure: Array<SimpleMeasureInput>;
  model: Scalars['String'];
  name: Scalars['String'];
  properties: Scalars['JSON'];
  refreshTime?: InputMaybe<Scalars['String']>;
  timeGrain: Array<TimeGrainInput>;
};

export type CreateSqlPairInput = {
  question: Scalars['String'];
  sql: Scalars['String'];
};

export type CreateThreadInput = {
  question?: InputMaybe<Scalars['String']>;
  sql?: InputMaybe<Scalars['String']>;
  taskId?: InputMaybe<Scalars['String']>;
};

export type CreateThreadResponseInput = {
  question?: InputMaybe<Scalars['String']>;
  sql?: InputMaybe<Scalars['String']>;
  taskId?: InputMaybe<Scalars['String']>;
};

export type CreateViewInput = {
  name: Scalars['String'];
  responseId: Scalars['Int'];
};

export type CustomFieldInput = {
  expression: Scalars['String'];
  name: Scalars['String'];
};

export type Dashboard = {
  __typename?: 'Dashboard';
  cacheEnabled: Scalars['Boolean'];
  id: Scalars['Int'];
  name: Scalars['String'];
  nextScheduledAt?: Maybe<Scalars['String']>;
  projectId: Scalars['Int'];
  scheduleCron?: Maybe<Scalars['String']>;
  scheduleFrequency?: Maybe<ScheduleFrequencyEnum>;
  scheduleTimezone?: Maybe<Scalars['String']>;
};

export type DashboardItem = {
  __typename?: 'DashboardItem';
  dashboardId: Scalars['Int'];
  detail: DashboardItemDetail;
  displayName?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  layout: DashboardItemLayout;
  type: DashboardItemType;
};

export type DashboardItemDetail = {
  __typename?: 'DashboardItemDetail';
  chartSchema?: Maybe<Scalars['JSON']>;
  sql: Scalars['String'];
};

export type DashboardItemLayout = {
  __typename?: 'DashboardItemLayout';
  h: Scalars['Int'];
  w: Scalars['Int'];
  x: Scalars['Int'];
  y: Scalars['Int'];
};

export enum DashboardItemType {
  AREA = 'AREA',
  BAR = 'BAR',
  GROUPED_BAR = 'GROUPED_BAR',
  LINE = 'LINE',
  MULTI_LINE = 'MULTI_LINE',
  NUMBER = 'NUMBER',
  PIE = 'PIE',
  STACKED_BAR = 'STACKED_BAR',
  TABLE = 'TABLE'
}

export type DashboardItemWhereInput = {
  id: Scalars['Int'];
};

export type DashboardSchedule = {
  __typename?: 'DashboardSchedule';
  cron?: Maybe<Scalars['String']>;
  day?: Maybe<CacheScheduleDayEnum>;
  frequency?: Maybe<ScheduleFrequencyEnum>;
  hour?: Maybe<Scalars['Int']>;
  minute?: Maybe<Scalars['Int']>;
  timezone?: Maybe<Scalars['String']>;
};

export type DataSource = {
  __typename?: 'DataSource';
  properties: Scalars['JSON'];
  sampleDataset?: Maybe<SampleDatasetName>;
  type: DataSourceName;
};

export type DataSourceInput = {
  properties: Scalars['JSON'];
  type: DataSourceName;
};

export enum DataSourceName {
  ATHENA = 'ATHENA',
  BIG_QUERY = 'BIG_QUERY',
  CLICK_HOUSE = 'CLICK_HOUSE',
  DUCKDB = 'DUCKDB',
  MSSQL = 'MSSQL',
  MYSQL = 'MYSQL',
  ORACLE = 'ORACLE',
  POSTGRES = 'POSTGRES',
  REDSHIFT = 'REDSHIFT',
  SNOWFLAKE = 'SNOWFLAKE',
  TRINO = 'TRINO'
}

export type DeleteDashboardItemInput = {
  itemId: Scalars['Int'];
};

export type DetailStep = {
  __typename?: 'DetailStep';
  cteName?: Maybe<Scalars['String']>;
  sql: Scalars['String'];
  summary: Scalars['String'];
};

export type DetailedAffectedCalculatedFields = {
  __typename?: 'DetailedAffectedCalculatedFields';
  displayName: Scalars['String'];
  referenceName: Scalars['String'];
  type: Scalars['String'];
};

export type DetailedAffectedRelationships = {
  __typename?: 'DetailedAffectedRelationships';
  displayName: Scalars['String'];
  referenceName: Scalars['String'];
};

export type DetailedChangeColumn = {
  __typename?: 'DetailedChangeColumn';
  displayName: Scalars['String'];
  sourceColumnName: Scalars['String'];
  type: Scalars['String'];
};

export type DetailedChangeTable = {
  __typename?: 'DetailedChangeTable';
  calculatedFields: Array<DetailedAffectedCalculatedFields>;
  columns: Array<DetailedChangeColumn>;
  displayName: Scalars['String'];
  relationships: Array<DetailedAffectedRelationships>;
  sourceTableName: Scalars['String'];
};

export type DetailedColumn = {
  __typename?: 'DetailedColumn';
  displayName: Scalars['String'];
  isCalculated: Scalars['Boolean'];
  nestedColumns?: Maybe<Array<DetailedNestedColumn>>;
  notNull: Scalars['Boolean'];
  properties: Scalars['JSON'];
  referenceName: Scalars['String'];
  sourceColumnName: Scalars['String'];
  type?: Maybe<Scalars['String']>;
};

export type DetailedDashboard = {
  __typename?: 'DetailedDashboard';
  cacheEnabled: Scalars['Boolean'];
  description?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  items: Array<DashboardItem>;
  name: Scalars['String'];
  nextScheduledAt?: Maybe<Scalars['String']>;
  schedule?: Maybe<DashboardSchedule>;
};

export type DetailedModel = {
  __typename?: 'DetailedModel';
  cached: Scalars['Boolean'];
  calculatedFields?: Maybe<Array<Maybe<DetailedColumn>>>;
  description?: Maybe<Scalars['String']>;
  displayName: Scalars['String'];
  fields?: Maybe<Array<Maybe<DetailedColumn>>>;
  primaryKey?: Maybe<Scalars['String']>;
  properties: Scalars['JSON'];
  refSql: Scalars['String'];
  referenceName: Scalars['String'];
  refreshTime?: Maybe<Scalars['String']>;
  relations?: Maybe<Array<Maybe<DetailedRelation>>>;
  sourceTableName: Scalars['String'];
};

export type DetailedNestedColumn = {
  __typename?: 'DetailedNestedColumn';
  columnPath: Array<Scalars['String']>;
  displayName: Scalars['String'];
  id: Scalars['Int'];
  properties?: Maybe<Scalars['JSON']>;
  referenceName: Scalars['String'];
  sourceColumnName: Scalars['String'];
  type?: Maybe<Scalars['String']>;
};

export type DetailedRelation = {
  __typename?: 'DetailedRelation';
  fromColumnId: Scalars['Int'];
  fromModelId: Scalars['Int'];
  name: Scalars['String'];
  properties: Scalars['JSON'];
  toColumnId: Scalars['Int'];
  toModelId: Scalars['Int'];
  type: RelationType;
};

export type DetailedThread = {
  __typename?: 'DetailedThread';
  id: Scalars['Int'];
  responses: Array<ThreadResponse>;
};

export type Diagram = {
  __typename?: 'Diagram';
  models: Array<Maybe<DiagramModel>>;
  views: Array<Maybe<DiagramView>>;
};

export type DiagramModel = {
  __typename?: 'DiagramModel';
  cached: Scalars['Boolean'];
  calculatedFields: Array<Maybe<DiagramModelField>>;
  description?: Maybe<Scalars['String']>;
  displayName: Scalars['String'];
  fields: Array<Maybe<DiagramModelField>>;
  id: Scalars['String'];
  modelId: Scalars['Int'];
  nodeType: NodeType;
  refSql?: Maybe<Scalars['String']>;
  referenceName: Scalars['String'];
  refreshTime?: Maybe<Scalars['String']>;
  relationFields: Array<Maybe<DiagramModelRelationField>>;
  sourceTableName: Scalars['String'];
};

export type DiagramModelField = {
  __typename?: 'DiagramModelField';
  aggregation?: Maybe<Scalars['String']>;
  columnId: Scalars['Int'];
  description?: Maybe<Scalars['String']>;
  displayName: Scalars['String'];
  expression?: Maybe<Scalars['String']>;
  id: Scalars['String'];
  isPrimaryKey: Scalars['Boolean'];
  lineage?: Maybe<Array<Scalars['Int']>>;
  nestedFields?: Maybe<Array<DiagramModelNestedField>>;
  nodeType: NodeType;
  referenceName: Scalars['String'];
  type: Scalars['String'];
};

export type DiagramModelNestedField = {
  __typename?: 'DiagramModelNestedField';
  columnPath: Array<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  displayName: Scalars['String'];
  id: Scalars['String'];
  nestedColumnId: Scalars['Int'];
  referenceName: Scalars['String'];
  type: Scalars['String'];
};

export type DiagramModelRelationField = {
  __typename?: 'DiagramModelRelationField';
  description?: Maybe<Scalars['String']>;
  displayName: Scalars['String'];
  fromColumnDisplayName: Scalars['String'];
  fromColumnId: Scalars['Int'];
  fromColumnName: Scalars['String'];
  fromModelDisplayName: Scalars['String'];
  fromModelId: Scalars['Int'];
  fromModelName: Scalars['String'];
  id: Scalars['String'];
  nodeType: NodeType;
  referenceName: Scalars['String'];
  relationId: Scalars['Int'];
  toColumnDisplayName: Scalars['String'];
  toColumnId: Scalars['Int'];
  toColumnName: Scalars['String'];
  toModelDisplayName: Scalars['String'];
  toModelId: Scalars['Int'];
  toModelName: Scalars['String'];
  type: RelationType;
};

export type DiagramView = {
  __typename?: 'DiagramView';
  description?: Maybe<Scalars['String']>;
  displayName: Scalars['String'];
  fields: Array<Maybe<DiagramViewField>>;
  id: Scalars['String'];
  nodeType: NodeType;
  referenceName: Scalars['String'];
  statement: Scalars['String'];
  viewId: Scalars['Int'];
};

export type DiagramViewField = {
  __typename?: 'DiagramViewField';
  description?: Maybe<Scalars['String']>;
  displayName: Scalars['String'];
  id: Scalars['String'];
  nodeType: NodeType;
  referenceName: Scalars['String'];
  type: Scalars['String'];
};

export type DimensionInput = {
  isCalculated: Scalars['Boolean'];
  name: Scalars['String'];
  notNull: Scalars['Boolean'];
  properties: Scalars['JSON'];
  type: Scalars['String'];
};

export type Error = {
  __typename?: 'Error';
  code?: Maybe<Scalars['String']>;
  message?: Maybe<Scalars['String']>;
  shortMessage?: Maybe<Scalars['String']>;
  stacktrace?: Maybe<Array<Maybe<Scalars['String']>>>;
};

export enum ExpressionName {
  ABS = 'ABS',
  AVG = 'AVG',
  CBRT = 'CBRT',
  CEIL = 'CEIL',
  CEILING = 'CEILING',
  COUNT = 'COUNT',
  COUNT_IF = 'COUNT_IF',
  EXP = 'EXP',
  FLOOR = 'FLOOR',
  LENGTH = 'LENGTH',
  LN = 'LN',
  LOG10 = 'LOG10',
  MAX = 'MAX',
  MIN = 'MIN',
  REVERSE = 'REVERSE',
  ROUND = 'ROUND',
  SIGN = 'SIGN',
  SUM = 'SUM'
}

export type FieldInfo = {
  __typename?: 'FieldInfo';
  displayName: Scalars['String'];
  expression?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  isCalculated: Scalars['Boolean'];
  nestedColumns?: Maybe<Array<NestedFieldInfo>>;
  notNull: Scalars['Boolean'];
  properties?: Maybe<Scalars['JSON']>;
  referenceName: Scalars['String'];
  sourceColumnName: Scalars['String'];
  type?: Maybe<Scalars['String']>;
};

export type GenerateQuestionInput = {
  sql: Scalars['String'];
};

export type GetMdlResult = {
  __typename?: 'GetMDLResult';
  hash: Scalars['String'];
  mdl?: Maybe<Scalars['String']>;
};

export type InstantRecommendedQuestionsInput = {
  previousQuestions?: InputMaybe<Array<Scalars['String']>>;
};

export type Instruction = {
  __typename?: 'Instruction';
  createdAt: Scalars['String'];
  id: Scalars['Int'];
  instruction: Scalars['String'];
  isDefault: Scalars['Boolean'];
  projectId: Scalars['Int'];
  questions: Array<Scalars['String']>;
  updatedAt: Scalars['String'];
};

export type InstructionWhereInput = {
  id: Scalars['Int'];
};

export type ItemLayoutInput = {
  h: Scalars['Int'];
  itemId: Scalars['Int'];
  w: Scalars['Int'];
  x: Scalars['Int'];
  y: Scalars['Int'];
};

export type LearningRecord = {
  __typename?: 'LearningRecord';
  paths: Array<Scalars['String']>;
};

export type MdlModelSubmitInput = {
  columns: Array<Scalars['String']>;
  name: Scalars['String'];
};

export type ModelInfo = {
  __typename?: 'ModelInfo';
  cached: Scalars['Boolean'];
  calculatedFields: Array<Maybe<FieldInfo>>;
  description?: Maybe<Scalars['String']>;
  displayName: Scalars['String'];
  fields: Array<Maybe<FieldInfo>>;
  id: Scalars['Int'];
  primaryKey?: Maybe<Scalars['String']>;
  properties?: Maybe<Scalars['JSON']>;
  refSql?: Maybe<Scalars['String']>;
  referenceName: Scalars['String'];
  refreshTime?: Maybe<Scalars['String']>;
  sourceTableName: Scalars['String'];
};

export type ModelSubstituteInput = {
  sql: Scalars['DialectSQL'];
};

export type ModelSyncResponse = {
  __typename?: 'ModelSyncResponse';
  status: SyncStatus;
};

export type ModelWhereInput = {
  id: Scalars['Int'];
};

export type Mutation = {
  __typename?: 'Mutation';
  adjustThreadResponse: ThreadResponse;
  adjustThreadResponseChart: ThreadResponse;
  cancelAdjustmentTask: Scalars['Boolean'];
  cancelAskingTask: Scalars['Boolean'];
  createAskingTask: Task;
  createCalculatedField: Scalars['JSON'];
  createDashboardItem: DashboardItem;
  createInstantRecommendedQuestions: Task;
  createInstruction: Instruction;
  createModel: Scalars['JSON'];
  createRelation: Scalars['JSON'];
  createSqlPair: SqlPair;
  createThread: Thread;
  createThreadResponse: ThreadResponse;
  createView: ViewInfo;
  deleteCalculatedField: Scalars['Boolean'];
  deleteDashboardItem: Scalars['Boolean'];
  deleteInstruction: Scalars['Boolean'];
  deleteModel: Scalars['Boolean'];
  deleteRelation: Scalars['Boolean'];
  deleteSqlPair: Scalars['Boolean'];
  deleteThread: Scalars['Boolean'];
  deleteView: Scalars['Boolean'];
  deploy: Scalars['JSON'];
  generateProjectRecommendationQuestions: Scalars['Boolean'];
  generateQuestion: Scalars['String'];
  generateThreadRecommendationQuestions: Scalars['Boolean'];
  generateThreadResponseAnswer: ThreadResponse;
  generateThreadResponseBreakdown: ThreadResponse;
  generateThreadResponseChart: ThreadResponse;
  modelSubstitute: Scalars['String'];
  previewBreakdownData: Scalars['JSON'];
  previewData: Scalars['JSON'];
  previewItemSQL: PreviewItemResponse;
  previewModelData: Scalars['JSON'];
  previewSql: Scalars['JSON'];
  previewViewData: Scalars['JSON'];
  rerunAdjustmentTask: Scalars['Boolean'];
  rerunAskingTask: Task;
  resetCurrentProject: Scalars['Boolean'];
  resolveSchemaChange: Scalars['Boolean'];
  saveDataSource: DataSource;
  saveLearningRecord: LearningRecord;
  saveRelations: Scalars['JSON'];
  saveTables: Scalars['JSON'];
  setDashboardSchedule: Dashboard;
  startSampleDataset: Scalars['JSON'];
  triggerDataSourceDetection: Scalars['Boolean'];
  updateCalculatedField: Scalars['JSON'];
  updateCurrentProject: Scalars['Boolean'];
  updateDashboardItem: DashboardItem;
  updateDashboardItemLayouts: Array<DashboardItem>;
  updateDataSource: DataSource;
  updateInstruction: Instruction;
  updateModel: Scalars['JSON'];
  updateModelMetadata: Scalars['Boolean'];
  updateRelation: Scalars['JSON'];
  updateSqlPair: SqlPair;
  updateThread: Thread;
  updateThreadResponse: ThreadResponse;
  updateViewMetadata: Scalars['Boolean'];
  validateCalculatedField: CalculatedFieldValidationResponse;
  validateView: ViewValidationResponse;
};


export type MutationAdjustThreadResponseArgs = {
  data: AdjustThreadResponseInput;
  responseId: Scalars['Int'];
};


export type MutationAdjustThreadResponseChartArgs = {
  data: AdjustThreadResponseChartInput;
  responseId: Scalars['Int'];
};


export type MutationCancelAdjustmentTaskArgs = {
  taskId: Scalars['String'];
};


export type MutationCancelAskingTaskArgs = {
  taskId: Scalars['String'];
};


export type MutationCreateAskingTaskArgs = {
  data: AskingTaskInput;
};


export type MutationCreateCalculatedFieldArgs = {
  data: CreateCalculatedFieldInput;
};


export type MutationCreateDashboardItemArgs = {
  data: CreateDashboardItemInput;
};


export type MutationCreateInstantRecommendedQuestionsArgs = {
  data: InstantRecommendedQuestionsInput;
};


export type MutationCreateInstructionArgs = {
  data: CreateInstructionInput;
};


export type MutationCreateModelArgs = {
  data: CreateModelInput;
};


export type MutationCreateRelationArgs = {
  data: RelationInput;
};


export type MutationCreateSqlPairArgs = {
  data: CreateSqlPairInput;
};


export type MutationCreateThreadArgs = {
  data: CreateThreadInput;
};


export type MutationCreateThreadResponseArgs = {
  data: CreateThreadResponseInput;
  threadId: Scalars['Int'];
};


export type MutationCreateViewArgs = {
  data: CreateViewInput;
};


export type MutationDeleteCalculatedFieldArgs = {
  where?: InputMaybe<UpdateCalculatedFieldWhere>;
};


export type MutationDeleteDashboardItemArgs = {
  where: DashboardItemWhereInput;
};


export type MutationDeleteInstructionArgs = {
  where: InstructionWhereInput;
};


export type MutationDeleteModelArgs = {
  where: ModelWhereInput;
};


export type MutationDeleteRelationArgs = {
  where: WhereIdInput;
};


export type MutationDeleteSqlPairArgs = {
  where: SqlPairWhereUniqueInput;
};


export type MutationDeleteThreadArgs = {
  where: ThreadUniqueWhereInput;
};


export type MutationDeleteViewArgs = {
  where: ViewWhereUniqueInput;
};


export type MutationDeployArgs = {
  force?: InputMaybe<Scalars['Boolean']>;
};


export type MutationGenerateQuestionArgs = {
  data: GenerateQuestionInput;
};


export type MutationGenerateThreadRecommendationQuestionsArgs = {
  threadId: Scalars['Int'];
};


export type MutationGenerateThreadResponseAnswerArgs = {
  responseId: Scalars['Int'];
};


export type MutationGenerateThreadResponseBreakdownArgs = {
  responseId: Scalars['Int'];
};


export type MutationGenerateThreadResponseChartArgs = {
  responseId: Scalars['Int'];
};


export type MutationModelSubstituteArgs = {
  data: ModelSubstituteInput;
};


export type MutationPreviewBreakdownDataArgs = {
  where: PreviewDataInput;
};


export type MutationPreviewDataArgs = {
  where: PreviewDataInput;
};


export type MutationPreviewItemSqlArgs = {
  data: PreviewItemSqlInput;
};


export type MutationPreviewModelDataArgs = {
  where: WhereIdInput;
};


export type MutationPreviewSqlArgs = {
  data?: InputMaybe<PreviewSqlDataInput>;
};


export type MutationPreviewViewDataArgs = {
  where: PreviewViewDataInput;
};


export type MutationRerunAdjustmentTaskArgs = {
  responseId: Scalars['Int'];
};


export type MutationRerunAskingTaskArgs = {
  responseId: Scalars['Int'];
};


export type MutationResolveSchemaChangeArgs = {
  where: ResolveSchemaChangeWhereInput;
};


export type MutationSaveDataSourceArgs = {
  data: DataSourceInput;
};


export type MutationSaveLearningRecordArgs = {
  data: SaveLearningRecordInput;
};


export type MutationSaveRelationsArgs = {
  data: SaveRelationInput;
};


export type MutationSaveTablesArgs = {
  data: SaveTablesInput;
};


export type MutationSetDashboardScheduleArgs = {
  data: SetDashboardScheduleInput;
};


export type MutationStartSampleDatasetArgs = {
  data: SampleDatasetInput;
};


export type MutationUpdateCalculatedFieldArgs = {
  data: UpdateCalculatedFieldInput;
  where: UpdateCalculatedFieldWhere;
};


export type MutationUpdateCurrentProjectArgs = {
  data: UpdateCurrentProjectInput;
};


export type MutationUpdateDashboardItemArgs = {
  data: UpdateDashboardItemInput;
  where: DashboardItemWhereInput;
};


export type MutationUpdateDashboardItemLayoutsArgs = {
  data: UpdateDashboardItemLayoutsInput;
};


export type MutationUpdateDataSourceArgs = {
  data: UpdateDataSourceInput;
};


export type MutationUpdateInstructionArgs = {
  data: UpdateInstructionInput;
  where: InstructionWhereInput;
};


export type MutationUpdateModelArgs = {
  data: UpdateModelInput;
  where: ModelWhereInput;
};


export type MutationUpdateModelMetadataArgs = {
  data: UpdateModelMetadataInput;
  where: ModelWhereInput;
};


export type MutationUpdateRelationArgs = {
  data: UpdateRelationInput;
  where: WhereIdInput;
};


export type MutationUpdateSqlPairArgs = {
  data: UpdateSqlPairInput;
  where: SqlPairWhereUniqueInput;
};


export type MutationUpdateThreadArgs = {
  data: UpdateThreadInput;
  where: ThreadUniqueWhereInput;
};


export type MutationUpdateThreadResponseArgs = {
  data: UpdateThreadResponseInput;
  where: ThreadResponseUniqueWhereInput;
};


export type MutationUpdateViewMetadataArgs = {
  data: UpdateViewMetadataInput;
  where: ViewWhereUniqueInput;
};


export type MutationValidateCalculatedFieldArgs = {
  data: ValidateCalculatedFieldInput;
};


export type MutationValidateViewArgs = {
  data: ValidateViewInput;
};

export type NestedFieldInfo = {
  __typename?: 'NestedFieldInfo';
  columnPath: Array<Scalars['String']>;
  displayName: Scalars['String'];
  id: Scalars['Int'];
  properties: Scalars['JSON'];
  referenceName: Scalars['String'];
  sourceColumnName: Scalars['String'];
  type: Scalars['String'];
};

export enum NodeType {
  CALCULATED_FIELD = 'CALCULATED_FIELD',
  FIELD = 'FIELD',
  METRIC = 'METRIC',
  MODEL = 'MODEL',
  RELATION = 'RELATION',
  VIEW = 'VIEW'
}

export enum OnboardingStatus {
  DATASOURCE_SAVED = 'DATASOURCE_SAVED',
  NOT_STARTED = 'NOT_STARTED',
  ONBOARDING_FINISHED = 'ONBOARDING_FINISHED',
  WITH_SAMPLE_DATASET = 'WITH_SAMPLE_DATASET'
}

export type OnboardingStatusResponse = {
  __typename?: 'OnboardingStatusResponse';
  status?: Maybe<OnboardingStatus>;
};

export type PreviewDataInput = {
  limit?: InputMaybe<Scalars['Int']>;
  responseId: Scalars['Int'];
  stepIndex?: InputMaybe<Scalars['Int']>;
};

export type PreviewItemResponse = {
  __typename?: 'PreviewItemResponse';
  cacheCreatedAt?: Maybe<Scalars['String']>;
  cacheHit: Scalars['Boolean'];
  cacheOverrodeAt?: Maybe<Scalars['String']>;
  data: Scalars['JSON'];
  override: Scalars['Boolean'];
};

export type PreviewItemSqlInput = {
  itemId: Scalars['Int'];
  limit?: InputMaybe<Scalars['Int']>;
  refresh?: InputMaybe<Scalars['Boolean']>;
};

export type PreviewSqlDataInput = {
  dryRun?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['Int']>;
  projectId?: InputMaybe<Scalars['String']>;
  sql: Scalars['String'];
};

export type PreviewViewDataInput = {
  id: Scalars['Int'];
  limit?: InputMaybe<Scalars['Int']>;
};

export enum ProjectLanguage {
  DE = 'DE',
  EN = 'EN',
  ES = 'ES',
  FR = 'FR',
  JA = 'JA',
  KO = 'KO',
  PT = 'PT',
  RU = 'RU',
  ZH_CN = 'ZH_CN',
  ZH_TW = 'ZH_TW'
}

export type Query = {
  __typename?: 'Query';
  adjustmentTask?: Maybe<AdjustmentTask>;
  apiHistory: ApiHistoryPaginatedResponse;
  askingTask?: Maybe<AskingTask>;
  autoGenerateRelation: Array<RecommendRelations>;
  dashboard: DetailedDashboard;
  dashboardItems: Array<DashboardItem>;
  diagram: Diagram;
  getMDL: GetMdlResult;
  getProjectRecommendationQuestions: RecommendedQuestionsTask;
  getThreadRecommendationQuestions: RecommendedQuestionsTask;
  instantRecommendedQuestions: RecommendedQuestionsTask;
  instructions: Array<Maybe<Instruction>>;
  learningRecord: LearningRecord;
  listDataSourceTables: Array<CompactTable>;
  listModels: Array<ModelInfo>;
  listViews: Array<ViewInfo>;
  model: DetailedModel;
  modelSync: ModelSyncResponse;
  nativeSql: Scalars['String'];
  onboardingStatus: OnboardingStatusResponse;
  schemaChange: SchemaChange;
  settings: Settings;
  sqlPairs: Array<Maybe<SqlPair>>;
  suggestedQuestions: SuggestedQuestionResponse;
  thread: DetailedThread;
  threadResponse: ThreadResponse;
  threads: Array<Thread>;
  view: ViewInfo;
};


export type QueryAdjustmentTaskArgs = {
  taskId: Scalars['String'];
};


export type QueryApiHistoryArgs = {
  filter?: InputMaybe<ApiHistoryFilterInput>;
  pagination: ApiHistoryPaginationInput;
};


export type QueryAskingTaskArgs = {
  taskId: Scalars['String'];
};


export type QueryGetMdlArgs = {
  hash: Scalars['String'];
};


export type QueryGetThreadRecommendationQuestionsArgs = {
  threadId: Scalars['Int'];
};


export type QueryInstantRecommendedQuestionsArgs = {
  taskId: Scalars['String'];
};


export type QueryModelArgs = {
  where: ModelWhereInput;
};


export type QueryNativeSqlArgs = {
  responseId: Scalars['Int'];
};


export type QueryThreadArgs = {
  threadId: Scalars['Int'];
};


export type QueryThreadResponseArgs = {
  responseId: Scalars['Int'];
};


export type QueryViewArgs = {
  where: ViewWhereUniqueInput;
};

export type RecommendRelations = {
  __typename?: 'RecommendRelations';
  displayName: Scalars['String'];
  id: Scalars['Int'];
  referenceName: Scalars['String'];
  relations: Array<Maybe<Relation>>;
};

export type RecommendedQuestionsTask = {
  __typename?: 'RecommendedQuestionsTask';
  error?: Maybe<Error>;
  questions: Array<ResultQuestion>;
  status: RecommendedQuestionsTaskStatus;
};

export enum RecommendedQuestionsTaskStatus {
  FAILED = 'FAILED',
  FINISHED = 'FINISHED',
  GENERATING = 'GENERATING',
  NOT_STARTED = 'NOT_STARTED'
}

export enum RedshiftConnectionType {
  redshift = 'redshift',
  redshift_iam = 'redshift_iam'
}

export type Relation = {
  __typename?: 'Relation';
  fromColumnId: Scalars['Int'];
  fromColumnReferenceName: Scalars['String'];
  fromModelId: Scalars['Int'];
  fromModelReferenceName: Scalars['String'];
  name: Scalars['String'];
  toColumnId: Scalars['Int'];
  toColumnReferenceName: Scalars['String'];
  toModelId: Scalars['Int'];
  toModelReferenceName: Scalars['String'];
  type: RelationType;
};

export type RelationInput = {
  fromColumnId: Scalars['Int'];
  fromModelId: Scalars['Int'];
  toColumnId: Scalars['Int'];
  toModelId: Scalars['Int'];
  type: RelationType;
};

export enum RelationType {
  MANY_TO_ONE = 'MANY_TO_ONE',
  ONE_TO_MANY = 'ONE_TO_MANY',
  ONE_TO_ONE = 'ONE_TO_ONE'
}

export type ResolveSchemaChangeWhereInput = {
  type: SchemaChangeType;
};

export type ResultCandidate = {
  __typename?: 'ResultCandidate';
  sql: Scalars['String'];
  sqlPair?: Maybe<SqlPair>;
  type: ResultCandidateType;
  view?: Maybe<ViewInfo>;
};

export enum ResultCandidateType {
  LLM = 'LLM',
  SQL_PAIR = 'SQL_PAIR',
  VIEW = 'VIEW'
}

export type ResultQuestion = {
  __typename?: 'ResultQuestion';
  category: Scalars['String'];
  question: Scalars['String'];
  sql: Scalars['String'];
};

export type SampleDatasetInput = {
  name: SampleDatasetName;
};

export enum SampleDatasetName {
  ECOMMERCE = 'ECOMMERCE',
  HR = 'HR',
  MUSIC = 'MUSIC',
  NBA = 'NBA'
}

export type SaveLearningRecordInput = {
  path: Scalars['String'];
};

export type SaveRelationInput = {
  relations: Array<InputMaybe<RelationInput>>;
};

export type SaveTablesInput = {
  tables: Array<Scalars['String']>;
};

export enum ScheduleFrequencyEnum {
  CUSTOM = 'CUSTOM',
  DAILY = 'DAILY',
  NEVER = 'NEVER',
  WEEKLY = 'WEEKLY'
}

export type SchemaChange = {
  __typename?: 'SchemaChange';
  deletedColumns?: Maybe<Array<DetailedChangeTable>>;
  deletedTables?: Maybe<Array<DetailedChangeTable>>;
  lastSchemaChangeTime?: Maybe<Scalars['String']>;
  modifiedColumns?: Maybe<Array<DetailedChangeTable>>;
};

export enum SchemaChangeType {
  DELETED_COLUMNS = 'DELETED_COLUMNS',
  DELETED_TABLES = 'DELETED_TABLES',
  MODIFIED_COLUMNS = 'MODIFIED_COLUMNS'
}

export type SetDashboardScheduleData = {
  cron?: InputMaybe<Scalars['String']>;
  day?: InputMaybe<CacheScheduleDayEnum>;
  frequency: ScheduleFrequencyEnum;
  hour?: InputMaybe<Scalars['Int']>;
  minute?: InputMaybe<Scalars['Int']>;
  timezone?: InputMaybe<Scalars['String']>;
};

export type SetDashboardScheduleInput = {
  cacheEnabled: Scalars['Boolean'];
  schedule?: InputMaybe<SetDashboardScheduleData>;
};

export type Settings = {
  __typename?: 'Settings';
  dataSource: DataSource;
  language: ProjectLanguage;
  productVersion: Scalars['String'];
};

export type SimpleMeasureInput = {
  isCalculated: Scalars['Boolean'];
  name: Scalars['String'];
  notNull: Scalars['Boolean'];
  properties: Scalars['JSON'];
  type: Scalars['String'];
};

export type SqlPair = {
  __typename?: 'SqlPair';
  createdAt?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  projectId: Scalars['Int'];
  question: Scalars['String'];
  sql: Scalars['String'];
  updatedAt?: Maybe<Scalars['String']>;
};

export type SqlPairWhereUniqueInput = {
  id: Scalars['Int'];
};

export type SuggestedQuestion = {
  __typename?: 'SuggestedQuestion';
  label: Scalars['String'];
  question: Scalars['String'];
};

export type SuggestedQuestionResponse = {
  __typename?: 'SuggestedQuestionResponse';
  questions: Array<Maybe<SuggestedQuestion>>;
};

export enum SyncStatus {
  IN_PROGRESS = 'IN_PROGRESS',
  SYNCRONIZED = 'SYNCRONIZED',
  UNSYNCRONIZED = 'UNSYNCRONIZED'
}

export type Task = {
  __typename?: 'Task';
  id: Scalars['String'];
};

export type Thread = {
  __typename?: 'Thread';
  id: Scalars['Int'];
  summary: Scalars['String'];
};

export type ThreadResponse = {
  __typename?: 'ThreadResponse';
  adjustment?: Maybe<ThreadResponseAdjustment>;
  adjustmentTask?: Maybe<AdjustmentTask>;
  answerDetail?: Maybe<ThreadResponseAnswerDetail>;
  askingTask?: Maybe<AskingTask>;
  breakdownDetail?: Maybe<ThreadResponseBreakdownDetail>;
  chartDetail?: Maybe<ThreadResponseChartDetail>;
  id: Scalars['Int'];
  question: Scalars['String'];
  sql?: Maybe<Scalars['String']>;
  threadId: Scalars['Int'];
  view?: Maybe<ViewInfo>;
};

export type ThreadResponseAdjustment = {
  __typename?: 'ThreadResponseAdjustment';
  payload?: Maybe<Scalars['JSON']>;
  type: ThreadResponseAdjustmentType;
};

export enum ThreadResponseAdjustmentType {
  APPLY_SQL = 'APPLY_SQL',
  REASONING = 'REASONING'
}

export type ThreadResponseAnswerDetail = {
  __typename?: 'ThreadResponseAnswerDetail';
  content?: Maybe<Scalars['String']>;
  error?: Maybe<Error>;
  numRowsUsedInLLM?: Maybe<Scalars['Int']>;
  queryId?: Maybe<Scalars['String']>;
  status?: Maybe<ThreadResponseAnswerStatus>;
};

export enum ThreadResponseAnswerStatus {
  FAILED = 'FAILED',
  FETCHING_DATA = 'FETCHING_DATA',
  FINISHED = 'FINISHED',
  INTERRUPTED = 'INTERRUPTED',
  NOT_STARTED = 'NOT_STARTED',
  PREPROCESSING = 'PREPROCESSING',
  STREAMING = 'STREAMING'
}

export type ThreadResponseBreakdownDetail = {
  __typename?: 'ThreadResponseBreakdownDetail';
  description?: Maybe<Scalars['String']>;
  error?: Maybe<Error>;
  queryId?: Maybe<Scalars['String']>;
  status: AskingTaskStatus;
  steps?: Maybe<Array<DetailStep>>;
};

export type ThreadResponseChartDetail = {
  __typename?: 'ThreadResponseChartDetail';
  adjustment?: Maybe<Scalars['Boolean']>;
  chartSchema?: Maybe<Scalars['JSON']>;
  chartType?: Maybe<ChartType>;
  description?: Maybe<Scalars['String']>;
  error?: Maybe<Error>;
  queryId?: Maybe<Scalars['String']>;
  status: ChartTaskStatus;
};

export type ThreadResponseUniqueWhereInput = {
  id: Scalars['Int'];
};

export type ThreadUniqueWhereInput = {
  id: Scalars['Int'];
};

export type TimeGrainInput = {
  dateParts: Array<Scalars['String']>;
  name: Scalars['String'];
  refColumn: Scalars['String'];
};

export type UpdateCalculatedFieldInput = {
  expression: ExpressionName;
  lineage: Array<Scalars['Int']>;
  name: Scalars['String'];
};

export type UpdateCalculatedFieldMetadataInput = {
  description?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

export type UpdateCalculatedFieldWhere = {
  id: Scalars['Int'];
};

export type UpdateColumnMetadataInput = {
  description?: InputMaybe<Scalars['String']>;
  displayName?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

export type UpdateCurrentProjectInput = {
  language: ProjectLanguage;
};

export type UpdateDashboardItemInput = {
  displayName: Scalars['String'];
};

export type UpdateDashboardItemLayoutsInput = {
  layouts: Array<ItemLayoutInput>;
};

export type UpdateDataSourceInput = {
  properties: Scalars['JSON'];
};

export type UpdateInstructionInput = {
  instruction?: InputMaybe<Scalars['String']>;
  isDefault?: InputMaybe<Scalars['Boolean']>;
  questions?: InputMaybe<Array<Scalars['String']>>;
};

export type UpdateModelInput = {
  fields: Array<Scalars['String']>;
  primaryKey?: InputMaybe<Scalars['String']>;
};

export type UpdateModelMetadataInput = {
  calculatedFields?: InputMaybe<Array<UpdateCalculatedFieldMetadataInput>>;
  columns?: InputMaybe<Array<UpdateColumnMetadataInput>>;
  description?: InputMaybe<Scalars['String']>;
  displayName?: InputMaybe<Scalars['String']>;
  nestedColumns?: InputMaybe<Array<UpdateNestedColumnMetadataInput>>;
  relationships?: InputMaybe<Array<UpdateRelationshipMetadataInput>>;
};

export type UpdateNestedColumnMetadataInput = {
  description?: InputMaybe<Scalars['String']>;
  displayName?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

export type UpdateRelationInput = {
  type: RelationType;
};

export type UpdateRelationshipMetadataInput = {
  description?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

export type UpdateSqlPairInput = {
  question?: InputMaybe<Scalars['String']>;
  sql?: InputMaybe<Scalars['String']>;
};

export type UpdateThreadInput = {
  summary?: InputMaybe<Scalars['String']>;
};

export type UpdateThreadResponseInput = {
  sql?: InputMaybe<Scalars['String']>;
};

export type UpdateViewColumnMetadataInput = {
  description?: InputMaybe<Scalars['String']>;
  referenceName: Scalars['String'];
};

export type UpdateViewMetadataInput = {
  columns?: InputMaybe<Array<UpdateViewColumnMetadataInput>>;
  description?: InputMaybe<Scalars['String']>;
  displayName?: InputMaybe<Scalars['String']>;
};

export type ValidateCalculatedFieldInput = {
  columnId?: InputMaybe<Scalars['Int']>;
  modelId: Scalars['Int'];
  name: Scalars['String'];
};

export type ValidateViewInput = {
  name: Scalars['String'];
};

export type ViewInfo = {
  __typename?: 'ViewInfo';
  displayName: Scalars['String'];
  id: Scalars['Int'];
  name: Scalars['String'];
  statement: Scalars['String'];
};

export type ViewValidationResponse = {
  __typename?: 'ViewValidationResponse';
  message?: Maybe<Scalars['String']>;
  valid: Scalars['Boolean'];
};

export type ViewWhereUniqueInput = {
  id: Scalars['Int'];
};

export type WhereIdInput = {
  id: Scalars['Int'];
};
</file>

<file path="src/apollo/client/graphql/apiManagement.generated.ts">
import * as Types from './__types__';

import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
const defaultOptions = {} as const;
export type ApiHistoryQueryVariables = Types.Exact<{
  filter?: Types.InputMaybe<Types.ApiHistoryFilterInput>;
  pagination: Types.ApiHistoryPaginationInput;
}>;


export type ApiHistoryQuery = { __typename?: 'Query', apiHistory: { __typename?: 'ApiHistoryPaginatedResponse', total: number, hasMore: boolean, items: Array<{ __typename?: 'ApiHistoryResponse', id: string, projectId: number, apiType: Types.ApiType, threadId?: string | null, headers?: any | null, requestPayload?: any | null, responsePayload?: any | null, statusCode?: number | null, durationMs?: number | null, createdAt: string, updatedAt: string }> } };


export const ApiHistoryDocument = gql`
    query ApiHistory($filter: ApiHistoryFilterInput, $pagination: ApiHistoryPaginationInput!) {
  apiHistory(filter: $filter, pagination: $pagination) {
    items {
      id
      projectId
      apiType
      threadId
      headers
      requestPayload
      responsePayload
      statusCode
      durationMs
      createdAt
      updatedAt
    }
    total
    hasMore
  }
}
    `;

/**
 * __useApiHistoryQuery__
 *
 * To run a query within a React component, call `useApiHistoryQuery` and pass it any options that fit your needs.
 * When your component renders, `useApiHistoryQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useApiHistoryQuery({
 *   variables: {
 *      filter: // value for 'filter'
 *      pagination: // value for 'pagination'
 *   },
 * });
 */
export function useApiHistoryQuery(baseOptions: Apollo.QueryHookOptions<ApiHistoryQuery, ApiHistoryQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ApiHistoryQuery, ApiHistoryQueryVariables>(ApiHistoryDocument, options);
      }
export function useApiHistoryLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ApiHistoryQuery, ApiHistoryQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ApiHistoryQuery, ApiHistoryQueryVariables>(ApiHistoryDocument, options);
        }
export type ApiHistoryQueryHookResult = ReturnType<typeof useApiHistoryQuery>;
export type ApiHistoryLazyQueryHookResult = ReturnType<typeof useApiHistoryLazyQuery>;
export type ApiHistoryQueryResult = Apollo.QueryResult<ApiHistoryQuery, ApiHistoryQueryVariables>;
</file>

<file path="src/apollo/client/graphql/apiManagement.ts">
import { gql } from '@apollo/client';

export const API_HISTORY = gql`
  query ApiHistory(
    $filter: ApiHistoryFilterInput
    $pagination: ApiHistoryPaginationInput!
  ) {
    apiHistory(filter: $filter, pagination: $pagination) {
      items {
        id
        projectId
        apiType
        threadId
        headers
        requestPayload
        responsePayload
        statusCode
        durationMs
        createdAt
        updatedAt
      }
      total
      hasMore
    }
  }
`;
</file>

<file path="src/apollo/client/graphql/calculatedField.generated.ts">
import * as Types from './__types__';

import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
const defaultOptions = {} as const;
export type ValidateCalculatedFieldMutationVariables = Types.Exact<{
  data: Types.ValidateCalculatedFieldInput;
}>;


export type ValidateCalculatedFieldMutation = { __typename?: 'Mutation', validateCalculatedField: { __typename?: 'CalculatedFieldValidationResponse', message?: string | null, valid: boolean } };

export type CreateCalculatedFieldMutationVariables = Types.Exact<{
  data: Types.CreateCalculatedFieldInput;
}>;


export type CreateCalculatedFieldMutation = { __typename?: 'Mutation', createCalculatedField: any };

export type UpdateCalculatedFieldMutationVariables = Types.Exact<{
  where: Types.UpdateCalculatedFieldWhere;
  data: Types.UpdateCalculatedFieldInput;
}>;


export type UpdateCalculatedFieldMutation = { __typename?: 'Mutation', updateCalculatedField: any };

export type DeleteCalculatedFieldMutationVariables = Types.Exact<{
  where: Types.UpdateCalculatedFieldWhere;
}>;


export type DeleteCalculatedFieldMutation = { __typename?: 'Mutation', deleteCalculatedField: boolean };


export const ValidateCalculatedFieldDocument = gql`
    mutation ValidateCalculatedField($data: ValidateCalculatedFieldInput!) {
  validateCalculatedField(data: $data) {
    message
    valid
  }
}
    `;
export type ValidateCalculatedFieldMutationFn = Apollo.MutationFunction<ValidateCalculatedFieldMutation, ValidateCalculatedFieldMutationVariables>;

/**
 * __useValidateCalculatedFieldMutation__
 *
 * To run a mutation, you first call `useValidateCalculatedFieldMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useValidateCalculatedFieldMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [validateCalculatedFieldMutation, { data, loading, error }] = useValidateCalculatedFieldMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useValidateCalculatedFieldMutation(baseOptions?: Apollo.MutationHookOptions<ValidateCalculatedFieldMutation, ValidateCalculatedFieldMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ValidateCalculatedFieldMutation, ValidateCalculatedFieldMutationVariables>(ValidateCalculatedFieldDocument, options);
      }
export type ValidateCalculatedFieldMutationHookResult = ReturnType<typeof useValidateCalculatedFieldMutation>;
export type ValidateCalculatedFieldMutationResult = Apollo.MutationResult<ValidateCalculatedFieldMutation>;
export type ValidateCalculatedFieldMutationOptions = Apollo.BaseMutationOptions<ValidateCalculatedFieldMutation, ValidateCalculatedFieldMutationVariables>;
export const CreateCalculatedFieldDocument = gql`
    mutation CreateCalculatedField($data: CreateCalculatedFieldInput!) {
  createCalculatedField(data: $data)
}
    `;
export type CreateCalculatedFieldMutationFn = Apollo.MutationFunction<CreateCalculatedFieldMutation, CreateCalculatedFieldMutationVariables>;

/**
 * __useCreateCalculatedFieldMutation__
 *
 * To run a mutation, you first call `useCreateCalculatedFieldMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateCalculatedFieldMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createCalculatedFieldMutation, { data, loading, error }] = useCreateCalculatedFieldMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useCreateCalculatedFieldMutation(baseOptions?: Apollo.MutationHookOptions<CreateCalculatedFieldMutation, CreateCalculatedFieldMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateCalculatedFieldMutation, CreateCalculatedFieldMutationVariables>(CreateCalculatedFieldDocument, options);
      }
export type CreateCalculatedFieldMutationHookResult = ReturnType<typeof useCreateCalculatedFieldMutation>;
export type CreateCalculatedFieldMutationResult = Apollo.MutationResult<CreateCalculatedFieldMutation>;
export type CreateCalculatedFieldMutationOptions = Apollo.BaseMutationOptions<CreateCalculatedFieldMutation, CreateCalculatedFieldMutationVariables>;
export const UpdateCalculatedFieldDocument = gql`
    mutation UpdateCalculatedField($where: UpdateCalculatedFieldWhere!, $data: UpdateCalculatedFieldInput!) {
  updateCalculatedField(where: $where, data: $data)
}
    `;
export type UpdateCalculatedFieldMutationFn = Apollo.MutationFunction<UpdateCalculatedFieldMutation, UpdateCalculatedFieldMutationVariables>;

/**
 * __useUpdateCalculatedFieldMutation__
 *
 * To run a mutation, you first call `useUpdateCalculatedFieldMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateCalculatedFieldMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateCalculatedFieldMutation, { data, loading, error }] = useUpdateCalculatedFieldMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateCalculatedFieldMutation(baseOptions?: Apollo.MutationHookOptions<UpdateCalculatedFieldMutation, UpdateCalculatedFieldMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateCalculatedFieldMutation, UpdateCalculatedFieldMutationVariables>(UpdateCalculatedFieldDocument, options);
      }
export type UpdateCalculatedFieldMutationHookResult = ReturnType<typeof useUpdateCalculatedFieldMutation>;
export type UpdateCalculatedFieldMutationResult = Apollo.MutationResult<UpdateCalculatedFieldMutation>;
export type UpdateCalculatedFieldMutationOptions = Apollo.BaseMutationOptions<UpdateCalculatedFieldMutation, UpdateCalculatedFieldMutationVariables>;
export const DeleteCalculatedFieldDocument = gql`
    mutation DeleteCalculatedField($where: UpdateCalculatedFieldWhere!) {
  deleteCalculatedField(where: $where)
}
    `;
export type DeleteCalculatedFieldMutationFn = Apollo.MutationFunction<DeleteCalculatedFieldMutation, DeleteCalculatedFieldMutationVariables>;

/**
 * __useDeleteCalculatedFieldMutation__
 *
 * To run a mutation, you first call `useDeleteCalculatedFieldMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteCalculatedFieldMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteCalculatedFieldMutation, { data, loading, error }] = useDeleteCalculatedFieldMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteCalculatedFieldMutation(baseOptions?: Apollo.MutationHookOptions<DeleteCalculatedFieldMutation, DeleteCalculatedFieldMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteCalculatedFieldMutation, DeleteCalculatedFieldMutationVariables>(DeleteCalculatedFieldDocument, options);
      }
export type DeleteCalculatedFieldMutationHookResult = ReturnType<typeof useDeleteCalculatedFieldMutation>;
export type DeleteCalculatedFieldMutationResult = Apollo.MutationResult<DeleteCalculatedFieldMutation>;
export type DeleteCalculatedFieldMutationOptions = Apollo.BaseMutationOptions<DeleteCalculatedFieldMutation, DeleteCalculatedFieldMutationVariables>;
</file>

<file path="src/apollo/client/graphql/calculatedField.ts">
import { gql } from '@apollo/client';

export const VALIDATE_CALCULATED_FIELD = gql`
  mutation ValidateCalculatedField($data: ValidateCalculatedFieldInput!) {
    validateCalculatedField(data: $data) {
      message
      valid
    }
  }
`;

export const CREATE_CALCULATED_FIELD = gql`
  mutation CreateCalculatedField($data: CreateCalculatedFieldInput!) {
    createCalculatedField(data: $data)
  }
`;

export const UPDATE_CALCULATED_FIELD = gql`
  mutation UpdateCalculatedField(
    $where: UpdateCalculatedFieldWhere!
    $data: UpdateCalculatedFieldInput!
  ) {
    updateCalculatedField(where: $where, data: $data)
  }
`;

export const DELETE_CALCULATED_FIELD = gql`
  mutation DeleteCalculatedField($where: UpdateCalculatedFieldWhere!) {
    deleteCalculatedField(where: $where)
  }
`;
</file>

<file path="src/apollo/client/graphql/dashboard.generated.ts">
import * as Types from './__types__';

import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
const defaultOptions = {} as const;
export type CommonDashboardItemFragment = { __typename?: 'DashboardItem', id: number, dashboardId: number, type: Types.DashboardItemType, displayName?: string | null, layout: { __typename?: 'DashboardItemLayout', x: number, y: number, w: number, h: number }, detail: { __typename?: 'DashboardItemDetail', sql: string, chartSchema?: any | null } };

export type DashboardItemsQueryVariables = Types.Exact<{ [key: string]: never; }>;


export type DashboardItemsQuery = { __typename?: 'Query', dashboardItems: Array<{ __typename?: 'DashboardItem', id: number, dashboardId: number, type: Types.DashboardItemType, displayName?: string | null, layout: { __typename?: 'DashboardItemLayout', x: number, y: number, w: number, h: number }, detail: { __typename?: 'DashboardItemDetail', sql: string, chartSchema?: any | null } }> };

export type CreateDashboardItemMutationVariables = Types.Exact<{
  data: Types.CreateDashboardItemInput;
}>;


export type CreateDashboardItemMutation = { __typename?: 'Mutation', createDashboardItem: { __typename?: 'DashboardItem', id: number, dashboardId: number, type: Types.DashboardItemType, displayName?: string | null, layout: { __typename?: 'DashboardItemLayout', x: number, y: number, w: number, h: number }, detail: { __typename?: 'DashboardItemDetail', sql: string, chartSchema?: any | null } } };

export type UpdateDashboardItemMutationVariables = Types.Exact<{
  where: Types.DashboardItemWhereInput;
  data: Types.UpdateDashboardItemInput;
}>;


export type UpdateDashboardItemMutation = { __typename?: 'Mutation', updateDashboardItem: { __typename?: 'DashboardItem', id: number, dashboardId: number, type: Types.DashboardItemType, displayName?: string | null, layout: { __typename?: 'DashboardItemLayout', x: number, y: number, w: number, h: number }, detail: { __typename?: 'DashboardItemDetail', sql: string, chartSchema?: any | null } } };

export type UpdateDashboardItemLayoutsMutationVariables = Types.Exact<{
  data: Types.UpdateDashboardItemLayoutsInput;
}>;


export type UpdateDashboardItemLayoutsMutation = { __typename?: 'Mutation', updateDashboardItemLayouts: Array<{ __typename?: 'DashboardItem', id: number, dashboardId: number, type: Types.DashboardItemType, displayName?: string | null, layout: { __typename?: 'DashboardItemLayout', x: number, y: number, w: number, h: number }, detail: { __typename?: 'DashboardItemDetail', sql: string, chartSchema?: any | null } }> };

export type DeleteDashboardItemMutationVariables = Types.Exact<{
  where: Types.DashboardItemWhereInput;
}>;


export type DeleteDashboardItemMutation = { __typename?: 'Mutation', deleteDashboardItem: boolean };

export type PreviewItemSqlMutationVariables = Types.Exact<{
  data: Types.PreviewItemSqlInput;
}>;


export type PreviewItemSqlMutation = { __typename?: 'Mutation', previewItemSQL: { __typename?: 'PreviewItemResponse', data: any, cacheHit: boolean, cacheCreatedAt?: string | null, cacheOverrodeAt?: string | null, override: boolean } };

export type SetDashboardScheduleMutationVariables = Types.Exact<{
  data: Types.SetDashboardScheduleInput;
}>;


export type SetDashboardScheduleMutation = { __typename?: 'Mutation', setDashboardSchedule: { __typename?: 'Dashboard', id: number, projectId: number, name: string, cacheEnabled: boolean, scheduleFrequency?: Types.ScheduleFrequencyEnum | null, scheduleTimezone?: string | null, scheduleCron?: string | null, nextScheduledAt?: string | null } };

export type DashboardQueryVariables = Types.Exact<{ [key: string]: never; }>;


export type DashboardQuery = { __typename?: 'Query', dashboard: { __typename?: 'DetailedDashboard', id: number, name: string, description?: string | null, cacheEnabled: boolean, nextScheduledAt?: string | null, schedule?: { __typename?: 'DashboardSchedule', frequency?: Types.ScheduleFrequencyEnum | null, hour?: number | null, minute?: number | null, day?: Types.CacheScheduleDayEnum | null, timezone?: string | null, cron?: string | null } | null, items: Array<{ __typename?: 'DashboardItem', id: number, dashboardId: number, type: Types.DashboardItemType, displayName?: string | null, layout: { __typename?: 'DashboardItemLayout', x: number, y: number, w: number, h: number }, detail: { __typename?: 'DashboardItemDetail', sql: string, chartSchema?: any | null } }> } };

export const CommonDashboardItemFragmentDoc = gql`
    fragment CommonDashboardItem on DashboardItem {
  id
  dashboardId
  type
  layout {
    x
    y
    w
    h
  }
  detail {
    sql
    chartSchema
  }
  displayName
}
    `;
export const DashboardItemsDocument = gql`
    query DashboardItems {
  dashboardItems {
    ...CommonDashboardItem
  }
}
    ${CommonDashboardItemFragmentDoc}`;

/**
 * __useDashboardItemsQuery__
 *
 * To run a query within a React component, call `useDashboardItemsQuery` and pass it any options that fit your needs.
 * When your component renders, `useDashboardItemsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useDashboardItemsQuery({
 *   variables: {
 *   },
 * });
 */
export function useDashboardItemsQuery(baseOptions?: Apollo.QueryHookOptions<DashboardItemsQuery, DashboardItemsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<DashboardItemsQuery, DashboardItemsQueryVariables>(DashboardItemsDocument, options);
      }
export function useDashboardItemsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<DashboardItemsQuery, DashboardItemsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<DashboardItemsQuery, DashboardItemsQueryVariables>(DashboardItemsDocument, options);
        }
export type DashboardItemsQueryHookResult = ReturnType<typeof useDashboardItemsQuery>;
export type DashboardItemsLazyQueryHookResult = ReturnType<typeof useDashboardItemsLazyQuery>;
export type DashboardItemsQueryResult = Apollo.QueryResult<DashboardItemsQuery, DashboardItemsQueryVariables>;
export const CreateDashboardItemDocument = gql`
    mutation CreateDashboardItem($data: CreateDashboardItemInput!) {
  createDashboardItem(data: $data) {
    ...CommonDashboardItem
  }
}
    ${CommonDashboardItemFragmentDoc}`;
export type CreateDashboardItemMutationFn = Apollo.MutationFunction<CreateDashboardItemMutation, CreateDashboardItemMutationVariables>;

/**
 * __useCreateDashboardItemMutation__
 *
 * To run a mutation, you first call `useCreateDashboardItemMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateDashboardItemMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createDashboardItemMutation, { data, loading, error }] = useCreateDashboardItemMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useCreateDashboardItemMutation(baseOptions?: Apollo.MutationHookOptions<CreateDashboardItemMutation, CreateDashboardItemMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateDashboardItemMutation, CreateDashboardItemMutationVariables>(CreateDashboardItemDocument, options);
      }
export type CreateDashboardItemMutationHookResult = ReturnType<typeof useCreateDashboardItemMutation>;
export type CreateDashboardItemMutationResult = Apollo.MutationResult<CreateDashboardItemMutation>;
export type CreateDashboardItemMutationOptions = Apollo.BaseMutationOptions<CreateDashboardItemMutation, CreateDashboardItemMutationVariables>;
export const UpdateDashboardItemDocument = gql`
    mutation UpdateDashboardItem($where: DashboardItemWhereInput!, $data: UpdateDashboardItemInput!) {
  updateDashboardItem(where: $where, data: $data) {
    ...CommonDashboardItem
  }
}
    ${CommonDashboardItemFragmentDoc}`;
export type UpdateDashboardItemMutationFn = Apollo.MutationFunction<UpdateDashboardItemMutation, UpdateDashboardItemMutationVariables>;

/**
 * __useUpdateDashboardItemMutation__
 *
 * To run a mutation, you first call `useUpdateDashboardItemMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateDashboardItemMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateDashboardItemMutation, { data, loading, error }] = useUpdateDashboardItemMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateDashboardItemMutation(baseOptions?: Apollo.MutationHookOptions<UpdateDashboardItemMutation, UpdateDashboardItemMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateDashboardItemMutation, UpdateDashboardItemMutationVariables>(UpdateDashboardItemDocument, options);
      }
export type UpdateDashboardItemMutationHookResult = ReturnType<typeof useUpdateDashboardItemMutation>;
export type UpdateDashboardItemMutationResult = Apollo.MutationResult<UpdateDashboardItemMutation>;
export type UpdateDashboardItemMutationOptions = Apollo.BaseMutationOptions<UpdateDashboardItemMutation, UpdateDashboardItemMutationVariables>;
export const UpdateDashboardItemLayoutsDocument = gql`
    mutation UpdateDashboardItemLayouts($data: UpdateDashboardItemLayoutsInput!) {
  updateDashboardItemLayouts(data: $data) {
    ...CommonDashboardItem
  }
}
    ${CommonDashboardItemFragmentDoc}`;
export type UpdateDashboardItemLayoutsMutationFn = Apollo.MutationFunction<UpdateDashboardItemLayoutsMutation, UpdateDashboardItemLayoutsMutationVariables>;

/**
 * __useUpdateDashboardItemLayoutsMutation__
 *
 * To run a mutation, you first call `useUpdateDashboardItemLayoutsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateDashboardItemLayoutsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateDashboardItemLayoutsMutation, { data, loading, error }] = useUpdateDashboardItemLayoutsMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateDashboardItemLayoutsMutation(baseOptions?: Apollo.MutationHookOptions<UpdateDashboardItemLayoutsMutation, UpdateDashboardItemLayoutsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateDashboardItemLayoutsMutation, UpdateDashboardItemLayoutsMutationVariables>(UpdateDashboardItemLayoutsDocument, options);
      }
export type UpdateDashboardItemLayoutsMutationHookResult = ReturnType<typeof useUpdateDashboardItemLayoutsMutation>;
export type UpdateDashboardItemLayoutsMutationResult = Apollo.MutationResult<UpdateDashboardItemLayoutsMutation>;
export type UpdateDashboardItemLayoutsMutationOptions = Apollo.BaseMutationOptions<UpdateDashboardItemLayoutsMutation, UpdateDashboardItemLayoutsMutationVariables>;
export const DeleteDashboardItemDocument = gql`
    mutation DeleteDashboardItem($where: DashboardItemWhereInput!) {
  deleteDashboardItem(where: $where)
}
    `;
export type DeleteDashboardItemMutationFn = Apollo.MutationFunction<DeleteDashboardItemMutation, DeleteDashboardItemMutationVariables>;

/**
 * __useDeleteDashboardItemMutation__
 *
 * To run a mutation, you first call `useDeleteDashboardItemMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteDashboardItemMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteDashboardItemMutation, { data, loading, error }] = useDeleteDashboardItemMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteDashboardItemMutation(baseOptions?: Apollo.MutationHookOptions<DeleteDashboardItemMutation, DeleteDashboardItemMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteDashboardItemMutation, DeleteDashboardItemMutationVariables>(DeleteDashboardItemDocument, options);
      }
export type DeleteDashboardItemMutationHookResult = ReturnType<typeof useDeleteDashboardItemMutation>;
export type DeleteDashboardItemMutationResult = Apollo.MutationResult<DeleteDashboardItemMutation>;
export type DeleteDashboardItemMutationOptions = Apollo.BaseMutationOptions<DeleteDashboardItemMutation, DeleteDashboardItemMutationVariables>;
export const PreviewItemSqlDocument = gql`
    mutation PreviewItemSQL($data: PreviewItemSQLInput!) {
  previewItemSQL(data: $data) {
    data
    cacheHit
    cacheCreatedAt
    cacheOverrodeAt
    override
  }
}
    `;
export type PreviewItemSqlMutationFn = Apollo.MutationFunction<PreviewItemSqlMutation, PreviewItemSqlMutationVariables>;

/**
 * __usePreviewItemSqlMutation__
 *
 * To run a mutation, you first call `usePreviewItemSqlMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `usePreviewItemSqlMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [previewItemSqlMutation, { data, loading, error }] = usePreviewItemSqlMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function usePreviewItemSqlMutation(baseOptions?: Apollo.MutationHookOptions<PreviewItemSqlMutation, PreviewItemSqlMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<PreviewItemSqlMutation, PreviewItemSqlMutationVariables>(PreviewItemSqlDocument, options);
      }
export type PreviewItemSqlMutationHookResult = ReturnType<typeof usePreviewItemSqlMutation>;
export type PreviewItemSqlMutationResult = Apollo.MutationResult<PreviewItemSqlMutation>;
export type PreviewItemSqlMutationOptions = Apollo.BaseMutationOptions<PreviewItemSqlMutation, PreviewItemSqlMutationVariables>;
export const SetDashboardScheduleDocument = gql`
    mutation SetDashboardSchedule($data: SetDashboardScheduleInput!) {
  setDashboardSchedule(data: $data) {
    id
    projectId
    name
    cacheEnabled
    scheduleFrequency
    scheduleTimezone
    scheduleCron
    nextScheduledAt
  }
}
    `;
export type SetDashboardScheduleMutationFn = Apollo.MutationFunction<SetDashboardScheduleMutation, SetDashboardScheduleMutationVariables>;

/**
 * __useSetDashboardScheduleMutation__
 *
 * To run a mutation, you first call `useSetDashboardScheduleMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSetDashboardScheduleMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [setDashboardScheduleMutation, { data, loading, error }] = useSetDashboardScheduleMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useSetDashboardScheduleMutation(baseOptions?: Apollo.MutationHookOptions<SetDashboardScheduleMutation, SetDashboardScheduleMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SetDashboardScheduleMutation, SetDashboardScheduleMutationVariables>(SetDashboardScheduleDocument, options);
      }
export type SetDashboardScheduleMutationHookResult = ReturnType<typeof useSetDashboardScheduleMutation>;
export type SetDashboardScheduleMutationResult = Apollo.MutationResult<SetDashboardScheduleMutation>;
export type SetDashboardScheduleMutationOptions = Apollo.BaseMutationOptions<SetDashboardScheduleMutation, SetDashboardScheduleMutationVariables>;
export const DashboardDocument = gql`
    query Dashboard {
  dashboard {
    id
    name
    description
    cacheEnabled
    nextScheduledAt
    schedule {
      frequency
      hour
      minute
      day
      timezone
      cron
    }
    items {
      ...CommonDashboardItem
    }
  }
}
    ${CommonDashboardItemFragmentDoc}`;

/**
 * __useDashboardQuery__
 *
 * To run a query within a React component, call `useDashboardQuery` and pass it any options that fit your needs.
 * When your component renders, `useDashboardQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useDashboardQuery({
 *   variables: {
 *   },
 * });
 */
export function useDashboardQuery(baseOptions?: Apollo.QueryHookOptions<DashboardQuery, DashboardQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<DashboardQuery, DashboardQueryVariables>(DashboardDocument, options);
      }
export function useDashboardLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<DashboardQuery, DashboardQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<DashboardQuery, DashboardQueryVariables>(DashboardDocument, options);
        }
export type DashboardQueryHookResult = ReturnType<typeof useDashboardQuery>;
export type DashboardLazyQueryHookResult = ReturnType<typeof useDashboardLazyQuery>;
export type DashboardQueryResult = Apollo.QueryResult<DashboardQuery, DashboardQueryVariables>;
</file>

<file path="src/apollo/client/graphql/dashboard.ts">
import { gql } from '@apollo/client';

export const COMMON_DASHBOARD_ITEM = gql`
  fragment CommonDashboardItem on DashboardItem {
    id
    dashboardId
    type
    layout {
      x
      y
      w
      h
    }
    detail {
      sql
      chartSchema
    }
    displayName
  }
`;

export const DASHBOARD_ITEMS = gql`
  query DashboardItems {
    dashboardItems {
      ...CommonDashboardItem
    }
  }
  ${COMMON_DASHBOARD_ITEM}
`;

export const CREATE_DASHBOARD_ITEM = gql`
  mutation CreateDashboardItem($data: CreateDashboardItemInput!) {
    createDashboardItem(data: $data) {
      ...CommonDashboardItem
    }
  }
  ${COMMON_DASHBOARD_ITEM}
`;

export const UPDATE_DASHBOARD_ITEM = gql`
  mutation UpdateDashboardItem(
    $where: DashboardItemWhereInput!
    $data: UpdateDashboardItemInput!
  ) {
    updateDashboardItem(where: $where, data: $data) {
      ...CommonDashboardItem
    }
  }
  ${COMMON_DASHBOARD_ITEM}
`;

export const UPDATE_DASHBOARD_ITEM_LAYOUTS = gql`
  mutation UpdateDashboardItemLayouts($data: UpdateDashboardItemLayoutsInput!) {
    updateDashboardItemLayouts(data: $data) {
      ...CommonDashboardItem
    }
  }
  ${COMMON_DASHBOARD_ITEM}
`;

export const DELETE_DASHBOARD_ITEM = gql`
  mutation DeleteDashboardItem($where: DashboardItemWhereInput!) {
    deleteDashboardItem(where: $where)
  }
`;

export const PREVIEW_ITEM_SQL = gql`
  mutation PreviewItemSQL($data: PreviewItemSQLInput!) {
    previewItemSQL(data: $data) {
      data
      cacheHit
      cacheCreatedAt
      cacheOverrodeAt
      override
    }
  }
`;

export const SET_DASHBOARD_SCHEDULE = gql`
  mutation SetDashboardSchedule($data: SetDashboardScheduleInput!) {
    setDashboardSchedule(data: $data) {
      id
      projectId
      name
      cacheEnabled
      scheduleFrequency
      scheduleTimezone
      scheduleCron
      nextScheduledAt
    }
  }
`;

export const DASHBOARD = gql`
  query Dashboard {
    dashboard {
      id
      name
      description
      cacheEnabled
      nextScheduledAt
      schedule {
        frequency
        hour
        minute
        day
        timezone
        cron
      }
      items {
        ...CommonDashboardItem
      }
    }
  }
  ${COMMON_DASHBOARD_ITEM}
`;
</file>

<file path="src/apollo/client/graphql/dataSource.generated.ts">
import * as Types from './__types__';

import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
const defaultOptions = {} as const;
export type StartSampleDatasetMutationVariables = Types.Exact<{
  data: Types.SampleDatasetInput;
}>;


export type StartSampleDatasetMutation = { __typename?: 'Mutation', startSampleDataset: any };

export type ListDataSourceTablesQueryVariables = Types.Exact<{ [key: string]: never; }>;


export type ListDataSourceTablesQuery = { __typename?: 'Query', listDataSourceTables: Array<{ __typename?: 'CompactTable', name: string, columns: Array<{ __typename?: 'CompactColumn', name: string, type: string }> }> };

export type AutoGeneratedRelationsQueryVariables = Types.Exact<{ [key: string]: never; }>;


export type AutoGeneratedRelationsQuery = { __typename?: 'Query', autoGenerateRelation: Array<{ __typename?: 'RecommendRelations', id: number, displayName: string, referenceName: string, relations: Array<{ __typename?: 'Relation', fromModelId: number, fromModelReferenceName: string, fromColumnId: number, fromColumnReferenceName: string, toModelId: number, toModelReferenceName: string, toColumnId: number, toColumnReferenceName: string, type: Types.RelationType, name: string } | null> }> };

export type SaveDataSourceMutationVariables = Types.Exact<{
  data: Types.DataSourceInput;
}>;


export type SaveDataSourceMutation = { __typename?: 'Mutation', saveDataSource: { __typename?: 'DataSource', type: Types.DataSourceName, properties: any } };

export type UpdateDataSourceMutationVariables = Types.Exact<{
  data: Types.UpdateDataSourceInput;
}>;


export type UpdateDataSourceMutation = { __typename?: 'Mutation', updateDataSource: { __typename?: 'DataSource', type: Types.DataSourceName, properties: any } };

export type SaveTablesMutationVariables = Types.Exact<{
  data: Types.SaveTablesInput;
}>;


export type SaveTablesMutation = { __typename?: 'Mutation', saveTables: any };

export type SaveRelationsMutationVariables = Types.Exact<{
  data: Types.SaveRelationInput;
}>;


export type SaveRelationsMutation = { __typename?: 'Mutation', saveRelations: any };

export type SchemaChangeQueryVariables = Types.Exact<{ [key: string]: never; }>;


export type SchemaChangeQuery = { __typename?: 'Query', schemaChange: { __typename?: 'SchemaChange', lastSchemaChangeTime?: string | null, deletedTables?: Array<{ __typename?: 'DetailedChangeTable', sourceTableName: string, displayName: string, columns: Array<{ __typename?: 'DetailedChangeColumn', sourceColumnName: string, displayName: string, type: string }>, relationships: Array<{ __typename?: 'DetailedAffectedRelationships', displayName: string, referenceName: string }>, calculatedFields: Array<{ __typename?: 'DetailedAffectedCalculatedFields', displayName: string, referenceName: string, type: string }> }> | null, deletedColumns?: Array<{ __typename?: 'DetailedChangeTable', sourceTableName: string, displayName: string, columns: Array<{ __typename?: 'DetailedChangeColumn', sourceColumnName: string, displayName: string, type: string }>, relationships: Array<{ __typename?: 'DetailedAffectedRelationships', displayName: string, referenceName: string }>, calculatedFields: Array<{ __typename?: 'DetailedAffectedCalculatedFields', displayName: string, referenceName: string, type: string }> }> | null, modifiedColumns?: Array<{ __typename?: 'DetailedChangeTable', sourceTableName: string, displayName: string, columns: Array<{ __typename?: 'DetailedChangeColumn', sourceColumnName: string, displayName: string, type: string }>, relationships: Array<{ __typename?: 'DetailedAffectedRelationships', displayName: string, referenceName: string }>, calculatedFields: Array<{ __typename?: 'DetailedAffectedCalculatedFields', displayName: string, referenceName: string, type: string }> }> | null } };

export type TriggerDataSourceDetectionMutationVariables = Types.Exact<{ [key: string]: never; }>;


export type TriggerDataSourceDetectionMutation = { __typename?: 'Mutation', triggerDataSourceDetection: boolean };

export type ResolveSchemaChangeMutationVariables = Types.Exact<{
  where: Types.ResolveSchemaChangeWhereInput;
}>;


export type ResolveSchemaChangeMutation = { __typename?: 'Mutation', resolveSchemaChange: boolean };


export const StartSampleDatasetDocument = gql`
    mutation StartSampleDataset($data: SampleDatasetInput!) {
  startSampleDataset(data: $data)
}
    `;
export type StartSampleDatasetMutationFn = Apollo.MutationFunction<StartSampleDatasetMutation, StartSampleDatasetMutationVariables>;

/**
 * __useStartSampleDatasetMutation__
 *
 * To run a mutation, you first call `useStartSampleDatasetMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useStartSampleDatasetMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [startSampleDatasetMutation, { data, loading, error }] = useStartSampleDatasetMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useStartSampleDatasetMutation(baseOptions?: Apollo.MutationHookOptions<StartSampleDatasetMutation, StartSampleDatasetMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<StartSampleDatasetMutation, StartSampleDatasetMutationVariables>(StartSampleDatasetDocument, options);
      }
export type StartSampleDatasetMutationHookResult = ReturnType<typeof useStartSampleDatasetMutation>;
export type StartSampleDatasetMutationResult = Apollo.MutationResult<StartSampleDatasetMutation>;
export type StartSampleDatasetMutationOptions = Apollo.BaseMutationOptions<StartSampleDatasetMutation, StartSampleDatasetMutationVariables>;
export const ListDataSourceTablesDocument = gql`
    query ListDataSourceTables {
  listDataSourceTables {
    name
    columns {
      name
      type
    }
  }
}
    `;

/**
 * __useListDataSourceTablesQuery__
 *
 * To run a query within a React component, call `useListDataSourceTablesQuery` and pass it any options that fit your needs.
 * When your component renders, `useListDataSourceTablesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useListDataSourceTablesQuery({
 *   variables: {
 *   },
 * });
 */
export function useListDataSourceTablesQuery(baseOptions?: Apollo.QueryHookOptions<ListDataSourceTablesQuery, ListDataSourceTablesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ListDataSourceTablesQuery, ListDataSourceTablesQueryVariables>(ListDataSourceTablesDocument, options);
      }
export function useListDataSourceTablesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ListDataSourceTablesQuery, ListDataSourceTablesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ListDataSourceTablesQuery, ListDataSourceTablesQueryVariables>(ListDataSourceTablesDocument, options);
        }
export type ListDataSourceTablesQueryHookResult = ReturnType<typeof useListDataSourceTablesQuery>;
export type ListDataSourceTablesLazyQueryHookResult = ReturnType<typeof useListDataSourceTablesLazyQuery>;
export type ListDataSourceTablesQueryResult = Apollo.QueryResult<ListDataSourceTablesQuery, ListDataSourceTablesQueryVariables>;
export const AutoGeneratedRelationsDocument = gql`
    query AutoGeneratedRelations {
  autoGenerateRelation {
    id
    displayName
    referenceName
    relations {
      fromModelId
      fromModelReferenceName
      fromColumnId
      fromColumnReferenceName
      toModelId
      toModelReferenceName
      toColumnId
      toColumnReferenceName
      type
      name
    }
  }
}
    `;

/**
 * __useAutoGeneratedRelationsQuery__
 *
 * To run a query within a React component, call `useAutoGeneratedRelationsQuery` and pass it any options that fit your needs.
 * When your component renders, `useAutoGeneratedRelationsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAutoGeneratedRelationsQuery({
 *   variables: {
 *   },
 * });
 */
export function useAutoGeneratedRelationsQuery(baseOptions?: Apollo.QueryHookOptions<AutoGeneratedRelationsQuery, AutoGeneratedRelationsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AutoGeneratedRelationsQuery, AutoGeneratedRelationsQueryVariables>(AutoGeneratedRelationsDocument, options);
      }
export function useAutoGeneratedRelationsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AutoGeneratedRelationsQuery, AutoGeneratedRelationsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AutoGeneratedRelationsQuery, AutoGeneratedRelationsQueryVariables>(AutoGeneratedRelationsDocument, options);
        }
export type AutoGeneratedRelationsQueryHookResult = ReturnType<typeof useAutoGeneratedRelationsQuery>;
export type AutoGeneratedRelationsLazyQueryHookResult = ReturnType<typeof useAutoGeneratedRelationsLazyQuery>;
export type AutoGeneratedRelationsQueryResult = Apollo.QueryResult<AutoGeneratedRelationsQuery, AutoGeneratedRelationsQueryVariables>;
export const SaveDataSourceDocument = gql`
    mutation SaveDataSource($data: DataSourceInput!) {
  saveDataSource(data: $data) {
    type
    properties
  }
}
    `;
export type SaveDataSourceMutationFn = Apollo.MutationFunction<SaveDataSourceMutation, SaveDataSourceMutationVariables>;

/**
 * __useSaveDataSourceMutation__
 *
 * To run a mutation, you first call `useSaveDataSourceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSaveDataSourceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [saveDataSourceMutation, { data, loading, error }] = useSaveDataSourceMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useSaveDataSourceMutation(baseOptions?: Apollo.MutationHookOptions<SaveDataSourceMutation, SaveDataSourceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SaveDataSourceMutation, SaveDataSourceMutationVariables>(SaveDataSourceDocument, options);
      }
export type SaveDataSourceMutationHookResult = ReturnType<typeof useSaveDataSourceMutation>;
export type SaveDataSourceMutationResult = Apollo.MutationResult<SaveDataSourceMutation>;
export type SaveDataSourceMutationOptions = Apollo.BaseMutationOptions<SaveDataSourceMutation, SaveDataSourceMutationVariables>;
export const UpdateDataSourceDocument = gql`
    mutation UpdateDataSource($data: UpdateDataSourceInput!) {
  updateDataSource(data: $data) {
    type
    properties
  }
}
    `;
export type UpdateDataSourceMutationFn = Apollo.MutationFunction<UpdateDataSourceMutation, UpdateDataSourceMutationVariables>;

/**
 * __useUpdateDataSourceMutation__
 *
 * To run a mutation, you first call `useUpdateDataSourceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateDataSourceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateDataSourceMutation, { data, loading, error }] = useUpdateDataSourceMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateDataSourceMutation(baseOptions?: Apollo.MutationHookOptions<UpdateDataSourceMutation, UpdateDataSourceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateDataSourceMutation, UpdateDataSourceMutationVariables>(UpdateDataSourceDocument, options);
      }
export type UpdateDataSourceMutationHookResult = ReturnType<typeof useUpdateDataSourceMutation>;
export type UpdateDataSourceMutationResult = Apollo.MutationResult<UpdateDataSourceMutation>;
export type UpdateDataSourceMutationOptions = Apollo.BaseMutationOptions<UpdateDataSourceMutation, UpdateDataSourceMutationVariables>;
export const SaveTablesDocument = gql`
    mutation SaveTables($data: SaveTablesInput!) {
  saveTables(data: $data)
}
    `;
export type SaveTablesMutationFn = Apollo.MutationFunction<SaveTablesMutation, SaveTablesMutationVariables>;

/**
 * __useSaveTablesMutation__
 *
 * To run a mutation, you first call `useSaveTablesMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSaveTablesMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [saveTablesMutation, { data, loading, error }] = useSaveTablesMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useSaveTablesMutation(baseOptions?: Apollo.MutationHookOptions<SaveTablesMutation, SaveTablesMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SaveTablesMutation, SaveTablesMutationVariables>(SaveTablesDocument, options);
      }
export type SaveTablesMutationHookResult = ReturnType<typeof useSaveTablesMutation>;
export type SaveTablesMutationResult = Apollo.MutationResult<SaveTablesMutation>;
export type SaveTablesMutationOptions = Apollo.BaseMutationOptions<SaveTablesMutation, SaveTablesMutationVariables>;
export const SaveRelationsDocument = gql`
    mutation SaveRelations($data: SaveRelationInput!) {
  saveRelations(data: $data)
}
    `;
export type SaveRelationsMutationFn = Apollo.MutationFunction<SaveRelationsMutation, SaveRelationsMutationVariables>;

/**
 * __useSaveRelationsMutation__
 *
 * To run a mutation, you first call `useSaveRelationsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSaveRelationsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [saveRelationsMutation, { data, loading, error }] = useSaveRelationsMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useSaveRelationsMutation(baseOptions?: Apollo.MutationHookOptions<SaveRelationsMutation, SaveRelationsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SaveRelationsMutation, SaveRelationsMutationVariables>(SaveRelationsDocument, options);
      }
export type SaveRelationsMutationHookResult = ReturnType<typeof useSaveRelationsMutation>;
export type SaveRelationsMutationResult = Apollo.MutationResult<SaveRelationsMutation>;
export type SaveRelationsMutationOptions = Apollo.BaseMutationOptions<SaveRelationsMutation, SaveRelationsMutationVariables>;
export const SchemaChangeDocument = gql`
    query SchemaChange {
  schemaChange {
    deletedTables {
      sourceTableName
      displayName
      columns {
        sourceColumnName
        displayName
        type
      }
      relationships {
        displayName
        referenceName
      }
      calculatedFields {
        displayName
        referenceName
        type
      }
    }
    deletedColumns {
      sourceTableName
      displayName
      columns {
        sourceColumnName
        displayName
        type
      }
      relationships {
        displayName
        referenceName
      }
      calculatedFields {
        displayName
        referenceName
        type
      }
    }
    modifiedColumns {
      sourceTableName
      displayName
      columns {
        sourceColumnName
        displayName
        type
      }
      relationships {
        displayName
        referenceName
      }
      calculatedFields {
        displayName
        referenceName
        type
      }
    }
    lastSchemaChangeTime
  }
}
    `;

/**
 * __useSchemaChangeQuery__
 *
 * To run a query within a React component, call `useSchemaChangeQuery` and pass it any options that fit your needs.
 * When your component renders, `useSchemaChangeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSchemaChangeQuery({
 *   variables: {
 *   },
 * });
 */
export function useSchemaChangeQuery(baseOptions?: Apollo.QueryHookOptions<SchemaChangeQuery, SchemaChangeQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SchemaChangeQuery, SchemaChangeQueryVariables>(SchemaChangeDocument, options);
      }
export function useSchemaChangeLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SchemaChangeQuery, SchemaChangeQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SchemaChangeQuery, SchemaChangeQueryVariables>(SchemaChangeDocument, options);
        }
export type SchemaChangeQueryHookResult = ReturnType<typeof useSchemaChangeQuery>;
export type SchemaChangeLazyQueryHookResult = ReturnType<typeof useSchemaChangeLazyQuery>;
export type SchemaChangeQueryResult = Apollo.QueryResult<SchemaChangeQuery, SchemaChangeQueryVariables>;
export const TriggerDataSourceDetectionDocument = gql`
    mutation TriggerDataSourceDetection {
  triggerDataSourceDetection
}
    `;
export type TriggerDataSourceDetectionMutationFn = Apollo.MutationFunction<TriggerDataSourceDetectionMutation, TriggerDataSourceDetectionMutationVariables>;

/**
 * __useTriggerDataSourceDetectionMutation__
 *
 * To run a mutation, you first call `useTriggerDataSourceDetectionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useTriggerDataSourceDetectionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [triggerDataSourceDetectionMutation, { data, loading, error }] = useTriggerDataSourceDetectionMutation({
 *   variables: {
 *   },
 * });
 */
export function useTriggerDataSourceDetectionMutation(baseOptions?: Apollo.MutationHookOptions<TriggerDataSourceDetectionMutation, TriggerDataSourceDetectionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<TriggerDataSourceDetectionMutation, TriggerDataSourceDetectionMutationVariables>(TriggerDataSourceDetectionDocument, options);
      }
export type TriggerDataSourceDetectionMutationHookResult = ReturnType<typeof useTriggerDataSourceDetectionMutation>;
export type TriggerDataSourceDetectionMutationResult = Apollo.MutationResult<TriggerDataSourceDetectionMutation>;
export type TriggerDataSourceDetectionMutationOptions = Apollo.BaseMutationOptions<TriggerDataSourceDetectionMutation, TriggerDataSourceDetectionMutationVariables>;
export const ResolveSchemaChangeDocument = gql`
    mutation ResolveSchemaChange($where: ResolveSchemaChangeWhereInput!) {
  resolveSchemaChange(where: $where)
}
    `;
export type ResolveSchemaChangeMutationFn = Apollo.MutationFunction<ResolveSchemaChangeMutation, ResolveSchemaChangeMutationVariables>;

/**
 * __useResolveSchemaChangeMutation__
 *
 * To run a mutation, you first call `useResolveSchemaChangeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useResolveSchemaChangeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [resolveSchemaChangeMutation, { data, loading, error }] = useResolveSchemaChangeMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useResolveSchemaChangeMutation(baseOptions?: Apollo.MutationHookOptions<ResolveSchemaChangeMutation, ResolveSchemaChangeMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ResolveSchemaChangeMutation, ResolveSchemaChangeMutationVariables>(ResolveSchemaChangeDocument, options);
      }
export type ResolveSchemaChangeMutationHookResult = ReturnType<typeof useResolveSchemaChangeMutation>;
export type ResolveSchemaChangeMutationResult = Apollo.MutationResult<ResolveSchemaChangeMutation>;
export type ResolveSchemaChangeMutationOptions = Apollo.BaseMutationOptions<ResolveSchemaChangeMutation, ResolveSchemaChangeMutationVariables>;
</file>

<file path="src/apollo/client/graphql/dataSource.ts">
import { gql } from '@apollo/client';

export const SET_SAMPLE_DATASETS = gql`
  mutation StartSampleDataset($data: SampleDatasetInput!) {
    startSampleDataset(data: $data)
  }
`;

export const LIST_DATA_SOURCE_TABLES = gql`
  query ListDataSourceTables {
    listDataSourceTables {
      name
      columns {
        name
        type
      }
    }
  }
`;

export const AUTO_GENERATED_RELATIONS = gql`
  query AutoGeneratedRelations {
    autoGenerateRelation {
      id
      displayName
      referenceName
      relations {
        fromModelId
        fromModelReferenceName
        fromColumnId
        fromColumnReferenceName
        toModelId
        toModelReferenceName
        toColumnId
        toColumnReferenceName
        type
        name
      }
    }
  }
`;

export const SAVE_DATA_SOURCE = gql`
  mutation SaveDataSource($data: DataSourceInput!) {
    saveDataSource(data: $data) {
      type
      properties
    }
  }
`;

export const UPDATE_DATA_SOURCE = gql`
  mutation UpdateDataSource($data: UpdateDataSourceInput!) {
    updateDataSource(data: $data) {
      type
      properties
    }
  }
`;

export const SAVE_TABLES = gql`
  mutation SaveTables($data: SaveTablesInput!) {
    saveTables(data: $data)
  }
`;

export const SAVE_RELATIONS = gql`
  mutation SaveRelations($data: SaveRelationInput!) {
    saveRelations(data: $data)
  }
`;

export const GET_SCHEMA_CHANGE = gql`
  query SchemaChange {
    schemaChange {
      deletedTables {
        sourceTableName
        displayName
        columns {
          sourceColumnName
          displayName
          type
        }
        relationships {
          displayName
          referenceName
        }
        calculatedFields {
          displayName
          referenceName
          type
        }
      }
      deletedColumns {
        sourceTableName
        displayName
        columns {
          sourceColumnName
          displayName
          type
        }
        relationships {
          displayName
          referenceName
        }
        calculatedFields {
          displayName
          referenceName
          type
        }
      }
      modifiedColumns {
        sourceTableName
        displayName
        columns {
          sourceColumnName
          displayName
          type
        }
        relationships {
          displayName
          referenceName
        }
        calculatedFields {
          displayName
          referenceName
          type
        }
      }
      lastSchemaChangeTime
    }
  }
`;

export const TRIGGER_DATA_SOURCE_DETECTION = gql`
  mutation TriggerDataSourceDetection {
    triggerDataSourceDetection
  }
`;

export const RESOLVE_SCHEMA_CHANGE = gql`
  mutation ResolveSchemaChange($where: ResolveSchemaChangeWhereInput!) {
    resolveSchemaChange(where: $where)
  }
`;
</file>

<file path="src/apollo/client/graphql/deploy.generated.ts">
import * as Types from './__types__';

import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
const defaultOptions = {} as const;
export type DeployMutationVariables = Types.Exact<{ [key: string]: never; }>;


export type DeployMutation = { __typename?: 'Mutation', deploy: any };

export type DeployStatusQueryVariables = Types.Exact<{ [key: string]: never; }>;


export type DeployStatusQuery = { __typename?: 'Query', modelSync: { __typename?: 'ModelSyncResponse', status: Types.SyncStatus } };


export const DeployDocument = gql`
    mutation Deploy {
  deploy
}
    `;
export type DeployMutationFn = Apollo.MutationFunction<DeployMutation, DeployMutationVariables>;

/**
 * __useDeployMutation__
 *
 * To run a mutation, you first call `useDeployMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeployMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deployMutation, { data, loading, error }] = useDeployMutation({
 *   variables: {
 *   },
 * });
 */
export function useDeployMutation(baseOptions?: Apollo.MutationHookOptions<DeployMutation, DeployMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeployMutation, DeployMutationVariables>(DeployDocument, options);
      }
export type DeployMutationHookResult = ReturnType<typeof useDeployMutation>;
export type DeployMutationResult = Apollo.MutationResult<DeployMutation>;
export type DeployMutationOptions = Apollo.BaseMutationOptions<DeployMutation, DeployMutationVariables>;
export const DeployStatusDocument = gql`
    query DeployStatus {
  modelSync {
    status
  }
}
    `;

/**
 * __useDeployStatusQuery__
 *
 * To run a query within a React component, call `useDeployStatusQuery` and pass it any options that fit your needs.
 * When your component renders, `useDeployStatusQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useDeployStatusQuery({
 *   variables: {
 *   },
 * });
 */
export function useDeployStatusQuery(baseOptions?: Apollo.QueryHookOptions<DeployStatusQuery, DeployStatusQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<DeployStatusQuery, DeployStatusQueryVariables>(DeployStatusDocument, options);
      }
export function useDeployStatusLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<DeployStatusQuery, DeployStatusQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<DeployStatusQuery, DeployStatusQueryVariables>(DeployStatusDocument, options);
        }
export type DeployStatusQueryHookResult = ReturnType<typeof useDeployStatusQuery>;
export type DeployStatusLazyQueryHookResult = ReturnType<typeof useDeployStatusLazyQuery>;
export type DeployStatusQueryResult = Apollo.QueryResult<DeployStatusQuery, DeployStatusQueryVariables>;
</file>

<file path="src/apollo/client/graphql/deploy.ts">
import { gql } from '@apollo/client';

export const DEPLOY = gql`
  mutation Deploy {
    deploy
  }
`;

export const GET_DEPLOY_STATUS = gql`
  query DeployStatus {
    modelSync {
      status
    }
  }
`;
</file>

<file path="src/apollo/client/graphql/diagram.generated.ts">
import * as Types from './__types__';

import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
const defaultOptions = {} as const;
export type ViewFieldFragment = { __typename?: 'DiagramViewField', id: string, displayName: string, referenceName: string, type: string, nodeType: Types.NodeType, description?: string | null };

export type RelationFieldFragment = { __typename?: 'DiagramModelRelationField', id: string, relationId: number, type: Types.RelationType, nodeType: Types.NodeType, displayName: string, referenceName: string, fromModelId: number, fromModelName: string, fromModelDisplayName: string, fromColumnId: number, fromColumnName: string, fromColumnDisplayName: string, toModelId: number, toModelName: string, toModelDisplayName: string, toColumnId: number, toColumnName: string, toColumnDisplayName: string, description?: string | null };

export type NestedFieldFragment = { __typename?: 'DiagramModelNestedField', id: string, nestedColumnId: number, columnPath: Array<string>, type: string, displayName: string, referenceName: string, description?: string | null };

export type FieldFragment = { __typename?: 'DiagramModelField', id: string, columnId: number, type: string, nodeType: Types.NodeType, displayName: string, referenceName: string, description?: string | null, isPrimaryKey: boolean, expression?: string | null, aggregation?: string | null, lineage?: Array<number> | null, nestedFields?: Array<{ __typename?: 'DiagramModelNestedField', id: string, nestedColumnId: number, columnPath: Array<string>, type: string, displayName: string, referenceName: string, description?: string | null }> | null };

export type DiagramQueryVariables = Types.Exact<{ [key: string]: never; }>;


export type DiagramQuery = { __typename?: 'Query', diagram: { __typename?: 'Diagram', models: Array<{ __typename?: 'DiagramModel', id: string, modelId: number, nodeType: Types.NodeType, displayName: string, referenceName: string, sourceTableName: string, refSql?: string | null, cached: boolean, refreshTime?: string | null, description?: string | null, fields: Array<{ __typename?: 'DiagramModelField', id: string, columnId: number, type: string, nodeType: Types.NodeType, displayName: string, referenceName: string, description?: string | null, isPrimaryKey: boolean, expression?: string | null, aggregation?: string | null, lineage?: Array<number> | null, nestedFields?: Array<{ __typename?: 'DiagramModelNestedField', id: string, nestedColumnId: number, columnPath: Array<string>, type: string, displayName: string, referenceName: string, description?: string | null }> | null } | null>, calculatedFields: Array<{ __typename?: 'DiagramModelField', id: string, columnId: number, type: string, nodeType: Types.NodeType, displayName: string, referenceName: string, description?: string | null, isPrimaryKey: boolean, expression?: string | null, aggregation?: string | null, lineage?: Array<number> | null, nestedFields?: Array<{ __typename?: 'DiagramModelNestedField', id: string, nestedColumnId: number, columnPath: Array<string>, type: string, displayName: string, referenceName: string, description?: string | null }> | null } | null>, relationFields: Array<{ __typename?: 'DiagramModelRelationField', id: string, relationId: number, type: Types.RelationType, nodeType: Types.NodeType, displayName: string, referenceName: string, fromModelId: number, fromModelName: string, fromModelDisplayName: string, fromColumnId: number, fromColumnName: string, fromColumnDisplayName: string, toModelId: number, toModelName: string, toModelDisplayName: string, toColumnId: number, toColumnName: string, toColumnDisplayName: string, description?: string | null } | null> } | null>, views: Array<{ __typename?: 'DiagramView', id: string, viewId: number, nodeType: Types.NodeType, displayName: string, description?: string | null, referenceName: string, statement: string, fields: Array<{ __typename?: 'DiagramViewField', id: string, displayName: string, referenceName: string, type: string, nodeType: Types.NodeType, description?: string | null } | null> } | null> } };

export const ViewFieldFragmentDoc = gql`
    fragment ViewField on DiagramViewField {
  id
  displayName
  referenceName
  type
  nodeType
  description
}
    `;
export const RelationFieldFragmentDoc = gql`
    fragment RelationField on DiagramModelRelationField {
  id
  relationId
  type
  nodeType
  displayName
  referenceName
  fromModelId
  fromModelName
  fromModelDisplayName
  fromColumnId
  fromColumnName
  fromColumnDisplayName
  toModelId
  toModelName
  toModelDisplayName
  toColumnId
  toColumnName
  toColumnDisplayName
  description
}
    `;
export const NestedFieldFragmentDoc = gql`
    fragment NestedField on DiagramModelNestedField {
  id
  nestedColumnId
  columnPath
  type
  displayName
  referenceName
  description
}
    `;
export const FieldFragmentDoc = gql`
    fragment Field on DiagramModelField {
  id
  columnId
  type
  nodeType
  displayName
  referenceName
  description
  isPrimaryKey
  expression
  aggregation
  lineage
  nestedFields {
    ...NestedField
  }
}
    ${NestedFieldFragmentDoc}`;
export const DiagramDocument = gql`
    query Diagram {
  diagram {
    models {
      id
      modelId
      nodeType
      displayName
      referenceName
      sourceTableName
      refSql
      cached
      refreshTime
      description
      fields {
        ...Field
      }
      calculatedFields {
        ...Field
      }
      relationFields {
        ...RelationField
      }
    }
    views {
      id
      viewId
      nodeType
      displayName
      description
      referenceName
      statement
      fields {
        ...ViewField
      }
    }
  }
}
    ${FieldFragmentDoc}
${RelationFieldFragmentDoc}
${ViewFieldFragmentDoc}`;

/**
 * __useDiagramQuery__
 *
 * To run a query within a React component, call `useDiagramQuery` and pass it any options that fit your needs.
 * When your component renders, `useDiagramQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useDiagramQuery({
 *   variables: {
 *   },
 * });
 */
export function useDiagramQuery(baseOptions?: Apollo.QueryHookOptions<DiagramQuery, DiagramQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<DiagramQuery, DiagramQueryVariables>(DiagramDocument, options);
      }
export function useDiagramLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<DiagramQuery, DiagramQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<DiagramQuery, DiagramQueryVariables>(DiagramDocument, options);
        }
export type DiagramQueryHookResult = ReturnType<typeof useDiagramQuery>;
export type DiagramLazyQueryHookResult = ReturnType<typeof useDiagramLazyQuery>;
export type DiagramQueryResult = Apollo.QueryResult<DiagramQuery, DiagramQueryVariables>;
</file>

<file path="src/apollo/client/graphql/diagram.ts">
import { gql } from '@apollo/client';

const VIEW_FIELD = gql`
  fragment ViewField on DiagramViewField {
    id
    displayName
    referenceName
    type
    nodeType
    description
  }
`;

const RELATION_FIELD = gql`
  fragment RelationField on DiagramModelRelationField {
    id
    relationId
    type
    nodeType
    displayName
    referenceName
    fromModelId
    fromModelName
    fromModelDisplayName
    fromColumnId
    fromColumnName
    fromColumnDisplayName
    toModelId
    toModelName
    toModelDisplayName
    toColumnId
    toColumnName
    toColumnDisplayName
    description
  }
`;

const NESTED_FIELD = gql`
  fragment NestedField on DiagramModelNestedField {
    id
    nestedColumnId
    columnPath
    type
    displayName
    referenceName
    description
  }
`;

const FIELD = gql`
  fragment Field on DiagramModelField {
    id
    columnId
    type
    nodeType
    displayName
    referenceName
    description
    isPrimaryKey
    expression
    aggregation
    lineage
    nestedFields {
      ...NestedField
    }
  }
  ${NESTED_FIELD}
`;

export const DIAGRAM = gql`
  query Diagram {
    diagram {
      models {
        id
        modelId
        nodeType
        displayName
        referenceName
        sourceTableName
        refSql
        cached
        refreshTime
        description
        fields {
          ...Field
        }
        calculatedFields {
          ...Field
        }
        relationFields {
          ...RelationField
        }
      }
      views {
        id
        viewId
        nodeType
        displayName
        description
        referenceName
        statement
        fields {
          ...ViewField
        }
      }
    }
  }
  ${FIELD}
  ${RELATION_FIELD}
  ${VIEW_FIELD}
`;
</file>

<file path="src/apollo/client/graphql/home.generated.ts">
import * as Types from './__types__';

import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
const defaultOptions = {} as const;
export type CommonErrorFragment = { __typename?: 'Error', code?: string | null, shortMessage?: string | null, message?: string | null, stacktrace?: Array<string | null> | null };

export type CommonBreakdownDetailFragment = { __typename?: 'ThreadResponseBreakdownDetail', queryId?: string | null, status: Types.AskingTaskStatus, description?: string | null, steps?: Array<{ __typename?: 'DetailStep', summary: string, sql: string, cteName?: string | null }> | null, error?: { __typename?: 'Error', code?: string | null, shortMessage?: string | null, message?: string | null, stacktrace?: Array<string | null> | null } | null };

export type CommonAnswerDetailFragment = { __typename?: 'ThreadResponseAnswerDetail', queryId?: string | null, status?: Types.ThreadResponseAnswerStatus | null, content?: string | null, numRowsUsedInLLM?: number | null, error?: { __typename?: 'Error', code?: string | null, shortMessage?: string | null, message?: string | null, stacktrace?: Array<string | null> | null } | null };

export type CommonChartDetailFragment = { __typename?: 'ThreadResponseChartDetail', queryId?: string | null, status: Types.ChartTaskStatus, description?: string | null, chartType?: Types.ChartType | null, chartSchema?: any | null, adjustment?: boolean | null, error?: { __typename?: 'Error', code?: string | null, shortMessage?: string | null, message?: string | null, stacktrace?: Array<string | null> | null } | null };

export type CommonAskingTaskFragment = { __typename?: 'AskingTask', status: Types.AskingTaskStatus, type?: Types.AskingTaskType | null, rephrasedQuestion?: string | null, intentReasoning?: string | null, sqlGenerationReasoning?: string | null, retrievedTables?: Array<string> | null, invalidSql?: string | null, traceId?: string | null, queryId?: string | null, candidates: Array<{ __typename?: 'ResultCandidate', sql: string, type: Types.ResultCandidateType, view?: { __typename?: 'ViewInfo', id: number, name: string, statement: string, displayName: string } | null, sqlPair?: { __typename?: 'SqlPair', id: number, question: string, sql: string, projectId: number } | null }>, error?: { __typename?: 'Error', code?: string | null, shortMessage?: string | null, message?: string | null, stacktrace?: Array<string | null> | null } | null };

export type CommonResponseFragment = { __typename?: 'ThreadResponse', id: number, threadId: number, question: string, sql?: string | null, view?: { __typename?: 'ViewInfo', id: number, name: string, statement: string, displayName: string } | null, breakdownDetail?: { __typename?: 'ThreadResponseBreakdownDetail', queryId?: string | null, status: Types.AskingTaskStatus, description?: string | null, steps?: Array<{ __typename?: 'DetailStep', summary: string, sql: string, cteName?: string | null }> | null, error?: { __typename?: 'Error', code?: string | null, shortMessage?: string | null, message?: string | null, stacktrace?: Array<string | null> | null } | null } | null, answerDetail?: { __typename?: 'ThreadResponseAnswerDetail', queryId?: string | null, status?: Types.ThreadResponseAnswerStatus | null, content?: string | null, numRowsUsedInLLM?: number | null, error?: { __typename?: 'Error', code?: string | null, shortMessage?: string | null, message?: string | null, stacktrace?: Array<string | null> | null } | null } | null, chartDetail?: { __typename?: 'ThreadResponseChartDetail', queryId?: string | null, status: Types.ChartTaskStatus, description?: string | null, chartType?: Types.ChartType | null, chartSchema?: any | null, adjustment?: boolean | null, error?: { __typename?: 'Error', code?: string | null, shortMessage?: string | null, message?: string | null, stacktrace?: Array<string | null> | null } | null } | null, askingTask?: { __typename?: 'AskingTask', status: Types.AskingTaskStatus, type?: Types.AskingTaskType | null, rephrasedQuestion?: string | null, intentReasoning?: string | null, sqlGenerationReasoning?: string | null, retrievedTables?: Array<string> | null, invalidSql?: string | null, traceId?: string | null, queryId?: string | null, candidates: Array<{ __typename?: 'ResultCandidate', sql: string, type: Types.ResultCandidateType, view?: { __typename?: 'ViewInfo', id: number, name: string, statement: string, displayName: string } | null, sqlPair?: { __typename?: 'SqlPair', id: number, question: string, sql: string, projectId: number } | null }>, error?: { __typename?: 'Error', code?: string | null, shortMessage?: string | null, message?: string | null, stacktrace?: Array<string | null> | null } | null } | null, adjustment?: { __typename?: 'ThreadResponseAdjustment', type: Types.ThreadResponseAdjustmentType, payload?: any | null } | null, adjustmentTask?: { __typename?: 'AdjustmentTask', queryId?: string | null, status?: Types.AskingTaskStatus | null, sql?: string | null, traceId?: string | null, invalidSql?: string | null, error?: { __typename?: 'Error', code?: string | null, shortMessage?: string | null, message?: string | null, stacktrace?: Array<string | null> | null } | null } | null };

export type CommonRecommendedQuestionsTaskFragment = { __typename?: 'RecommendedQuestionsTask', status: Types.RecommendedQuestionsTaskStatus, questions: Array<{ __typename?: 'ResultQuestion', question: string, category: string, sql: string }>, error?: { __typename?: 'Error', code?: string | null, shortMessage?: string | null, message?: string | null, stacktrace?: Array<string | null> | null } | null };

export type SuggestedQuestionsQueryVariables = Types.Exact<{ [key: string]: never; }>;


export type SuggestedQuestionsQuery = { __typename?: 'Query', suggestedQuestions: { __typename?: 'SuggestedQuestionResponse', questions: Array<{ __typename?: 'SuggestedQuestion', label: string, question: string } | null> } };

export type AskingTaskQueryVariables = Types.Exact<{
  taskId: Types.Scalars['String'];
}>;


export type AskingTaskQuery = { __typename?: 'Query', askingTask?: { __typename?: 'AskingTask', status: Types.AskingTaskStatus, type?: Types.AskingTaskType | null, rephrasedQuestion?: string | null, intentReasoning?: string | null, sqlGenerationReasoning?: string | null, retrievedTables?: Array<string> | null, invalidSql?: string | null, traceId?: string | null, queryId?: string | null, candidates: Array<{ __typename?: 'ResultCandidate', sql: string, type: Types.ResultCandidateType, view?: { __typename?: 'ViewInfo', id: number, name: string, statement: string, displayName: string } | null, sqlPair?: { __typename?: 'SqlPair', id: number, question: string, sql: string, projectId: number } | null }>, error?: { __typename?: 'Error', code?: string | null, shortMessage?: string | null, message?: string | null, stacktrace?: Array<string | null> | null } | null } | null };

export type ThreadsQueryVariables = Types.Exact<{ [key: string]: never; }>;


export type ThreadsQuery = { __typename?: 'Query', threads: Array<{ __typename?: 'Thread', id: number, summary: string }> };

export type ThreadQueryVariables = Types.Exact<{
  threadId: Types.Scalars['Int'];
}>;


export type ThreadQuery = { __typename?: 'Query', thread: { __typename?: 'DetailedThread', id: number, responses: Array<{ __typename?: 'ThreadResponse', id: number, threadId: number, question: string, sql?: string | null, view?: { __typename?: 'ViewInfo', id: number, name: string, statement: string, displayName: string } | null, breakdownDetail?: { __typename?: 'ThreadResponseBreakdownDetail', queryId?: string | null, status: Types.AskingTaskStatus, description?: string | null, steps?: Array<{ __typename?: 'DetailStep', summary: string, sql: string, cteName?: string | null }> | null, error?: { __typename?: 'Error', code?: string | null, shortMessage?: string | null, message?: string | null, stacktrace?: Array<string | null> | null } | null } | null, answerDetail?: { __typename?: 'ThreadResponseAnswerDetail', queryId?: string | null, status?: Types.ThreadResponseAnswerStatus | null, content?: string | null, numRowsUsedInLLM?: number | null, error?: { __typename?: 'Error', code?: string | null, shortMessage?: string | null, message?: string | null, stacktrace?: Array<string | null> | null } | null } | null, chartDetail?: { __typename?: 'ThreadResponseChartDetail', queryId?: string | null, status: Types.ChartTaskStatus, description?: string | null, chartType?: Types.ChartType | null, chartSchema?: any | null, adjustment?: boolean | null, error?: { __typename?: 'Error', code?: string | null, shortMessage?: string | null, message?: string | null, stacktrace?: Array<string | null> | null } | null } | null, askingTask?: { __typename?: 'AskingTask', status: Types.AskingTaskStatus, type?: Types.AskingTaskType | null, rephrasedQuestion?: string | null, intentReasoning?: string | null, sqlGenerationReasoning?: string | null, retrievedTables?: Array<string> | null, invalidSql?: string | null, traceId?: string | null, queryId?: string | null, candidates: Array<{ __typename?: 'ResultCandidate', sql: string, type: Types.ResultCandidateType, view?: { __typename?: 'ViewInfo', id: number, name: string, statement: string, displayName: string } | null, sqlPair?: { __typename?: 'SqlPair', id: number, question: string, sql: string, projectId: number } | null }>, error?: { __typename?: 'Error', code?: string | null, shortMessage?: string | null, message?: string | null, stacktrace?: Array<string | null> | null } | null } | null, adjustment?: { __typename?: 'ThreadResponseAdjustment', type: Types.ThreadResponseAdjustmentType, payload?: any | null } | null, adjustmentTask?: { __typename?: 'AdjustmentTask', queryId?: string | null, status?: Types.AskingTaskStatus | null, sql?: string | null, traceId?: string | null, invalidSql?: string | null, error?: { __typename?: 'Error', code?: string | null, shortMessage?: string | null, message?: string | null, stacktrace?: Array<string | null> | null } | null } | null }> } };

export type ThreadResponseQueryVariables = Types.Exact<{
  responseId: Types.Scalars['Int'];
}>;


export type ThreadResponseQuery = { __typename?: 'Query', threadResponse: { __typename?: 'ThreadResponse', id: number, threadId: number, question: string, sql?: string | null, view?: { __typename?: 'ViewInfo', id: number, name: string, statement: string, displayName: string } | null, breakdownDetail?: { __typename?: 'ThreadResponseBreakdownDetail', queryId?: string | null, status: Types.AskingTaskStatus, description?: string | null, steps?: Array<{ __typename?: 'DetailStep', summary: string, sql: string, cteName?: string | null }> | null, error?: { __typename?: 'Error', code?: string | null, shortMessage?: string | null, message?: string | null, stacktrace?: Array<string | null> | null } | null } | null, answerDetail?: { __typename?: 'ThreadResponseAnswerDetail', queryId?: string | null, status?: Types.ThreadResponseAnswerStatus | null, content?: string | null, numRowsUsedInLLM?: number | null, error?: { __typename?: 'Error', code?: string | null, shortMessage?: string | null, message?: string | null, stacktrace?: Array<string | null> | null } | null } | null, chartDetail?: { __typename?: 'ThreadResponseChartDetail', queryId?: string | null, status: Types.ChartTaskStatus, description?: string | null, chartType?: Types.ChartType | null, chartSchema?: any | null, adjustment?: boolean | null, error?: { __typename?: 'Error', code?: string | null, shortMessage?: string | null, message?: string | null, stacktrace?: Array<string | null> | null } | null } | null, askingTask?: { __typename?: 'AskingTask', status: Types.AskingTaskStatus, type?: Types.AskingTaskType | null, rephrasedQuestion?: string | null, intentReasoning?: string | null, sqlGenerationReasoning?: string | null, retrievedTables?: Array<string> | null, invalidSql?: string | null, traceId?: string | null, queryId?: string | null, candidates: Array<{ __typename?: 'ResultCandidate', sql: string, type: Types.ResultCandidateType, view?: { __typename?: 'ViewInfo', id: number, name: string, statement: string, displayName: string } | null, sqlPair?: { __typename?: 'SqlPair', id: number, question: string, sql: string, projectId: number } | null }>, error?: { __typename?: 'Error', code?: string | null, shortMessage?: string | null, message?: string | null, stacktrace?: Array<string | null> | null } | null } | null, adjustment?: { __typename?: 'ThreadResponseAdjustment', type: Types.ThreadResponseAdjustmentType, payload?: any | null } | null, adjustmentTask?: { __typename?: 'AdjustmentTask', queryId?: string | null, status?: Types.AskingTaskStatus | null, sql?: string | null, traceId?: string | null, invalidSql?: string | null, error?: { __typename?: 'Error', code?: string | null, shortMessage?: string | null, message?: string | null, stacktrace?: Array<string | null> | null } | null } | null } };

export type CreateAskingTaskMutationVariables = Types.Exact<{
  data: Types.AskingTaskInput;
}>;


export type CreateAskingTaskMutation = { __typename?: 'Mutation', createAskingTask: { __typename?: 'Task', id: string } };

export type CancelAskingTaskMutationVariables = Types.Exact<{
  taskId: Types.Scalars['String'];
}>;


export type CancelAskingTaskMutation = { __typename?: 'Mutation', cancelAskingTask: boolean };

export type RerunAskingTaskMutationVariables = Types.Exact<{
  responseId: Types.Scalars['Int'];
}>;


export type RerunAskingTaskMutation = { __typename?: 'Mutation', rerunAskingTask: { __typename?: 'Task', id: string } };

export type CreateThreadMutationVariables = Types.Exact<{
  data: Types.CreateThreadInput;
}>;


export type CreateThreadMutation = { __typename?: 'Mutation', createThread: { __typename?: 'Thread', id: number } };

export type CreateThreadResponseMutationVariables = Types.Exact<{
  threadId: Types.Scalars['Int'];
  data: Types.CreateThreadResponseInput;
}>;


export type CreateThreadResponseMutation = { __typename?: 'Mutation', createThreadResponse: { __typename?: 'ThreadResponse', id: number, threadId: number, question: string, sql?: string | null, view?: { __typename?: 'ViewInfo', id: number, name: string, statement: string, displayName: string } | null, breakdownDetail?: { __typename?: 'ThreadResponseBreakdownDetail', queryId?: string | null, status: Types.AskingTaskStatus, description?: string | null, steps?: Array<{ __typename?: 'DetailStep', summary: string, sql: string, cteName?: string | null }> | null, error?: { __typename?: 'Error', code?: string | null, shortMessage?: string | null, message?: string | null, stacktrace?: Array<string | null> | null } | null } | null, answerDetail?: { __typename?: 'ThreadResponseAnswerDetail', queryId?: string | null, status?: Types.ThreadResponseAnswerStatus | null, content?: string | null, numRowsUsedInLLM?: number | null, error?: { __typename?: 'Error', code?: string | null, shortMessage?: string | null, message?: string | null, stacktrace?: Array<string | null> | null } | null } | null, chartDetail?: { __typename?: 'ThreadResponseChartDetail', queryId?: string | null, status: Types.ChartTaskStatus, description?: string | null, chartType?: Types.ChartType | null, chartSchema?: any | null, adjustment?: boolean | null, error?: { __typename?: 'Error', code?: string | null, shortMessage?: string | null, message?: string | null, stacktrace?: Array<string | null> | null } | null } | null, askingTask?: { __typename?: 'AskingTask', status: Types.AskingTaskStatus, type?: Types.AskingTaskType | null, rephrasedQuestion?: string | null, intentReasoning?: string | null, sqlGenerationReasoning?: string | null, retrievedTables?: Array<string> | null, invalidSql?: string | null, traceId?: string | null, queryId?: string | null, candidates: Array<{ __typename?: 'ResultCandidate', sql: string, type: Types.ResultCandidateType, view?: { __typename?: 'ViewInfo', id: number, name: string, statement: string, displayName: string } | null, sqlPair?: { __typename?: 'SqlPair', id: number, question: string, sql: string, projectId: number } | null }>, error?: { __typename?: 'Error', code?: string | null, shortMessage?: string | null, message?: string | null, stacktrace?: Array<string | null> | null } | null } | null, adjustment?: { __typename?: 'ThreadResponseAdjustment', type: Types.ThreadResponseAdjustmentType, payload?: any | null } | null, adjustmentTask?: { __typename?: 'AdjustmentTask', queryId?: string | null, status?: Types.AskingTaskStatus | null, sql?: string | null, traceId?: string | null, invalidSql?: string | null, error?: { __typename?: 'Error', code?: string | null, shortMessage?: string | null, message?: string | null, stacktrace?: Array<string | null> | null } | null } | null } };

export type UpdateThreadMutationVariables = Types.Exact<{
  where: Types.ThreadUniqueWhereInput;
  data: Types.UpdateThreadInput;
}>;


export type UpdateThreadMutation = { __typename?: 'Mutation', updateThread: { __typename?: 'Thread', id: number, summary: string } };

export type UpdateThreadResponseMutationVariables = Types.Exact<{
  where: Types.ThreadResponseUniqueWhereInput;
  data: Types.UpdateThreadResponseInput;
}>;


export type UpdateThreadResponseMutation = { __typename?: 'Mutation', updateThreadResponse: { __typename?: 'ThreadResponse', id: number, threadId: number, question: string, sql?: string | null, view?: { __typename?: 'ViewInfo', id: number, name: string, statement: string, displayName: string } | null, breakdownDetail?: { __typename?: 'ThreadResponseBreakdownDetail', queryId?: string | null, status: Types.AskingTaskStatus, description?: string | null, steps?: Array<{ __typename?: 'DetailStep', summary: string, sql: string, cteName?: string | null }> | null, error?: { __typename?: 'Error', code?: string | null, shortMessage?: string | null, message?: string | null, stacktrace?: Array<string | null> | null } | null } | null, answerDetail?: { __typename?: 'ThreadResponseAnswerDetail', queryId?: string | null, status?: Types.ThreadResponseAnswerStatus | null, content?: string | null, numRowsUsedInLLM?: number | null, error?: { __typename?: 'Error', code?: string | null, shortMessage?: string | null, message?: string | null, stacktrace?: Array<string | null> | null } | null } | null, chartDetail?: { __typename?: 'ThreadResponseChartDetail', queryId?: string | null, status: Types.ChartTaskStatus, description?: string | null, chartType?: Types.ChartType | null, chartSchema?: any | null, adjustment?: boolean | null, error?: { __typename?: 'Error', code?: string | null, shortMessage?: string | null, message?: string | null, stacktrace?: Array<string | null> | null } | null } | null, askingTask?: { __typename?: 'AskingTask', status: Types.AskingTaskStatus, type?: Types.AskingTaskType | null, rephrasedQuestion?: string | null, intentReasoning?: string | null, sqlGenerationReasoning?: string | null, retrievedTables?: Array<string> | null, invalidSql?: string | null, traceId?: string | null, queryId?: string | null, candidates: Array<{ __typename?: 'ResultCandidate', sql: string, type: Types.ResultCandidateType, view?: { __typename?: 'ViewInfo', id: number, name: string, statement: string, displayName: string } | null, sqlPair?: { __typename?: 'SqlPair', id: number, question: string, sql: string, projectId: number } | null }>, error?: { __typename?: 'Error', code?: string | null, shortMessage?: string | null, message?: string | null, stacktrace?: Array<string | null> | null } | null } | null, adjustment?: { __typename?: 'ThreadResponseAdjustment', type: Types.ThreadResponseAdjustmentType, payload?: any | null } | null, adjustmentTask?: { __typename?: 'AdjustmentTask', queryId?: string | null, status?: Types.AskingTaskStatus | null, sql?: string | null, traceId?: string | null, invalidSql?: string | null, error?: { __typename?: 'Error', code?: string | null, shortMessage?: string | null, message?: string | null, stacktrace?: Array<string | null> | null } | null } | null } };

export type AdjustThreadResponseMutationVariables = Types.Exact<{
  responseId: Types.Scalars['Int'];
  data: Types.AdjustThreadResponseInput;
}>;


export type AdjustThreadResponseMutation = { __typename?: 'Mutation', adjustThreadResponse: { __typename?: 'ThreadResponse', id: number, threadId: number, question: string, sql?: string | null, view?: { __typename?: 'ViewInfo', id: number, name: string, statement: string, displayName: string } | null, breakdownDetail?: { __typename?: 'ThreadResponseBreakdownDetail', queryId?: string | null, status: Types.AskingTaskStatus, description?: string | null, steps?: Array<{ __typename?: 'DetailStep', summary: string, sql: string, cteName?: string | null }> | null, error?: { __typename?: 'Error', code?: string | null, shortMessage?: string | null, message?: string | null, stacktrace?: Array<string | null> | null } | null } | null, answerDetail?: { __typename?: 'ThreadResponseAnswerDetail', queryId?: string | null, status?: Types.ThreadResponseAnswerStatus | null, content?: string | null, numRowsUsedInLLM?: number | null, error?: { __typename?: 'Error', code?: string | null, shortMessage?: string | null, message?: string | null, stacktrace?: Array<string | null> | null } | null } | null, chartDetail?: { __typename?: 'ThreadResponseChartDetail', queryId?: string | null, status: Types.ChartTaskStatus, description?: string | null, chartType?: Types.ChartType | null, chartSchema?: any | null, adjustment?: boolean | null, error?: { __typename?: 'Error', code?: string | null, shortMessage?: string | null, message?: string | null, stacktrace?: Array<string | null> | null } | null } | null, askingTask?: { __typename?: 'AskingTask', status: Types.AskingTaskStatus, type?: Types.AskingTaskType | null, rephrasedQuestion?: string | null, intentReasoning?: string | null, sqlGenerationReasoning?: string | null, retrievedTables?: Array<string> | null, invalidSql?: string | null, traceId?: string | null, queryId?: string | null, candidates: Array<{ __typename?: 'ResultCandidate', sql: string, type: Types.ResultCandidateType, view?: { __typename?: 'ViewInfo', id: number, name: string, statement: string, displayName: string } | null, sqlPair?: { __typename?: 'SqlPair', id: number, question: string, sql: string, projectId: number } | null }>, error?: { __typename?: 'Error', code?: string | null, shortMessage?: string | null, message?: string | null, stacktrace?: Array<string | null> | null } | null } | null, adjustment?: { __typename?: 'ThreadResponseAdjustment', type: Types.ThreadResponseAdjustmentType, payload?: any | null } | null, adjustmentTask?: { __typename?: 'AdjustmentTask', queryId?: string | null, status?: Types.AskingTaskStatus | null, sql?: string | null, traceId?: string | null, invalidSql?: string | null, error?: { __typename?: 'Error', code?: string | null, shortMessage?: string | null, message?: string | null, stacktrace?: Array<string | null> | null } | null } | null } };

export type DeleteThreadMutationVariables = Types.Exact<{
  where: Types.ThreadUniqueWhereInput;
}>;


export type DeleteThreadMutation = { __typename?: 'Mutation', deleteThread: boolean };

export type PreviewDataMutationVariables = Types.Exact<{
  where: Types.PreviewDataInput;
}>;


export type PreviewDataMutation = { __typename?: 'Mutation', previewData: any };

export type PreviewBreakdownDataMutationVariables = Types.Exact<{
  where: Types.PreviewDataInput;
}>;


export type PreviewBreakdownDataMutation = { __typename?: 'Mutation', previewBreakdownData: any };

export type GetNativeSqlQueryVariables = Types.Exact<{
  responseId: Types.Scalars['Int'];
}>;


export type GetNativeSqlQuery = { __typename?: 'Query', nativeSql: string };

export type CreateInstantRecommendedQuestionsMutationVariables = Types.Exact<{
  data: Types.InstantRecommendedQuestionsInput;
}>;


export type CreateInstantRecommendedQuestionsMutation = { __typename?: 'Mutation', createInstantRecommendedQuestions: { __typename?: 'Task', id: string } };

export type InstantRecommendedQuestionsQueryVariables = Types.Exact<{
  taskId: Types.Scalars['String'];
}>;


export type InstantRecommendedQuestionsQuery = { __typename?: 'Query', instantRecommendedQuestions: { __typename?: 'RecommendedQuestionsTask', status: Types.RecommendedQuestionsTaskStatus, questions: Array<{ __typename?: 'ResultQuestion', question: string, category: string, sql: string }>, error?: { __typename?: 'Error', code?: string | null, shortMessage?: string | null, message?: string | null, stacktrace?: Array<string | null> | null } | null } };

export type GetThreadRecommendationQuestionsQueryVariables = Types.Exact<{
  threadId: Types.Scalars['Int'];
}>;


export type GetThreadRecommendationQuestionsQuery = { __typename?: 'Query', getThreadRecommendationQuestions: { __typename?: 'RecommendedQuestionsTask', status: Types.RecommendedQuestionsTaskStatus, questions: Array<{ __typename?: 'ResultQuestion', question: string, category: string, sql: string }>, error?: { __typename?: 'Error', code?: string | null, shortMessage?: string | null, message?: string | null, stacktrace?: Array<string | null> | null } | null } };

export type GetProjectRecommendationQuestionsQueryVariables = Types.Exact<{ [key: string]: never; }>;


export type GetProjectRecommendationQuestionsQuery = { __typename?: 'Query', getProjectRecommendationQuestions: { __typename?: 'RecommendedQuestionsTask', status: Types.RecommendedQuestionsTaskStatus, questions: Array<{ __typename?: 'ResultQuestion', question: string, category: string, sql: string }>, error?: { __typename?: 'Error', code?: string | null, shortMessage?: string | null, message?: string | null, stacktrace?: Array<string | null> | null } | null } };

export type GenerateProjectRecommendationQuestionsMutationVariables = Types.Exact<{ [key: string]: never; }>;


export type GenerateProjectRecommendationQuestionsMutation = { __typename?: 'Mutation', generateProjectRecommendationQuestions: boolean };

export type GenerateThreadRecommendationQuestionsMutationVariables = Types.Exact<{
  threadId: Types.Scalars['Int'];
}>;


export type GenerateThreadRecommendationQuestionsMutation = { __typename?: 'Mutation', generateThreadRecommendationQuestions: boolean };

export type GenerateThreadResponseAnswerMutationVariables = Types.Exact<{
  responseId: Types.Scalars['Int'];
}>;


export type GenerateThreadResponseAnswerMutation = { __typename?: 'Mutation', generateThreadResponseAnswer: { __typename?: 'ThreadResponse', id: number, threadId: number, question: string, sql?: string | null, view?: { __typename?: 'ViewInfo', id: number, name: string, statement: string, displayName: string } | null, breakdownDetail?: { __typename?: 'ThreadResponseBreakdownDetail', queryId?: string | null, status: Types.AskingTaskStatus, description?: string | null, steps?: Array<{ __typename?: 'DetailStep', summary: string, sql: string, cteName?: string | null }> | null, error?: { __typename?: 'Error', code?: string | null, shortMessage?: string | null, message?: string | null, stacktrace?: Array<string | null> | null } | null } | null, answerDetail?: { __typename?: 'ThreadResponseAnswerDetail', queryId?: string | null, status?: Types.ThreadResponseAnswerStatus | null, content?: string | null, numRowsUsedInLLM?: number | null, error?: { __typename?: 'Error', code?: string | null, shortMessage?: string | null, message?: string | null, stacktrace?: Array<string | null> | null } | null } | null, chartDetail?: { __typename?: 'ThreadResponseChartDetail', queryId?: string | null, status: Types.ChartTaskStatus, description?: string | null, chartType?: Types.ChartType | null, chartSchema?: any | null, adjustment?: boolean | null, error?: { __typename?: 'Error', code?: string | null, shortMessage?: string | null, message?: string | null, stacktrace?: Array<string | null> | null } | null } | null, askingTask?: { __typename?: 'AskingTask', status: Types.AskingTaskStatus, type?: Types.AskingTaskType | null, rephrasedQuestion?: string | null, intentReasoning?: string | null, sqlGenerationReasoning?: string | null, retrievedTables?: Array<string> | null, invalidSql?: string | null, traceId?: string | null, queryId?: string | null, candidates: Array<{ __typename?: 'ResultCandidate', sql: string, type: Types.ResultCandidateType, view?: { __typename?: 'ViewInfo', id: number, name: string, statement: string, displayName: string } | null, sqlPair?: { __typename?: 'SqlPair', id: number, question: string, sql: string, projectId: number } | null }>, error?: { __typename?: 'Error', code?: string | null, shortMessage?: string | null, message?: string | null, stacktrace?: Array<string | null> | null } | null } | null, adjustment?: { __typename?: 'ThreadResponseAdjustment', type: Types.ThreadResponseAdjustmentType, payload?: any | null } | null, adjustmentTask?: { __typename?: 'AdjustmentTask', queryId?: string | null, status?: Types.AskingTaskStatus | null, sql?: string | null, traceId?: string | null, invalidSql?: string | null, error?: { __typename?: 'Error', code?: string | null, shortMessage?: string | null, message?: string | null, stacktrace?: Array<string | null> | null } | null } | null } };

export type GenerateThreadResponseChartMutationVariables = Types.Exact<{
  responseId: Types.Scalars['Int'];
}>;


export type GenerateThreadResponseChartMutation = { __typename?: 'Mutation', generateThreadResponseChart: { __typename?: 'ThreadResponse', id: number, threadId: number, question: string, sql?: string | null, view?: { __typename?: 'ViewInfo', id: number, name: string, statement: string, displayName: string } | null, breakdownDetail?: { __typename?: 'ThreadResponseBreakdownDetail', queryId?: string | null, status: Types.AskingTaskStatus, description?: string | null, steps?: Array<{ __typename?: 'DetailStep', summary: string, sql: string, cteName?: string | null }> | null, error?: { __typename?: 'Error', code?: string | null, shortMessage?: string | null, message?: string | null, stacktrace?: Array<string | null> | null } | null } | null, answerDetail?: { __typename?: 'ThreadResponseAnswerDetail', queryId?: string | null, status?: Types.ThreadResponseAnswerStatus | null, content?: string | null, numRowsUsedInLLM?: number | null, error?: { __typename?: 'Error', code?: string | null, shortMessage?: string | null, message?: string | null, stacktrace?: Array<string | null> | null } | null } | null, chartDetail?: { __typename?: 'ThreadResponseChartDetail', queryId?: string | null, status: Types.ChartTaskStatus, description?: string | null, chartType?: Types.ChartType | null, chartSchema?: any | null, adjustment?: boolean | null, error?: { __typename?: 'Error', code?: string | null, shortMessage?: string | null, message?: string | null, stacktrace?: Array<string | null> | null } | null } | null, askingTask?: { __typename?: 'AskingTask', status: Types.AskingTaskStatus, type?: Types.AskingTaskType | null, rephrasedQuestion?: string | null, intentReasoning?: string | null, sqlGenerationReasoning?: string | null, retrievedTables?: Array<string> | null, invalidSql?: string | null, traceId?: string | null, queryId?: string | null, candidates: Array<{ __typename?: 'ResultCandidate', sql: string, type: Types.ResultCandidateType, view?: { __typename?: 'ViewInfo', id: number, name: string, statement: string, displayName: string } | null, sqlPair?: { __typename?: 'SqlPair', id: number, question: string, sql: string, projectId: number } | null }>, error?: { __typename?: 'Error', code?: string | null, shortMessage?: string | null, message?: string | null, stacktrace?: Array<string | null> | null } | null } | null, adjustment?: { __typename?: 'ThreadResponseAdjustment', type: Types.ThreadResponseAdjustmentType, payload?: any | null } | null, adjustmentTask?: { __typename?: 'AdjustmentTask', queryId?: string | null, status?: Types.AskingTaskStatus | null, sql?: string | null, traceId?: string | null, invalidSql?: string | null, error?: { __typename?: 'Error', code?: string | null, shortMessage?: string | null, message?: string | null, stacktrace?: Array<string | null> | null } | null } | null } };

export type AdjustThreadResponseChartMutationVariables = Types.Exact<{
  responseId: Types.Scalars['Int'];
  data: Types.AdjustThreadResponseChartInput;
}>;


export type AdjustThreadResponseChartMutation = { __typename?: 'Mutation', adjustThreadResponseChart: { __typename?: 'ThreadResponse', id: number, threadId: number, question: string, sql?: string | null, view?: { __typename?: 'ViewInfo', id: number, name: string, statement: string, displayName: string } | null, breakdownDetail?: { __typename?: 'ThreadResponseBreakdownDetail', queryId?: string | null, status: Types.AskingTaskStatus, description?: string | null, steps?: Array<{ __typename?: 'DetailStep', summary: string, sql: string, cteName?: string | null }> | null, error?: { __typename?: 'Error', code?: string | null, shortMessage?: string | null, message?: string | null, stacktrace?: Array<string | null> | null } | null } | null, answerDetail?: { __typename?: 'ThreadResponseAnswerDetail', queryId?: string | null, status?: Types.ThreadResponseAnswerStatus | null, content?: string | null, numRowsUsedInLLM?: number | null, error?: { __typename?: 'Error', code?: string | null, shortMessage?: string | null, message?: string | null, stacktrace?: Array<string | null> | null } | null } | null, chartDetail?: { __typename?: 'ThreadResponseChartDetail', queryId?: string | null, status: Types.ChartTaskStatus, description?: string | null, chartType?: Types.ChartType | null, chartSchema?: any | null, adjustment?: boolean | null, error?: { __typename?: 'Error', code?: string | null, shortMessage?: string | null, message?: string | null, stacktrace?: Array<string | null> | null } | null } | null, askingTask?: { __typename?: 'AskingTask', status: Types.AskingTaskStatus, type?: Types.AskingTaskType | null, rephrasedQuestion?: string | null, intentReasoning?: string | null, sqlGenerationReasoning?: string | null, retrievedTables?: Array<string> | null, invalidSql?: string | null, traceId?: string | null, queryId?: string | null, candidates: Array<{ __typename?: 'ResultCandidate', sql: string, type: Types.ResultCandidateType, view?: { __typename?: 'ViewInfo', id: number, name: string, statement: string, displayName: string } | null, sqlPair?: { __typename?: 'SqlPair', id: number, question: string, sql: string, projectId: number } | null }>, error?: { __typename?: 'Error', code?: string | null, shortMessage?: string | null, message?: string | null, stacktrace?: Array<string | null> | null } | null } | null, adjustment?: { __typename?: 'ThreadResponseAdjustment', type: Types.ThreadResponseAdjustmentType, payload?: any | null } | null, adjustmentTask?: { __typename?: 'AdjustmentTask', queryId?: string | null, status?: Types.AskingTaskStatus | null, sql?: string | null, traceId?: string | null, invalidSql?: string | null, error?: { __typename?: 'Error', code?: string | null, shortMessage?: string | null, message?: string | null, stacktrace?: Array<string | null> | null } | null } | null } };

export type AdjustmentTaskQueryVariables = Types.Exact<{
  taskId: Types.Scalars['String'];
}>;


export type AdjustmentTaskQuery = { __typename?: 'Query', adjustmentTask?: { __typename?: 'AdjustmentTask', queryId?: string | null, status?: Types.AskingTaskStatus | null, sql?: string | null, traceId?: string | null, invalidSql?: string | null, error?: { __typename?: 'Error', code?: string | null, shortMessage?: string | null, message?: string | null, stacktrace?: Array<string | null> | null } | null } | null };

export type CancelAdjustmentTaskMutationVariables = Types.Exact<{
  taskId: Types.Scalars['String'];
}>;


export type CancelAdjustmentTaskMutation = { __typename?: 'Mutation', cancelAdjustmentTask: boolean };

export type RerunAdjustmentTaskMutationVariables = Types.Exact<{
  responseId: Types.Scalars['Int'];
}>;


export type RerunAdjustmentTaskMutation = { __typename?: 'Mutation', rerunAdjustmentTask: boolean };

export const CommonErrorFragmentDoc = gql`
    fragment CommonError on Error {
  code
  shortMessage
  message
  stacktrace
}
    `;
export const CommonBreakdownDetailFragmentDoc = gql`
    fragment CommonBreakdownDetail on ThreadResponseBreakdownDetail {
  queryId
  status
  description
  steps {
    summary
    sql
    cteName
  }
  error {
    ...CommonError
  }
}
    ${CommonErrorFragmentDoc}`;
export const CommonAnswerDetailFragmentDoc = gql`
    fragment CommonAnswerDetail on ThreadResponseAnswerDetail {
  queryId
  status
  content
  numRowsUsedInLLM
  error {
    ...CommonError
  }
}
    ${CommonErrorFragmentDoc}`;
export const CommonChartDetailFragmentDoc = gql`
    fragment CommonChartDetail on ThreadResponseChartDetail {
  queryId
  status
  description
  chartType
  chartSchema
  error {
    ...CommonError
  }
  adjustment
}
    ${CommonErrorFragmentDoc}`;
export const CommonAskingTaskFragmentDoc = gql`
    fragment CommonAskingTask on AskingTask {
  status
  type
  candidates {
    sql
    type
    view {
      id
      name
      statement
      displayName
    }
    sqlPair {
      id
      question
      sql
      projectId
    }
  }
  error {
    ...CommonError
  }
  rephrasedQuestion
  intentReasoning
  sqlGenerationReasoning
  retrievedTables
  invalidSql
  traceId
  queryId
}
    ${CommonErrorFragmentDoc}`;
export const CommonResponseFragmentDoc = gql`
    fragment CommonResponse on ThreadResponse {
  id
  threadId
  question
  sql
  view {
    id
    name
    statement
    displayName
  }
  breakdownDetail {
    ...CommonBreakdownDetail
  }
  answerDetail {
    ...CommonAnswerDetail
  }
  chartDetail {
    ...CommonChartDetail
  }
  askingTask {
    ...CommonAskingTask
  }
  adjustment {
    type
    payload
  }
  adjustmentTask {
    queryId
    status
    error {
      ...CommonError
    }
    sql
    traceId
    invalidSql
  }
}
    ${CommonBreakdownDetailFragmentDoc}
${CommonAnswerDetailFragmentDoc}
${CommonChartDetailFragmentDoc}
${CommonAskingTaskFragmentDoc}
${CommonErrorFragmentDoc}`;
export const CommonRecommendedQuestionsTaskFragmentDoc = gql`
    fragment CommonRecommendedQuestionsTask on RecommendedQuestionsTask {
  status
  questions {
    question
    category
    sql
  }
  error {
    ...CommonError
  }
}
    ${CommonErrorFragmentDoc}`;
export const SuggestedQuestionsDocument = gql`
    query SuggestedQuestions {
  suggestedQuestions {
    questions {
      label
      question
    }
  }
}
    `;

/**
 * __useSuggestedQuestionsQuery__
 *
 * To run a query within a React component, call `useSuggestedQuestionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useSuggestedQuestionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSuggestedQuestionsQuery({
 *   variables: {
 *   },
 * });
 */
export function useSuggestedQuestionsQuery(baseOptions?: Apollo.QueryHookOptions<SuggestedQuestionsQuery, SuggestedQuestionsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SuggestedQuestionsQuery, SuggestedQuestionsQueryVariables>(SuggestedQuestionsDocument, options);
      }
export function useSuggestedQuestionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SuggestedQuestionsQuery, SuggestedQuestionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SuggestedQuestionsQuery, SuggestedQuestionsQueryVariables>(SuggestedQuestionsDocument, options);
        }
export type SuggestedQuestionsQueryHookResult = ReturnType<typeof useSuggestedQuestionsQuery>;
export type SuggestedQuestionsLazyQueryHookResult = ReturnType<typeof useSuggestedQuestionsLazyQuery>;
export type SuggestedQuestionsQueryResult = Apollo.QueryResult<SuggestedQuestionsQuery, SuggestedQuestionsQueryVariables>;
export const AskingTaskDocument = gql`
    query AskingTask($taskId: String!) {
  askingTask(taskId: $taskId) {
    ...CommonAskingTask
  }
}
    ${CommonAskingTaskFragmentDoc}`;

/**
 * __useAskingTaskQuery__
 *
 * To run a query within a React component, call `useAskingTaskQuery` and pass it any options that fit your needs.
 * When your component renders, `useAskingTaskQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAskingTaskQuery({
 *   variables: {
 *      taskId: // value for 'taskId'
 *   },
 * });
 */
export function useAskingTaskQuery(baseOptions: Apollo.QueryHookOptions<AskingTaskQuery, AskingTaskQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AskingTaskQuery, AskingTaskQueryVariables>(AskingTaskDocument, options);
      }
export function useAskingTaskLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AskingTaskQuery, AskingTaskQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AskingTaskQuery, AskingTaskQueryVariables>(AskingTaskDocument, options);
        }
export type AskingTaskQueryHookResult = ReturnType<typeof useAskingTaskQuery>;
export type AskingTaskLazyQueryHookResult = ReturnType<typeof useAskingTaskLazyQuery>;
export type AskingTaskQueryResult = Apollo.QueryResult<AskingTaskQuery, AskingTaskQueryVariables>;
export const ThreadsDocument = gql`
    query Threads {
  threads {
    id
    summary
  }
}
    `;

/**
 * __useThreadsQuery__
 *
 * To run a query within a React component, call `useThreadsQuery` and pass it any options that fit your needs.
 * When your component renders, `useThreadsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useThreadsQuery({
 *   variables: {
 *   },
 * });
 */
export function useThreadsQuery(baseOptions?: Apollo.QueryHookOptions<ThreadsQuery, ThreadsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ThreadsQuery, ThreadsQueryVariables>(ThreadsDocument, options);
      }
export function useThreadsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ThreadsQuery, ThreadsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ThreadsQuery, ThreadsQueryVariables>(ThreadsDocument, options);
        }
export type ThreadsQueryHookResult = ReturnType<typeof useThreadsQuery>;
export type ThreadsLazyQueryHookResult = ReturnType<typeof useThreadsLazyQuery>;
export type ThreadsQueryResult = Apollo.QueryResult<ThreadsQuery, ThreadsQueryVariables>;
export const ThreadDocument = gql`
    query Thread($threadId: Int!) {
  thread(threadId: $threadId) {
    id
    responses {
      ...CommonResponse
    }
  }
}
    ${CommonResponseFragmentDoc}`;

/**
 * __useThreadQuery__
 *
 * To run a query within a React component, call `useThreadQuery` and pass it any options that fit your needs.
 * When your component renders, `useThreadQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useThreadQuery({
 *   variables: {
 *      threadId: // value for 'threadId'
 *   },
 * });
 */
export function useThreadQuery(baseOptions: Apollo.QueryHookOptions<ThreadQuery, ThreadQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ThreadQuery, ThreadQueryVariables>(ThreadDocument, options);
      }
export function useThreadLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ThreadQuery, ThreadQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ThreadQuery, ThreadQueryVariables>(ThreadDocument, options);
        }
export type ThreadQueryHookResult = ReturnType<typeof useThreadQuery>;
export type ThreadLazyQueryHookResult = ReturnType<typeof useThreadLazyQuery>;
export type ThreadQueryResult = Apollo.QueryResult<ThreadQuery, ThreadQueryVariables>;
export const ThreadResponseDocument = gql`
    query ThreadResponse($responseId: Int!) {
  threadResponse(responseId: $responseId) {
    ...CommonResponse
  }
}
    ${CommonResponseFragmentDoc}`;

/**
 * __useThreadResponseQuery__
 *
 * To run a query within a React component, call `useThreadResponseQuery` and pass it any options that fit your needs.
 * When your component renders, `useThreadResponseQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useThreadResponseQuery({
 *   variables: {
 *      responseId: // value for 'responseId'
 *   },
 * });
 */
export function useThreadResponseQuery(baseOptions: Apollo.QueryHookOptions<ThreadResponseQuery, ThreadResponseQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ThreadResponseQuery, ThreadResponseQueryVariables>(ThreadResponseDocument, options);
      }
export function useThreadResponseLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ThreadResponseQuery, ThreadResponseQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ThreadResponseQuery, ThreadResponseQueryVariables>(ThreadResponseDocument, options);
        }
export type ThreadResponseQueryHookResult = ReturnType<typeof useThreadResponseQuery>;
export type ThreadResponseLazyQueryHookResult = ReturnType<typeof useThreadResponseLazyQuery>;
export type ThreadResponseQueryResult = Apollo.QueryResult<ThreadResponseQuery, ThreadResponseQueryVariables>;
export const CreateAskingTaskDocument = gql`
    mutation CreateAskingTask($data: AskingTaskInput!) {
  createAskingTask(data: $data) {
    id
  }
}
    `;
export type CreateAskingTaskMutationFn = Apollo.MutationFunction<CreateAskingTaskMutation, CreateAskingTaskMutationVariables>;

/**
 * __useCreateAskingTaskMutation__
 *
 * To run a mutation, you first call `useCreateAskingTaskMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateAskingTaskMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createAskingTaskMutation, { data, loading, error }] = useCreateAskingTaskMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useCreateAskingTaskMutation(baseOptions?: Apollo.MutationHookOptions<CreateAskingTaskMutation, CreateAskingTaskMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateAskingTaskMutation, CreateAskingTaskMutationVariables>(CreateAskingTaskDocument, options);
      }
export type CreateAskingTaskMutationHookResult = ReturnType<typeof useCreateAskingTaskMutation>;
export type CreateAskingTaskMutationResult = Apollo.MutationResult<CreateAskingTaskMutation>;
export type CreateAskingTaskMutationOptions = Apollo.BaseMutationOptions<CreateAskingTaskMutation, CreateAskingTaskMutationVariables>;
export const CancelAskingTaskDocument = gql`
    mutation CancelAskingTask($taskId: String!) {
  cancelAskingTask(taskId: $taskId)
}
    `;
export type CancelAskingTaskMutationFn = Apollo.MutationFunction<CancelAskingTaskMutation, CancelAskingTaskMutationVariables>;

/**
 * __useCancelAskingTaskMutation__
 *
 * To run a mutation, you first call `useCancelAskingTaskMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCancelAskingTaskMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [cancelAskingTaskMutation, { data, loading, error }] = useCancelAskingTaskMutation({
 *   variables: {
 *      taskId: // value for 'taskId'
 *   },
 * });
 */
export function useCancelAskingTaskMutation(baseOptions?: Apollo.MutationHookOptions<CancelAskingTaskMutation, CancelAskingTaskMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CancelAskingTaskMutation, CancelAskingTaskMutationVariables>(CancelAskingTaskDocument, options);
      }
export type CancelAskingTaskMutationHookResult = ReturnType<typeof useCancelAskingTaskMutation>;
export type CancelAskingTaskMutationResult = Apollo.MutationResult<CancelAskingTaskMutation>;
export type CancelAskingTaskMutationOptions = Apollo.BaseMutationOptions<CancelAskingTaskMutation, CancelAskingTaskMutationVariables>;
export const RerunAskingTaskDocument = gql`
    mutation RerunAskingTask($responseId: Int!) {
  rerunAskingTask(responseId: $responseId) {
    id
  }
}
    `;
export type RerunAskingTaskMutationFn = Apollo.MutationFunction<RerunAskingTaskMutation, RerunAskingTaskMutationVariables>;

/**
 * __useRerunAskingTaskMutation__
 *
 * To run a mutation, you first call `useRerunAskingTaskMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRerunAskingTaskMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [rerunAskingTaskMutation, { data, loading, error }] = useRerunAskingTaskMutation({
 *   variables: {
 *      responseId: // value for 'responseId'
 *   },
 * });
 */
export function useRerunAskingTaskMutation(baseOptions?: Apollo.MutationHookOptions<RerunAskingTaskMutation, RerunAskingTaskMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RerunAskingTaskMutation, RerunAskingTaskMutationVariables>(RerunAskingTaskDocument, options);
      }
export type RerunAskingTaskMutationHookResult = ReturnType<typeof useRerunAskingTaskMutation>;
export type RerunAskingTaskMutationResult = Apollo.MutationResult<RerunAskingTaskMutation>;
export type RerunAskingTaskMutationOptions = Apollo.BaseMutationOptions<RerunAskingTaskMutation, RerunAskingTaskMutationVariables>;
export const CreateThreadDocument = gql`
    mutation CreateThread($data: CreateThreadInput!) {
  createThread(data: $data) {
    id
  }
}
    `;
export type CreateThreadMutationFn = Apollo.MutationFunction<CreateThreadMutation, CreateThreadMutationVariables>;

/**
 * __useCreateThreadMutation__
 *
 * To run a mutation, you first call `useCreateThreadMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateThreadMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createThreadMutation, { data, loading, error }] = useCreateThreadMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useCreateThreadMutation(baseOptions?: Apollo.MutationHookOptions<CreateThreadMutation, CreateThreadMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateThreadMutation, CreateThreadMutationVariables>(CreateThreadDocument, options);
      }
export type CreateThreadMutationHookResult = ReturnType<typeof useCreateThreadMutation>;
export type CreateThreadMutationResult = Apollo.MutationResult<CreateThreadMutation>;
export type CreateThreadMutationOptions = Apollo.BaseMutationOptions<CreateThreadMutation, CreateThreadMutationVariables>;
export const CreateThreadResponseDocument = gql`
    mutation CreateThreadResponse($threadId: Int!, $data: CreateThreadResponseInput!) {
  createThreadResponse(threadId: $threadId, data: $data) {
    ...CommonResponse
  }
}
    ${CommonResponseFragmentDoc}`;
export type CreateThreadResponseMutationFn = Apollo.MutationFunction<CreateThreadResponseMutation, CreateThreadResponseMutationVariables>;

/**
 * __useCreateThreadResponseMutation__
 *
 * To run a mutation, you first call `useCreateThreadResponseMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateThreadResponseMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createThreadResponseMutation, { data, loading, error }] = useCreateThreadResponseMutation({
 *   variables: {
 *      threadId: // value for 'threadId'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useCreateThreadResponseMutation(baseOptions?: Apollo.MutationHookOptions<CreateThreadResponseMutation, CreateThreadResponseMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateThreadResponseMutation, CreateThreadResponseMutationVariables>(CreateThreadResponseDocument, options);
      }
export type CreateThreadResponseMutationHookResult = ReturnType<typeof useCreateThreadResponseMutation>;
export type CreateThreadResponseMutationResult = Apollo.MutationResult<CreateThreadResponseMutation>;
export type CreateThreadResponseMutationOptions = Apollo.BaseMutationOptions<CreateThreadResponseMutation, CreateThreadResponseMutationVariables>;
export const UpdateThreadDocument = gql`
    mutation UpdateThread($where: ThreadUniqueWhereInput!, $data: UpdateThreadInput!) {
  updateThread(where: $where, data: $data) {
    id
    summary
  }
}
    `;
export type UpdateThreadMutationFn = Apollo.MutationFunction<UpdateThreadMutation, UpdateThreadMutationVariables>;

/**
 * __useUpdateThreadMutation__
 *
 * To run a mutation, you first call `useUpdateThreadMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateThreadMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateThreadMutation, { data, loading, error }] = useUpdateThreadMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateThreadMutation(baseOptions?: Apollo.MutationHookOptions<UpdateThreadMutation, UpdateThreadMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateThreadMutation, UpdateThreadMutationVariables>(UpdateThreadDocument, options);
      }
export type UpdateThreadMutationHookResult = ReturnType<typeof useUpdateThreadMutation>;
export type UpdateThreadMutationResult = Apollo.MutationResult<UpdateThreadMutation>;
export type UpdateThreadMutationOptions = Apollo.BaseMutationOptions<UpdateThreadMutation, UpdateThreadMutationVariables>;
export const UpdateThreadResponseDocument = gql`
    mutation UpdateThreadResponse($where: ThreadResponseUniqueWhereInput!, $data: UpdateThreadResponseInput!) {
  updateThreadResponse(where: $where, data: $data) {
    ...CommonResponse
  }
}
    ${CommonResponseFragmentDoc}`;
export type UpdateThreadResponseMutationFn = Apollo.MutationFunction<UpdateThreadResponseMutation, UpdateThreadResponseMutationVariables>;

/**
 * __useUpdateThreadResponseMutation__
 *
 * To run a mutation, you first call `useUpdateThreadResponseMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateThreadResponseMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateThreadResponseMutation, { data, loading, error }] = useUpdateThreadResponseMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateThreadResponseMutation(baseOptions?: Apollo.MutationHookOptions<UpdateThreadResponseMutation, UpdateThreadResponseMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateThreadResponseMutation, UpdateThreadResponseMutationVariables>(UpdateThreadResponseDocument, options);
      }
export type UpdateThreadResponseMutationHookResult = ReturnType<typeof useUpdateThreadResponseMutation>;
export type UpdateThreadResponseMutationResult = Apollo.MutationResult<UpdateThreadResponseMutation>;
export type UpdateThreadResponseMutationOptions = Apollo.BaseMutationOptions<UpdateThreadResponseMutation, UpdateThreadResponseMutationVariables>;
export const AdjustThreadResponseDocument = gql`
    mutation AdjustThreadResponse($responseId: Int!, $data: AdjustThreadResponseInput!) {
  adjustThreadResponse(responseId: $responseId, data: $data) {
    ...CommonResponse
  }
}
    ${CommonResponseFragmentDoc}`;
export type AdjustThreadResponseMutationFn = Apollo.MutationFunction<AdjustThreadResponseMutation, AdjustThreadResponseMutationVariables>;

/**
 * __useAdjustThreadResponseMutation__
 *
 * To run a mutation, you first call `useAdjustThreadResponseMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAdjustThreadResponseMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [adjustThreadResponseMutation, { data, loading, error }] = useAdjustThreadResponseMutation({
 *   variables: {
 *      responseId: // value for 'responseId'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useAdjustThreadResponseMutation(baseOptions?: Apollo.MutationHookOptions<AdjustThreadResponseMutation, AdjustThreadResponseMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AdjustThreadResponseMutation, AdjustThreadResponseMutationVariables>(AdjustThreadResponseDocument, options);
      }
export type AdjustThreadResponseMutationHookResult = ReturnType<typeof useAdjustThreadResponseMutation>;
export type AdjustThreadResponseMutationResult = Apollo.MutationResult<AdjustThreadResponseMutation>;
export type AdjustThreadResponseMutationOptions = Apollo.BaseMutationOptions<AdjustThreadResponseMutation, AdjustThreadResponseMutationVariables>;
export const DeleteThreadDocument = gql`
    mutation DeleteThread($where: ThreadUniqueWhereInput!) {
  deleteThread(where: $where)
}
    `;
export type DeleteThreadMutationFn = Apollo.MutationFunction<DeleteThreadMutation, DeleteThreadMutationVariables>;

/**
 * __useDeleteThreadMutation__
 *
 * To run a mutation, you first call `useDeleteThreadMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteThreadMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteThreadMutation, { data, loading, error }] = useDeleteThreadMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteThreadMutation(baseOptions?: Apollo.MutationHookOptions<DeleteThreadMutation, DeleteThreadMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteThreadMutation, DeleteThreadMutationVariables>(DeleteThreadDocument, options);
      }
export type DeleteThreadMutationHookResult = ReturnType<typeof useDeleteThreadMutation>;
export type DeleteThreadMutationResult = Apollo.MutationResult<DeleteThreadMutation>;
export type DeleteThreadMutationOptions = Apollo.BaseMutationOptions<DeleteThreadMutation, DeleteThreadMutationVariables>;
export const PreviewDataDocument = gql`
    mutation PreviewData($where: PreviewDataInput!) {
  previewData(where: $where)
}
    `;
export type PreviewDataMutationFn = Apollo.MutationFunction<PreviewDataMutation, PreviewDataMutationVariables>;

/**
 * __usePreviewDataMutation__
 *
 * To run a mutation, you first call `usePreviewDataMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `usePreviewDataMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [previewDataMutation, { data, loading, error }] = usePreviewDataMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function usePreviewDataMutation(baseOptions?: Apollo.MutationHookOptions<PreviewDataMutation, PreviewDataMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<PreviewDataMutation, PreviewDataMutationVariables>(PreviewDataDocument, options);
      }
export type PreviewDataMutationHookResult = ReturnType<typeof usePreviewDataMutation>;
export type PreviewDataMutationResult = Apollo.MutationResult<PreviewDataMutation>;
export type PreviewDataMutationOptions = Apollo.BaseMutationOptions<PreviewDataMutation, PreviewDataMutationVariables>;
export const PreviewBreakdownDataDocument = gql`
    mutation PreviewBreakdownData($where: PreviewDataInput!) {
  previewBreakdownData(where: $where)
}
    `;
export type PreviewBreakdownDataMutationFn = Apollo.MutationFunction<PreviewBreakdownDataMutation, PreviewBreakdownDataMutationVariables>;

/**
 * __usePreviewBreakdownDataMutation__
 *
 * To run a mutation, you first call `usePreviewBreakdownDataMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `usePreviewBreakdownDataMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [previewBreakdownDataMutation, { data, loading, error }] = usePreviewBreakdownDataMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function usePreviewBreakdownDataMutation(baseOptions?: Apollo.MutationHookOptions<PreviewBreakdownDataMutation, PreviewBreakdownDataMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<PreviewBreakdownDataMutation, PreviewBreakdownDataMutationVariables>(PreviewBreakdownDataDocument, options);
      }
export type PreviewBreakdownDataMutationHookResult = ReturnType<typeof usePreviewBreakdownDataMutation>;
export type PreviewBreakdownDataMutationResult = Apollo.MutationResult<PreviewBreakdownDataMutation>;
export type PreviewBreakdownDataMutationOptions = Apollo.BaseMutationOptions<PreviewBreakdownDataMutation, PreviewBreakdownDataMutationVariables>;
export const GetNativeSqlDocument = gql`
    query GetNativeSQL($responseId: Int!) {
  nativeSql(responseId: $responseId)
}
    `;

/**
 * __useGetNativeSqlQuery__
 *
 * To run a query within a React component, call `useGetNativeSqlQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetNativeSqlQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetNativeSqlQuery({
 *   variables: {
 *      responseId: // value for 'responseId'
 *   },
 * });
 */
export function useGetNativeSqlQuery(baseOptions: Apollo.QueryHookOptions<GetNativeSqlQuery, GetNativeSqlQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetNativeSqlQuery, GetNativeSqlQueryVariables>(GetNativeSqlDocument, options);
      }
export function useGetNativeSqlLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetNativeSqlQuery, GetNativeSqlQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetNativeSqlQuery, GetNativeSqlQueryVariables>(GetNativeSqlDocument, options);
        }
export type GetNativeSqlQueryHookResult = ReturnType<typeof useGetNativeSqlQuery>;
export type GetNativeSqlLazyQueryHookResult = ReturnType<typeof useGetNativeSqlLazyQuery>;
export type GetNativeSqlQueryResult = Apollo.QueryResult<GetNativeSqlQuery, GetNativeSqlQueryVariables>;
export const CreateInstantRecommendedQuestionsDocument = gql`
    mutation CreateInstantRecommendedQuestions($data: InstantRecommendedQuestionsInput!) {
  createInstantRecommendedQuestions(data: $data) {
    id
  }
}
    `;
export type CreateInstantRecommendedQuestionsMutationFn = Apollo.MutationFunction<CreateInstantRecommendedQuestionsMutation, CreateInstantRecommendedQuestionsMutationVariables>;

/**
 * __useCreateInstantRecommendedQuestionsMutation__
 *
 * To run a mutation, you first call `useCreateInstantRecommendedQuestionsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateInstantRecommendedQuestionsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createInstantRecommendedQuestionsMutation, { data, loading, error }] = useCreateInstantRecommendedQuestionsMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useCreateInstantRecommendedQuestionsMutation(baseOptions?: Apollo.MutationHookOptions<CreateInstantRecommendedQuestionsMutation, CreateInstantRecommendedQuestionsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateInstantRecommendedQuestionsMutation, CreateInstantRecommendedQuestionsMutationVariables>(CreateInstantRecommendedQuestionsDocument, options);
      }
export type CreateInstantRecommendedQuestionsMutationHookResult = ReturnType<typeof useCreateInstantRecommendedQuestionsMutation>;
export type CreateInstantRecommendedQuestionsMutationResult = Apollo.MutationResult<CreateInstantRecommendedQuestionsMutation>;
export type CreateInstantRecommendedQuestionsMutationOptions = Apollo.BaseMutationOptions<CreateInstantRecommendedQuestionsMutation, CreateInstantRecommendedQuestionsMutationVariables>;
export const InstantRecommendedQuestionsDocument = gql`
    query InstantRecommendedQuestions($taskId: String!) {
  instantRecommendedQuestions(taskId: $taskId) {
    ...CommonRecommendedQuestionsTask
  }
}
    ${CommonRecommendedQuestionsTaskFragmentDoc}`;

/**
 * __useInstantRecommendedQuestionsQuery__
 *
 * To run a query within a React component, call `useInstantRecommendedQuestionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useInstantRecommendedQuestionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useInstantRecommendedQuestionsQuery({
 *   variables: {
 *      taskId: // value for 'taskId'
 *   },
 * });
 */
export function useInstantRecommendedQuestionsQuery(baseOptions: Apollo.QueryHookOptions<InstantRecommendedQuestionsQuery, InstantRecommendedQuestionsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<InstantRecommendedQuestionsQuery, InstantRecommendedQuestionsQueryVariables>(InstantRecommendedQuestionsDocument, options);
      }
export function useInstantRecommendedQuestionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<InstantRecommendedQuestionsQuery, InstantRecommendedQuestionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<InstantRecommendedQuestionsQuery, InstantRecommendedQuestionsQueryVariables>(InstantRecommendedQuestionsDocument, options);
        }
export type InstantRecommendedQuestionsQueryHookResult = ReturnType<typeof useInstantRecommendedQuestionsQuery>;
export type InstantRecommendedQuestionsLazyQueryHookResult = ReturnType<typeof useInstantRecommendedQuestionsLazyQuery>;
export type InstantRecommendedQuestionsQueryResult = Apollo.QueryResult<InstantRecommendedQuestionsQuery, InstantRecommendedQuestionsQueryVariables>;
export const GetThreadRecommendationQuestionsDocument = gql`
    query GetThreadRecommendationQuestions($threadId: Int!) {
  getThreadRecommendationQuestions(threadId: $threadId) {
    ...CommonRecommendedQuestionsTask
  }
}
    ${CommonRecommendedQuestionsTaskFragmentDoc}`;

/**
 * __useGetThreadRecommendationQuestionsQuery__
 *
 * To run a query within a React component, call `useGetThreadRecommendationQuestionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetThreadRecommendationQuestionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetThreadRecommendationQuestionsQuery({
 *   variables: {
 *      threadId: // value for 'threadId'
 *   },
 * });
 */
export function useGetThreadRecommendationQuestionsQuery(baseOptions: Apollo.QueryHookOptions<GetThreadRecommendationQuestionsQuery, GetThreadRecommendationQuestionsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetThreadRecommendationQuestionsQuery, GetThreadRecommendationQuestionsQueryVariables>(GetThreadRecommendationQuestionsDocument, options);
      }
export function useGetThreadRecommendationQuestionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetThreadRecommendationQuestionsQuery, GetThreadRecommendationQuestionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetThreadRecommendationQuestionsQuery, GetThreadRecommendationQuestionsQueryVariables>(GetThreadRecommendationQuestionsDocument, options);
        }
export type GetThreadRecommendationQuestionsQueryHookResult = ReturnType<typeof useGetThreadRecommendationQuestionsQuery>;
export type GetThreadRecommendationQuestionsLazyQueryHookResult = ReturnType<typeof useGetThreadRecommendationQuestionsLazyQuery>;
export type GetThreadRecommendationQuestionsQueryResult = Apollo.QueryResult<GetThreadRecommendationQuestionsQuery, GetThreadRecommendationQuestionsQueryVariables>;
export const GetProjectRecommendationQuestionsDocument = gql`
    query GetProjectRecommendationQuestions {
  getProjectRecommendationQuestions {
    ...CommonRecommendedQuestionsTask
  }
}
    ${CommonRecommendedQuestionsTaskFragmentDoc}`;

/**
 * __useGetProjectRecommendationQuestionsQuery__
 *
 * To run a query within a React component, call `useGetProjectRecommendationQuestionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetProjectRecommendationQuestionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetProjectRecommendationQuestionsQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetProjectRecommendationQuestionsQuery(baseOptions?: Apollo.QueryHookOptions<GetProjectRecommendationQuestionsQuery, GetProjectRecommendationQuestionsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetProjectRecommendationQuestionsQuery, GetProjectRecommendationQuestionsQueryVariables>(GetProjectRecommendationQuestionsDocument, options);
      }
export function useGetProjectRecommendationQuestionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetProjectRecommendationQuestionsQuery, GetProjectRecommendationQuestionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetProjectRecommendationQuestionsQuery, GetProjectRecommendationQuestionsQueryVariables>(GetProjectRecommendationQuestionsDocument, options);
        }
export type GetProjectRecommendationQuestionsQueryHookResult = ReturnType<typeof useGetProjectRecommendationQuestionsQuery>;
export type GetProjectRecommendationQuestionsLazyQueryHookResult = ReturnType<typeof useGetProjectRecommendationQuestionsLazyQuery>;
export type GetProjectRecommendationQuestionsQueryResult = Apollo.QueryResult<GetProjectRecommendationQuestionsQuery, GetProjectRecommendationQuestionsQueryVariables>;
export const GenerateProjectRecommendationQuestionsDocument = gql`
    mutation GenerateProjectRecommendationQuestions {
  generateProjectRecommendationQuestions
}
    `;
export type GenerateProjectRecommendationQuestionsMutationFn = Apollo.MutationFunction<GenerateProjectRecommendationQuestionsMutation, GenerateProjectRecommendationQuestionsMutationVariables>;

/**
 * __useGenerateProjectRecommendationQuestionsMutation__
 *
 * To run a mutation, you first call `useGenerateProjectRecommendationQuestionsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useGenerateProjectRecommendationQuestionsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [generateProjectRecommendationQuestionsMutation, { data, loading, error }] = useGenerateProjectRecommendationQuestionsMutation({
 *   variables: {
 *   },
 * });
 */
export function useGenerateProjectRecommendationQuestionsMutation(baseOptions?: Apollo.MutationHookOptions<GenerateProjectRecommendationQuestionsMutation, GenerateProjectRecommendationQuestionsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<GenerateProjectRecommendationQuestionsMutation, GenerateProjectRecommendationQuestionsMutationVariables>(GenerateProjectRecommendationQuestionsDocument, options);
      }
export type GenerateProjectRecommendationQuestionsMutationHookResult = ReturnType<typeof useGenerateProjectRecommendationQuestionsMutation>;
export type GenerateProjectRecommendationQuestionsMutationResult = Apollo.MutationResult<GenerateProjectRecommendationQuestionsMutation>;
export type GenerateProjectRecommendationQuestionsMutationOptions = Apollo.BaseMutationOptions<GenerateProjectRecommendationQuestionsMutation, GenerateProjectRecommendationQuestionsMutationVariables>;
export const GenerateThreadRecommendationQuestionsDocument = gql`
    mutation GenerateThreadRecommendationQuestions($threadId: Int!) {
  generateThreadRecommendationQuestions(threadId: $threadId)
}
    `;
export type GenerateThreadRecommendationQuestionsMutationFn = Apollo.MutationFunction<GenerateThreadRecommendationQuestionsMutation, GenerateThreadRecommendationQuestionsMutationVariables>;

/**
 * __useGenerateThreadRecommendationQuestionsMutation__
 *
 * To run a mutation, you first call `useGenerateThreadRecommendationQuestionsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useGenerateThreadRecommendationQuestionsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [generateThreadRecommendationQuestionsMutation, { data, loading, error }] = useGenerateThreadRecommendationQuestionsMutation({
 *   variables: {
 *      threadId: // value for 'threadId'
 *   },
 * });
 */
export function useGenerateThreadRecommendationQuestionsMutation(baseOptions?: Apollo.MutationHookOptions<GenerateThreadRecommendationQuestionsMutation, GenerateThreadRecommendationQuestionsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<GenerateThreadRecommendationQuestionsMutation, GenerateThreadRecommendationQuestionsMutationVariables>(GenerateThreadRecommendationQuestionsDocument, options);
      }
export type GenerateThreadRecommendationQuestionsMutationHookResult = ReturnType<typeof useGenerateThreadRecommendationQuestionsMutation>;
export type GenerateThreadRecommendationQuestionsMutationResult = Apollo.MutationResult<GenerateThreadRecommendationQuestionsMutation>;
export type GenerateThreadRecommendationQuestionsMutationOptions = Apollo.BaseMutationOptions<GenerateThreadRecommendationQuestionsMutation, GenerateThreadRecommendationQuestionsMutationVariables>;
export const GenerateThreadResponseAnswerDocument = gql`
    mutation GenerateThreadResponseAnswer($responseId: Int!) {
  generateThreadResponseAnswer(responseId: $responseId) {
    ...CommonResponse
  }
}
    ${CommonResponseFragmentDoc}`;
export type GenerateThreadResponseAnswerMutationFn = Apollo.MutationFunction<GenerateThreadResponseAnswerMutation, GenerateThreadResponseAnswerMutationVariables>;

/**
 * __useGenerateThreadResponseAnswerMutation__
 *
 * To run a mutation, you first call `useGenerateThreadResponseAnswerMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useGenerateThreadResponseAnswerMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [generateThreadResponseAnswerMutation, { data, loading, error }] = useGenerateThreadResponseAnswerMutation({
 *   variables: {
 *      responseId: // value for 'responseId'
 *   },
 * });
 */
export function useGenerateThreadResponseAnswerMutation(baseOptions?: Apollo.MutationHookOptions<GenerateThreadResponseAnswerMutation, GenerateThreadResponseAnswerMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<GenerateThreadResponseAnswerMutation, GenerateThreadResponseAnswerMutationVariables>(GenerateThreadResponseAnswerDocument, options);
      }
export type GenerateThreadResponseAnswerMutationHookResult = ReturnType<typeof useGenerateThreadResponseAnswerMutation>;
export type GenerateThreadResponseAnswerMutationResult = Apollo.MutationResult<GenerateThreadResponseAnswerMutation>;
export type GenerateThreadResponseAnswerMutationOptions = Apollo.BaseMutationOptions<GenerateThreadResponseAnswerMutation, GenerateThreadResponseAnswerMutationVariables>;
export const GenerateThreadResponseChartDocument = gql`
    mutation GenerateThreadResponseChart($responseId: Int!) {
  generateThreadResponseChart(responseId: $responseId) {
    ...CommonResponse
  }
}
    ${CommonResponseFragmentDoc}`;
export type GenerateThreadResponseChartMutationFn = Apollo.MutationFunction<GenerateThreadResponseChartMutation, GenerateThreadResponseChartMutationVariables>;

/**
 * __useGenerateThreadResponseChartMutation__
 *
 * To run a mutation, you first call `useGenerateThreadResponseChartMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useGenerateThreadResponseChartMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [generateThreadResponseChartMutation, { data, loading, error }] = useGenerateThreadResponseChartMutation({
 *   variables: {
 *      responseId: // value for 'responseId'
 *   },
 * });
 */
export function useGenerateThreadResponseChartMutation(baseOptions?: Apollo.MutationHookOptions<GenerateThreadResponseChartMutation, GenerateThreadResponseChartMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<GenerateThreadResponseChartMutation, GenerateThreadResponseChartMutationVariables>(GenerateThreadResponseChartDocument, options);
      }
export type GenerateThreadResponseChartMutationHookResult = ReturnType<typeof useGenerateThreadResponseChartMutation>;
export type GenerateThreadResponseChartMutationResult = Apollo.MutationResult<GenerateThreadResponseChartMutation>;
export type GenerateThreadResponseChartMutationOptions = Apollo.BaseMutationOptions<GenerateThreadResponseChartMutation, GenerateThreadResponseChartMutationVariables>;
export const AdjustThreadResponseChartDocument = gql`
    mutation AdjustThreadResponseChart($responseId: Int!, $data: AdjustThreadResponseChartInput!) {
  adjustThreadResponseChart(responseId: $responseId, data: $data) {
    ...CommonResponse
  }
}
    ${CommonResponseFragmentDoc}`;
export type AdjustThreadResponseChartMutationFn = Apollo.MutationFunction<AdjustThreadResponseChartMutation, AdjustThreadResponseChartMutationVariables>;

/**
 * __useAdjustThreadResponseChartMutation__
 *
 * To run a mutation, you first call `useAdjustThreadResponseChartMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAdjustThreadResponseChartMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [adjustThreadResponseChartMutation, { data, loading, error }] = useAdjustThreadResponseChartMutation({
 *   variables: {
 *      responseId: // value for 'responseId'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useAdjustThreadResponseChartMutation(baseOptions?: Apollo.MutationHookOptions<AdjustThreadResponseChartMutation, AdjustThreadResponseChartMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AdjustThreadResponseChartMutation, AdjustThreadResponseChartMutationVariables>(AdjustThreadResponseChartDocument, options);
      }
export type AdjustThreadResponseChartMutationHookResult = ReturnType<typeof useAdjustThreadResponseChartMutation>;
export type AdjustThreadResponseChartMutationResult = Apollo.MutationResult<AdjustThreadResponseChartMutation>;
export type AdjustThreadResponseChartMutationOptions = Apollo.BaseMutationOptions<AdjustThreadResponseChartMutation, AdjustThreadResponseChartMutationVariables>;
export const AdjustmentTaskDocument = gql`
    query AdjustmentTask($taskId: String!) {
  adjustmentTask(taskId: $taskId) {
    queryId
    status
    error {
      code
      shortMessage
      message
      stacktrace
    }
    sql
    traceId
    invalidSql
  }
}
    `;

/**
 * __useAdjustmentTaskQuery__
 *
 * To run a query within a React component, call `useAdjustmentTaskQuery` and pass it any options that fit your needs.
 * When your component renders, `useAdjustmentTaskQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAdjustmentTaskQuery({
 *   variables: {
 *      taskId: // value for 'taskId'
 *   },
 * });
 */
export function useAdjustmentTaskQuery(baseOptions: Apollo.QueryHookOptions<AdjustmentTaskQuery, AdjustmentTaskQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AdjustmentTaskQuery, AdjustmentTaskQueryVariables>(AdjustmentTaskDocument, options);
      }
export function useAdjustmentTaskLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AdjustmentTaskQuery, AdjustmentTaskQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AdjustmentTaskQuery, AdjustmentTaskQueryVariables>(AdjustmentTaskDocument, options);
        }
export type AdjustmentTaskQueryHookResult = ReturnType<typeof useAdjustmentTaskQuery>;
export type AdjustmentTaskLazyQueryHookResult = ReturnType<typeof useAdjustmentTaskLazyQuery>;
export type AdjustmentTaskQueryResult = Apollo.QueryResult<AdjustmentTaskQuery, AdjustmentTaskQueryVariables>;
export const CancelAdjustmentTaskDocument = gql`
    mutation CancelAdjustmentTask($taskId: String!) {
  cancelAdjustmentTask(taskId: $taskId)
}
    `;
export type CancelAdjustmentTaskMutationFn = Apollo.MutationFunction<CancelAdjustmentTaskMutation, CancelAdjustmentTaskMutationVariables>;

/**
 * __useCancelAdjustmentTaskMutation__
 *
 * To run a mutation, you first call `useCancelAdjustmentTaskMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCancelAdjustmentTaskMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [cancelAdjustmentTaskMutation, { data, loading, error }] = useCancelAdjustmentTaskMutation({
 *   variables: {
 *      taskId: // value for 'taskId'
 *   },
 * });
 */
export function useCancelAdjustmentTaskMutation(baseOptions?: Apollo.MutationHookOptions<CancelAdjustmentTaskMutation, CancelAdjustmentTaskMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CancelAdjustmentTaskMutation, CancelAdjustmentTaskMutationVariables>(CancelAdjustmentTaskDocument, options);
      }
export type CancelAdjustmentTaskMutationHookResult = ReturnType<typeof useCancelAdjustmentTaskMutation>;
export type CancelAdjustmentTaskMutationResult = Apollo.MutationResult<CancelAdjustmentTaskMutation>;
export type CancelAdjustmentTaskMutationOptions = Apollo.BaseMutationOptions<CancelAdjustmentTaskMutation, CancelAdjustmentTaskMutationVariables>;
export const RerunAdjustmentTaskDocument = gql`
    mutation RerunAdjustmentTask($responseId: Int!) {
  rerunAdjustmentTask(responseId: $responseId)
}
    `;
export type RerunAdjustmentTaskMutationFn = Apollo.MutationFunction<RerunAdjustmentTaskMutation, RerunAdjustmentTaskMutationVariables>;

/**
 * __useRerunAdjustmentTaskMutation__
 *
 * To run a mutation, you first call `useRerunAdjustmentTaskMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRerunAdjustmentTaskMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [rerunAdjustmentTaskMutation, { data, loading, error }] = useRerunAdjustmentTaskMutation({
 *   variables: {
 *      responseId: // value for 'responseId'
 *   },
 * });
 */
export function useRerunAdjustmentTaskMutation(baseOptions?: Apollo.MutationHookOptions<RerunAdjustmentTaskMutation, RerunAdjustmentTaskMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RerunAdjustmentTaskMutation, RerunAdjustmentTaskMutationVariables>(RerunAdjustmentTaskDocument, options);
      }
export type RerunAdjustmentTaskMutationHookResult = ReturnType<typeof useRerunAdjustmentTaskMutation>;
export type RerunAdjustmentTaskMutationResult = Apollo.MutationResult<RerunAdjustmentTaskMutation>;
export type RerunAdjustmentTaskMutationOptions = Apollo.BaseMutationOptions<RerunAdjustmentTaskMutation, RerunAdjustmentTaskMutationVariables>;
</file>

<file path="src/apollo/client/graphql/home.ts">
import { gql } from '@apollo/client';

const COMMON_ERROR = gql`
  fragment CommonError on Error {
    code
    shortMessage
    message
    stacktrace
  }
`;

const COMMON_BREAKDOWN_DETAIL = gql`
  fragment CommonBreakdownDetail on ThreadResponseBreakdownDetail {
    queryId
    status
    description
    steps {
      summary
      sql
      cteName
    }
    error {
      ...CommonError
    }
  }

  ${COMMON_ERROR}
`;

const COMMON_ANSWER_DETAIL = gql`
  fragment CommonAnswerDetail on ThreadResponseAnswerDetail {
    queryId
    status
    content
    numRowsUsedInLLM
    error {
      ...CommonError
    }
  }

  ${COMMON_ERROR}
`;

const COMMON_CHART_DETAIL = gql`
  fragment CommonChartDetail on ThreadResponseChartDetail {
    queryId
    status
    description
    chartType
    chartSchema
    error {
      ...CommonError
    }
    adjustment
  }
`;

const COMMON_ASKING_TASK = gql`
  fragment CommonAskingTask on AskingTask {
    status
    type
    candidates {
      sql
      type
      view {
        id
        name
        statement
        displayName
      }
      sqlPair {
        id
        question
        sql
        projectId
      }
    }
    error {
      ...CommonError
    }
    rephrasedQuestion
    intentReasoning
    sqlGenerationReasoning
    retrievedTables
    invalidSql
    traceId
    queryId
  }
  ${COMMON_ERROR}
`;

const COMMON_RESPONSE = gql`
  fragment CommonResponse on ThreadResponse {
    id
    threadId
    question
    sql
    view {
      id
      name
      statement
      displayName
    }
    breakdownDetail {
      ...CommonBreakdownDetail
    }
    answerDetail {
      ...CommonAnswerDetail
    }
    chartDetail {
      ...CommonChartDetail
    }
    askingTask {
      ...CommonAskingTask
    }
    adjustment {
      type
      payload
    }
    adjustmentTask {
      queryId
      status
      error {
        ...CommonError
      }
      sql
      traceId
      invalidSql
    }
  }

  ${COMMON_BREAKDOWN_DETAIL}
  ${COMMON_ANSWER_DETAIL}
  ${COMMON_CHART_DETAIL}
  ${COMMON_ASKING_TASK}
  ${COMMON_ERROR}
`;

const COMMON_RECOMMENDED_QUESTIONS_TASK = gql`
  fragment CommonRecommendedQuestionsTask on RecommendedQuestionsTask {
    status
    questions {
      question
      category
      sql
    }
    error {
      ...CommonError
    }
  }

  ${COMMON_ERROR}
`;

export const SUGGESTED_QUESTIONS = gql`
  query SuggestedQuestions {
    suggestedQuestions {
      questions {
        label
        question
      }
    }
  }
`;

export const ASKING_TASK = gql`
  query AskingTask($taskId: String!) {
    askingTask(taskId: $taskId) {
      ...CommonAskingTask
    }
  }
  ${COMMON_ASKING_TASK}
`;

export const THREADS = gql`
  query Threads {
    threads {
      id
      summary
    }
  }
`;

export const THREAD = gql`
  query Thread($threadId: Int!) {
    thread(threadId: $threadId) {
      id
      responses {
        ...CommonResponse
      }
    }
  }
  ${COMMON_RESPONSE}
`;

export const THREAD_RESPONSE = gql`
  query ThreadResponse($responseId: Int!) {
    threadResponse(responseId: $responseId) {
      ...CommonResponse
    }
  }
  ${COMMON_RESPONSE}
`;

export const CREATE_ASKING_TASK = gql`
  mutation CreateAskingTask($data: AskingTaskInput!) {
    createAskingTask(data: $data) {
      id
    }
  }
`;

export const CANCEL_ASKING_TASK = gql`
  mutation CancelAskingTask($taskId: String!) {
    cancelAskingTask(taskId: $taskId)
  }
`;

export const RERUN_ASKING_TASK = gql`
  mutation RerunAskingTask($responseId: Int!) {
    rerunAskingTask(responseId: $responseId) {
      id
    }
  }
`;

export const CREATE_THREAD = gql`
  mutation CreateThread($data: CreateThreadInput!) {
    createThread(data: $data) {
      id
    }
  }
`;

export const CREATE_THREAD_RESPONSE = gql`
  mutation CreateThreadResponse(
    $threadId: Int!
    $data: CreateThreadResponseInput!
  ) {
    createThreadResponse(threadId: $threadId, data: $data) {
      ...CommonResponse
    }
  }
  ${COMMON_RESPONSE}
`;

export const UPDATE_THREAD = gql`
  mutation UpdateThread(
    $where: ThreadUniqueWhereInput!
    $data: UpdateThreadInput!
  ) {
    updateThread(where: $where, data: $data) {
      id
      summary
    }
  }
`;

export const UPDATE_THREAD_RESPONSE = gql`
  mutation UpdateThreadResponse(
    $where: ThreadResponseUniqueWhereInput!
    $data: UpdateThreadResponseInput!
  ) {
    updateThreadResponse(where: $where, data: $data) {
      ...CommonResponse
    }
  }
  ${COMMON_RESPONSE}
`;

// For adjust reasoning steps or SQL
export const ADJUST_THREAD_RESPONSE = gql`
  mutation AdjustThreadResponse(
    $responseId: Int!
    $data: AdjustThreadResponseInput!
  ) {
    adjustThreadResponse(responseId: $responseId, data: $data) {
      ...CommonResponse
    }
  }
  ${COMMON_RESPONSE}
`;

export const DELETE_THREAD = gql`
  mutation DeleteThread($where: ThreadUniqueWhereInput!) {
    deleteThread(where: $where)
  }
`;

// For text-based answer & chart-based answer
export const PREVIEW_DATA = gql`
  mutation PreviewData($where: PreviewDataInput!) {
    previewData(where: $where)
  }
`;

export const PREVIEW_BREAKDOWN_DATA = gql`
  mutation PreviewBreakdownData($where: PreviewDataInput!) {
    previewBreakdownData(where: $where)
  }
`;

export const GET_NATIVE_SQL = gql`
  query GetNativeSQL($responseId: Int!) {
    nativeSql(responseId: $responseId)
  }
`;

export const CREATE_INSTANT_RECOMMENDED_QUESTIONS = gql`
  mutation CreateInstantRecommendedQuestions(
    $data: InstantRecommendedQuestionsInput!
  ) {
    createInstantRecommendedQuestions(data: $data) {
      id
    }
  }
`;

export const INSTANT_RECOMMENDED_QUESTIONS = gql`
  query InstantRecommendedQuestions($taskId: String!) {
    instantRecommendedQuestions(taskId: $taskId) {
      ...CommonRecommendedQuestionsTask
    }
  }
  ${COMMON_RECOMMENDED_QUESTIONS_TASK}
`;

export const GET_THREAD_RECOMMENDATION_QUESTIONS = gql`
  query GetThreadRecommendationQuestions($threadId: Int!) {
    getThreadRecommendationQuestions(threadId: $threadId) {
      ...CommonRecommendedQuestionsTask
    }
  }

  ${COMMON_RECOMMENDED_QUESTIONS_TASK}
`;

export const GET_PROJECT_RECOMMENDATION_QUESTIONS = gql`
  query GetProjectRecommendationQuestions {
    getProjectRecommendationQuestions {
      ...CommonRecommendedQuestionsTask
    }
  }

  ${COMMON_RECOMMENDED_QUESTIONS_TASK}
`;

export const GENERATE_PROJECT_RECOMMENDATION_QUESTIONS = gql`
  mutation GenerateProjectRecommendationQuestions {
    generateProjectRecommendationQuestions
  }
`;

export const GENERATE_THREAD_RECOMMENDATION_QUESTIONS = gql`
  mutation GenerateThreadRecommendationQuestions($threadId: Int!) {
    generateThreadRecommendationQuestions(threadId: $threadId)
  }
`;

export const GENERATE_THREAD_RESPONSE_ANSWER = gql`
  mutation GenerateThreadResponseAnswer($responseId: Int!) {
    generateThreadResponseAnswer(responseId: $responseId) {
      ...CommonResponse
    }
  }

  ${COMMON_RESPONSE}
`;

export const GENERATE_THREAD_RESPONSE_CHART = gql`
  mutation GenerateThreadResponseChart($responseId: Int!) {
    generateThreadResponseChart(responseId: $responseId) {
      ...CommonResponse
    }
  }
  ${COMMON_RESPONSE}
`;

export const ADJUST_THREAD_RESPONSE_CHART = gql`
  mutation AdjustThreadResponseChart(
    $responseId: Int!
    $data: AdjustThreadResponseChartInput!
  ) {
    adjustThreadResponseChart(responseId: $responseId, data: $data) {
      ...CommonResponse
    }
  }
  ${COMMON_RESPONSE}
`;

export const ADJUSTMENT_TASK = gql`
  query AdjustmentTask($taskId: String!) {
    adjustmentTask(taskId: $taskId) {
      queryId
      status
      error {
        code
        shortMessage
        message
        stacktrace
      }
      sql
      traceId
      invalidSql
    }
  }
`;

export const CANCEL_ADJUSTMENT_TASK = gql`
  mutation CancelAdjustmentTask($taskId: String!) {
    cancelAdjustmentTask(taskId: $taskId)
  }
`;

export const RERUN_ADJUSTMENT_TASK = gql`
  mutation RerunAdjustmentTask($responseId: Int!) {
    rerunAdjustmentTask(responseId: $responseId)
  }
`;
</file>

<file path="src/apollo/client/graphql/instructions.generated.ts">
import * as Types from './__types__';

import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
const defaultOptions = {} as const;
export type InstructionFragment = { __typename?: 'Instruction', id: number, projectId: number, instruction: string, questions: Array<string>, isDefault: boolean, createdAt: string, updatedAt: string };

export type InstructionsQueryVariables = Types.Exact<{ [key: string]: never; }>;


export type InstructionsQuery = { __typename?: 'Query', instructions: Array<{ __typename?: 'Instruction', id: number, projectId: number, instruction: string, questions: Array<string>, isDefault: boolean, createdAt: string, updatedAt: string } | null> };

export type CreateInstructionMutationVariables = Types.Exact<{
  data: Types.CreateInstructionInput;
}>;


export type CreateInstructionMutation = { __typename?: 'Mutation', createInstruction: { __typename?: 'Instruction', id: number, projectId: number, instruction: string, questions: Array<string>, isDefault: boolean, createdAt: string, updatedAt: string } };

export type UpdateInstructionMutationVariables = Types.Exact<{
  where: Types.InstructionWhereInput;
  data: Types.UpdateInstructionInput;
}>;


export type UpdateInstructionMutation = { __typename?: 'Mutation', updateInstruction: { __typename?: 'Instruction', id: number, projectId: number, instruction: string, questions: Array<string>, isDefault: boolean, createdAt: string, updatedAt: string } };

export type DeleteInstructionMutationVariables = Types.Exact<{
  where: Types.InstructionWhereInput;
}>;


export type DeleteInstructionMutation = { __typename?: 'Mutation', deleteInstruction: boolean };

export const InstructionFragmentDoc = gql`
    fragment Instruction on Instruction {
  id
  projectId
  instruction
  questions
  isDefault
  createdAt
  updatedAt
}
    `;
export const InstructionsDocument = gql`
    query Instructions {
  instructions {
    ...Instruction
  }
}
    ${InstructionFragmentDoc}`;

/**
 * __useInstructionsQuery__
 *
 * To run a query within a React component, call `useInstructionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useInstructionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useInstructionsQuery({
 *   variables: {
 *   },
 * });
 */
export function useInstructionsQuery(baseOptions?: Apollo.QueryHookOptions<InstructionsQuery, InstructionsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<InstructionsQuery, InstructionsQueryVariables>(InstructionsDocument, options);
      }
export function useInstructionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<InstructionsQuery, InstructionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<InstructionsQuery, InstructionsQueryVariables>(InstructionsDocument, options);
        }
export type InstructionsQueryHookResult = ReturnType<typeof useInstructionsQuery>;
export type InstructionsLazyQueryHookResult = ReturnType<typeof useInstructionsLazyQuery>;
export type InstructionsQueryResult = Apollo.QueryResult<InstructionsQuery, InstructionsQueryVariables>;
export const CreateInstructionDocument = gql`
    mutation CreateInstruction($data: CreateInstructionInput!) {
  createInstruction(data: $data) {
    ...Instruction
  }
}
    ${InstructionFragmentDoc}`;
export type CreateInstructionMutationFn = Apollo.MutationFunction<CreateInstructionMutation, CreateInstructionMutationVariables>;

/**
 * __useCreateInstructionMutation__
 *
 * To run a mutation, you first call `useCreateInstructionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateInstructionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createInstructionMutation, { data, loading, error }] = useCreateInstructionMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useCreateInstructionMutation(baseOptions?: Apollo.MutationHookOptions<CreateInstructionMutation, CreateInstructionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateInstructionMutation, CreateInstructionMutationVariables>(CreateInstructionDocument, options);
      }
export type CreateInstructionMutationHookResult = ReturnType<typeof useCreateInstructionMutation>;
export type CreateInstructionMutationResult = Apollo.MutationResult<CreateInstructionMutation>;
export type CreateInstructionMutationOptions = Apollo.BaseMutationOptions<CreateInstructionMutation, CreateInstructionMutationVariables>;
export const UpdateInstructionDocument = gql`
    mutation UpdateInstruction($where: InstructionWhereInput!, $data: UpdateInstructionInput!) {
  updateInstruction(where: $where, data: $data) {
    ...Instruction
  }
}
    ${InstructionFragmentDoc}`;
export type UpdateInstructionMutationFn = Apollo.MutationFunction<UpdateInstructionMutation, UpdateInstructionMutationVariables>;

/**
 * __useUpdateInstructionMutation__
 *
 * To run a mutation, you first call `useUpdateInstructionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateInstructionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateInstructionMutation, { data, loading, error }] = useUpdateInstructionMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateInstructionMutation(baseOptions?: Apollo.MutationHookOptions<UpdateInstructionMutation, UpdateInstructionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateInstructionMutation, UpdateInstructionMutationVariables>(UpdateInstructionDocument, options);
      }
export type UpdateInstructionMutationHookResult = ReturnType<typeof useUpdateInstructionMutation>;
export type UpdateInstructionMutationResult = Apollo.MutationResult<UpdateInstructionMutation>;
export type UpdateInstructionMutationOptions = Apollo.BaseMutationOptions<UpdateInstructionMutation, UpdateInstructionMutationVariables>;
export const DeleteInstructionDocument = gql`
    mutation DeleteInstruction($where: InstructionWhereInput!) {
  deleteInstruction(where: $where)
}
    `;
export type DeleteInstructionMutationFn = Apollo.MutationFunction<DeleteInstructionMutation, DeleteInstructionMutationVariables>;

/**
 * __useDeleteInstructionMutation__
 *
 * To run a mutation, you first call `useDeleteInstructionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteInstructionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteInstructionMutation, { data, loading, error }] = useDeleteInstructionMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteInstructionMutation(baseOptions?: Apollo.MutationHookOptions<DeleteInstructionMutation, DeleteInstructionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteInstructionMutation, DeleteInstructionMutationVariables>(DeleteInstructionDocument, options);
      }
export type DeleteInstructionMutationHookResult = ReturnType<typeof useDeleteInstructionMutation>;
export type DeleteInstructionMutationResult = Apollo.MutationResult<DeleteInstructionMutation>;
export type DeleteInstructionMutationOptions = Apollo.BaseMutationOptions<DeleteInstructionMutation, DeleteInstructionMutationVariables>;
</file>

<file path="src/apollo/client/graphql/instructions.ts">
import { gql } from '@apollo/client';

const INSTRUCTION = gql`
  fragment Instruction on Instruction {
    id
    projectId
    instruction
    questions
    isDefault
    createdAt
    updatedAt
  }
`;

export const LIST_INSTRUCTIONS = gql`
  query Instructions {
    instructions {
      ...Instruction
    }
  }

  ${INSTRUCTION}
`;

export const CREATE_INSTRUCTION = gql`
  mutation CreateInstruction($data: CreateInstructionInput!) {
    createInstruction(data: $data) {
      ...Instruction
    }
  }

  ${INSTRUCTION}
`;

export const UPDATE_INSTRUCTION = gql`
  mutation UpdateInstruction(
    $where: InstructionWhereInput!
    $data: UpdateInstructionInput!
  ) {
    updateInstruction(where: $where, data: $data) {
      ...Instruction
    }
  }

  ${INSTRUCTION}
`;

export const DELETE_INSTRUCTION = gql`
  mutation DeleteInstruction($where: InstructionWhereInput!) {
    deleteInstruction(where: $where)
  }
`;
</file>

<file path="src/apollo/client/graphql/learning.generated.ts">
import * as Types from './__types__';

import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
const defaultOptions = {} as const;
export type LearningRecordQueryVariables = Types.Exact<{ [key: string]: never; }>;


export type LearningRecordQuery = { __typename?: 'Query', learningRecord: { __typename?: 'LearningRecord', paths: Array<string> } };

export type SaveLearningRecordMutationVariables = Types.Exact<{
  data: Types.SaveLearningRecordInput;
}>;


export type SaveLearningRecordMutation = { __typename?: 'Mutation', saveLearningRecord: { __typename?: 'LearningRecord', paths: Array<string> } };


export const LearningRecordDocument = gql`
    query LearningRecord {
  learningRecord {
    paths
  }
}
    `;

/**
 * __useLearningRecordQuery__
 *
 * To run a query within a React component, call `useLearningRecordQuery` and pass it any options that fit your needs.
 * When your component renders, `useLearningRecordQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useLearningRecordQuery({
 *   variables: {
 *   },
 * });
 */
export function useLearningRecordQuery(baseOptions?: Apollo.QueryHookOptions<LearningRecordQuery, LearningRecordQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<LearningRecordQuery, LearningRecordQueryVariables>(LearningRecordDocument, options);
      }
export function useLearningRecordLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<LearningRecordQuery, LearningRecordQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<LearningRecordQuery, LearningRecordQueryVariables>(LearningRecordDocument, options);
        }
export type LearningRecordQueryHookResult = ReturnType<typeof useLearningRecordQuery>;
export type LearningRecordLazyQueryHookResult = ReturnType<typeof useLearningRecordLazyQuery>;
export type LearningRecordQueryResult = Apollo.QueryResult<LearningRecordQuery, LearningRecordQueryVariables>;
export const SaveLearningRecordDocument = gql`
    mutation SaveLearningRecord($data: SaveLearningRecordInput!) {
  saveLearningRecord(data: $data) {
    paths
  }
}
    `;
export type SaveLearningRecordMutationFn = Apollo.MutationFunction<SaveLearningRecordMutation, SaveLearningRecordMutationVariables>;

/**
 * __useSaveLearningRecordMutation__
 *
 * To run a mutation, you first call `useSaveLearningRecordMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSaveLearningRecordMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [saveLearningRecordMutation, { data, loading, error }] = useSaveLearningRecordMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useSaveLearningRecordMutation(baseOptions?: Apollo.MutationHookOptions<SaveLearningRecordMutation, SaveLearningRecordMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SaveLearningRecordMutation, SaveLearningRecordMutationVariables>(SaveLearningRecordDocument, options);
      }
export type SaveLearningRecordMutationHookResult = ReturnType<typeof useSaveLearningRecordMutation>;
export type SaveLearningRecordMutationResult = Apollo.MutationResult<SaveLearningRecordMutation>;
export type SaveLearningRecordMutationOptions = Apollo.BaseMutationOptions<SaveLearningRecordMutation, SaveLearningRecordMutationVariables>;
</file>

<file path="src/apollo/client/graphql/learning.ts">
import { gql } from '@apollo/client';

export const LEARNING_RECORD = gql`
  query LearningRecord {
    learningRecord {
      paths
    }
  }
`;

export const SAVE_LEARNING_RECORD = gql`
  mutation SaveLearningRecord($data: SaveLearningRecordInput!) {
    saveLearningRecord(data: $data) {
      paths
    }
  }
`;
</file>

<file path="src/apollo/client/graphql/metadata.generated.ts">
import * as Types from './__types__';

import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
const defaultOptions = {} as const;
export type UpdateModelMetadataMutationVariables = Types.Exact<{
  where: Types.ModelWhereInput;
  data: Types.UpdateModelMetadataInput;
}>;


export type UpdateModelMetadataMutation = { __typename?: 'Mutation', updateModelMetadata: boolean };

export type UpdateViewMetadataMutationVariables = Types.Exact<{
  where: Types.ViewWhereUniqueInput;
  data: Types.UpdateViewMetadataInput;
}>;


export type UpdateViewMetadataMutation = { __typename?: 'Mutation', updateViewMetadata: boolean };


export const UpdateModelMetadataDocument = gql`
    mutation UpdateModelMetadata($where: ModelWhereInput!, $data: UpdateModelMetadataInput!) {
  updateModelMetadata(where: $where, data: $data)
}
    `;
export type UpdateModelMetadataMutationFn = Apollo.MutationFunction<UpdateModelMetadataMutation, UpdateModelMetadataMutationVariables>;

/**
 * __useUpdateModelMetadataMutation__
 *
 * To run a mutation, you first call `useUpdateModelMetadataMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateModelMetadataMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateModelMetadataMutation, { data, loading, error }] = useUpdateModelMetadataMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateModelMetadataMutation(baseOptions?: Apollo.MutationHookOptions<UpdateModelMetadataMutation, UpdateModelMetadataMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateModelMetadataMutation, UpdateModelMetadataMutationVariables>(UpdateModelMetadataDocument, options);
      }
export type UpdateModelMetadataMutationHookResult = ReturnType<typeof useUpdateModelMetadataMutation>;
export type UpdateModelMetadataMutationResult = Apollo.MutationResult<UpdateModelMetadataMutation>;
export type UpdateModelMetadataMutationOptions = Apollo.BaseMutationOptions<UpdateModelMetadataMutation, UpdateModelMetadataMutationVariables>;
export const UpdateViewMetadataDocument = gql`
    mutation UpdateViewMetadata($where: ViewWhereUniqueInput!, $data: UpdateViewMetadataInput!) {
  updateViewMetadata(where: $where, data: $data)
}
    `;
export type UpdateViewMetadataMutationFn = Apollo.MutationFunction<UpdateViewMetadataMutation, UpdateViewMetadataMutationVariables>;

/**
 * __useUpdateViewMetadataMutation__
 *
 * To run a mutation, you first call `useUpdateViewMetadataMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateViewMetadataMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateViewMetadataMutation, { data, loading, error }] = useUpdateViewMetadataMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateViewMetadataMutation(baseOptions?: Apollo.MutationHookOptions<UpdateViewMetadataMutation, UpdateViewMetadataMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateViewMetadataMutation, UpdateViewMetadataMutationVariables>(UpdateViewMetadataDocument, options);
      }
export type UpdateViewMetadataMutationHookResult = ReturnType<typeof useUpdateViewMetadataMutation>;
export type UpdateViewMetadataMutationResult = Apollo.MutationResult<UpdateViewMetadataMutation>;
export type UpdateViewMetadataMutationOptions = Apollo.BaseMutationOptions<UpdateViewMetadataMutation, UpdateViewMetadataMutationVariables>;
</file>

<file path="src/apollo/client/graphql/metadata.ts">
import { gql } from '@apollo/client';

export const UPDATE_MODEL_METADATA = gql`
  mutation UpdateModelMetadata(
    $where: ModelWhereInput!
    $data: UpdateModelMetadataInput!
  ) {
    updateModelMetadata(where: $where, data: $data)
  }
`;

export const UPDATE_VIEW_METADATA = gql`
  mutation UpdateViewMetadata(
    $where: ViewWhereUniqueInput!
    $data: UpdateViewMetadataInput!
  ) {
    updateViewMetadata(where: $where, data: $data)
  }
`;
</file>

<file path="src/apollo/client/graphql/model.generated.ts">
import * as Types from './__types__';

import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
const defaultOptions = {} as const;
export type CommonColumnFragment = { __typename?: 'DetailedColumn', displayName: string, referenceName: string, sourceColumnName: string, type?: string | null, isCalculated: boolean, notNull: boolean, properties: any };

export type CommonFieldFragment = { __typename?: 'FieldInfo', id: number, displayName: string, referenceName: string, sourceColumnName: string, type?: string | null, isCalculated: boolean, notNull: boolean, expression?: string | null, properties?: any | null };

export type CommonRelationFragment = { __typename?: 'DetailedRelation', fromModelId: number, fromColumnId: number, toModelId: number, toColumnId: number, type: Types.RelationType, name: string };

export type ListModelsQueryVariables = Types.Exact<{ [key: string]: never; }>;


export type ListModelsQuery = { __typename?: 'Query', listModels: Array<{ __typename?: 'ModelInfo', id: number, displayName: string, referenceName: string, sourceTableName: string, refSql?: string | null, primaryKey?: string | null, cached: boolean, refreshTime?: string | null, description?: string | null, fields: Array<{ __typename?: 'FieldInfo', id: number, displayName: string, referenceName: string, sourceColumnName: string, type?: string | null, isCalculated: boolean, notNull: boolean, expression?: string | null, properties?: any | null } | null>, calculatedFields: Array<{ __typename?: 'FieldInfo', id: number, displayName: string, referenceName: string, sourceColumnName: string, type?: string | null, isCalculated: boolean, notNull: boolean, expression?: string | null, properties?: any | null } | null> }> };

export type GetModelQueryVariables = Types.Exact<{
  where: Types.ModelWhereInput;
}>;


export type GetModelQuery = { __typename?: 'Query', model: { __typename?: 'DetailedModel', displayName: string, referenceName: string, sourceTableName: string, refSql: string, primaryKey?: string | null, cached: boolean, refreshTime?: string | null, description?: string | null, properties: any, fields?: Array<{ __typename?: 'DetailedColumn', displayName: string, referenceName: string, sourceColumnName: string, type?: string | null, isCalculated: boolean, notNull: boolean, properties: any } | null> | null, calculatedFields?: Array<{ __typename?: 'DetailedColumn', displayName: string, referenceName: string, sourceColumnName: string, type?: string | null, isCalculated: boolean, notNull: boolean, properties: any } | null> | null, relations?: Array<{ __typename?: 'DetailedRelation', fromModelId: number, fromColumnId: number, toModelId: number, toColumnId: number, type: Types.RelationType, name: string } | null> | null } };

export type CreateModelMutationVariables = Types.Exact<{
  data: Types.CreateModelInput;
}>;


export type CreateModelMutation = { __typename?: 'Mutation', createModel: any };

export type UpdateModelMutationVariables = Types.Exact<{
  where: Types.ModelWhereInput;
  data: Types.UpdateModelInput;
}>;


export type UpdateModelMutation = { __typename?: 'Mutation', updateModel: any };

export type DeleteModelMutationVariables = Types.Exact<{
  where: Types.ModelWhereInput;
}>;


export type DeleteModelMutation = { __typename?: 'Mutation', deleteModel: boolean };

export type PreviewModelDataMutationVariables = Types.Exact<{
  where: Types.WhereIdInput;
}>;


export type PreviewModelDataMutation = { __typename?: 'Mutation', previewModelData: any };

export const CommonColumnFragmentDoc = gql`
    fragment CommonColumn on DetailedColumn {
  displayName
  referenceName
  sourceColumnName
  type
  isCalculated
  notNull
  properties
}
    `;
export const CommonFieldFragmentDoc = gql`
    fragment CommonField on FieldInfo {
  id
  displayName
  referenceName
  sourceColumnName
  type
  isCalculated
  notNull
  expression
  properties
}
    `;
export const CommonRelationFragmentDoc = gql`
    fragment CommonRelation on DetailedRelation {
  fromModelId
  fromColumnId
  toModelId
  toColumnId
  type
  name
}
    `;
export const ListModelsDocument = gql`
    query ListModels {
  listModels {
    id
    displayName
    referenceName
    sourceTableName
    refSql
    primaryKey
    cached
    refreshTime
    description
    fields {
      ...CommonField
    }
    calculatedFields {
      ...CommonField
    }
  }
}
    ${CommonFieldFragmentDoc}`;

/**
 * __useListModelsQuery__
 *
 * To run a query within a React component, call `useListModelsQuery` and pass it any options that fit your needs.
 * When your component renders, `useListModelsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useListModelsQuery({
 *   variables: {
 *   },
 * });
 */
export function useListModelsQuery(baseOptions?: Apollo.QueryHookOptions<ListModelsQuery, ListModelsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ListModelsQuery, ListModelsQueryVariables>(ListModelsDocument, options);
      }
export function useListModelsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ListModelsQuery, ListModelsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ListModelsQuery, ListModelsQueryVariables>(ListModelsDocument, options);
        }
export type ListModelsQueryHookResult = ReturnType<typeof useListModelsQuery>;
export type ListModelsLazyQueryHookResult = ReturnType<typeof useListModelsLazyQuery>;
export type ListModelsQueryResult = Apollo.QueryResult<ListModelsQuery, ListModelsQueryVariables>;
export const GetModelDocument = gql`
    query GetModel($where: ModelWhereInput!) {
  model(where: $where) {
    displayName
    referenceName
    sourceTableName
    refSql
    primaryKey
    cached
    refreshTime
    description
    fields {
      ...CommonColumn
    }
    calculatedFields {
      ...CommonColumn
    }
    relations {
      ...CommonRelation
    }
    properties
  }
}
    ${CommonColumnFragmentDoc}
${CommonRelationFragmentDoc}`;

/**
 * __useGetModelQuery__
 *
 * To run a query within a React component, call `useGetModelQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetModelQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetModelQuery({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useGetModelQuery(baseOptions: Apollo.QueryHookOptions<GetModelQuery, GetModelQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetModelQuery, GetModelQueryVariables>(GetModelDocument, options);
      }
export function useGetModelLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetModelQuery, GetModelQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetModelQuery, GetModelQueryVariables>(GetModelDocument, options);
        }
export type GetModelQueryHookResult = ReturnType<typeof useGetModelQuery>;
export type GetModelLazyQueryHookResult = ReturnType<typeof useGetModelLazyQuery>;
export type GetModelQueryResult = Apollo.QueryResult<GetModelQuery, GetModelQueryVariables>;
export const CreateModelDocument = gql`
    mutation CreateModel($data: CreateModelInput!) {
  createModel(data: $data)
}
    `;
export type CreateModelMutationFn = Apollo.MutationFunction<CreateModelMutation, CreateModelMutationVariables>;

/**
 * __useCreateModelMutation__
 *
 * To run a mutation, you first call `useCreateModelMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateModelMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createModelMutation, { data, loading, error }] = useCreateModelMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useCreateModelMutation(baseOptions?: Apollo.MutationHookOptions<CreateModelMutation, CreateModelMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateModelMutation, CreateModelMutationVariables>(CreateModelDocument, options);
      }
export type CreateModelMutationHookResult = ReturnType<typeof useCreateModelMutation>;
export type CreateModelMutationResult = Apollo.MutationResult<CreateModelMutation>;
export type CreateModelMutationOptions = Apollo.BaseMutationOptions<CreateModelMutation, CreateModelMutationVariables>;
export const UpdateModelDocument = gql`
    mutation UpdateModel($where: ModelWhereInput!, $data: UpdateModelInput!) {
  updateModel(where: $where, data: $data)
}
    `;
export type UpdateModelMutationFn = Apollo.MutationFunction<UpdateModelMutation, UpdateModelMutationVariables>;

/**
 * __useUpdateModelMutation__
 *
 * To run a mutation, you first call `useUpdateModelMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateModelMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateModelMutation, { data, loading, error }] = useUpdateModelMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateModelMutation(baseOptions?: Apollo.MutationHookOptions<UpdateModelMutation, UpdateModelMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateModelMutation, UpdateModelMutationVariables>(UpdateModelDocument, options);
      }
export type UpdateModelMutationHookResult = ReturnType<typeof useUpdateModelMutation>;
export type UpdateModelMutationResult = Apollo.MutationResult<UpdateModelMutation>;
export type UpdateModelMutationOptions = Apollo.BaseMutationOptions<UpdateModelMutation, UpdateModelMutationVariables>;
export const DeleteModelDocument = gql`
    mutation DeleteModel($where: ModelWhereInput!) {
  deleteModel(where: $where)
}
    `;
export type DeleteModelMutationFn = Apollo.MutationFunction<DeleteModelMutation, DeleteModelMutationVariables>;

/**
 * __useDeleteModelMutation__
 *
 * To run a mutation, you first call `useDeleteModelMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteModelMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteModelMutation, { data, loading, error }] = useDeleteModelMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteModelMutation(baseOptions?: Apollo.MutationHookOptions<DeleteModelMutation, DeleteModelMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteModelMutation, DeleteModelMutationVariables>(DeleteModelDocument, options);
      }
export type DeleteModelMutationHookResult = ReturnType<typeof useDeleteModelMutation>;
export type DeleteModelMutationResult = Apollo.MutationResult<DeleteModelMutation>;
export type DeleteModelMutationOptions = Apollo.BaseMutationOptions<DeleteModelMutation, DeleteModelMutationVariables>;
export const PreviewModelDataDocument = gql`
    mutation PreviewModelData($where: WhereIdInput!) {
  previewModelData(where: $where)
}
    `;
export type PreviewModelDataMutationFn = Apollo.MutationFunction<PreviewModelDataMutation, PreviewModelDataMutationVariables>;

/**
 * __usePreviewModelDataMutation__
 *
 * To run a mutation, you first call `usePreviewModelDataMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `usePreviewModelDataMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [previewModelDataMutation, { data, loading, error }] = usePreviewModelDataMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function usePreviewModelDataMutation(baseOptions?: Apollo.MutationHookOptions<PreviewModelDataMutation, PreviewModelDataMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<PreviewModelDataMutation, PreviewModelDataMutationVariables>(PreviewModelDataDocument, options);
      }
export type PreviewModelDataMutationHookResult = ReturnType<typeof usePreviewModelDataMutation>;
export type PreviewModelDataMutationResult = Apollo.MutationResult<PreviewModelDataMutation>;
export type PreviewModelDataMutationOptions = Apollo.BaseMutationOptions<PreviewModelDataMutation, PreviewModelDataMutationVariables>;
</file>

<file path="src/apollo/client/graphql/model.ts">
import { gql } from '@apollo/client';

const COMMON_COLUMN = gql`
  fragment CommonColumn on DetailedColumn {
    displayName
    referenceName
    sourceColumnName
    type
    isCalculated
    notNull
    properties
  }
`;

const COMMON_FIELD = gql`
  fragment CommonField on FieldInfo {
    id
    displayName
    referenceName
    sourceColumnName
    type
    isCalculated
    notNull
    expression
    properties
  }
`;

const COMMON_RELATION = gql`
  fragment CommonRelation on DetailedRelation {
    fromModelId
    fromColumnId
    toModelId
    toColumnId
    type
    name
  }
`;

export const LIST_MODELS = gql`
  query ListModels {
    listModels {
      id
      displayName
      referenceName
      sourceTableName
      refSql
      primaryKey
      cached
      refreshTime
      description
      fields {
        ...CommonField
      }
      calculatedFields {
        ...CommonField
      }
    }
  }
  ${COMMON_FIELD}
`;

export const GET_MODEL = gql`
  query GetModel($where: ModelWhereInput!) {
    model(where: $where) {
      displayName
      referenceName
      sourceTableName
      refSql
      primaryKey
      cached
      refreshTime
      description
      fields {
        ...CommonColumn
      }
      calculatedFields {
        ...CommonColumn
      }
      relations {
        ...CommonRelation
      }
      properties
    }
  }
  ${COMMON_COLUMN}
  ${COMMON_RELATION}
`;

export const CREATE_MODEL = gql`
  mutation CreateModel($data: CreateModelInput!) {
    createModel(data: $data)
  }
`;

export const UPDATE_MODEL = gql`
  mutation UpdateModel($where: ModelWhereInput!, $data: UpdateModelInput!) {
    updateModel(where: $where, data: $data)
  }
`;

export const DELETE_MODEL = gql`
  mutation DeleteModel($where: ModelWhereInput!) {
    deleteModel(where: $where)
  }
`;

export const PREVIEW_MODEL_DATA = gql`
  mutation PreviewModelData($where: WhereIdInput!) {
    previewModelData(where: $where)
  }
`;
</file>

<file path="src/apollo/client/graphql/onboarding.generated.ts">
import * as Types from './__types__';

import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
const defaultOptions = {} as const;
export type OnboardingStatusQueryVariables = Types.Exact<{ [key: string]: never; }>;


export type OnboardingStatusQuery = { __typename?: 'Query', onboardingStatus: { __typename?: 'OnboardingStatusResponse', status?: Types.OnboardingStatus | null } };


export const OnboardingStatusDocument = gql`
    query OnboardingStatus {
  onboardingStatus {
    status
  }
}
    `;

/**
 * __useOnboardingStatusQuery__
 *
 * To run a query within a React component, call `useOnboardingStatusQuery` and pass it any options that fit your needs.
 * When your component renders, `useOnboardingStatusQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useOnboardingStatusQuery({
 *   variables: {
 *   },
 * });
 */
export function useOnboardingStatusQuery(baseOptions?: Apollo.QueryHookOptions<OnboardingStatusQuery, OnboardingStatusQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<OnboardingStatusQuery, OnboardingStatusQueryVariables>(OnboardingStatusDocument, options);
      }
export function useOnboardingStatusLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<OnboardingStatusQuery, OnboardingStatusQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<OnboardingStatusQuery, OnboardingStatusQueryVariables>(OnboardingStatusDocument, options);
        }
export type OnboardingStatusQueryHookResult = ReturnType<typeof useOnboardingStatusQuery>;
export type OnboardingStatusLazyQueryHookResult = ReturnType<typeof useOnboardingStatusLazyQuery>;
export type OnboardingStatusQueryResult = Apollo.QueryResult<OnboardingStatusQuery, OnboardingStatusQueryVariables>;
</file>

<file path="src/apollo/client/graphql/onboarding.ts">
import { gql } from '@apollo/client';

export const ONBOARDING_STATUS = gql`
  query OnboardingStatus {
    onboardingStatus {
      status
    }
  }
`;
</file>

<file path="src/apollo/client/graphql/relationship.generated.ts">
import * as Types from './__types__';

import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
const defaultOptions = {} as const;
export type CreateRelationshipMutationVariables = Types.Exact<{
  data: Types.RelationInput;
}>;


export type CreateRelationshipMutation = { __typename?: 'Mutation', createRelation: any };

export type UpdateRelationshipMutationVariables = Types.Exact<{
  where: Types.WhereIdInput;
  data: Types.UpdateRelationInput;
}>;


export type UpdateRelationshipMutation = { __typename?: 'Mutation', updateRelation: any };

export type DeleteRelationshipMutationVariables = Types.Exact<{
  where: Types.WhereIdInput;
}>;


export type DeleteRelationshipMutation = { __typename?: 'Mutation', deleteRelation: boolean };


export const CreateRelationshipDocument = gql`
    mutation CreateRelationship($data: RelationInput!) {
  createRelation(data: $data)
}
    `;
export type CreateRelationshipMutationFn = Apollo.MutationFunction<CreateRelationshipMutation, CreateRelationshipMutationVariables>;

/**
 * __useCreateRelationshipMutation__
 *
 * To run a mutation, you first call `useCreateRelationshipMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateRelationshipMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createRelationshipMutation, { data, loading, error }] = useCreateRelationshipMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useCreateRelationshipMutation(baseOptions?: Apollo.MutationHookOptions<CreateRelationshipMutation, CreateRelationshipMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateRelationshipMutation, CreateRelationshipMutationVariables>(CreateRelationshipDocument, options);
      }
export type CreateRelationshipMutationHookResult = ReturnType<typeof useCreateRelationshipMutation>;
export type CreateRelationshipMutationResult = Apollo.MutationResult<CreateRelationshipMutation>;
export type CreateRelationshipMutationOptions = Apollo.BaseMutationOptions<CreateRelationshipMutation, CreateRelationshipMutationVariables>;
export const UpdateRelationshipDocument = gql`
    mutation UpdateRelationship($where: WhereIdInput!, $data: UpdateRelationInput!) {
  updateRelation(where: $where, data: $data)
}
    `;
export type UpdateRelationshipMutationFn = Apollo.MutationFunction<UpdateRelationshipMutation, UpdateRelationshipMutationVariables>;

/**
 * __useUpdateRelationshipMutation__
 *
 * To run a mutation, you first call `useUpdateRelationshipMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateRelationshipMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateRelationshipMutation, { data, loading, error }] = useUpdateRelationshipMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateRelationshipMutation(baseOptions?: Apollo.MutationHookOptions<UpdateRelationshipMutation, UpdateRelationshipMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateRelationshipMutation, UpdateRelationshipMutationVariables>(UpdateRelationshipDocument, options);
      }
export type UpdateRelationshipMutationHookResult = ReturnType<typeof useUpdateRelationshipMutation>;
export type UpdateRelationshipMutationResult = Apollo.MutationResult<UpdateRelationshipMutation>;
export type UpdateRelationshipMutationOptions = Apollo.BaseMutationOptions<UpdateRelationshipMutation, UpdateRelationshipMutationVariables>;
export const DeleteRelationshipDocument = gql`
    mutation DeleteRelationship($where: WhereIdInput!) {
  deleteRelation(where: $where)
}
    `;
export type DeleteRelationshipMutationFn = Apollo.MutationFunction<DeleteRelationshipMutation, DeleteRelationshipMutationVariables>;

/**
 * __useDeleteRelationshipMutation__
 *
 * To run a mutation, you first call `useDeleteRelationshipMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteRelationshipMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteRelationshipMutation, { data, loading, error }] = useDeleteRelationshipMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteRelationshipMutation(baseOptions?: Apollo.MutationHookOptions<DeleteRelationshipMutation, DeleteRelationshipMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteRelationshipMutation, DeleteRelationshipMutationVariables>(DeleteRelationshipDocument, options);
      }
export type DeleteRelationshipMutationHookResult = ReturnType<typeof useDeleteRelationshipMutation>;
export type DeleteRelationshipMutationResult = Apollo.MutationResult<DeleteRelationshipMutation>;
export type DeleteRelationshipMutationOptions = Apollo.BaseMutationOptions<DeleteRelationshipMutation, DeleteRelationshipMutationVariables>;
</file>

<file path="src/apollo/client/graphql/relationship.ts">
import { gql } from '@apollo/client';

export const CREATE_RELATIONSHIP = gql`
  mutation CreateRelationship($data: RelationInput!) {
    createRelation(data: $data)
  }
`;

export const UPDATE_RELATIONSHIP = gql`
  mutation UpdateRelationship(
    $where: WhereIdInput!
    $data: UpdateRelationInput!
  ) {
    updateRelation(where: $where, data: $data)
  }
`;

export const DELETE_RELATIONSHIP = gql`
  mutation DeleteRelationship($where: WhereIdInput!) {
    deleteRelation(where: $where)
  }
`;
</file>

<file path="src/apollo/client/graphql/settings.generated.ts">
import * as Types from './__types__';

import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
const defaultOptions = {} as const;
export type GetSettingsQueryVariables = Types.Exact<{ [key: string]: never; }>;


export type GetSettingsQuery = { __typename?: 'Query', settings: { __typename?: 'Settings', productVersion: string, language: Types.ProjectLanguage, dataSource: { __typename?: 'DataSource', type: Types.DataSourceName, properties: any, sampleDataset?: Types.SampleDatasetName | null } } };

export type ResetCurrentProjectMutationVariables = Types.Exact<{ [key: string]: never; }>;


export type ResetCurrentProjectMutation = { __typename?: 'Mutation', resetCurrentProject: boolean };

export type UpdateCurrentProjectMutationVariables = Types.Exact<{
  data: Types.UpdateCurrentProjectInput;
}>;


export type UpdateCurrentProjectMutation = { __typename?: 'Mutation', updateCurrentProject: boolean };


export const GetSettingsDocument = gql`
    query GetSettings {
  settings {
    productVersion
    dataSource {
      type
      properties
      sampleDataset
    }
    language
  }
}
    `;

/**
 * __useGetSettingsQuery__
 *
 * To run a query within a React component, call `useGetSettingsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSettingsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSettingsQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetSettingsQuery(baseOptions?: Apollo.QueryHookOptions<GetSettingsQuery, GetSettingsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetSettingsQuery, GetSettingsQueryVariables>(GetSettingsDocument, options);
      }
export function useGetSettingsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSettingsQuery, GetSettingsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetSettingsQuery, GetSettingsQueryVariables>(GetSettingsDocument, options);
        }
export type GetSettingsQueryHookResult = ReturnType<typeof useGetSettingsQuery>;
export type GetSettingsLazyQueryHookResult = ReturnType<typeof useGetSettingsLazyQuery>;
export type GetSettingsQueryResult = Apollo.QueryResult<GetSettingsQuery, GetSettingsQueryVariables>;
export const ResetCurrentProjectDocument = gql`
    mutation ResetCurrentProject {
  resetCurrentProject
}
    `;
export type ResetCurrentProjectMutationFn = Apollo.MutationFunction<ResetCurrentProjectMutation, ResetCurrentProjectMutationVariables>;

/**
 * __useResetCurrentProjectMutation__
 *
 * To run a mutation, you first call `useResetCurrentProjectMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useResetCurrentProjectMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [resetCurrentProjectMutation, { data, loading, error }] = useResetCurrentProjectMutation({
 *   variables: {
 *   },
 * });
 */
export function useResetCurrentProjectMutation(baseOptions?: Apollo.MutationHookOptions<ResetCurrentProjectMutation, ResetCurrentProjectMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ResetCurrentProjectMutation, ResetCurrentProjectMutationVariables>(ResetCurrentProjectDocument, options);
      }
export type ResetCurrentProjectMutationHookResult = ReturnType<typeof useResetCurrentProjectMutation>;
export type ResetCurrentProjectMutationResult = Apollo.MutationResult<ResetCurrentProjectMutation>;
export type ResetCurrentProjectMutationOptions = Apollo.BaseMutationOptions<ResetCurrentProjectMutation, ResetCurrentProjectMutationVariables>;
export const UpdateCurrentProjectDocument = gql`
    mutation UpdateCurrentProject($data: UpdateCurrentProjectInput!) {
  updateCurrentProject(data: $data)
}
    `;
export type UpdateCurrentProjectMutationFn = Apollo.MutationFunction<UpdateCurrentProjectMutation, UpdateCurrentProjectMutationVariables>;

/**
 * __useUpdateCurrentProjectMutation__
 *
 * To run a mutation, you first call `useUpdateCurrentProjectMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateCurrentProjectMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateCurrentProjectMutation, { data, loading, error }] = useUpdateCurrentProjectMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateCurrentProjectMutation(baseOptions?: Apollo.MutationHookOptions<UpdateCurrentProjectMutation, UpdateCurrentProjectMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateCurrentProjectMutation, UpdateCurrentProjectMutationVariables>(UpdateCurrentProjectDocument, options);
      }
export type UpdateCurrentProjectMutationHookResult = ReturnType<typeof useUpdateCurrentProjectMutation>;
export type UpdateCurrentProjectMutationResult = Apollo.MutationResult<UpdateCurrentProjectMutation>;
export type UpdateCurrentProjectMutationOptions = Apollo.BaseMutationOptions<UpdateCurrentProjectMutation, UpdateCurrentProjectMutationVariables>;
</file>

<file path="src/apollo/client/graphql/settings.ts">
import { gql } from '@apollo/client';

export const GET_SETTINGS = gql`
  query GetSettings {
    settings {
      productVersion
      dataSource {
        type
        properties
        sampleDataset
      }
      language
    }
  }
`;

export const RESET_CURRENT_PROJECT = gql`
  mutation ResetCurrentProject {
    resetCurrentProject
  }
`;

export const UPDATE_CURRENT_PROJECT = gql`
  mutation UpdateCurrentProject($data: UpdateCurrentProjectInput!) {
    updateCurrentProject(data: $data)
  }
`;
</file>

<file path="src/apollo/client/graphql/sql.generated.ts">
import * as Types from './__types__';

import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
const defaultOptions = {} as const;
export type PreviewSqlMutationVariables = Types.Exact<{
  data: Types.PreviewSqlDataInput;
}>;


export type PreviewSqlMutation = { __typename?: 'Mutation', previewSql: any };

export type GenerateQuestionMutationVariables = Types.Exact<{
  data: Types.GenerateQuestionInput;
}>;


export type GenerateQuestionMutation = { __typename?: 'Mutation', generateQuestion: string };

export type ModelSubstituteMutationVariables = Types.Exact<{
  data: Types.ModelSubstituteInput;
}>;


export type ModelSubstituteMutation = { __typename?: 'Mutation', modelSubstitute: string };


export const PreviewSqlDocument = gql`
    mutation PreviewSQL($data: PreviewSQLDataInput!) {
  previewSql(data: $data)
}
    `;
export type PreviewSqlMutationFn = Apollo.MutationFunction<PreviewSqlMutation, PreviewSqlMutationVariables>;

/**
 * __usePreviewSqlMutation__
 *
 * To run a mutation, you first call `usePreviewSqlMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `usePreviewSqlMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [previewSqlMutation, { data, loading, error }] = usePreviewSqlMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function usePreviewSqlMutation(baseOptions?: Apollo.MutationHookOptions<PreviewSqlMutation, PreviewSqlMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<PreviewSqlMutation, PreviewSqlMutationVariables>(PreviewSqlDocument, options);
      }
export type PreviewSqlMutationHookResult = ReturnType<typeof usePreviewSqlMutation>;
export type PreviewSqlMutationResult = Apollo.MutationResult<PreviewSqlMutation>;
export type PreviewSqlMutationOptions = Apollo.BaseMutationOptions<PreviewSqlMutation, PreviewSqlMutationVariables>;
export const GenerateQuestionDocument = gql`
    mutation GenerateQuestion($data: GenerateQuestionInput!) {
  generateQuestion(data: $data)
}
    `;
export type GenerateQuestionMutationFn = Apollo.MutationFunction<GenerateQuestionMutation, GenerateQuestionMutationVariables>;

/**
 * __useGenerateQuestionMutation__
 *
 * To run a mutation, you first call `useGenerateQuestionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useGenerateQuestionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [generateQuestionMutation, { data, loading, error }] = useGenerateQuestionMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useGenerateQuestionMutation(baseOptions?: Apollo.MutationHookOptions<GenerateQuestionMutation, GenerateQuestionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<GenerateQuestionMutation, GenerateQuestionMutationVariables>(GenerateQuestionDocument, options);
      }
export type GenerateQuestionMutationHookResult = ReturnType<typeof useGenerateQuestionMutation>;
export type GenerateQuestionMutationResult = Apollo.MutationResult<GenerateQuestionMutation>;
export type GenerateQuestionMutationOptions = Apollo.BaseMutationOptions<GenerateQuestionMutation, GenerateQuestionMutationVariables>;
export const ModelSubstituteDocument = gql`
    mutation ModelSubstitute($data: ModelSubstituteInput!) {
  modelSubstitute(data: $data)
}
    `;
export type ModelSubstituteMutationFn = Apollo.MutationFunction<ModelSubstituteMutation, ModelSubstituteMutationVariables>;

/**
 * __useModelSubstituteMutation__
 *
 * To run a mutation, you first call `useModelSubstituteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useModelSubstituteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [modelSubstituteMutation, { data, loading, error }] = useModelSubstituteMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useModelSubstituteMutation(baseOptions?: Apollo.MutationHookOptions<ModelSubstituteMutation, ModelSubstituteMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ModelSubstituteMutation, ModelSubstituteMutationVariables>(ModelSubstituteDocument, options);
      }
export type ModelSubstituteMutationHookResult = ReturnType<typeof useModelSubstituteMutation>;
export type ModelSubstituteMutationResult = Apollo.MutationResult<ModelSubstituteMutation>;
export type ModelSubstituteMutationOptions = Apollo.BaseMutationOptions<ModelSubstituteMutation, ModelSubstituteMutationVariables>;
</file>

<file path="src/apollo/client/graphql/sql.ts">
import { gql } from '@apollo/client';

export const PREVIEW_SQL_STATEMENT = gql`
  mutation PreviewSQL($data: PreviewSQLDataInput!) {
    previewSql(data: $data)
  }
`;

export const GENERATE_QUESTION = gql`
  mutation GenerateQuestion($data: GenerateQuestionInput!) {
    generateQuestion(data: $data)
  }
`;

export const MODEL_SUBSTITUDE = gql`
  mutation ModelSubstitute($data: ModelSubstituteInput!) {
    modelSubstitute(data: $data)
  }
`;
</file>

<file path="src/apollo/client/graphql/sqlPairs.generated.ts">
import * as Types from './__types__';

import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
const defaultOptions = {} as const;
export type SqlPairFragment = { __typename?: 'SqlPair', id: number, projectId: number, sql: string, question: string, createdAt?: string | null, updatedAt?: string | null };

export type SqlPairsQueryVariables = Types.Exact<{ [key: string]: never; }>;


export type SqlPairsQuery = { __typename?: 'Query', sqlPairs: Array<{ __typename?: 'SqlPair', id: number, projectId: number, sql: string, question: string, createdAt?: string | null, updatedAt?: string | null } | null> };

export type CreateSqlPairMutationVariables = Types.Exact<{
  data: Types.CreateSqlPairInput;
}>;


export type CreateSqlPairMutation = { __typename?: 'Mutation', createSqlPair: { __typename?: 'SqlPair', id: number, projectId: number, sql: string, question: string, createdAt?: string | null, updatedAt?: string | null } };

export type UpdateSqlPairMutationVariables = Types.Exact<{
  where: Types.SqlPairWhereUniqueInput;
  data: Types.UpdateSqlPairInput;
}>;


export type UpdateSqlPairMutation = { __typename?: 'Mutation', updateSqlPair: { __typename?: 'SqlPair', id: number, projectId: number, sql: string, question: string, createdAt?: string | null, updatedAt?: string | null } };

export type DeleteSqlPairMutationVariables = Types.Exact<{
  where: Types.SqlPairWhereUniqueInput;
}>;


export type DeleteSqlPairMutation = { __typename?: 'Mutation', deleteSqlPair: boolean };

export const SqlPairFragmentDoc = gql`
    fragment SqlPair on SqlPair {
  id
  projectId
  sql
  question
  createdAt
  updatedAt
}
    `;
export const SqlPairsDocument = gql`
    query SqlPairs {
  sqlPairs {
    ...SqlPair
  }
}
    ${SqlPairFragmentDoc}`;

/**
 * __useSqlPairsQuery__
 *
 * To run a query within a React component, call `useSqlPairsQuery` and pass it any options that fit your needs.
 * When your component renders, `useSqlPairsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSqlPairsQuery({
 *   variables: {
 *   },
 * });
 */
export function useSqlPairsQuery(baseOptions?: Apollo.QueryHookOptions<SqlPairsQuery, SqlPairsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SqlPairsQuery, SqlPairsQueryVariables>(SqlPairsDocument, options);
      }
export function useSqlPairsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SqlPairsQuery, SqlPairsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SqlPairsQuery, SqlPairsQueryVariables>(SqlPairsDocument, options);
        }
export type SqlPairsQueryHookResult = ReturnType<typeof useSqlPairsQuery>;
export type SqlPairsLazyQueryHookResult = ReturnType<typeof useSqlPairsLazyQuery>;
export type SqlPairsQueryResult = Apollo.QueryResult<SqlPairsQuery, SqlPairsQueryVariables>;
export const CreateSqlPairDocument = gql`
    mutation CreateSqlPair($data: CreateSqlPairInput!) {
  createSqlPair(data: $data) {
    ...SqlPair
  }
}
    ${SqlPairFragmentDoc}`;
export type CreateSqlPairMutationFn = Apollo.MutationFunction<CreateSqlPairMutation, CreateSqlPairMutationVariables>;

/**
 * __useCreateSqlPairMutation__
 *
 * To run a mutation, you first call `useCreateSqlPairMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateSqlPairMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createSqlPairMutation, { data, loading, error }] = useCreateSqlPairMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useCreateSqlPairMutation(baseOptions?: Apollo.MutationHookOptions<CreateSqlPairMutation, CreateSqlPairMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateSqlPairMutation, CreateSqlPairMutationVariables>(CreateSqlPairDocument, options);
      }
export type CreateSqlPairMutationHookResult = ReturnType<typeof useCreateSqlPairMutation>;
export type CreateSqlPairMutationResult = Apollo.MutationResult<CreateSqlPairMutation>;
export type CreateSqlPairMutationOptions = Apollo.BaseMutationOptions<CreateSqlPairMutation, CreateSqlPairMutationVariables>;
export const UpdateSqlPairDocument = gql`
    mutation UpdateSqlPair($where: SqlPairWhereUniqueInput!, $data: UpdateSqlPairInput!) {
  updateSqlPair(where: $where, data: $data) {
    ...SqlPair
  }
}
    ${SqlPairFragmentDoc}`;
export type UpdateSqlPairMutationFn = Apollo.MutationFunction<UpdateSqlPairMutation, UpdateSqlPairMutationVariables>;

/**
 * __useUpdateSqlPairMutation__
 *
 * To run a mutation, you first call `useUpdateSqlPairMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateSqlPairMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateSqlPairMutation, { data, loading, error }] = useUpdateSqlPairMutation({
 *   variables: {
 *      where: // value for 'where'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateSqlPairMutation(baseOptions?: Apollo.MutationHookOptions<UpdateSqlPairMutation, UpdateSqlPairMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateSqlPairMutation, UpdateSqlPairMutationVariables>(UpdateSqlPairDocument, options);
      }
export type UpdateSqlPairMutationHookResult = ReturnType<typeof useUpdateSqlPairMutation>;
export type UpdateSqlPairMutationResult = Apollo.MutationResult<UpdateSqlPairMutation>;
export type UpdateSqlPairMutationOptions = Apollo.BaseMutationOptions<UpdateSqlPairMutation, UpdateSqlPairMutationVariables>;
export const DeleteSqlPairDocument = gql`
    mutation DeleteSqlPair($where: SqlPairWhereUniqueInput!) {
  deleteSqlPair(where: $where)
}
    `;
export type DeleteSqlPairMutationFn = Apollo.MutationFunction<DeleteSqlPairMutation, DeleteSqlPairMutationVariables>;

/**
 * __useDeleteSqlPairMutation__
 *
 * To run a mutation, you first call `useDeleteSqlPairMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteSqlPairMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteSqlPairMutation, { data, loading, error }] = useDeleteSqlPairMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteSqlPairMutation(baseOptions?: Apollo.MutationHookOptions<DeleteSqlPairMutation, DeleteSqlPairMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteSqlPairMutation, DeleteSqlPairMutationVariables>(DeleteSqlPairDocument, options);
      }
export type DeleteSqlPairMutationHookResult = ReturnType<typeof useDeleteSqlPairMutation>;
export type DeleteSqlPairMutationResult = Apollo.MutationResult<DeleteSqlPairMutation>;
export type DeleteSqlPairMutationOptions = Apollo.BaseMutationOptions<DeleteSqlPairMutation, DeleteSqlPairMutationVariables>;
</file>

<file path="src/apollo/client/graphql/sqlPairs.ts">
import { gql } from '@apollo/client';

const SQL_PAIR = gql`
  fragment SqlPair on SqlPair {
    id
    projectId
    sql
    question
    createdAt
    updatedAt
  }
`;

export const LIST_SQL_PAIRS = gql`
  query SqlPairs {
    sqlPairs {
      ...SqlPair
    }
  }

  ${SQL_PAIR}
`;

export const CREATE_SQL_PAIR = gql`
  mutation CreateSqlPair($data: CreateSqlPairInput!) {
    createSqlPair(data: $data) {
      ...SqlPair
    }
  }

  ${SQL_PAIR}
`;

export const UPDATE_SQL_PAIR = gql`
  mutation UpdateSqlPair(
    $where: SqlPairWhereUniqueInput!
    $data: UpdateSqlPairInput!
  ) {
    updateSqlPair(where: $where, data: $data) {
      ...SqlPair
    }
  }

  ${SQL_PAIR}
`;

export const DELETE_SQL_PAIR = gql`
  mutation DeleteSqlPair($where: SqlPairWhereUniqueInput!) {
    deleteSqlPair(where: $where)
  }
`;
</file>

<file path="src/apollo/client/graphql/view.generated.ts">
import * as Types from './__types__';

import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
const defaultOptions = {} as const;
export type CreateViewMutationVariables = Types.Exact<{
  data: Types.CreateViewInput;
}>;


export type CreateViewMutation = { __typename?: 'Mutation', createView: { __typename?: 'ViewInfo', id: number, name: string, statement: string } };

export type DeleteViewMutationVariables = Types.Exact<{
  where: Types.ViewWhereUniqueInput;
}>;


export type DeleteViewMutation = { __typename?: 'Mutation', deleteView: boolean };

export type GetViewQueryVariables = Types.Exact<{
  where: Types.ViewWhereUniqueInput;
}>;


export type GetViewQuery = { __typename?: 'Query', view: { __typename?: 'ViewInfo', id: number, name: string, statement: string } };

export type ListViewsQueryVariables = Types.Exact<{ [key: string]: never; }>;


export type ListViewsQuery = { __typename?: 'Query', listViews: Array<{ __typename?: 'ViewInfo', id: number, name: string, displayName: string, statement: string }> };

export type PreviewViewDataMutationVariables = Types.Exact<{
  where: Types.PreviewViewDataInput;
}>;


export type PreviewViewDataMutation = { __typename?: 'Mutation', previewViewData: any };

export type ValidateViewMutationVariables = Types.Exact<{
  data: Types.ValidateViewInput;
}>;


export type ValidateViewMutation = { __typename?: 'Mutation', validateView: { __typename?: 'ViewValidationResponse', valid: boolean, message?: string | null } };


export const CreateViewDocument = gql`
    mutation CreateView($data: CreateViewInput!) {
  createView(data: $data) {
    id
    name
    statement
  }
}
    `;
export type CreateViewMutationFn = Apollo.MutationFunction<CreateViewMutation, CreateViewMutationVariables>;

/**
 * __useCreateViewMutation__
 *
 * To run a mutation, you first call `useCreateViewMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateViewMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createViewMutation, { data, loading, error }] = useCreateViewMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useCreateViewMutation(baseOptions?: Apollo.MutationHookOptions<CreateViewMutation, CreateViewMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateViewMutation, CreateViewMutationVariables>(CreateViewDocument, options);
      }
export type CreateViewMutationHookResult = ReturnType<typeof useCreateViewMutation>;
export type CreateViewMutationResult = Apollo.MutationResult<CreateViewMutation>;
export type CreateViewMutationOptions = Apollo.BaseMutationOptions<CreateViewMutation, CreateViewMutationVariables>;
export const DeleteViewDocument = gql`
    mutation DeleteView($where: ViewWhereUniqueInput!) {
  deleteView(where: $where)
}
    `;
export type DeleteViewMutationFn = Apollo.MutationFunction<DeleteViewMutation, DeleteViewMutationVariables>;

/**
 * __useDeleteViewMutation__
 *
 * To run a mutation, you first call `useDeleteViewMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteViewMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteViewMutation, { data, loading, error }] = useDeleteViewMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useDeleteViewMutation(baseOptions?: Apollo.MutationHookOptions<DeleteViewMutation, DeleteViewMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteViewMutation, DeleteViewMutationVariables>(DeleteViewDocument, options);
      }
export type DeleteViewMutationHookResult = ReturnType<typeof useDeleteViewMutation>;
export type DeleteViewMutationResult = Apollo.MutationResult<DeleteViewMutation>;
export type DeleteViewMutationOptions = Apollo.BaseMutationOptions<DeleteViewMutation, DeleteViewMutationVariables>;
export const GetViewDocument = gql`
    query GetView($where: ViewWhereUniqueInput!) {
  view(where: $ViewWhereUniqueInput) {
    id
    name
    statement
  }
}
    `;

/**
 * __useGetViewQuery__
 *
 * To run a query within a React component, call `useGetViewQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetViewQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetViewQuery({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useGetViewQuery(baseOptions: Apollo.QueryHookOptions<GetViewQuery, GetViewQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetViewQuery, GetViewQueryVariables>(GetViewDocument, options);
      }
export function useGetViewLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetViewQuery, GetViewQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetViewQuery, GetViewQueryVariables>(GetViewDocument, options);
        }
export type GetViewQueryHookResult = ReturnType<typeof useGetViewQuery>;
export type GetViewLazyQueryHookResult = ReturnType<typeof useGetViewLazyQuery>;
export type GetViewQueryResult = Apollo.QueryResult<GetViewQuery, GetViewQueryVariables>;
export const ListViewsDocument = gql`
    query ListViews {
  listViews {
    id
    name
    displayName
    statement
  }
}
    `;

/**
 * __useListViewsQuery__
 *
 * To run a query within a React component, call `useListViewsQuery` and pass it any options that fit your needs.
 * When your component renders, `useListViewsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useListViewsQuery({
 *   variables: {
 *   },
 * });
 */
export function useListViewsQuery(baseOptions?: Apollo.QueryHookOptions<ListViewsQuery, ListViewsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ListViewsQuery, ListViewsQueryVariables>(ListViewsDocument, options);
      }
export function useListViewsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ListViewsQuery, ListViewsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ListViewsQuery, ListViewsQueryVariables>(ListViewsDocument, options);
        }
export type ListViewsQueryHookResult = ReturnType<typeof useListViewsQuery>;
export type ListViewsLazyQueryHookResult = ReturnType<typeof useListViewsLazyQuery>;
export type ListViewsQueryResult = Apollo.QueryResult<ListViewsQuery, ListViewsQueryVariables>;
export const PreviewViewDataDocument = gql`
    mutation PreviewViewData($where: PreviewViewDataInput!) {
  previewViewData(where: $where)
}
    `;
export type PreviewViewDataMutationFn = Apollo.MutationFunction<PreviewViewDataMutation, PreviewViewDataMutationVariables>;

/**
 * __usePreviewViewDataMutation__
 *
 * To run a mutation, you first call `usePreviewViewDataMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `usePreviewViewDataMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [previewViewDataMutation, { data, loading, error }] = usePreviewViewDataMutation({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function usePreviewViewDataMutation(baseOptions?: Apollo.MutationHookOptions<PreviewViewDataMutation, PreviewViewDataMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<PreviewViewDataMutation, PreviewViewDataMutationVariables>(PreviewViewDataDocument, options);
      }
export type PreviewViewDataMutationHookResult = ReturnType<typeof usePreviewViewDataMutation>;
export type PreviewViewDataMutationResult = Apollo.MutationResult<PreviewViewDataMutation>;
export type PreviewViewDataMutationOptions = Apollo.BaseMutationOptions<PreviewViewDataMutation, PreviewViewDataMutationVariables>;
export const ValidateViewDocument = gql`
    mutation ValidateView($data: ValidateViewInput!) {
  validateView(data: $data) {
    valid
    message
  }
}
    `;
export type ValidateViewMutationFn = Apollo.MutationFunction<ValidateViewMutation, ValidateViewMutationVariables>;

/**
 * __useValidateViewMutation__
 *
 * To run a mutation, you first call `useValidateViewMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useValidateViewMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [validateViewMutation, { data, loading, error }] = useValidateViewMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useValidateViewMutation(baseOptions?: Apollo.MutationHookOptions<ValidateViewMutation, ValidateViewMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ValidateViewMutation, ValidateViewMutationVariables>(ValidateViewDocument, options);
      }
export type ValidateViewMutationHookResult = ReturnType<typeof useValidateViewMutation>;
export type ValidateViewMutationResult = Apollo.MutationResult<ValidateViewMutation>;
export type ValidateViewMutationOptions = Apollo.BaseMutationOptions<ValidateViewMutation, ValidateViewMutationVariables>;
</file>

<file path="src/apollo/client/graphql/view.ts">
import { gql } from '@apollo/client';

export const CREATE_VIEW = gql`
  mutation CreateView($data: CreateViewInput!) {
    createView(data: $data) {
      id
      name
      statement
    }
  }
`;

export const DELETE_VIEW = gql`
  mutation DeleteView($where: ViewWhereUniqueInput!) {
    deleteView(where: $where)
  }
`;

export const GET_VIEW = gql`
  query GetView($where: ViewWhereUniqueInput!) {
    view(where: $ViewWhereUniqueInput) {
      id
      name
      statement
    }
  }
`;

export const LIST_VIEWS = gql`
  query ListViews {
    listViews {
      id
      name
      displayName
      statement
    }
  }
`;

export const PREVIEW_VIEW_DATA = gql`
  mutation PreviewViewData($where: PreviewViewDataInput!) {
    previewViewData(where: $where)
  }
`;

export const VALIDATE_CREATE_VIEW = gql`
  mutation ValidateView($data: ValidateViewInput!) {
    validateView(data: $data) {
      valid
      message
    }
  }
`;
</file>

<file path="src/apollo/client/index.ts">
import { ApolloClient, HttpLink, InMemoryCache, from } from '@apollo/client';
import { onError } from '@apollo/client/link/error';
import errorHandler from '@/utils/errorHandler';

const apolloErrorLink = onError((error) => errorHandler(error));

const httpLink = new HttpLink({
  uri: '/api/graphql',
});

const client = new ApolloClient({
  link: from([apolloErrorLink, httpLink]),
  cache: new InMemoryCache(),
});

export default client;
</file>

<file path="src/apollo/server/adaptors/ibisAdaptor.ts">
import axios, { AxiosResponse } from 'axios';

import { getLogger } from '@server/utils/logger';
import { DataSourceName } from '@server/types';
import { Manifest } from '@server/mdl/type';
import * as Errors from '@server/utils/error';
import { getConfig } from '@server/config';
import { toDockerHost } from '@server/utils';
import {
  CompactColumn,
  CompactTable,
  DEFAULT_PREVIEW_LIMIT,
  RecommendConstraint,
} from '@server/services';
import { snakeCase } from 'lodash';
import { WREN_AI_CONNECTION_INFO } from '../repositories';
import {
  toIbisConnectionInfo,
  toMultipleIbisConnectionInfos,
} from '../dataSource';
import { DialectSQL, WrenSQL } from '../models/adaptor';

export type { WrenSQL };

const logger = getLogger('IbisAdaptor');
logger.level = 'debug';

const config = getConfig();

export interface HostBasedConnectionInfo {
  host: string;
  port: number;
  database: string;
  user: string;
  password: string;
}

export interface UrlBasedConnectionInfo {
  connectionUrl: string;
}

export type IbisPostgresConnectionInfo =
  | UrlBasedConnectionInfo
  | HostBasedConnectionInfo;

export interface IbisBigQueryConnectionInfo {
  project_id: string;
  dataset_id: string;
  credentials: string; // base64 encoded
}

export interface IbisTrinoConnectionInfo {
  host: string;
  port: number;
  catalog: string;
  schema: string;
  user: string;
  password: string;
}

export interface IbisSnowflakeConnectionInfo {
  user: string;
  password: string;
  account: string;
  database: string;
  schema: string;
}

export interface IbisAthenaConnectionInfo {
  aws_access_key_id: string;
  aws_secret_access_key: string;
  region_name: string;
  s3_staging_dir: string;
  schema_name: string;
}

export enum IbisRedshiftConnectionType {
  REDSHIFT = 'redshift',
  REDSHIFT_IAM = 'redshift_iam',
}

interface IbisRedshiftPasswordAuth {
  host: string;
  port: number;
  database: string;
  user: string;
  password: string;
  redshift_type: IbisRedshiftConnectionType;
}

interface IbisRedshiftIAMAuth {
  cluster_identifier: string;
  user: string;
  database: string;
  region: string;
  access_key_id: string;
  access_key_secret: string;
  redshift_type: IbisRedshiftConnectionType;
}

export type IbisRedshiftConnectionInfo =
  | IbisRedshiftPasswordAuth
  | IbisRedshiftIAMAuth;

export enum SupportedDataSource {
  POSTGRES = 'POSTGRES',
  BIG_QUERY = 'BIG_QUERY',
  SNOWFLAKE = 'SNOWFLAKE',
  MYSQL = 'MYSQL',
  ORACLE = 'ORACLE',
  MSSQL = 'MSSQL',
  CLICK_HOUSE = 'CLICK_HOUSE',
  TRINO = 'TRINO',
  ATHENA = 'ATHENA',
  REDSHIFT = 'REDSHIFT',
}

const dataSourceUrlMap: Record<SupportedDataSource, string> = {
  [SupportedDataSource.POSTGRES]: 'postgres',
  [SupportedDataSource.BIG_QUERY]: 'bigquery',
  [SupportedDataSource.SNOWFLAKE]: 'snowflake',
  [SupportedDataSource.MYSQL]: 'mysql',
  [SupportedDataSource.ORACLE]: 'oracle',
  [SupportedDataSource.MSSQL]: 'mssql',
  [SupportedDataSource.CLICK_HOUSE]: 'clickhouse',
  [SupportedDataSource.TRINO]: 'trino',
  [SupportedDataSource.ATHENA]: 'athena',
  [SupportedDataSource.REDSHIFT]: 'redshift',
};

export interface TableResponse {
  tables: CompactTable[];
}

export enum ValidationRules {
  COLUMN_IS_VALID = 'COLUMN_IS_VALID',
}

export interface ValidationResponse {
  valid: boolean;
  message: string | null;
}

export interface IbisBaseOptions {
  dataSource: DataSourceName;
  connectionInfo: WREN_AI_CONNECTION_INFO;
  mdl: Manifest;
}
export interface IbisQueryOptions extends IbisBaseOptions {
  limit?: number;
  refresh?: boolean;
  cacheEnabled?: boolean;
}
export interface IbisDryPlanOptions {
  dataSource: DataSourceName;
  mdl: Manifest;
  // TODO: replace sql type with WrenSQL
  sql: string;
}

export interface IIbisAdaptor {
  query: (
    // TODO: replace query type with WrenSQL
    query: string,
    options: IbisQueryOptions,
  ) => Promise<IbisQueryResponse>;
  dryRun: (query: string, options: IbisBaseOptions) => Promise<DryRunResponse>;
  getTables: (
    dataSource: DataSourceName,
    connectionInfo: WREN_AI_CONNECTION_INFO,
  ) => Promise<CompactTable[]>;
  getConstraints: (
    dataSource: DataSourceName,
    connectionInfo: WREN_AI_CONNECTION_INFO,
  ) => Promise<RecommendConstraint[]>;

  getNativeSql: (options: IbisDryPlanOptions) => Promise<string>;
  validate: (
    dataSource: DataSourceName,
    rule: ValidationRules,
    connectionInfo: WREN_AI_CONNECTION_INFO,
    mdl: Manifest,
    parameters: Record<string, any>,
  ) => Promise<ValidationResponse>;
  modelSubstitute: (
    sql: DialectSQL,
    options: {
      dataSource: DataSourceName;
      connectionInfo: WREN_AI_CONNECTION_INFO;
      mdl: Manifest;
      catalog?: string;
      schema?: string;
    },
  ) => Promise<WrenSQL>;
  getVersion: (
    dataSource: DataSourceName,
    connectionInfo: WREN_AI_CONNECTION_INFO,
  ) => Promise<string>;
}

export interface IbisResponse {
  correlationId?: string;
  processTime?: string;
}

export interface IbisQueryResponse extends IbisResponse {
  columns: string[];
  data: any[];
  dtypes: Record<string, string>;
  cacheHit?: boolean;
  cacheCreatedAt?: string;
  cacheOverrodeAt?: string;
  override?: boolean;
}

export interface DryRunResponse extends IbisResponse {}

enum IBIS_API_TYPE {
  QUERY = 'QUERY',
  DRY_RUN = 'DRY_RUN',
  DRY_PLAN = 'DRY_PLAN',
  METADATA = 'METADATA',
  VALIDATION = 'VALIDATION',
  ANALYSIS = 'ANALYSIS',
  MODEL_SUBSTITUTE = 'MODEL_SUBSTITUTE',
}

export class IbisAdaptor implements IIbisAdaptor {
  private ibisServerEndpoint: string;

  constructor({ ibisServerEndpoint }: { ibisServerEndpoint: string }) {
    this.ibisServerEndpoint = ibisServerEndpoint;
  }
  public async getNativeSql(options: IbisDryPlanOptions): Promise<string> {
    const { dataSource, mdl, sql } = options;
    const body = {
      sql,
      manifestStr: Buffer.from(JSON.stringify(mdl)).toString('base64'),
    };
    try {
      const res = await axios.post(
        `${this.ibisServerEndpoint}/${this.getIbisApiVersion(IBIS_API_TYPE.DRY_PLAN)}/connector/${dataSourceUrlMap[dataSource]}/dry-plan`,
        body,
      );
      return res.data;
    } catch (e) {
      logger.debug(`Dry plan error: ${e.response?.data || e.message}`);
      this.throwError(e, 'Error during dry plan execution');
    }
  }

  public async query(
    query: string,
    options: IbisQueryOptions,
  ): Promise<IbisQueryResponse> {
    const { dataSource, mdl } = options;
    const connectionInfo = this.updateConnectionInfo(options.connectionInfo);
    const ibisConnectionInfo = toIbisConnectionInfo(dataSource, connectionInfo);
    const queryString = this.buildQueryString(options);
    const body = {
      sql: query,
      connectionInfo: ibisConnectionInfo,
      manifestStr: Buffer.from(JSON.stringify(mdl)).toString('base64'),
    };
    try {
      const res = await axios.post(
        `${this.ibisServerEndpoint}/${this.getIbisApiVersion(IBIS_API_TYPE.QUERY)}/connector/${dataSourceUrlMap[dataSource]}/query${queryString}`,
        body,
        {
          params: {
            limit: options.limit || DEFAULT_PREVIEW_LIMIT,
          },
        },
      );
      return {
        ...res.data,
        correlationId: res.headers['x-correlation-id'],
        processTime: res.headers['x-process-time'],
        cacheHit: res.headers['x-cache-hit'] === 'true',
        cacheCreatedAt:
          res.headers['x-cache-create-at'] &&
          new Date(parseInt(res.headers['x-cache-create-at'])).toISOString(),
        cacheOverrodeAt:
          res.headers['x-cache-override-at'] &&
          new Date(parseInt(res.headers['x-cache-override-at'])).toISOString(),
        override: res.headers['x-cache-override'] === 'true',
      };
    } catch (e) {
      logger.debug(`Query error: ${e.response?.data || e.message}`);
      this.throwError(e, 'Error querying ibis server');
    }
  }

  public async dryRun(
    query: string,
    options: IbisQueryOptions,
  ): Promise<DryRunResponse> {
    const { dataSource, mdl } = options;
    const connectionInfo = this.updateConnectionInfo(options.connectionInfo);
    const ibisConnectionInfo = toIbisConnectionInfo(dataSource, connectionInfo);
    const body = {
      sql: query,
      connectionInfo: ibisConnectionInfo,
      manifestStr: Buffer.from(JSON.stringify(mdl)).toString('base64'),
    };
    logger.debug(`Dry run sql from ibis with body:`);
    try {
      const response = await axios.post(
        `${this.ibisServerEndpoint}/${this.getIbisApiVersion(IBIS_API_TYPE.DRY_RUN)}/connector/${dataSourceUrlMap[dataSource]}/query?dryRun=true`,
        body,
      );
      logger.debug(`Ibis server Dry run success`);
      return {
        correlationId: response.headers['x-correlation-id'],
        processTime: response.headers['x-process-time'],
      };
    } catch (err) {
      logger.debug(`Dry run error: ${err.response?.data || err.message}`);
      this.throwError(err, 'Error during dry run execution');
    }
  }

  public async getTables(
    dataSource: DataSourceName,
    connectionInfo: WREN_AI_CONNECTION_INFO,
  ): Promise<CompactTable[]> {
    try {
      const getTablesByConnectionInfo = async (ibisConnectionInfo) => {
        const body = {
          connectionInfo: ibisConnectionInfo,
        };
        logger.debug(`Getting tables from ibis`);
        const res: AxiosResponse<CompactTable[]> = await axios.post(
          `${this.ibisServerEndpoint}/${this.getIbisApiVersion(IBIS_API_TYPE.METADATA)}/connector/${dataSourceUrlMap[dataSource]}/metadata/tables`,
          body,
        );

        return this.transformDescriptionToProperties(res.data);
      };

      connectionInfo = this.updateConnectionInfo(connectionInfo);

      // If the dataSource supports multiple connection info, we need to get tables from each connection info
      const multipleIbisConnectionInfos = toMultipleIbisConnectionInfos(
        dataSource,
        connectionInfo,
      );
      if (multipleIbisConnectionInfos) {
        const results = await Promise.all(
          multipleIbisConnectionInfos.map(getTablesByConnectionInfo),
        );
        return results.flat();
      }

      // If the dataSource does not support multiple connection info, we only need to get tables from one connection info
      const ibisConnectionInfo = toIbisConnectionInfo(
        dataSource,
        connectionInfo,
      );
      return await getTablesByConnectionInfo(ibisConnectionInfo);
    } catch (e) {
      logger.debug(`Get tables error: ${e.response?.data || e.message}`);
      this.throwError(e, 'Error getting table from ibis server');
    }
  }

  public async getConstraints(
    dataSource: DataSourceName,
    connectionInfo: WREN_AI_CONNECTION_INFO,
  ): Promise<RecommendConstraint[]> {
    connectionInfo = this.updateConnectionInfo(connectionInfo);
    const ibisConnectionInfo = toIbisConnectionInfo(dataSource, connectionInfo);
    const body = {
      connectionInfo: ibisConnectionInfo,
    };
    try {
      logger.debug(`Getting constraint from ibis`);
      const res: AxiosResponse<RecommendConstraint[]> = await axios.post(
        `${this.ibisServerEndpoint}/${this.getIbisApiVersion(IBIS_API_TYPE.METADATA)}/connector/${dataSourceUrlMap[dataSource]}/metadata/constraints`,
        body,
      );
      return res.data;
    } catch (e) {
      logger.debug(`Get constraints error: ${e.response?.data || e.message}`);
      this.throwError(e, 'Error getting constraint from ibis server');
    }
  }

  public async validate(
    dataSource: DataSourceName,
    validationRule: ValidationRules,
    connectionInfo: WREN_AI_CONNECTION_INFO,
    mdl: Manifest,
    parameters: Record<string, any>,
  ): Promise<ValidationResponse> {
    connectionInfo = this.updateConnectionInfo(connectionInfo);
    const ibisConnectionInfo = toIbisConnectionInfo(dataSource, connectionInfo);
    const body = {
      connectionInfo: ibisConnectionInfo,
      manifestStr: Buffer.from(JSON.stringify(mdl)).toString('base64'),
      parameters,
    };
    try {
      logger.debug(`Run validation rule "${validationRule}" with ibis`);
      await axios.post(
        `${this.ibisServerEndpoint}/${this.getIbisApiVersion(IBIS_API_TYPE.VALIDATION)}/connector/${dataSourceUrlMap[dataSource]}/validate/${snakeCase(validationRule)}`,
        body,
      );
      return { valid: true, message: null };
    } catch (e) {
      logger.debug(`Validation error: ${e.response?.data || e.message}`);
      return { valid: false, message: e.response?.data || e.message };
    }
  }

  public async modelSubstitute(
    sql: DialectSQL,
    options: {
      dataSource: DataSourceName;
      connectionInfo: WREN_AI_CONNECTION_INFO;
      mdl: Manifest;
      catalog?: string;
      schema?: string;
    },
  ): Promise<WrenSQL> {
    const { dataSource, mdl, catalog, schema } = options;
    let connectionInfo = options.connectionInfo;
    connectionInfo = this.updateConnectionInfo(connectionInfo);
    const headers = {
      'X-User-CATALOG': catalog,
      'X-User-SCHEMA': schema,
    };
    const ibisConnectionInfo = toIbisConnectionInfo(dataSource, connectionInfo);
    const body = {
      sql,
      connectionInfo: ibisConnectionInfo,
      manifestStr: Buffer.from(JSON.stringify(mdl)).toString('base64'),
    };
    try {
      logger.debug(`Running model substitution with ibis`);
      const res = await axios.post(
        `${this.ibisServerEndpoint}/${this.getIbisApiVersion(IBIS_API_TYPE.MODEL_SUBSTITUTE)}/connector/${dataSourceUrlMap[dataSource]}/model-substitute`,
        body,
        {
          headers,
        },
      );
      return res.data as WrenSQL;
    } catch (e) {
      logger.debug(
        `Model substitution error: ${e.response?.data || e.message}`,
      );
      this.throwError(
        e,
        'Error running model substitution with ibis server',
        this.modelSubstituteErrorMessageBuilder,
      );
    }
  }

  public async getVersion(
    dataSource: DataSourceName,
    connectionInfo: WREN_AI_CONNECTION_INFO,
  ): Promise<string> {
    connectionInfo = this.updateConnectionInfo(connectionInfo);
    const ibisConnectionInfo = toIbisConnectionInfo(dataSource, connectionInfo);
    const body = {
      connectionInfo: ibisConnectionInfo,
    };
    try {
      logger.debug(`Getting version from ibis`);
      const res: AxiosResponse<string> = await axios.post(
        `${this.ibisServerEndpoint}/${this.getIbisApiVersion(IBIS_API_TYPE.METADATA)}/connector/${dataSourceUrlMap[dataSource]}/metadata/version`,
        body,
      );
      return res.data;
    } catch (e) {
      logger.debug(`Get version error: ${e.response?.data || e.message}`);
      this.throwError(e, 'Error getting version from ibis server');
    }
  }

  private updateConnectionInfo(connectionInfo: any) {
    if (
      config.otherServiceUsingDocker &&
      Object.hasOwnProperty.call(connectionInfo, 'host')
    ) {
      connectionInfo.host = toDockerHost(connectionInfo.host);
      logger.debug(`Host replaced with docker host`);
    }
    return connectionInfo;
  }

  private transformDescriptionToProperties(
    tables: CompactTable[],
  ): CompactTable[] {
    const handleColumnProperties = (column: CompactColumn): CompactColumn => {
      const properties = column?.properties || {};
      if (column.description) {
        properties.description = column.description;
      }
      const nestedColumns = column.nestedColumns?.map((nc) => {
        return handleColumnProperties(nc);
      });
      return { ...column, properties, nestedColumns };
    };

    return tables.map((table) => {
      try {
        const properties = table?.properties || {};
        if (table.description) {
          properties.description = table.description;
        }
        if (table.columns) {
          const transformedColumns = table.columns.map((column) =>
            handleColumnProperties(column),
          );
          table.columns = transformedColumns;
        }
        return { ...table, properties };
      } catch (e) {
        console.log('e', e);
      }
    });
  }

  private getIbisApiVersion(apiType: IBIS_API_TYPE) {
    if (!config.experimentalEngineRustVersion) {
      return 'v2';
    }
    const useV3 = [
      IBIS_API_TYPE.QUERY,
      IBIS_API_TYPE.DRY_RUN,
      IBIS_API_TYPE.DRY_PLAN,
      IBIS_API_TYPE.VALIDATION,
      IBIS_API_TYPE.MODEL_SUBSTITUTE,
    ].includes(apiType);
    if (useV3) logger.debug('Using ibis v3 api');
    return useV3 ? 'v3' : 'v2';
  }

  private throwError(
    e: any,
    defaultMessage: string,
    errorMessageBuilder?: CallableFunction,
  ) {
    const customMessage =
      e.response?.data?.message ||
      e.response?.data ||
      e.message ||
      defaultMessage;
    throw Errors.create(Errors.GeneralErrorCodes.IBIS_SERVER_ERROR, {
      customMessage: errorMessageBuilder
        ? errorMessageBuilder(customMessage)
        : customMessage,
      originalError: e,
      other: {
        correlationId: e.response?.headers['x-correlation-id'],
        processTime: e.response?.headers['x-process-time'],
      },
    });
  }

  private modelSubstituteErrorMessageBuilder(message: string) {
    const ModelSubstituteErrorEnum = {
      MODEL_NOT_FOUND: () => {
        return message.includes('Model not found');
      },
      PARSING_EXCEPTION: () => {
        return message.includes('sql.parser.ParsingException');
      },
    };
    if (ModelSubstituteErrorEnum.MODEL_NOT_FOUND()) {
      const modelName = message.split(': ')[1];
      const dotCount = modelName.split('.').length - 1;
      switch (dotCount) {
        case 0:
          return (
            message +
            `. Try adding both catalog and schema before your table name. e.g. my_database.public.${modelName}`
          );
        case 1:
          return (
            message +
            `. Try adding the catalog before the schema in your table name. e.g. my_database.${modelName}`
          );
        case 2:
          return (
            message +
            `. It may be missing from models, misnamed, or have a case mismatch.`
          );
        default:
          return (
            message +
            `. It may be missing from models, misnamed, or have a case mismatch.`
          );
      }
    } else if (ModelSubstituteErrorEnum.PARSING_EXCEPTION()) {
      return (
        message +
        '. Please check your selected column and make sure its quoted for columns with non-alphanumeric characters.'
      );
    }
    return message;
  }

  private buildQueryString(options: IbisQueryOptions) {
    if (!options.cacheEnabled) {
      return '';
    }
    const queryString = [];
    queryString.push('cacheEnable=true');
    if (options.refresh) {
      queryString.push('overrideCache=true');
    }
    return `?${queryString.join('&')}`;
  }
}
</file>

<file path="src/apollo/server/adaptors/index.ts">
export * from './ibisAdaptor';
export * from './wrenAIAdaptor';
export * from './wrenEngineAdaptor';
</file>

<file path="src/apollo/server/adaptors/tests/ibisAdaptor.test.ts">
import axios from 'axios';
import {
  DryRunResponse,
  IbisAdaptor,
  IbisQueryOptions,
  IbisQueryResponse,
  ValidationRules,
} from '../ibisAdaptor';
import { DataSourceName } from '../../types';
import { Manifest } from '../../mdl/type';
import { DialectSQL } from '../../models/adaptor';
import {
  BIG_QUERY_CONNECTION_INFO,
  CLICK_HOUSE_CONNECTION_INFO,
  MS_SQL_CONNECTION_INFO,
  MYSQL_CONNECTION_INFO,
  POSTGRES_CONNECTION_INFO,
  TRINO_CONNECTION_INFO,
  SNOWFLAKE_CONNECTION_INFO,
} from '../../repositories';
import { snakeCase } from 'lodash';
import { Encryptor } from '../../utils';
import { DEFAULT_PREVIEW_LIMIT } from '../../services';

jest.mock('axios');
jest.mock('@server/utils/encryptor');
const mockedAxios = axios as jest.Mocked<typeof axios>;
// mock encryptor
const mockedEncryptor = Encryptor as jest.MockedClass<typeof Encryptor>;

describe('IbisAdaptor', () => {
  let ibisAdaptor: IbisAdaptor;
  const ibisServerEndpoint = 'http://localhost:8080';

  const mockMSSQLConnectionInfo: MS_SQL_CONNECTION_INFO = {
    host: 'localhost',
    port: 1433,
    database: 'my-database',
    user: 'my-user',
    password: 'my-password',
    trustServerCertificate: false,
  };

  const mockMySQLConnectionInfo: MYSQL_CONNECTION_INFO = {
    host: 'localhost',
    port: 3306,
    database: 'my-database',
    user: 'my-user',
    password: 'my-password',
    ssl: false,
  };

  const mockPostgresConnectionInfo: POSTGRES_CONNECTION_INFO = {
    host: 'localhost',
    port: 5432,
    database: 'my-database',
    user: 'my-user',
    password: 'my-password',
    ssl: true,
  };

  const mockClickHouseConnectionInfo: CLICK_HOUSE_CONNECTION_INFO = {
    host: 'my-host',
    port: 8443,
    database: 'my-database',
    user: 'my-user',
    password: 'my-password',
    ssl: true,
  };
  const { host, port, database, user, password } = mockPostgresConnectionInfo;
  const postgresConnectionUrl = `postgresql://${user}:${password}@${host}:${port}/${database}?sslmode=require`;

  const mockBigQueryConnectionInfo: BIG_QUERY_CONNECTION_INFO = {
    projectId: 'my-bq-project-id',
    datasetId: 'my-bq-dataset-id',
    credentials: 'encrypted-credential-string',
  };

  const mockTrinoConnectionInfo: TRINO_CONNECTION_INFO = {
    schemas: 'my-catalog.my-schema',
    host: 'localhost',
    port: 5450,
    password: 'my-password',
    ssl: true,
    username: 'my-username',
  };

  const mockSnowflakeConnectionInfo: SNOWFLAKE_CONNECTION_INFO = {
    user: 'my-user',
    password: 'my-password',
    account: 'my-account',
    database: 'my-database',
    schema: 'my-schema',
  };

  const mockManifest: Manifest = {
    catalog: 'wrenai', // eg: "test-catalog"
    schema: 'wrenai', // eg: "test-schema"
    models: [
      {
        name: 'test_table',
        tableReference: {
          catalog: 'wrenai',
          schema: 'wrenai',
          table: 'test_table',
        },
        properties: {
          description: 'test table',
        },
        columns: [
          {
            name: 'id',
            type: 'integer',
            properties: {},
            isCalculated: false,
          },
          {
            name: 'sumId',
            type: 'float',
            properties: {},
            isCalculated: true,
            expression: 'SUM(id)',
          },
        ],
        cached: false,
      },
    ],
    relationships: [],
    views: [],
  };

  beforeEach(() => {
    ibisAdaptor = new IbisAdaptor({
      ibisServerEndpoint: ibisServerEndpoint,
    });
  });

  afterEach(() => {
    jest.resetAllMocks();
  });

  it('should get mssql constraints', async () => {
    const mockResponse = { data: [] };
    mockedAxios.post.mockResolvedValue(mockResponse);
    // mock decrypt method in Encryptor to return the same password
    mockedEncryptor.prototype.decrypt.mockReturnValue(
      JSON.stringify({ password: mockMSSQLConnectionInfo.password }),
    );

    const result = await ibisAdaptor.getConstraints(
      DataSourceName.MSSQL,
      mockMSSQLConnectionInfo,
    );
    const expectConnectionInfo = Object.entries(mockMSSQLConnectionInfo).reduce(
      (acc, [key, value]) => {
        if (key === 'trustServerCertificate') {
          if (value) {
            acc['kwargs'] = { trustServerCertificate: 'YES' };
            return acc;
          }
        } else {
          acc[snakeCase(key)] = value;
        }
        return acc;
      },
      {},
    );

    expect(result).toEqual([]);
    expect(mockedAxios.post).toHaveBeenCalledWith(
      `${ibisServerEndpoint}/v2/connector/mssql/metadata/constraints`,
      { connectionInfo: expectConnectionInfo },
    );
  });

  it('should get mysql constraints', async () => {
    const mockResponse = { data: [] };
    mockedAxios.post.mockResolvedValue(mockResponse);
    // mock decrypt method in Encryptor to return the same password
    mockedEncryptor.prototype.decrypt.mockReturnValue(
      JSON.stringify({ password: mockMySQLConnectionInfo.password }),
    );

    const result = await ibisAdaptor.getConstraints(
      DataSourceName.MYSQL,
      mockMySQLConnectionInfo,
    );
    const expectConnectionInfo = Object.entries(mockMySQLConnectionInfo).reduce(
      (acc, [key, value]) => ((acc[snakeCase(key)] = value), acc),
      {},
    );

    expect(result).toEqual([]);
    expect(mockedAxios.post).toHaveBeenCalledWith(
      `${ibisServerEndpoint}/v2/connector/mysql/metadata/constraints`,
      { connectionInfo: expectConnectionInfo },
    );
  });

  // check clickhouse connection info
  it.each([
    [
      {
        host: 'my-host',
        port: 8443,
        database: 'my-database',
        user: 'my-user',
        password: 'my-password',
        ssl: true,
      },
      `clickhouse://my-user:my-password@my-host:8443/my-database?secure=1`,
    ],
    [
      {
        host: 'my-host',
        port: 8443,
        database: 'my-database',
        user: 'my-user',
        password: 'my-password',
        ssl: false,
      },
      `clickhouse://my-user:my-password@my-host:8443/my-database?`,
    ],
  ])(
    'should get correct clickhouse connection info',
    async (connectionInfo, expectConnectionUrl) => {
      const mockResponse = { data: [] };
      mockedAxios.post.mockResolvedValue(mockResponse);
      // mock decrypt method in Encryptor to return the same password
      mockedEncryptor.prototype.decrypt.mockReturnValue(
        JSON.stringify({ password: connectionInfo.password }),
      );

      const result = await ibisAdaptor.getConstraints(
        DataSourceName.CLICK_HOUSE,
        connectionInfo,
      );
      const expectConnectionInfo = {
        connectionUrl: expectConnectionUrl,
      };

      expect(result).toEqual([]);
      expect(mockedAxios.post).toHaveBeenCalledWith(
        `${ibisServerEndpoint}/v2/connector/clickhouse/metadata/constraints`,
        { connectionInfo: expectConnectionInfo },
      );
    },
  );

  it('should get trino constraints', async () => {
    const mockResponse = { data: [] };
    mockedAxios.post.mockResolvedValue(mockResponse);

    mockedEncryptor.prototype.decrypt.mockReturnValue(
      JSON.stringify({ password: mockTrinoConnectionInfo.password }),
    );

    const result = await ibisAdaptor.getConstraints(
      DataSourceName.TRINO,
      mockTrinoConnectionInfo,
    );

    const { username, host, password, port, schemas } = mockTrinoConnectionInfo;
    const schemasArray = schemas.split(',');
    const [catalog, schema] = schemasArray[0].split('.');
    const expectConnectionInfo = {
      catalog,
      host: `https://${host}`,
      password,
      port,
      schema,
      user: username,
    };

    expect(result).toEqual([]);
    expect(mockedAxios.post).toHaveBeenCalledWith(
      `${ibisServerEndpoint}/v2/connector/trino/metadata/constraints`,
      { connectionInfo: expectConnectionInfo },
    );
  });

  it('should get snowflake constraints', async () => {
    const mockResponse = { data: [] };
    mockedAxios.post.mockResolvedValue(mockResponse);
    // mock decrypt method in Encryptor to return the same password
    mockedEncryptor.prototype.decrypt.mockReturnValue(
      JSON.stringify({ password: mockSnowflakeConnectionInfo.password }),
    );

    const result = await ibisAdaptor.getConstraints(
      DataSourceName.SNOWFLAKE,
      mockSnowflakeConnectionInfo,
    );
    const expectConnectionInfo = Object.entries(
      mockSnowflakeConnectionInfo,
    ).reduce((acc, [key, value]) => ((acc[snakeCase(key)] = value), acc), {});

    expect(result).toEqual([]);
    expect(mockedAxios.post).toHaveBeenCalledWith(
      `${ibisServerEndpoint}/v2/connector/snowflake/metadata/constraints`,
      { connectionInfo: expectConnectionInfo },
    );
  });

  it('should get click house constraints', async () => {
    const mockResponse = { data: [] };
    mockedAxios.post.mockResolvedValue(mockResponse);
    // mock decrypt method in Encryptor to return the same password
    mockedEncryptor.prototype.decrypt.mockReturnValue(
      JSON.stringify({ password: mockClickHouseConnectionInfo.password }),
    );

    const result = await ibisAdaptor.getConstraints(
      DataSourceName.CLICK_HOUSE,
      mockClickHouseConnectionInfo,
    );
    const { user, password, host, port, database, ssl } =
      mockClickHouseConnectionInfo;
    const expectConnectionInfo = {
      connectionUrl: `clickhouse://${user}:${password}@${host}:${port}/${database}${ssl ? '?secure=1' : ''}`,
    };

    expect(result).toEqual([]);
    expect(mockedAxios.post).toHaveBeenCalledWith(
      `${ibisServerEndpoint}/v2/connector/clickhouse/metadata/constraints`,
      { connectionInfo: expectConnectionInfo },
    );
  });

  it('should get postgres constraints', async () => {
    const mockResponse = { data: [] };
    mockedAxios.post.mockResolvedValue(mockResponse);
    mockedEncryptor.prototype.decrypt.mockReturnValue(
      JSON.stringify({ password: mockPostgresConnectionInfo.password }),
    );

    const result = await ibisAdaptor.getConstraints(
      DataSourceName.POSTGRES,
      mockPostgresConnectionInfo,
    );

    expect(result).toEqual([]);
    expect(mockedAxios.post).toHaveBeenCalledWith(
      `${ibisServerEndpoint}/v2/connector/postgres/metadata/constraints`,
      {
        connectionInfo: {
          connectionUrl: postgresConnectionUrl,
        },
      },
    );
  });

  it('should get bigquery constraints', async () => {
    const mockResponse = { data: [] };
    mockedAxios.post.mockResolvedValue(mockResponse);
    mockedEncryptor.prototype.decrypt.mockReturnValue(
      JSON.stringify({ credentials: mockBigQueryConnectionInfo.credentials }),
    );
    const result = await ibisAdaptor.getConstraints(
      DataSourceName.BIG_QUERY,
      mockBigQueryConnectionInfo,
    );
    const expectConnectionInfo = Object.entries(
      mockBigQueryConnectionInfo,
    ).reduce((acc, [key, value]) => {
      if (key === 'credentials') {
        acc['credentials'] = Buffer.from(
          JSON.stringify(mockBigQueryConnectionInfo.credentials),
        ).toString('base64');
      } else {
        acc[snakeCase(key)] = value;
      }
      return acc;
    }, {});

    expect(result).toEqual([]);
    expect(mockedAxios.post).toHaveBeenCalledWith(
      `${ibisServerEndpoint}/v2/connector/bigquery/metadata/constraints`,
      { connectionInfo: expectConnectionInfo },
    );
  });

  it('should validate with rule COLUMN_IS_VALID', async () => {
    mockedAxios.post.mockResolvedValue(true);
    mockedEncryptor.prototype.decrypt.mockReturnValue(
      JSON.stringify({ password: mockPostgresConnectionInfo.password }),
    );

    const parameters = {
      modelName: 'test_table',
      columnName: 'sumId',
    };
    const result = await ibisAdaptor.validate(
      DataSourceName.POSTGRES,
      ValidationRules.COLUMN_IS_VALID,
      mockPostgresConnectionInfo,
      mockManifest,
      parameters,
    );

    expect(result).toEqual({ valid: true, message: null });
    expect(mockedAxios.post).toHaveBeenCalledWith(
      `${ibisServerEndpoint}/v3/connector/postgres/validate/column_is_valid`,
      {
        connectionInfo: { connectionUrl: postgresConnectionUrl },
        manifestStr: Buffer.from(JSON.stringify(mockManifest)).toString(
          'base64',
        ),
        parameters,
      },
    );
  });

  it('should handle error when validating', async () => {
    const mockError = { response: { data: 'Error' } };
    const parameters = {
      modelName: 'test_table',
      columnName: 'sumId',
    };
    mockedAxios.post.mockRejectedValue(mockError);
    mockedEncryptor.prototype.decrypt.mockReturnValue(
      JSON.stringify({ password: mockPostgresConnectionInfo.password }),
    );

    const result = await ibisAdaptor.validate(
      DataSourceName.POSTGRES,
      ValidationRules.COLUMN_IS_VALID,
      mockPostgresConnectionInfo,
      mockManifest,
      parameters,
    );

    expect(result).toEqual({ valid: false, message: 'Error' });
    expect(mockedAxios.post).toHaveBeenCalledWith(
      `${ibisServerEndpoint}/v3/connector/postgres/validate/column_is_valid`,
      {
        connectionInfo: { connectionUrl: postgresConnectionUrl },
        manifestStr: Buffer.from(JSON.stringify(mockManifest)).toString(
          'base64',
        ),
        parameters,
      },
    );
  });

  it('should get data, correlationId and processTime', async () => {
    mockedAxios.post.mockResolvedValue({
      data: {
        columns: [],
        data: [],
        dtypes: {},
      },
      headers: {
        'x-correlation-id': '123',
        'x-process-time': '1s',
      },
    });
    mockedEncryptor.prototype.decrypt.mockReturnValue(
      JSON.stringify({ password: mockPostgresConnectionInfo.password }),
    );

    const res: IbisQueryResponse = await ibisAdaptor.query(
      'SELECT * FROM test_table',
      {
        dataSource: DataSourceName.POSTGRES,
        connectionInfo: mockPostgresConnectionInfo,
        mdl: mockManifest,
        limit: 10,
      } as IbisQueryOptions,
    );

    expect(res.data).toEqual([]);
    expect(res.correlationId).toEqual('123');
    expect(res.processTime).toEqual('1s');
  });

  it('should handle query with cache-related headers', async () => {
    mockedAxios.post.mockResolvedValue({
      data: {
        columns: ['id'],
        data: [[1]],
        dtypes: { id: 'integer' },
      },
      headers: {
        'x-correlation-id': '123',
        'x-process-time': '1s',
        'x-cache-hit': 'true',
        'x-cache-create-at': '2024-01-01T00:00:00Z',
        'x-cache-override': 'false',
        'x-cache-override-at': '2024-01-01T00:00:00Z',
      },
    });
    mockedEncryptor.prototype.decrypt.mockReturnValue(
      JSON.stringify({ password: mockPostgresConnectionInfo.password }),
    );

    const res: IbisQueryResponse = await ibisAdaptor.query(
      'SELECT * FROM test_table',
      {
        dataSource: DataSourceName.POSTGRES,
        connectionInfo: mockPostgresConnectionInfo,
        mdl: mockManifest,
        cacheEnabled: true,
      } as IbisQueryOptions,
    );

    expect(res.data).toEqual([[1]]);
    expect(res.columns).toEqual(['id']);
    expect(res.dtypes).toEqual({ id: 'integer' });
    expect(res.cacheHit).toEqual(true);
    expect(new Date(res.cacheCreatedAt).getTime()).toBeGreaterThan(0);
    expect(res.override).toEqual(false);
    expect(new Date(res.cacheOverrodeAt).getTime()).toBeGreaterThan(0);
    expect(mockedAxios.post).toHaveBeenCalledWith(
      `${ibisServerEndpoint}/v3/connector/postgres/query?cacheEnable=true`,
      expect.any(Object),
      expect.any(Object),
    );
  });

  it('should handle query with cache refresh', async () => {
    mockedAxios.post.mockResolvedValue({
      data: {
        columns: ['id'],
        data: [[1]],
        dtypes: { id: 'integer' },
      },
      headers: {
        'x-correlation-id': '123',
        'x-process-time': '1s',
      },
    });
    mockedEncryptor.prototype.decrypt.mockReturnValue(
      JSON.stringify({ password: mockPostgresConnectionInfo.password }),
    );

    const res: IbisQueryResponse = await ibisAdaptor.query(
      'SELECT * FROM test_table',
      {
        dataSource: DataSourceName.POSTGRES,
        connectionInfo: mockPostgresConnectionInfo,
        mdl: mockManifest,
        cacheEnabled: true,
        refresh: true,
      } as IbisQueryOptions,
    );

    expect(res.data).toEqual([[1]]);
    expect(mockedAxios.post).toHaveBeenCalledWith(
      `${ibisServerEndpoint}/v3/connector/postgres/query?cacheEnable=true&overrideCache=true`,
      expect.any(Object),
      expect.any(Object),
    );
  });

  it('should use default limit when not specified', async () => {
    mockedAxios.post.mockResolvedValue({
      data: {
        columns: ['id'],
        data: [[1]],
        dtypes: { id: 'integer' },
      },
      headers: {
        'x-correlation-id': '123',
        'x-process-time': '1s',
      },
    });
    mockedEncryptor.prototype.decrypt.mockReturnValue(
      JSON.stringify({ password: mockPostgresConnectionInfo.password }),
    );

    await ibisAdaptor.query('SELECT * FROM test_table', {
      dataSource: DataSourceName.POSTGRES,
      connectionInfo: mockPostgresConnectionInfo,
      mdl: mockManifest,
    } as IbisQueryOptions);

    expect(mockedAxios.post).toHaveBeenCalledWith(
      expect.any(String),
      expect.any(Object),
      {
        params: {
          limit: DEFAULT_PREVIEW_LIMIT,
        },
      },
    );
  });

  it('should use custom limit when specified', async () => {
    mockedAxios.post.mockResolvedValue({
      data: {
        columns: ['id'],
        data: [[1]],
        dtypes: { id: 'integer' },
      },
      headers: {
        'x-correlation-id': '123',
        'x-process-time': '1s',
      },
    });
    mockedEncryptor.prototype.decrypt.mockReturnValue(
      JSON.stringify({ password: mockPostgresConnectionInfo.password }),
    );

    const customLimit = 50;
    await ibisAdaptor.query('SELECT * FROM test_table', {
      dataSource: DataSourceName.POSTGRES,
      connectionInfo: mockPostgresConnectionInfo,
      mdl: mockManifest,
      limit: customLimit,
    } as IbisQueryOptions);

    expect(mockedAxios.post).toHaveBeenCalledWith(
      expect.any(String),
      expect.any(Object),
      {
        params: {
          limit: customLimit,
        },
      },
    );
  });

  it('should throw an exception with correlationId and processTime when query fails', async () => {
    const mockError = {
      response: {
        data: 'Error message',
        headers: {
          'x-correlation-id': '123',
          'x-process-time': '1s',
        },
      },
    };
    mockedAxios.post.mockRejectedValue(mockError);
    mockedEncryptor.prototype.decrypt.mockReturnValue(
      JSON.stringify({ password: mockPostgresConnectionInfo.password }),
    );

    await expect(
      ibisAdaptor.query('SELECT * FROM test_table', {
        dataSource: DataSourceName.POSTGRES,
        connectionInfo: mockPostgresConnectionInfo,
        mdl: mockManifest,
        limit: 10,
      }),
    ).rejects.toMatchObject({
      message: 'Error message',
      extensions: {
        other: {
          correlationId: '123',
          processTime: '1s',
        },
      },
    });
  });

  it('should get data, correlationId and processTime when dry run succeeds', async () => {
    mockedAxios.post.mockResolvedValue({
      headers: {
        'x-correlation-id': '123',
        'x-process-time': '1s',
      },
    });
    mockedEncryptor.prototype.decrypt.mockReturnValue(
      JSON.stringify({ password: mockPostgresConnectionInfo.password }),
    );

    const res: DryRunResponse = await ibisAdaptor.dryRun(
      'SELECT * FROM test_table',
      {
        dataSource: DataSourceName.POSTGRES,
        connectionInfo: mockPostgresConnectionInfo,
        mdl: mockManifest,
      } as IbisQueryOptions,
    );

    expect(res.correlationId).toEqual('123');
    expect(res.processTime).toEqual('1s');
  });

  it('should throw an exception with correlationId and processTime when dry run fails', async () => {
    const mockError = {
      response: {
        data: 'Error message',
        headers: {
          'x-correlation-id': '123',
          'x-process-time': '1s',
        },
      },
    };
    mockedAxios.post.mockRejectedValue(mockError);
    mockedEncryptor.prototype.decrypt.mockReturnValue(
      JSON.stringify({ password: mockPostgresConnectionInfo.password }),
    );

    await expect(
      ibisAdaptor.dryRun('SELECT * FROM test_table', {
        dataSource: DataSourceName.POSTGRES,
        connectionInfo: mockPostgresConnectionInfo,
        mdl: mockManifest,
      }),
    ).rejects.toMatchObject({
      message: 'Error message',
      extensions: {
        other: {
          correlationId: '123',
          processTime: '1s',
        },
      },
    });
  });

  it('should successfully substitute SQL with model', async () => {
    const mockResponse = { data: 'SELECT * FROM substituted_table' };
    mockedAxios.post.mockResolvedValue(mockResponse);
    mockedEncryptor.prototype.decrypt.mockReturnValue(
      JSON.stringify({ password: mockPostgresConnectionInfo.password }),
    );

    const result = await ibisAdaptor.modelSubstitute(
      'SELECT * FROM test_table' as DialectSQL,
      {
        dataSource: DataSourceName.POSTGRES,
        connectionInfo: mockPostgresConnectionInfo,
        mdl: mockManifest,
      },
    );

    expect(result).toEqual('SELECT * FROM substituted_table');
    expect(mockedAxios.post).toHaveBeenCalledWith(
      `${ibisServerEndpoint}/v3/connector/postgres/model-substitute`,
      {
        sql: 'SELECT * FROM test_table',
        connectionInfo: { connectionUrl: postgresConnectionUrl },
        manifestStr: Buffer.from(JSON.stringify(mockManifest)).toString(
          'base64',
        ),
      },
      {
        headers: {
          'X-User-CATALOG': undefined,
          'X-User-SCHEMA': undefined,
        },
      },
    );
  });

  it('should handle error when model substitution fails with MODEL_NOT_FOUND', async () => {
    const mockError = {
      response: {
        data: 'Model not found: test_table',
        headers: {
          'x-correlation-id': '123',
          'x-process-time': '1s',
        },
      },
    };
    mockedAxios.post.mockRejectedValue(mockError);
    mockedEncryptor.prototype.decrypt.mockReturnValue(
      JSON.stringify({ password: mockPostgresConnectionInfo.password }),
    );

    await expect(
      ibisAdaptor.modelSubstitute('SELECT * FROM test_table' as DialectSQL, {
        dataSource: DataSourceName.POSTGRES,
        connectionInfo: mockPostgresConnectionInfo,
        mdl: mockManifest,
      }),
    ).rejects.toMatchObject({
      message:
        'Model not found: test_table. Try adding both catalog and schema before your table name. e.g. my_database.public.test_table',
      extensions: {
        other: {
          correlationId: '123',
          processTime: '1s',
        },
      },
    });
  });

  it('should handle error when model substitution fails with MODEL_NOT_FOUND and one dot in model name', async () => {
    const mockError = {
      response: {
        data: 'Model not found: public.test_table',
        headers: {
          'x-correlation-id': '123',
          'x-process-time': '1s',
        },
      },
    };
    mockedAxios.post.mockRejectedValue(mockError);
    mockedEncryptor.prototype.decrypt.mockReturnValue(
      JSON.stringify({ password: mockPostgresConnectionInfo.password }),
    );

    await expect(
      ibisAdaptor.modelSubstitute(
        'SELECT * FROM public.test_table' as DialectSQL,
        {
          dataSource: DataSourceName.POSTGRES,
          connectionInfo: mockPostgresConnectionInfo,
          mdl: mockManifest,
        },
      ),
    ).rejects.toMatchObject({
      message:
        'Model not found: public.test_table. Try adding the catalog before the schema in your table name. e.g. my_database.public.test_table',
      extensions: {
        other: {
          correlationId: '123',
          processTime: '1s',
        },
      },
    });
  });

  it('should handle error when model substitution fails with MODEL_NOT_FOUND and two dots in model name', async () => {
    const mockError = {
      response: {
        data: 'Model not found: my_database.public.test_table',
        headers: {
          'x-correlation-id': '123',
          'x-process-time': '1s',
        },
      },
    };
    mockedAxios.post.mockRejectedValue(mockError);
    mockedEncryptor.prototype.decrypt.mockReturnValue(
      JSON.stringify({ password: mockPostgresConnectionInfo.password }),
    );

    await expect(
      ibisAdaptor.modelSubstitute(
        'SELECT * FROM my_database.public.test_table' as DialectSQL,
        {
          dataSource: DataSourceName.POSTGRES,
          connectionInfo: mockPostgresConnectionInfo,
          mdl: mockManifest,
        },
      ),
    ).rejects.toMatchObject({
      message:
        'Model not found: my_database.public.test_table. It may be missing from models, misnamed, or have a case mismatch.',
      extensions: {
        other: {
          correlationId: '123',
          processTime: '1s',
        },
      },
    });
  });

  it('should handle error when model substitution fails with MODEL_NOT_FOUND and more than two dots in model name', async () => {
    const mockError = {
      response: {
        data: 'Model not found: my_database.public.schema.test_table',
        headers: {
          'x-correlation-id': '123',
          'x-process-time': '1s',
        },
      },
    };
    mockedAxios.post.mockRejectedValue(mockError);
    mockedEncryptor.prototype.decrypt.mockReturnValue(
      JSON.stringify({ password: mockPostgresConnectionInfo.password }),
    );

    await expect(
      ibisAdaptor.modelSubstitute(
        'SELECT * FROM my_database.public.schema.test_table' as DialectSQL,
        {
          dataSource: DataSourceName.POSTGRES,
          connectionInfo: mockPostgresConnectionInfo,
          mdl: mockManifest,
        },
      ),
    ).rejects.toMatchObject({
      message:
        'Model not found: my_database.public.schema.test_table. It may be missing from models, misnamed, or have a case mismatch.',
      extensions: {
        other: {
          correlationId: '123',
          processTime: '1s',
        },
      },
    });
  });

  it('should handle error when model substitution fails with PARSING_EXCEPTION', async () => {
    const mockError = {
      response: {
        data: 'sql.parser.ParsingException: Invalid SQL syntax',
        headers: {
          'x-correlation-id': '123',
          'x-process-time': '1s',
        },
      },
    };
    mockedAxios.post.mockRejectedValue(mockError);
    mockedEncryptor.prototype.decrypt.mockReturnValue(
      JSON.stringify({ password: mockPostgresConnectionInfo.password }),
    );

    await expect(
      ibisAdaptor.modelSubstitute('SELECT * FROM test_table' as DialectSQL, {
        dataSource: DataSourceName.POSTGRES,
        connectionInfo: mockPostgresConnectionInfo,
        mdl: mockManifest,
      }),
    ).rejects.toMatchObject({
      message:
        'sql.parser.ParsingException: Invalid SQL syntax. Please check your selected column and make sure its quoted for columns with non-alphanumeric characters.',
      extensions: {
        other: {
          correlationId: '123',
          processTime: '1s',
        },
      },
    });
  });

  it('should handle error when model substitution fails with generic error', async () => {
    const mockError = {
      response: {
        data: 'Generic error occurred',
        headers: {
          'x-correlation-id': '123',
          'x-process-time': '1s',
        },
      },
    };
    mockedAxios.post.mockRejectedValue(mockError);
    mockedEncryptor.prototype.decrypt.mockReturnValue(
      JSON.stringify({ password: mockPostgresConnectionInfo.password }),
    );

    await expect(
      ibisAdaptor.modelSubstitute('SELECT * FROM test_table' as DialectSQL, {
        dataSource: DataSourceName.POSTGRES,
        connectionInfo: mockPostgresConnectionInfo,
        mdl: mockManifest,
      }),
    ).rejects.toMatchObject({
      message: 'Generic error occurred',
      extensions: {
        other: {
          correlationId: '123',
          processTime: '1s',
        },
      },
    });
  });

  it('should include catalog and schema in headers when provided', async () => {
    const mockResponse = { data: 'SELECT * FROM substituted_table' };
    mockedAxios.post.mockResolvedValue(mockResponse);
    mockedEncryptor.prototype.decrypt.mockReturnValue(
      JSON.stringify({ password: mockPostgresConnectionInfo.password }),
    );

    const catalog = 'my_catalog';
    const schema = 'my_schema';

    const result = await ibisAdaptor.modelSubstitute(
      'SELECT * FROM test_table' as DialectSQL,
      {
        dataSource: DataSourceName.POSTGRES,
        connectionInfo: mockPostgresConnectionInfo,
        mdl: mockManifest,
        catalog,
        schema,
      },
    );

    expect(result).toEqual('SELECT * FROM substituted_table');
    expect(mockedAxios.post).toHaveBeenCalledWith(
      `${ibisServerEndpoint}/v3/connector/postgres/model-substitute`,
      {
        sql: 'SELECT * FROM test_table',
        connectionInfo: { connectionUrl: postgresConnectionUrl },
        manifestStr: Buffer.from(JSON.stringify(mockManifest)).toString(
          'base64',
        ),
      },
      {
        headers: {
          'X-User-CATALOG': catalog,
          'X-User-SCHEMA': schema,
        },
      },
    );
  });

  it('should get version successfully', async () => {
    const mockVersion = '1.2.3';
    mockedAxios.post.mockResolvedValue({ data: mockVersion });
    mockedEncryptor.prototype.decrypt.mockReturnValue(
      JSON.stringify({ password: mockPostgresConnectionInfo.password }),
    );

    const result = await ibisAdaptor.getVersion(
      DataSourceName.POSTGRES,
      mockPostgresConnectionInfo,
    );

    expect(result).toEqual(mockVersion);
    expect(mockedAxios.post).toHaveBeenCalledWith(
      `${ibisServerEndpoint}/v2/connector/postgres/metadata/version`,
      {
        connectionInfo: { connectionUrl: postgresConnectionUrl },
      },
    );
  });

  it('should throw an error when getting version fails', async () => {
    const mockError = {
      response: {
        data: 'Failed to get version',
        headers: {
          'x-correlation-id': '123',
          'x-process-time': '1s',
        },
      },
    };
    mockedAxios.post.mockRejectedValue(mockError);
    mockedEncryptor.prototype.decrypt.mockReturnValue(
      JSON.stringify({ password: mockPostgresConnectionInfo.password }),
    );

    await expect(
      ibisAdaptor.getVersion(
        DataSourceName.POSTGRES,
        mockPostgresConnectionInfo,
      ),
    ).rejects.toMatchObject({
      message: 'Failed to get version',
      extensions: {
        other: {
          correlationId: '123',
          processTime: '1s',
        },
      },
    });
  });

  it('should get version for different data sources', async () => {
    const mockVersion = '1.2.3';
    mockedAxios.post.mockResolvedValue({ data: mockVersion });

    // Test BigQuery
    mockedEncryptor.prototype.decrypt.mockReturnValue(
      JSON.stringify({ credentials: mockBigQueryConnectionInfo.credentials }),
    );

    const bigQueryResult = await ibisAdaptor.getVersion(
      DataSourceName.BIG_QUERY,
      mockBigQueryConnectionInfo,
    );

    expect(bigQueryResult).toEqual(mockVersion);
    expect(mockedAxios.post).toHaveBeenCalledWith(
      `${ibisServerEndpoint}/v2/connector/bigquery/metadata/version`,
      {
        connectionInfo: {
          project_id: mockBigQueryConnectionInfo.projectId,
          dataset_id: mockBigQueryConnectionInfo.datasetId,
          credentials: Buffer.from(
            JSON.stringify(mockBigQueryConnectionInfo.credentials),
          ).toString('base64'),
        },
      },
    );

    // Test Snowflake
    mockedEncryptor.prototype.decrypt.mockReturnValue(
      JSON.stringify({ password: mockSnowflakeConnectionInfo.password }),
    );

    const snowflakeResult = await ibisAdaptor.getVersion(
      DataSourceName.SNOWFLAKE,
      mockSnowflakeConnectionInfo,
    );

    expect(snowflakeResult).toEqual(mockVersion);
    expect(mockedAxios.post).toHaveBeenCalledWith(
      `${ibisServerEndpoint}/v2/connector/snowflake/metadata/version`,
      {
        connectionInfo: {
          user: mockSnowflakeConnectionInfo.user,
          password: mockSnowflakeConnectionInfo.password,
          account: mockSnowflakeConnectionInfo.account,
          database: mockSnowflakeConnectionInfo.database,
          schema: mockSnowflakeConnectionInfo.schema,
        },
      },
    );
  });
});
</file>

<file path="src/apollo/server/adaptors/tests/wrenAIAdaptor.test.ts">
import axios from 'axios';
import { WrenAIAdaptor } from '../wrenAIAdaptor';
import {
  RecommendationQuestionsInput,
  RecommendationQuestionStatus,
} from '@server/models/adaptor';
import { Manifest } from '../../mdl/type';

jest.mock('axios');
const mockedAxios = axios as jest.Mocked<typeof axios>;

const sampleManifest: Manifest = {
  models: [
    {
      name: 'model1',
      columns: [
        {
          name: 'column1',
          type: 'string',
          isCalculated: false,
        },
      ],
    },
  ],
};

describe('WrenAIAdaptor', () => {
  const baseEndpoint = 'http://test-endpoint';
  let adaptor: WrenAIAdaptor;

  beforeEach(() => {
    adaptor = new WrenAIAdaptor({ wrenAIBaseEndpoint: baseEndpoint });
    jest.clearAllMocks();
  });

  describe('generateRecommendationQuestions', () => {
    const mockInput: RecommendationQuestionsInput = {
      manifest: sampleManifest,
      previousQuestions: ['What is sales by region?'],
      projectId: 'project-123',
      maxQuestions: 5,
      maxCategories: 3,
      configuration: {
        language: 'English',
      },
    };

    it('should successfully generate recommendation questions', async () => {
      const mockQueryId = 'query-123';
      mockedAxios.post.mockResolvedValueOnce({ data: { id: mockQueryId } });

      const result = await adaptor.generateRecommendationQuestions(mockInput);

      expect(result).toEqual({ queryId: mockQueryId });
      expect(mockedAxios.post).toHaveBeenCalledWith(
        `${baseEndpoint}/v1/question-recommendations`,
        {
          mdl: JSON.stringify(mockInput.manifest),
          previous_questions: mockInput.previousQuestions,
          project_id: mockInput.projectId,
          max_questions: mockInput.maxQuestions,
          max_categories: mockInput.maxCategories,
          configuration: mockInput.configuration,
        },
      );
    });

    it('should handle errors when generating recommendation questions', async () => {
      const errorMessage = 'Network error';
      mockedAxios.post.mockRejectedValueOnce(new Error(errorMessage));

      await expect(
        adaptor.generateRecommendationQuestions(mockInput),
      ).rejects.toThrow(errorMessage);
    });
  });

  describe('getRecommendationQuestionsResult', () => {
    const queryId = 'query-123';

    it('should successfully get recommendation questions result', async () => {
      const mockResponse = {
        status: 'FINISHED',
        response: {
          questions: [
            {
              question: 'What is the total revenue?',
              explanation: 'This shows overall business performance',
              category: 'Revenue',
            },
          ],
        },
      };

      mockedAxios.get.mockResolvedValueOnce({ data: mockResponse });

      const result = await adaptor.getRecommendationQuestionsResult(queryId);

      expect(result).toEqual({
        status: RecommendationQuestionStatus.FINISHED,
        error: null,
        ...mockResponse,
      });
      expect(mockedAxios.get).toHaveBeenCalledWith(
        `${baseEndpoint}/v1/question-recommendations/${queryId}/result`,
      );
    });

    it('should handle errors when getting recommendation questions result', async () => {
      const errorMessage = 'Network error';
      mockedAxios.get.mockRejectedValueOnce(new Error(errorMessage));

      await expect(
        adaptor.getRecommendationQuestionsResult(queryId),
      ).rejects.toThrow(errorMessage);
    });
  });
});
</file>

<file path="src/apollo/server/adaptors/wrenAIAdaptor.ts">
import axios from 'axios';
import { Readable } from 'stream';
import {
  AskCandidateType,
  AskDetailInput,
  AskDetailResult,
  AskHistory,
  AskResult,
  AskResultStatus,
  AsyncQueryResponse,
  RecommendationQuestionsInput,
  RecommendationQuestionsResult,
  WrenAIDeployStatusEnum,
  WrenAISystemStatus,
  WrenAIDeployResponse,
  DeployData,
  AskInput,
  TextBasedAnswerInput,
  TextBasedAnswerResult,
  ChartInput,
  ChartAdjustmentInput,
  ChartResult,
  ChartStatus,
  TextBasedAnswerStatus,
  SqlPairResult,
  SqlPairStatus,
  QuestionInput,
  QuestionsResult,
  QuestionsStatus,
  GenerateInstructionInput,
  InstructionStatus,
  InstructionResult,
  AskFeedbackInput,
  AskFeedbackResult,
  AskFeedbackStatus,
} from '@server/models/adaptor';
import { getLogger } from '@server/utils';
import * as Errors from '@server/utils/error';
import { SqlPair } from '../repositories';
import { ThreadResponse } from '@server/repositories';

const logger = getLogger('WrenAIAdaptor');
logger.level = 'debug';

const getAIServiceError = (error: any) => {
  const { data } = error.response || {};
  return data?.detail
    ? `${error.message}, detail: ${data.detail}`
    : error.message;
};

export interface IWrenAIAdaptor {
  deploy(deployData: DeployData): Promise<WrenAIDeployResponse>;
  delete(projectId: number): Promise<void>;

  /**
   * Ask AI service a question.
   * AI service will return anwser candidates containing sql.
   * 1. use ask() to ask a question, AI service will return a queryId
   * 2. use getAskResult() to get the result of the queryId
   * 3. use cancelAsk() to cancel the query
   **/
  ask(input: AskInput): Promise<AsyncQueryResponse>;
  cancelAsk(queryId: string): Promise<void>;
  getAskResult(queryId: string): Promise<AskResult>;
  getAskStreamingResult(queryId: string): Promise<Readable>;

  /**
   * After you choose a candidate, you can request AI service to generate the detail.
   * 1. use generateAskDetail() to generate the detail. AI service will return a queryId
   * 2. use getAskDetailResult() to get the result of the queryId
   */
  generateAskDetail(input: AskDetailInput): Promise<AsyncQueryResponse>;
  getAskDetailResult(queryId: string): Promise<AskDetailResult>;

  /**
   * Generate recommendation questions
   */
  generateRecommendationQuestions(
    input: RecommendationQuestionsInput,
  ): Promise<AsyncQueryResponse>;
  getRecommendationQuestionsResult(
    queryId: string,
  ): Promise<RecommendationQuestionsResult>;

  /**
   * Get text-based answer from SQL
   */
  createTextBasedAnswer(
    input: TextBasedAnswerInput,
  ): Promise<AsyncQueryResponse>;
  getTextBasedAnswerResult(queryId: string): Promise<TextBasedAnswerResult>;
  streamTextBasedAnswer(queryId: string): Promise<Readable>;

  /**
   * Chart related APIs
   */
  generateChart(input: ChartInput): Promise<AsyncQueryResponse>;
  getChartResult(queryId: string): Promise<ChartResult>;
  cancelChart(queryId: string): Promise<void>;
  adjustChart(input: ChartAdjustmentInput): Promise<AsyncQueryResponse>;
  getChartAdjustmentResult(queryId: string): Promise<ChartResult>;
  cancelChartAdjustment(queryId: string): Promise<void>;

  /**
   * Sql Pair APIs
   */
  deploySqlPair(
    projectId: number,
    sqlPair: { question: string; sql: string },
  ): Promise<AsyncQueryResponse>;
  getSqlPairResult(queryId: string): Promise<SqlPairResult>;
  deleteSqlPairs(projectId: number, sqlPairIds: number[]): Promise<void>;
  generateQuestions(input: QuestionInput): Promise<AsyncQueryResponse>;
  getQuestionsResult(queryId: string): Promise<Partial<QuestionsResult>>;

  /**
   * instruction related APIs
   */
  generateInstruction(
    input: GenerateInstructionInput[],
  ): Promise<AsyncQueryResponse>;
  getInstructionResult(queryId: string): Promise<InstructionResult>;
  deleteInstructions(ids: number[], projectId: number): Promise<void>;

  /**
   * Ask feedback APIs
   */
  createAskFeedback(input: AskFeedbackInput): Promise<AsyncQueryResponse>;
  getAskFeedbackResult(queryId: string): Promise<AskFeedbackResult>;
  cancelAskFeedback(queryId: string): Promise<void>;
}

export class WrenAIAdaptor implements IWrenAIAdaptor {
  private readonly wrenAIBaseEndpoint: string;

  constructor({ wrenAIBaseEndpoint }: { wrenAIBaseEndpoint: string }) {
    this.wrenAIBaseEndpoint = wrenAIBaseEndpoint;
  }

  public async delete(projectId: number): Promise<void> {
    try {
      if (!projectId) {
        throw new Error('Project ID is required');
      }
      const url = `${this.wrenAIBaseEndpoint}/v1/semantics`;
      const response = await axios.delete(url, {
        params: {
          project_id: projectId.toString(),
        },
      });

      if (response.status === 200) {
        logger.info(`Wren AI: Deleted semantics for project ${projectId}`);
      } else {
        throw new Error(`Failed to delete semantics. ${response.data?.error}`);
      }
    } catch (error: any) {
      throw new Error(
        `Wren AI: Failed to delete semantics: ${getAIServiceError(error)}`,
      );
    }
  }

  public async deploySqlPair(
    projectId: number,
    sqlPair: Partial<SqlPair>,
  ): Promise<AsyncQueryResponse> {
    try {
      const body = {
        sql_pairs: [
          {
            id: `${sqlPair.id}`,
            sql: sqlPair.sql,
            question: sqlPair.question,
          },
        ],
        project_id: projectId.toString(),
      };

      return axios
        .post(`${this.wrenAIBaseEndpoint}/v1/sql-pairs`, body)
        .then((res) => {
          return { queryId: res.data.event_id };
        });
    } catch (err: any) {
      logger.debug(
        `Got error when deploying SQL pair: ${getAIServiceError(err)}`,
      );
      throw err;
    }
  }
  public async getSqlPairResult(queryId: string): Promise<SqlPairResult> {
    try {
      const res = await axios.get(
        `${this.wrenAIBaseEndpoint}/v1/sql-pairs/${queryId}`,
      );
      const { status, error } = this.transformStatusAndError(res.data);
      return {
        status: status as SqlPairStatus,
        error,
      };
    } catch (err: any) {
      logger.debug(
        `Got error when getting SQL pair result: ${getAIServiceError(err)}`,
      );
      throw err;
    }
  }
  public async deleteSqlPairs(
    projectId: number,
    sqlPairIds: number[],
  ): Promise<void> {
    try {
      await axios.delete(`${this.wrenAIBaseEndpoint}/v1/sql-pairs`, {
        data: {
          sql_pair_ids: sqlPairIds.map((id) => id.toString()),
          project_id: projectId.toString(),
        },
      });
      return;
    } catch (err: any) {
      logger.debug(
        `Got error when deleting SQL pair: ${getAIServiceError(err)}`,
      );
      throw err;
    }
  }

  /**
   * Ask AI service a question.
   * AI service will return anwser candidates containing sql.
   */

  public async ask(input: AskInput): Promise<AsyncQueryResponse> {
    try {
      const res = await axios.post(`${this.wrenAIBaseEndpoint}/v1/asks`, {
        query: input.query,
        id: input.deployId,
        histories: this.transformHistoryInput(input.histories),
        configurations: input.configurations,
      });
      return { queryId: res.data.query_id };
    } catch (err: any) {
      logger.debug(`Got error when asking wren AI: ${getAIServiceError(err)}`);
      throw err;
    }
  }

  public async cancelAsk(queryId: string): Promise<void> {
    // make PATCH request /v1/asks/:query_id to cancel the query
    try {
      await axios.patch(`${this.wrenAIBaseEndpoint}/v1/asks/${queryId}`, {
        status: 'stopped',
      });
    } catch (err: any) {
      logger.debug(`Got error when canceling ask: ${getAIServiceError(err)}`);
      throw err;
    }
  }

  public async getAskResult(queryId: string): Promise<AskResult> {
    // make GET request /v1/asks/:query_id/result to get the result
    try {
      const res = await axios.get(
        `${this.wrenAIBaseEndpoint}/v1/asks/${queryId}/result`,
      );
      return this.transformAskResult(res.data);
    } catch (err: any) {
      logger.debug(
        `Got error when getting ask result: ${getAIServiceError(err)}`,
      );
      // throw err;
      throw Errors.create(Errors.GeneralErrorCodes.INTERNAL_SERVER_ERROR, {
        originalError: err,
      });
    }
  }

  public async getAskStreamingResult(queryId: string): Promise<Readable> {
    // make GET request /v1/asks/:query_id/streaming-result to get the streaming result
    try {
      const res = await axios.get(
        `${this.wrenAIBaseEndpoint}/v1/asks/${queryId}/streaming-result`,
        { responseType: 'stream' },
      );
      return res.data;
    } catch (err: any) {
      logger.debug(
        `Got error when getting ask streaming result: ${getAIServiceError(err)}`,
      );
      // throw err;
      throw Errors.create(Errors.GeneralErrorCodes.INTERNAL_SERVER_ERROR, {
        originalError: err,
      });
    }
  }

  /**
   * After you choose a candidate, you can request AI service to generate the detail.
   */

  public async generateAskDetail(
    input: AskDetailInput,
  ): Promise<AsyncQueryResponse> {
    try {
      const res = await axios.post(
        `${this.wrenAIBaseEndpoint}/v1/ask-details`,
        input,
      );
      return { queryId: res.data.query_id };
    } catch (err: any) {
      logger.debug(
        `Got error when generating ask detail: ${getAIServiceError(err)}`,
      );
      throw err;
    }
  }

  public async getAskDetailResult(queryId: string): Promise<AskDetailResult> {
    // make GET request /v1/ask-details/:query_id/result to get the result
    try {
      const res = await axios.get(
        `${this.wrenAIBaseEndpoint}/v1/ask-details/${queryId}/result`,
      );
      return this.transformAskDetailResult(res.data);
    } catch (err: any) {
      logger.debug(
        `Got error when getting ask detail result: ${getAIServiceError(err)}`,
      );
      throw err;
    }
  }

  public async deploy(deployData: DeployData): Promise<WrenAIDeployResponse> {
    const { manifest, hash } = deployData;
    try {
      const res = await axios.post(
        `${this.wrenAIBaseEndpoint}/v1/semantics-preparations`,
        {
          mdl: JSON.stringify(manifest),
          id: hash,
        },
      );
      const deployId = res.data.id;
      logger.debug(
        `Wren AI: Deploying wren AI, hash: ${hash}, deployId: ${deployId}`,
      );
      const deploySuccess = await this.waitDeployFinished(deployId);
      if (deploySuccess) {
        logger.debug(`Wren AI: Deploy wren AI success, hash: ${hash}`);
        return { status: WrenAIDeployStatusEnum.SUCCESS };
      } else {
        return {
          status: WrenAIDeployStatusEnum.FAILED,
          error: `Wren AI: Deploy wren AI failed or timeout, hash: ${hash}`,
        };
      }
    } catch (err: any) {
      logger.debug(
        `Got error when deploying to wren AI, hash: ${hash}. Error: ${err.message}`,
      );
      return {
        status: WrenAIDeployStatusEnum.FAILED,
        error: `Wren AI Error: deployment hash:${hash}, ${err.message}`,
      };
    }
  }

  public async generateRecommendationQuestions(
    input: RecommendationQuestionsInput,
  ): Promise<AsyncQueryResponse> {
    const body = {
      mdl: JSON.stringify(input.manifest),
      previous_questions: input.previousQuestions,
      max_questions: input.maxQuestions,
      max_categories: input.maxCategories,
      configuration: input.configuration,
    };
    logger.info(`Wren AI: Generating recommendation questions`);
    try {
      const res = await axios.post(
        `${this.wrenAIBaseEndpoint}/v1/question-recommendations`,
        body,
      );
      logger.info(
        `Wren AI: Generating recommendation questions, queryId: ${res.data.id}`,
      );
      return { queryId: res.data.id };
    } catch (err: any) {
      logger.debug(
        `Got error when generating recommendation questions: ${getAIServiceError(err)}`,
      );
      throw err;
    }
  }

  public async getRecommendationQuestionsResult(
    queryId: string,
  ): Promise<RecommendationQuestionsResult> {
    try {
      const res = await axios.get(
        `${this.wrenAIBaseEndpoint}/v1/question-recommendations/${queryId}`,
      );
      return this.transformRecommendationQuestionsResult(res.data);
    } catch (err: any) {
      logger.debug(
        `Got error when getting recommendation questions result: ${getAIServiceError(err)}`,
      );
      throw err;
    }
  }

  public async createTextBasedAnswer(
    input: TextBasedAnswerInput,
  ): Promise<AsyncQueryResponse> {
    const body = {
      query: input.query,
      sql: input.sql,
      sql_data: input.sqlData,
      thread_id: input.threadId,
      user_id: input.userId,
      configurations: input.configurations,
    };
    // make POST request /v1/sql-answers to create text-based answer
    try {
      const res = await axios.post(
        `${this.wrenAIBaseEndpoint}/v1/sql-answers`,
        body,
      );
      return { queryId: res.data.query_id };
    } catch (err: any) {
      logger.debug(
        `Got error when creating text-based answer: ${getAIServiceError(err)}`,
      );
      throw err;
    }
  }

  public async getTextBasedAnswerResult(
    queryId: string,
  ): Promise<TextBasedAnswerResult> {
    // make GET request /v1/sql-answers/:query_id to get the result
    try {
      const res = await axios.get(
        `${this.wrenAIBaseEndpoint}/v1/sql-answers/${queryId}`,
      );
      return this.transformTextBasedAnswerResult(res.data);
    } catch (err: any) {
      logger.debug(
        `Got error when getting text-based answer result: ${getAIServiceError(err)}`,
      );
      throw err;
    }
  }

  public async streamTextBasedAnswer(queryId: string): Promise<Readable> {
    // make GET request /v1/sql-answers/:query_id/streaming to get the streaming result
    try {
      const res = await axios.get(
        `${this.wrenAIBaseEndpoint}/v1/sql-answers/${queryId}/streaming`,
        { responseType: 'stream' },
      );
      return res.data;
    } catch (err: any) {
      logger.debug(
        `Got error when getting text-based answer streaming result: ${getAIServiceError(err)}`,
      );
      throw err;
    }
  }

  public async generateChart(input: ChartInput): Promise<AsyncQueryResponse> {
    try {
      const res = await axios.post(
        `${this.wrenAIBaseEndpoint}/v1/charts`,
        input,
      );
      return { queryId: res.data.query_id };
    } catch (err: any) {
      logger.debug(`Got error when creating chart: ${getAIServiceError(err)}`);
      throw err;
    }
  }

  public async getChartResult(queryId: string): Promise<ChartResult> {
    try {
      const res = await axios.get(
        `${this.wrenAIBaseEndpoint}/v1/charts/${queryId}`,
      );
      return this.transformChartResult(res.data);
    } catch (err: any) {
      logger.debug(
        `Got error when getting chart result: ${getAIServiceError(err)}`,
      );
      throw err;
    }
  }

  public async cancelChart(queryId: string): Promise<void> {
    try {
      await axios.patch(`${this.wrenAIBaseEndpoint}/v1/charts/${queryId}`, {
        status: 'stopped',
      });
    } catch (err: any) {
      logger.debug(`Got error when canceling chart: ${getAIServiceError(err)}`);
      throw err;
    }
  }

  public async adjustChart(
    input: ChartAdjustmentInput,
  ): Promise<AsyncQueryResponse> {
    try {
      const res = await axios.post(
        `${this.wrenAIBaseEndpoint}/v1/chart-adjustments`,
        this.transformChartAdjustmentInput(input),
      );
      return { queryId: res.data.query_id };
    } catch (err: any) {
      logger.debug(`Got error when adjusting chart: ${getAIServiceError(err)}`);
      throw err;
    }
  }

  public async getChartAdjustmentResult(queryId: string): Promise<ChartResult> {
    try {
      const res = await axios.get(
        `${this.wrenAIBaseEndpoint}/v1/chart-adjustments/${queryId}`,
      );
      return this.transformChartResult(res.data);
    } catch (err: any) {
      logger.debug(
        `Got error when getting chart adjustment result: ${getAIServiceError(err)}`,
      );
      throw err;
    }
  }

  public async cancelChartAdjustment(queryId: string): Promise<void> {
    try {
      await axios.patch(
        `${this.wrenAIBaseEndpoint}/v1/chart-adjustments/${queryId}`,
        {
          status: 'stopped',
        },
      );
    } catch (err: any) {
      logger.debug(
        `Got error when canceling chart adjustment: ${getAIServiceError(err)}`,
      );
      throw err;
    }
  }
  public async generateQuestions(
    input: QuestionInput,
  ): Promise<AsyncQueryResponse> {
    try {
      const body = {
        sqls: input.sqls,
        project_id: input.projectId.toString(),
        configurations: input.configurations,
      };

      const res = await axios.post(
        `${this.wrenAIBaseEndpoint}/v1/sql-questions`,
        body,
      );
      return { queryId: res.data.query_id };
    } catch (err: any) {
      logger.debug(
        `Got error when generating questions: ${getAIServiceError(err)}`,
      );
      throw err;
    }
  }

  public async generateInstruction(
    input: GenerateInstructionInput[],
  ): Promise<AsyncQueryResponse> {
    const body = {
      instructions: input.map((item) => ({
        id: item.id.toString(),
        instruction: item.instruction,
        questions: item.questions,
        is_default: item.isDefault,
      })),
      project_id: input[0]?.projectId.toString(),
    };
    try {
      const res = await axios.post(
        `${this.wrenAIBaseEndpoint}/v1/instructions`,
        body,
      );
      return { queryId: res.data.event_id };
    } catch (err: any) {
      logger.debug(
        `Got error when generating instruction: ${getAIServiceError(err)}`,
      );
      throw err;
    }
  }

  public async getQuestionsResult(
    queryId: string,
  ): Promise<Partial<QuestionsResult>> {
    try {
      const res = await axios.get(
        `${this.wrenAIBaseEndpoint}/v1/sql-questions/${queryId}`,
      );
      const { status, error } = this.transformStatusAndError(res.data);
      return {
        status: status as QuestionsStatus,
        error,
        questions: res.data.questions || [],
      };
    } catch (err: any) {
      logger.debug(
        `Got error when getting questions result: ${getAIServiceError(err)}`,
      );
      throw err;
    }
  }

  public async getInstructionResult(
    queryId: string,
  ): Promise<InstructionResult> {
    try {
      const res = await axios.get(
        `${this.wrenAIBaseEndpoint}/v1/instructions/${queryId}`,
      );
      return this.transformStatusAndError(res.data) as InstructionResult;
    } catch (err: any) {
      logger.debug(
        `Got error when getting instruction result: ${getAIServiceError(err)}`,
      );
      throw err;
    }
  }

  public async deleteInstructions(
    ids: number[],
    projectId: number,
  ): Promise<void> {
    try {
      await axios.delete(`${this.wrenAIBaseEndpoint}/v1/instructions`, {
        data: {
          instruction_ids: ids.map((id) => id.toString()),
          project_id: projectId.toString(),
        },
      });
    } catch (err: any) {
      logger.debug(
        `Got error when deleting instruction: ${getAIServiceError(err)}`,
      );
      throw err;
    }
  }

  public async createAskFeedback(
    input: AskFeedbackInput,
  ): Promise<AsyncQueryResponse> {
    try {
      const body = {
        question: input.question,
        tables: input.tables,
        sql_generation_reasoning: input.sqlGenerationReasoning,
        sql: input.sql,
        project_id: input.projectId.toString(),
        configurations: input.configurations,
      };
      const res = await axios.post(
        `${this.wrenAIBaseEndpoint}/v1/ask-feedbacks`,
        body,
      );
      return { queryId: res.data.query_id };
    } catch (err: any) {
      logger.debug(
        `Got error when creating ask feedback: ${getAIServiceError(err)}`,
      );
      throw err;
    }
  }

  public async getAskFeedbackResult(
    queryId: string,
  ): Promise<AskFeedbackResult> {
    try {
      const res = await axios.get(
        `${this.wrenAIBaseEndpoint}/v1/ask-feedbacks/${queryId}`,
      );
      return this.transformAskFeedbackResult(res.data);
    } catch (err: any) {
      logger.debug(
        `Got error when getting ask feedback result: ${getAIServiceError(err)}`,
      );
      throw err;
    }
  }

  public async cancelAskFeedback(queryId: string): Promise<void> {
    try {
      await axios.patch(
        `${this.wrenAIBaseEndpoint}/v1/ask-feedbacks/${queryId}`,
        {
          status: 'stopped',
        },
      );
    } catch (err: any) {
      logger.debug(
        `Got error when canceling ask feedback: ${getAIServiceError(err)}`,
      );
      throw err;
    }
  }

  private transformAskFeedbackResult(body: any): AskFeedbackResult {
    const { status, error } = this.transformStatusAndError(body);
    return {
      status: status as AskFeedbackStatus,
      error,
      response:
        body.response?.map((result: any) => ({
          sql: result.sql,
          type: result.type?.toUpperCase() as AskCandidateType,
        })) || [],
      traceId: body.trace_id,
      invalidSql: body.invalid_sql,
    };
  }

  private transformChartAdjustmentInput(input: ChartAdjustmentInput) {
    const { query, sql, adjustmentOption, chartSchema, configurations } = input;
    return {
      query,
      sql,
      adjustment_option: {
        chart_type: adjustmentOption.chartType.toLowerCase(),
        x_axis: adjustmentOption.xAxis,
        y_axis: adjustmentOption.yAxis,
        x_offset: adjustmentOption.xOffset,
        color: adjustmentOption.color,
        theta: adjustmentOption.theta,
      },
      chart_schema: chartSchema,
      configurations,
    };
  }

  private transformChartResult(body: any): ChartResult {
    const { status, error } = this.transformStatusAndError(body);
    return {
      status: status as ChartStatus,
      error,
      response: {
        reasoning: body.response?.reasoning,
        chartType: body.response?.chart_type,
        chartSchema: body.response?.chart_schema,
      },
    };
  }

  private transformTextBasedAnswerResult(body: any): TextBasedAnswerResult {
    const { status, error } = this.transformStatusAndError(body);
    return {
      status: status as TextBasedAnswerStatus,
      numRowsUsedInLLM: body.num_rows_used_in_llm,
      error,
    };
  }

  private async waitDeployFinished(deployId: string): Promise<boolean> {
    let deploySuccess = false;
    // timeout after 30 seconds
    for (let waitTime = 1; waitTime <= 7; waitTime++) {
      try {
        const status = await this.getDeployStatus(deployId);
        logger.debug(`Wren AI: Deploy status: ${status}`);
        if (status === WrenAISystemStatus.FINISHED) {
          deploySuccess = true;
          break;
        } else if (status === WrenAISystemStatus.FAILED) {
          break;
        } else if (status === WrenAISystemStatus.INDEXING) {
          // do nothing
        } else {
          logger.debug(`Wren AI: Unknown Wren AI deploy status: ${status}`);
          return;
        }
      } catch (err: any) {
        throw err;
      }
      await new Promise((resolve) => setTimeout(resolve, waitTime * 1000));
    }
    return deploySuccess;
  }

  private async getDeployStatus(deployId: string): Promise<WrenAISystemStatus> {
    try {
      const res = await axios.get(
        `${this.wrenAIBaseEndpoint}/v1/semantics-preparations/${deployId}/status`,
      );
      if (res.data.error) {
        // passing AI response error string to catch block
        throw new Error(res.data.error);
      }
      return res.data?.status.toUpperCase() as WrenAISystemStatus;
    } catch (err: any) {
      logger.debug(
        `Got error in API /v1/semantics-preparations/${deployId}/status: ${err.message}`,
      );
      throw err;
    }
  }

  private transformAskResult(body: any): AskResult {
    const { status, error } = this.transformStatusAndError(body);
    const candidates = (body?.response || []).map((candidate: any) => ({
      type: candidate?.type?.toUpperCase() as AskCandidateType,
      sql: candidate.sql,
      viewId: candidate?.viewId ? Number(candidate.viewId) : null,
      sqlpairId: candidate?.sqlpairId ? Number(candidate.sqlpairId) : null,
    }));

    return {
      type: body?.type,
      status: status as AskResultStatus,
      error,
      response: candidates,
      rephrasedQuestion: body?.rephrased_question,
      intentReasoning: body?.intent_reasoning,
      sqlGenerationReasoning: body?.sql_generation_reasoning,
      retrievedTables: body?.retrieved_tables,
      invalidSql: body?.invalid_sql,
      traceId: body?.trace_id,
    };
  }

  private transformRecommendationQuestionsResult(
    body: any,
  ): RecommendationQuestionsResult {
    const { status, error } = this.transformStatusAndError(body);
    return {
      ...body,
      status,
      error,
    };
  }

  private transformAskDetailResult(body: any): AskDetailResult {
    const { type } = body;
    const { status, error } = this.transformStatusAndError(body);

    // snake_case to camelCase
    const steps = (body?.response?.steps || []).map((step: any) => ({
      summary: step.summary,
      sql: step.sql,
      cteName: step.cte_name,
    }));

    return {
      type,
      status: status as AskResultStatus,
      error,
      response: {
        description: body?.response?.description,
        steps,
      },
    };
  }

  private transformStatusAndError(body: any): {
    status:
      | AskResultStatus
      | TextBasedAnswerStatus
      | ChartStatus
      | SqlPairStatus
      | QuestionsStatus
      | InstructionStatus
      | AskFeedbackStatus;
    error?: {
      code: Errors.GeneralErrorCodes;
      message: string;
      shortMessage: string;
    } | null;
  } {
    // transform status to enum
    const status = body?.status?.toUpperCase();

    if (!status) {
      throw new Error(`Unknown ask status: ${body?.status}`);
    }

    // use custom error to transform error
    const code = body?.error?.code;
    const isShowAIServiceErrorMessage =
      code === Errors.GeneralErrorCodes.NO_RELEVANT_SQL ||
      code === Errors.GeneralErrorCodes.AI_SERVICE_UNDEFINED_ERROR;

    const error = code
      ? Errors.create(
          code,
          isShowAIServiceErrorMessage
            ? {
                customMessage: body?.error?.message,
              }
            : undefined,
        )
      : null;

    // format custom error into WrenAIError that is used in graphql
    const formattedError = error
      ? {
          code: error.extensions.code as Errors.GeneralErrorCodes,
          message: error.message,
          shortMessage: error.extensions.shortMessage as string,
        }
      : null;

    return {
      status,
      error: formattedError,
    };
  }

  private transformHistoryInput(histories: ThreadResponse[]): AskHistory[] {
    if (!histories) {
      return [];
    }

    // make it snake_case
    return histories.map((history) => ({
      sql: history.sql,
      question: history.question,
    }));
  }
}
</file>

<file path="src/apollo/server/adaptors/wrenEngineAdaptor.ts">
import axios, { AxiosResponse } from 'axios';
import { Manifest } from '../mdl/type';
import { getLogger } from '@server/utils';
import * as Errors from '@server/utils/error';
import { CompactTable, DEFAULT_PREVIEW_LIMIT } from '../services';

const logger = getLogger('WrenEngineAdaptor');
logger.level = 'debug';

export interface WrenEngineDeployStatusResponse {
  systemStatus: string;
  version: string;
}

export interface ColumnMetadata {
  name: string;
  type: string;
}

export interface EngineQueryResponse {
  columns: ColumnMetadata[];
  data: any[][];
}

export interface DescribeStatementResponse {
  columns: ColumnMetadata[];
}

export enum WrenEngineValidateStatus {
  PASS = 'PASS',
  ERROR = 'ERROR',
  FAIL = 'FAIL',
  WARN = 'WARN',
  SKIP = 'SKIP',
}

export interface WrenEngineValidateResponse {
  duration: string;
  name: string;
  status: WrenEngineValidateStatus;
}

export interface WrenEngineValidationResponse {
  valid: boolean;
  message?: string;
}

export interface DryPlanOption {
  modelingOnly?: boolean;
  manifest?: Manifest;
}

export interface WrenEngineDryRunOption {
  manifest?: Manifest;
  limit?: number;
}

export interface DuckDBPrepareOptions {
  initSql: string;
  sessionProps: Record<string, any>;
}

// The response consists of an array containing columns. Each column contains a name and a type.
export interface WrenEngineDryRunResponse {
  name: string;
  type: string;
}

export interface IWrenEngineAdaptor {
  // duckdb data source related
  prepareDuckDB(options: DuckDBPrepareOptions): Promise<void>;
  queryDuckdb(sql: string): Promise<EngineQueryResponse>;
  putSessionProps(props: Record<string, any>): Promise<void>;

  // metadata related, used to fetch metadata of duckdb
  listTables(): Promise<CompactTable[]>;

  // config wren engine
  patchConfig(config: Record<string, any>): Promise<void>;

  // query
  previewData(
    sql: string,
    mdl: Manifest,
    limit?: number,
  ): Promise<EngineQueryResponse>;
  getNativeSQL(sql: string, options?: DryPlanOption): Promise<string>;
  validateColumnIsValid(
    manifest: Manifest,
    modelName: string,
    columnName: string,
  ): Promise<WrenEngineValidationResponse>;
  dryRun(
    sql: string,
    options: WrenEngineDryRunOption,
  ): Promise<WrenEngineDryRunResponse[]>;
}

export class WrenEngineAdaptor implements IWrenEngineAdaptor {
  private readonly wrenEngineBaseEndpoint: string;
  private sessionPropsUrlPath = '/v1/data-source/duckdb/settings/session-sql';
  private queryDuckdbUrlPath = '/v1/data-source/duckdb/query';
  private initSqlUrlPath = '/v1/data-source/duckdb/settings/init-sql';
  private previewUrlPath = '/v1/mdl/preview';
  private dryPlanUrlPath = '/v1/mdl/dry-plan';
  private dryRunUrlPath = '/v1/mdl/dry-run';
  private validateUrlPath = '/v1/mdl/validate';

  constructor({ wrenEngineEndpoint }: { wrenEngineEndpoint: string }) {
    this.wrenEngineBaseEndpoint = wrenEngineEndpoint;
  }

  public async validateColumnIsValid(
    manifest: Manifest,
    modelName: string,
    columnName: string,
  ) {
    const model = manifest.models.find((m) => m.name === modelName);
    if (!model) {
      return {
        valid: false,
        message: `Model ${modelName} not found in the manifest`,
      };
    }
    const column = model.columns.find((c) => c.name === columnName);
    if (!column) {
      return {
        valid: false,
        message: `Column ${columnName} not found in model ${modelName} in the manifest`,
      };
    }
    try {
      const payload = {
        manifest,
        parameters: { modelName, columnName },
      };
      const res = await axios.post(
        `${this.wrenEngineBaseEndpoint}${this.validateUrlPath}/column_is_valid`,
        payload,
      );
      const result = res.data[0] as WrenEngineValidateResponse;
      if (result.status === WrenEngineValidateStatus.PASS) {
        return { valid: true };
      } else {
        return { valid: false, message: JSON.stringify(result) };
      }
    } catch (err: any) {
      logger.debug(`Got error when validating column: ${err.message}`);
      return { valid: false, message: err.message };
    }
  }

  public async prepareDuckDB(options: DuckDBPrepareOptions): Promise<void> {
    const { initSql, sessionProps } = options;
    await this.initDatabase(initSql);
    await this.putSessionProps(sessionProps);
  }

  public async listTables() {
    const sql =
      'SELECT \
      table_catalog, table_schema, table_name, column_name, ordinal_position, is_nullable, data_type\
      FROM INFORMATION_SCHEMA.COLUMNS;';
    const response = await this.queryDuckdb(sql);
    return this.formatToCompactTable(response);
  }

  public async putSessionProps(props: Record<string, any>) {
    const setSessionStatements = Object.entries(props)
      .map(([key, value]) => {
        return `SET ${key} = '${value}';`;
      })
      .join('\n');
    try {
      const url = new URL(
        this.sessionPropsUrlPath,
        this.wrenEngineBaseEndpoint,
      );
      const headers = {
        'Content-Type': 'text/plain; charset=utf-8',
      };
      await axios.put(url.href, setSessionStatements, { headers });
    } catch (err: any) {
      logger.debug(`Got error when put session props: ${err.message}`);
      throw Errors.create(Errors.GeneralErrorCodes.SESSION_PROPS_ERROR, {
        customMessage:
          Errors.errorMessages[Errors.GeneralErrorCodes.SESSION_PROPS_ERROR],
        originalError: err,
      });
    }
  }

  public async queryDuckdb(sql: string): Promise<EngineQueryResponse> {
    try {
      const url = new URL(this.queryDuckdbUrlPath, this.wrenEngineBaseEndpoint);
      const headers = {
        'Content-Type': 'text/plain; charset=utf-8',
      };
      const res = await axios.post(url.href, sql, { headers });
      return res.data as EngineQueryResponse;
    } catch (err: any) {
      logger.debug(`Got error when querying duckdb: ${err.message}`);
      throw Errors.create(Errors.GeneralErrorCodes.WREN_ENGINE_ERROR, {
        customMessage: err.response?.data?.message || err.message,
        originalError: err,
      });
    }
  }

  public async patchConfig(config: Record<string, any>) {
    try {
      const configPayload = Object.entries(config).map(([key, value]) => {
        return {
          name: key,
          value,
        };
      });
      const url = new URL('/v1/config', this.wrenEngineBaseEndpoint);
      const headers = {
        'Content-Type': 'application/json',
      };
      await axios.patch(url.href, configPayload, { headers });
    } catch (err: any) {
      logger.debug(`Got error when patching config: ${err.message}`);
      throw Errors.create(Errors.GeneralErrorCodes.WREN_ENGINE_ERROR, {
        customMessage: err.response?.data?.message || err.message,
        originalError: err,
      });
    }
  }

  public async previewData(
    sql: string,
    manifest: Manifest,
    limit: number = DEFAULT_PREVIEW_LIMIT,
  ): Promise<EngineQueryResponse> {
    try {
      const url = new URL(this.previewUrlPath, this.wrenEngineBaseEndpoint);
      const headers = {
        'Content-Type': 'application/json',
      };

      const res: AxiosResponse<EngineQueryResponse> = await axios({
        method: 'get',
        url: url.href,
        headers,
        data: {
          sql,
          limit,
          manifest,
        },
      });

      return res.data;
    } catch (err: any) {
      logger.debug(`Got error when previewing data: ${err.message}`);
      throw Errors.create(Errors.GeneralErrorCodes.WREN_ENGINE_ERROR, {
        customMessage: err.response?.data?.message || err.message,
        originalError: err,
      });
    }
  }

  public async getNativeSQL(
    sql: string,
    options: DryPlanOption,
  ): Promise<string> {
    try {
      const props = {
        modelingOnly: options?.modelingOnly ? true : false,
        manifest: options?.manifest,
      };

      const url = new URL(this.dryPlanUrlPath, this.wrenEngineBaseEndpoint);
      const headers = { 'Content-Type': 'application/json' };

      const res: AxiosResponse<string> = await axios({
        method: 'get',
        url: url.href,
        headers,
        data: {
          sql,
          ...props,
        },
      });

      return res.data;
    } catch (err: any) {
      logger.debug(`Got error when getting native SQL: ${err.message}`);
      Errors.create(Errors.GeneralErrorCodes.DRY_PLAN_ERROR, {
        customMessage: err.message,
        originalError: err,
      });
    }
  }

  public async dryRun(
    sql: string,
    options: WrenEngineDryRunOption,
  ): Promise<WrenEngineDryRunResponse[]> {
    try {
      const { manifest } = options;
      const body = {
        sql,
        manifest,
      };
      logger.debug(
        `Dry run wren engine with body: ${JSON.stringify(sql, null, 2)}`,
      );
      const url = new URL(this.dryRunUrlPath, this.wrenEngineBaseEndpoint);
      const res: AxiosResponse<WrenEngineDryRunResponse[]> = await axios({
        method: 'get',
        url: url.href,
        data: body,
      });
      logger.debug(`Wren Engine Dry run success`);
      return res.data;
    } catch (err: any) {
      logger.info(`Got error when dry running`);
      throw Errors.create(Errors.GeneralErrorCodes.DRY_RUN_ERROR, {
        customMessage: err.response.data.message,
        originalError: err,
      });
    }
  }

  private async getDeployStatus(): Promise<WrenEngineDeployStatusResponse> {
    try {
      const res = await axios.get(
        `${this.wrenEngineBaseEndpoint}/v1/mdl/status`,
      );
      return res.data as WrenEngineDeployStatusResponse;
    } catch (err: any) {
      logger.debug(
        `WrenEngine: Got error when getting deploy status: ${err.message}`,
      );
      throw err;
    }
  }

  private async initDatabase(sql) {
    try {
      const url = new URL(this.initSqlUrlPath, this.wrenEngineBaseEndpoint);
      const headers = {
        'Content-Type': 'text/plain; charset=utf-8',
      };
      await axios.put(url.href, sql, { headers });
    } catch (err: any) {
      logger.debug(`Got error when init database: ${err}`);
      throw Errors.create(Errors.GeneralErrorCodes.INIT_SQL_ERROR, {
        customMessage:
          Errors.errorMessages[Errors.GeneralErrorCodes.INIT_SQL_ERROR],
        originalError: err,
      });
    }
  }

  private formatToCompactTable(columns: EngineQueryResponse): CompactTable[] {
    return columns.data.reduce((acc: CompactTable[], row: any) => {
      const [
        table_catalog,
        table_schema,
        table_name,
        column_name,
        _ordinal_position,
        is_nullable,
        data_type,
      ] = row;
      let table = acc.find(
        (t) => t.name === table_name && t.properties.schema === table_schema,
      );
      if (!table) {
        table = {
          name: table_name,
          description: '',
          columns: [],
          properties: {
            schema: table_schema,
            catalog: table_catalog,
            table: table_name,
          },
          primaryKey: null,
        };
        acc.push(table);
      }
      table.columns.push({
        name: column_name,
        type: data_type,
        notNull: is_nullable.toLocaleLowerCase() !== 'yes',
        description: '',
        properties: {},
      });
      return acc;
    }, []);
  }
}
</file>

<file path="src/apollo/server/backgrounds/adjustmentBackgroundTracker.ts">
import { getLogger } from '@server/utils';
import {
  AskFeedbackInput,
  AskFeedbackResult,
  AskFeedbackStatus,
} from '@server/models/adaptor';
import {
  AskingTask,
  IAskingTaskRepository,
  IThreadResponseRepository,
  ThreadResponse,
  ThreadResponseAdjustmentType,
} from '@server/repositories';
import { IWrenAIAdaptor } from '../adaptors';
import { TelemetryEvent, WrenService } from '../telemetry/telemetry';
import { PostHogTelemetry } from '../telemetry/telemetry';

const logger = getLogger('AdjustmentTaskTracker');
logger.level = 'debug';

interface TrackedTask {
  queryId: string;
  taskId?: number;
  lastPolled: number;
  result?: AskFeedbackResult;
  isFinalized: boolean;
  threadResponseId: number;
  question: string;
  originalThreadResponseId: number;
  rerun?: boolean;
  adjustmentPayload?: {
    originalThreadResponseId: number;
    retrievedTables: string[];
    sqlGenerationReasoning: string;
  };
}

export type TrackedAdjustmentResult = AskFeedbackResult & {
  taskId?: number;
  queryId: string;
};

export type CreateAdjustmentTaskInput = AskFeedbackInput & {
  threadId: number;
  question: string;
  originalThreadResponseId: number;
  configurations: { language: string };
};

export type RerunAdjustmentTaskInput = {
  threadResponseId: number;
  threadId: number;
  projectId: number;
  configurations: { language: string };
};

export interface IAdjustmentBackgroundTaskTracker {
  createAdjustmentTask(
    input: CreateAdjustmentTaskInput,
  ): Promise<{ queryId: string }>;
  getAdjustmentResult(queryId: string): Promise<TrackedAdjustmentResult | null>;
  getAdjustmentResultById(id: number): Promise<TrackedAdjustmentResult | null>;
  cancelAdjustmentTask(queryId: string): Promise<void>;
  rerunAdjustmentTask(
    input: RerunAdjustmentTaskInput,
  ): Promise<{ queryId: string }>;
}

export class AdjustmentBackgroundTaskTracker
  implements IAdjustmentBackgroundTaskTracker
{
  private wrenAIAdaptor: IWrenAIAdaptor;
  private askingTaskRepository: IAskingTaskRepository;
  private trackedTasks: Map<string, TrackedTask> = new Map();
  private trackedTasksById: Map<number, TrackedTask> = new Map();
  private pollingInterval: number;
  private memoryRetentionTime: number;
  private pollingIntervalId: NodeJS.Timeout;
  private runningJobs = new Set<string>();
  private threadResponseRepository: IThreadResponseRepository;
  private telemetry: PostHogTelemetry;

  constructor({
    telemetry,
    wrenAIAdaptor,
    askingTaskRepository,
    threadResponseRepository,
    pollingInterval = 1000, // 1 second
    memoryRetentionTime = 5 * 60 * 1000, // 5 minutes
  }: {
    telemetry: PostHogTelemetry;
    wrenAIAdaptor: IWrenAIAdaptor;
    askingTaskRepository: IAskingTaskRepository;
    threadResponseRepository: IThreadResponseRepository;
    pollingInterval?: number;
    memoryRetentionTime?: number;
  }) {
    this.telemetry = telemetry;
    this.wrenAIAdaptor = wrenAIAdaptor;
    this.askingTaskRepository = askingTaskRepository;
    this.threadResponseRepository = threadResponseRepository;
    this.pollingInterval = pollingInterval;
    this.memoryRetentionTime = memoryRetentionTime;
    this.startPolling();
  }

  public async createAdjustmentTask(
    input: CreateAdjustmentTaskInput,
  ): Promise<{ queryId: string; createdThreadResponse: ThreadResponse }> {
    try {
      // Call the AI service to create a task
      const response = await this.wrenAIAdaptor.createAskFeedback(input);
      const queryId = response.queryId;

      // create a new asking task
      const createdAskingTask = await this.askingTaskRepository.createOne({
        queryId,
        question: input.question,
        threadId: input.threadId,
        detail: {
          adjustment: true,
          status: AskFeedbackStatus.UNDERSTANDING,
          response: [],
          error: null,
        },
      });

      // create a new thread response with adjustment payload
      const createdThreadResponse =
        await this.threadResponseRepository.createOne({
          question: input.question,
          threadId: input.threadId,
          askingTaskId: createdAskingTask.id,
          adjustment: {
            type: ThreadResponseAdjustmentType.REASONING,
            payload: {
              originalThreadResponseId: input.originalThreadResponseId,
              retrievedTables: input.tables,
              sqlGenerationReasoning: input.sqlGenerationReasoning,
            },
          },
        });

      // bind the thread response to the asking task
      // todo: it's weird that we need to update the asking task again
      // find a better way to do this
      await this.askingTaskRepository.updateOne(createdAskingTask.id, {
        threadResponseId: createdThreadResponse.id,
      });

      // Start tracking this task
      const task = {
        queryId,
        lastPolled: Date.now(),
        isFinalized: false,
        originalThreadResponseId: input.originalThreadResponseId,
        threadResponseId: createdThreadResponse.id,
        question: input.question,
        adjustmentPayload: {
          originalThreadResponseId: input.originalThreadResponseId,
          retrievedTables: input.tables,
          sqlGenerationReasoning: input.sqlGenerationReasoning,
        },
      } as TrackedTask;
      this.trackedTasks.set(queryId, task);
      this.trackedTasksById.set(createdThreadResponse.id, task);

      logger.info(`Created adjustment task with queryId: ${queryId}`);
      return { queryId, createdThreadResponse };
    } catch (err) {
      logger.error(`Failed to create adjustment task: ${err}`);
      throw err;
    }
  }

  public async rerunAdjustmentTask(
    input: RerunAdjustmentTaskInput,
  ): Promise<{ queryId: string }> {
    const currentThreadResponse = await this.threadResponseRepository.findOneBy(
      {
        id: input.threadResponseId,
      },
    );
    if (!currentThreadResponse) {
      throw new Error(`Thread response ${input.threadResponseId} not found`);
    }

    const adjustment = currentThreadResponse.adjustment;
    if (!adjustment) {
      throw new Error(
        `Thread response ${input.threadResponseId} has no adjustment`,
      );
    }

    const originalThreadResponse =
      await this.threadResponseRepository.findOneBy({
        id: adjustment.payload?.originalThreadResponseId,
      });
    if (!originalThreadResponse) {
      throw new Error(
        `Original thread response ${adjustment.payload?.originalThreadResponseId} not found`,
      );
    }

    // call createAskFeedback on AI service
    const response = await this.wrenAIAdaptor.createAskFeedback({
      ...input,
      tables: adjustment.payload?.retrievedTables,
      sqlGenerationReasoning: adjustment.payload?.sqlGenerationReasoning,
      sql: originalThreadResponse.sql,
      question: originalThreadResponse.question,
    });
    const queryId = response.queryId;

    // update asking task with new queryId
    await this.askingTaskRepository.updateOne(
      currentThreadResponse.askingTaskId,
      {
        queryId,

        // reset detail
        detail: {
          adjustment: true,
          status: AskFeedbackStatus.UNDERSTANDING,
          response: [],
          error: null,
        },
      },
    );

    // schedule task
    const task = {
      queryId,
      lastPolled: Date.now(),
      isFinalized: false,
      originalThreadResponseId: originalThreadResponse.id,
      threadResponseId: currentThreadResponse.id,
      question: originalThreadResponse.question,
      rerun: true,
      adjustmentPayload: {
        originalThreadResponseId: originalThreadResponse.id,
        retrievedTables: adjustment.payload?.retrievedTables,
        sqlGenerationReasoning: adjustment.payload?.sqlGenerationReasoning,
      },
    } as TrackedTask;
    this.trackedTasks.set(queryId, task);
    this.trackedTasksById.set(currentThreadResponse.id, task);

    logger.info(`Rerun adjustment task with queryId: ${queryId}`);
    return { queryId };
  }

  public async getAdjustmentResult(
    queryId: string,
  ): Promise<TrackedAdjustmentResult | null> {
    // Check if we're tracking this task in memory
    const trackedTask = this.trackedTasks.get(queryId);

    if (trackedTask && trackedTask.result) {
      return {
        ...trackedTask.result,
        queryId,
        taskId: trackedTask.taskId,
      };
    }

    // If not in memory or no result yet, check the database
    return this.getAdjustmentResultFromDB({ queryId });
  }

  public async getAdjustmentResultById(
    id: number,
  ): Promise<TrackedAdjustmentResult | null> {
    const task = this.trackedTasksById.get(id);
    if (task) {
      return this.getAdjustmentResult(task.queryId);
    }

    return this.getAdjustmentResultFromDB({ taskId: id });
  }

  public async cancelAdjustmentTask(queryId: string): Promise<void> {
    await this.wrenAIAdaptor.cancelAskFeedback(queryId);

    // telemetry
    const eventName = TelemetryEvent.HOME_ADJUST_THREAD_RESPONSE_CANCEL;
    this.telemetry.sendEvent(eventName, {
      queryId,
    });
  }

  public stopPolling(): void {
    if (this.pollingIntervalId) {
      clearInterval(this.pollingIntervalId);
    }
  }

  private startPolling(): void {
    this.pollingIntervalId = setInterval(() => {
      this.pollTasks();
    }, this.pollingInterval);
  }

  private async pollTasks(): Promise<void> {
    const now = Date.now();
    const tasksToRemove: string[] = [];

    // Create an array of job functions
    const jobs = Array.from(this.trackedTasks.entries()).map(
      ([queryId, task]) =>
        async () => {
          try {
            // Skip if the job is already running
            if (this.runningJobs.has(queryId)) {
              return;
            }

            // Skip finalized tasks that have been in memory too long
            if (
              task.isFinalized &&
              now - task.lastPolled > this.memoryRetentionTime
            ) {
              tasksToRemove.push(queryId);
              return;
            }

            // Skip finalized tasks
            if (task.isFinalized) {
              return;
            }

            // Mark the job as running
            this.runningJobs.add(queryId);

            // Poll for updates
            logger.info(`Polling for updates for task ${queryId}`);
            const result =
              await this.wrenAIAdaptor.getAskFeedbackResult(queryId);
            task.lastPolled = now;

            // if result is not changed, we don't need to update the database
            if (!this.isResultChanged(task.result, result)) {
              this.runningJobs.delete(queryId);
              return;
            }

            // Check if task is now finalized
            if (this.isTaskFinalized(result.status)) {
              task.isFinalized = true;
              // update thread response if threadResponseId is provided
              if (task.threadResponseId) {
                await this.updateThreadResponseWhenTaskFinalized(
                  task.threadResponseId,
                  result,
                );
              }

              // telemetry
              const eventName = task.rerun
                ? TelemetryEvent.HOME_ADJUST_THREAD_RESPONSE_RERUN
                : TelemetryEvent.HOME_ADJUST_THREAD_RESPONSE;
              const eventProperties = {
                taskId: task.taskId,
                queryId: task.queryId,
                status: result.status,
                error: result.error,
                adjustmentPayload: task.adjustmentPayload,
              };
              if (result.status === AskFeedbackStatus.FINISHED) {
                this.telemetry.sendEvent(eventName, eventProperties);
              } else {
                this.telemetry.sendEvent(
                  eventName,
                  eventProperties,
                  WrenService.AI,
                  false,
                );
              }

              logger.info(
                `Task ${queryId} is finalized with status: ${result.status}`,
              );
            }

            // update task in memory if any change
            task.result = result;

            // update the database
            logger.info(`Updating task ${queryId} in database`);
            await this.updateTaskInDatabase({ queryId }, result);

            // Mark the job as finished
            this.runningJobs.delete(queryId);
          } catch (err) {
            this.runningJobs.delete(queryId);
            logger.error(err.stack);
            throw err;
          }
        },
    );

    // Run all jobs in parallel
    Promise.allSettled(jobs.map((job) => job())).then((results) => {
      // Log any rejected promises
      results.forEach((result, index) => {
        if (result.status === 'rejected') {
          logger.error(`Job ${index} failed: ${result.reason}`);
        }
      });

      // Clean up tasks that have been in memory too long
      if (tasksToRemove.length > 0) {
        logger.info(
          `Cleaning up tasks that have been in memory too long. Tasks: ${tasksToRemove.join(
            ', ',
          )}`,
        );
      }
      for (const queryId of tasksToRemove) {
        this.trackedTasks.delete(queryId);
      }
    });
  }

  private async updateThreadResponseWhenTaskFinalized(
    threadResponseId: number,
    result: AskFeedbackResult,
  ): Promise<void> {
    const response = result?.response?.[0];
    if (!response) {
      return;
    }
    await this.threadResponseRepository.updateOne(threadResponseId, {
      sql: response?.sql,
    });
  }

  private async getAdjustmentResultFromDB({
    queryId,
    taskId,
  }: {
    queryId?: string;
    taskId?: number;
  }): Promise<TrackedAdjustmentResult | null> {
    let taskRecord: AskingTask | null = null;
    if (queryId) {
      taskRecord = await this.askingTaskRepository.findByQueryId(queryId);
    } else if (taskId) {
      taskRecord = await this.askingTaskRepository.findOneBy({ id: taskId });
    }

    if (!taskRecord) {
      return null;
    }

    return {
      ...(taskRecord?.detail as AskFeedbackResult),
      queryId: queryId || taskRecord?.queryId,
      taskId: taskRecord?.id,
    };
  }

  private async updateTaskInDatabase(
    filter: { queryId?: string; taskId?: number },
    result: AskFeedbackResult,
  ): Promise<void> {
    const { queryId, taskId } = filter;
    let taskRecord: AskingTask | null = null;
    if (queryId) {
      taskRecord = await this.askingTaskRepository.findByQueryId(queryId);
    } else if (taskId) {
      taskRecord = await this.askingTaskRepository.findOneBy({ id: taskId });
    }

    if (!taskRecord) {
      throw new Error('Asking task not found');
    }

    // update the task
    await this.askingTaskRepository.updateOne(taskRecord.id, {
      detail: {
        adjustment: true,
        ...result,
      },
    });
  }

  private isTaskFinalized(status: AskFeedbackStatus): boolean {
    return [
      AskFeedbackStatus.FINISHED,
      AskFeedbackStatus.FAILED,
      AskFeedbackStatus.STOPPED,
    ].includes(status);
  }

  private isResultChanged(
    previousResult: AskFeedbackResult,
    newResult: AskFeedbackResult,
  ): boolean {
    // check status change
    if (previousResult?.status !== newResult.status) {
      return true;
    }

    return false;
  }
}
</file>

<file path="src/apollo/server/backgrounds/chart.ts">
import { ChartStatus } from '@server/models/adaptor';
import { IWrenAIAdaptor } from '@server/adaptors/wrenAIAdaptor';
import {
  IThreadResponseRepository,
  ThreadResponse,
} from '@server/repositories';
import { getLogger } from '@server/utils/logger';
import {
  PostHogTelemetry,
  TelemetryEvent,
  WrenService,
} from '@server/telemetry/telemetry';

const logger = getLogger('ChartBackgroundTracker');
logger.level = 'debug';

const isFinalized = (status: ChartStatus) => {
  return (
    status === ChartStatus.FINISHED ||
    status === ChartStatus.FAILED ||
    status === ChartStatus.STOPPED
  );
};

export class ChartBackgroundTracker {
  private tasks: Record<number, ThreadResponse> = {};
  private intervalTime: number;
  private wrenAIAdaptor: IWrenAIAdaptor;
  private threadResponseRepository: IThreadResponseRepository;
  private runningJobs = new Set();
  private telemetry: PostHogTelemetry;

  constructor({
    telemetry,
    wrenAIAdaptor,
    threadResponseRepository,
  }: {
    telemetry: PostHogTelemetry;
    wrenAIAdaptor: IWrenAIAdaptor;
    threadResponseRepository: IThreadResponseRepository;
  }) {
    this.telemetry = telemetry;
    this.wrenAIAdaptor = wrenAIAdaptor;
    this.threadResponseRepository = threadResponseRepository;
    this.intervalTime = 1000;
    this.start();
  }

  private start() {
    logger.info('Chart background tracker started');
    setInterval(() => {
      const jobs = Object.values(this.tasks).map(
        (threadResponse) => async () => {
          // check if same job is running
          if (this.runningJobs.has(threadResponse.id)) {
            return;
          }

          // mark the job as running
          this.runningJobs.add(threadResponse.id);

          // get the chart detail
          const chartDetail = threadResponse.chartDetail;

          // get the latest result from AI service
          const result = await this.wrenAIAdaptor.getChartResult(
            chartDetail.queryId,
          );

          // check if status change
          if (chartDetail.status === result.status) {
            // mark the job as finished
            logger.debug(
              `Job ${threadResponse.id} chart status not changed, finished`,
            );
            this.runningJobs.delete(threadResponse.id);
            return;
          }

          // update database
          const updatedChartDetail = {
            queryId: chartDetail.queryId,
            status: result?.status,
            error: result?.error,
            description: result?.response?.reasoning,
            chartType: result?.response?.chartType?.toUpperCase() || null,
            chartSchema: result?.response?.chartSchema,
          };
          logger.debug(
            `Job ${threadResponse.id} chart status changed, updating`,
          );
          await this.threadResponseRepository.updateOne(threadResponse.id, {
            chartDetail: updatedChartDetail,
          });

          // remove the task from tracker if it is finalized
          if (isFinalized(result.status)) {
            const eventProperties = {
              question: threadResponse.question,
              error: result.error,
            };
            if (result.status === ChartStatus.FINISHED) {
              this.telemetry.sendEvent(
                TelemetryEvent.HOME_ANSWER_CHART,
                eventProperties,
              );
            } else {
              this.telemetry.sendEvent(
                TelemetryEvent.HOME_ANSWER_CHART,
                eventProperties,
                WrenService.AI,
                false,
              );
            }
            logger.debug(
              `Job ${threadResponse.id} chart is finalized, removing`,
            );
            delete this.tasks[threadResponse.id];
          }

          // mark the job as finished
          this.runningJobs.delete(threadResponse.id);
        },
      );

      // run the jobs
      Promise.allSettled(jobs.map((job) => job())).then((results) => {
        // show reason of rejection
        results.forEach((result, index) => {
          if (result.status === 'rejected') {
            logger.error(`Job ${index} failed: ${result.reason}`);
          }
        });
      });
    }, this.intervalTime);
  }

  public addTask(threadResponse: ThreadResponse) {
    this.tasks[threadResponse.id] = threadResponse;
  }

  public getTasks() {
    return this.tasks;
  }
}

export class ChartAdjustmentBackgroundTracker {
  private tasks: Record<number, ThreadResponse> = {};
  private intervalTime: number;
  private wrenAIAdaptor: IWrenAIAdaptor;
  private threadResponseRepository: IThreadResponseRepository;
  private runningJobs = new Set();
  private telemetry: PostHogTelemetry;

  constructor({
    telemetry,
    wrenAIAdaptor,
    threadResponseRepository,
  }: {
    telemetry: PostHogTelemetry;
    wrenAIAdaptor: IWrenAIAdaptor;
    threadResponseRepository: IThreadResponseRepository;
  }) {
    this.telemetry = telemetry;
    this.wrenAIAdaptor = wrenAIAdaptor;
    this.threadResponseRepository = threadResponseRepository;
    this.intervalTime = 1000;
    this.start();
  }

  private start() {
    logger.info('Chart adjustment background tracker started');
    setInterval(() => {
      const jobs = Object.values(this.tasks).map(
        (threadResponse) => async () => {
          // check if same job is running
          if (this.runningJobs.has(threadResponse.id)) {
            return;
          }

          // mark the job as running
          this.runningJobs.add(threadResponse.id);

          // get the chart detail
          const chartDetail = threadResponse.chartDetail;

          // get the latest result from AI service
          const result = await this.wrenAIAdaptor.getChartAdjustmentResult(
            chartDetail.queryId,
          );

          // check if status change
          if (chartDetail.status === result.status) {
            // mark the job as finished
            logger.debug(
              `Job ${threadResponse.id} chart status not changed, finished`,
            );
            this.runningJobs.delete(threadResponse.id);
            return;
          }

          // update database
          const updatedChartDetail = {
            queryId: chartDetail.queryId,
            status: result?.status,
            error: result?.error,
            description: result?.response?.reasoning,
            chartType: result?.response?.chartType?.toUpperCase() || null,
            chartSchema: result?.response?.chartSchema,
            adjustment: true,
          };
          logger.debug(
            `Job ${threadResponse.id} chart status changed, updating`,
          );
          await this.threadResponseRepository.updateOne(threadResponse.id, {
            chartDetail: updatedChartDetail,
          });

          // remove the task from tracker if it is finalized
          if (isFinalized(result.status)) {
            const eventProperties = {
              question: threadResponse.question,
              error: result.error,
            };
            if (result.status === ChartStatus.FINISHED) {
              this.telemetry.sendEvent(
                TelemetryEvent.HOME_ANSWER_ADJUST_CHART,
                eventProperties,
              );
            } else {
              this.telemetry.sendEvent(
                TelemetryEvent.HOME_ANSWER_ADJUST_CHART,
                eventProperties,
                WrenService.AI,
                false,
              );
            }
            logger.debug(
              `Job ${threadResponse.id} chart is finalized, removing`,
            );
            delete this.tasks[threadResponse.id];
          }

          // mark the job as finished
          this.runningJobs.delete(threadResponse.id);
        },
      );

      // run the jobs
      Promise.allSettled(jobs.map((job) => job())).then((results) => {
        // show reason of rejection
        results.forEach((result, index) => {
          if (result.status === 'rejected') {
            logger.error(`Job ${index} failed: ${result.reason}`);
          }
        });
      });
    }, this.intervalTime);
  }

  public addTask(threadResponse: ThreadResponse) {
    this.tasks[threadResponse.id] = threadResponse;
  }

  public getTasks() {
    return this.tasks;
  }
}
</file>

<file path="src/apollo/server/backgrounds/dashboardCacheBackgroundTracker.ts">
import { getLogger } from '@server/utils';
import {
  IDashboardRepository,
  IDashboardItemRepository,
  IDashboardItemRefreshJobRepository,
  DashboardCacheRefreshStatus,
} from '@server/repositories';
import {
  IProjectService,
  IDeployService,
  IQueryService,
} from '@server/services';
import { CronExpressionParser } from 'cron-parser';
import { v4 as uuidv4 } from 'uuid';

const logger = getLogger('DashboardCacheBackgroundTracker');
logger.level = 'debug';

export class DashboardCacheBackgroundTracker {
  private intervalTime: number;
  private dashboardRepository: IDashboardRepository;
  private dashboardItemRepository: IDashboardItemRepository;
  private dashboardItemRefreshJobRepository: IDashboardItemRefreshJobRepository;
  private projectService: IProjectService;
  private deployService: IDeployService;
  private queryService: IQueryService;
  private runningJobs = new Set<number>();

  constructor({
    dashboardRepository,
    dashboardItemRepository,
    dashboardItemRefreshJobRepository,
    projectService,
    deployService,
    queryService,
  }: {
    dashboardRepository: IDashboardRepository;
    dashboardItemRepository: IDashboardItemRepository;
    dashboardItemRefreshJobRepository: IDashboardItemRefreshJobRepository;
    projectService: IProjectService;
    deployService: IDeployService;
    queryService: IQueryService;
  }) {
    this.dashboardRepository = dashboardRepository;
    this.dashboardItemRepository = dashboardItemRepository;
    this.dashboardItemRefreshJobRepository = dashboardItemRefreshJobRepository;
    this.projectService = projectService;
    this.deployService = deployService;
    this.queryService = queryService;
    this.intervalTime = 60000; // 1 minute
    this.start();
  }

  private start(): void {
    logger.info('Dashboard cache background tracker started');
    setInterval(() => {
      this.checkAndRefreshCaches();
    }, this.intervalTime);
  }

  private async checkAndRefreshCaches(): Promise<void> {
    try {
      // Get all dashboards with cache enabled
      const dashboards = await this.dashboardRepository.findAllBy({
        cacheEnabled: true,
      });

      for (const dashboard of dashboards) {
        if (!dashboard.scheduleCron || !dashboard.nextScheduledAt) {
          continue;
        }

        const now = new Date();
        const nextScheduledAt = new Date(dashboard.nextScheduledAt);

        // Check if it's time to refresh
        if (now >= nextScheduledAt) {
          logger.info(`Start Refreshing cache for dashboard ${dashboard.id}`);
          await this.refreshDashboardCache(dashboard);
          logger.info(
            `Finished Refreshing cache for dashboard ${dashboard.id}`,
          );
        }
      }
    } catch (error) {
      logger.error(`Error checking dashboard caches: ${error.message}`);
    }
  }

  private async refreshDashboardCache(dashboard: any): Promise<void> {
    if (this.runningJobs.has(dashboard.id)) {
      logger.debug(`Dashboard ${dashboard.id} refresh already in progress`);
      return;
    }

    this.runningJobs.add(dashboard.id);

    try {
      // Get all items for this dashboard
      const items = await this.dashboardItemRepository.findAllBy({
        dashboardId: dashboard.id,
      });

      // Get project and deployment info
      const project = await this.projectService.getCurrentProject();
      const deployment = await this.deployService.getLastDeployment(project.id);
      const mdl = deployment.manifest;
      const hash = uuidv4();

      // Refresh cache for each item
      await Promise.all(
        items.map(async (item) => {
          try {
            // Create a record for this refresh job
            const refreshJob =
              await this.dashboardItemRefreshJobRepository.createOne({
                hash,
                dashboardId: dashboard.id,
                dashboardItemId: item.id,
                startedAt: new Date(),
                finishedAt: null,
                status: DashboardCacheRefreshStatus.IN_PROGRESS,
                errorMessage: null,
              });

            try {
              await this.queryService.preview(item.detail.sql, {
                project,
                manifest: mdl,
                cacheEnabled: true,
                refresh: true,
              });

              // Update the record with success
              await this.dashboardItemRefreshJobRepository.updateOne(
                refreshJob.id,
                {
                  finishedAt: new Date(),
                  status: DashboardCacheRefreshStatus.SUCCESS,
                },
              );
            } catch (error) {
              // Update the record with failure
              await this.dashboardItemRefreshJobRepository.updateOne(
                refreshJob.id,
                {
                  finishedAt: new Date(),
                  status: DashboardCacheRefreshStatus.FAILED,
                  errorMessage: error.message,
                },
              );
              logger.debug(
                `Error refreshing cache for item ${item.id}: ${error.message}`,
              );
            }
          } catch (error) {
            logger.debug(
              `Error creating refresh job record for item ${item.id}: ${error.message}`,
            );
          }
        }),
      );

      // Calculate next scheduled time
      const nextScheduledAt = this.calculateNextRunTime(dashboard.scheduleCron);

      // Update dashboard with new next scheduled time
      await this.dashboardRepository.updateOne(dashboard.id, {
        nextScheduledAt,
      });
      logger.info(
        `Next scheduled time for dashboard ${dashboard.id}: ${nextScheduledAt}`,
      );

      logger.info(`Successfully refreshed cache for dashboard ${dashboard.id}`);
    } catch (error) {
      logger.error(
        `Error refreshing dashboard ${dashboard.id}: ${error.message}`,
      );
    } finally {
      this.runningJobs.delete(dashboard.id);
    }
  }

  private calculateNextRunTime(cronExpression: string): Date | null {
    try {
      const interval = CronExpressionParser.parse(cronExpression, {
        currentDate: new Date(),
      });
      return interval.next().toDate();
    } catch (error) {
      logger.error(`Failed to parse cron expression: ${error.message}`);
      return null;
    }
  }
}
</file>

<file path="src/apollo/server/backgrounds/index.ts">
export * from './adjustmentBackgroundTracker';
export * from './textBasedAnswerBackgroundTracker';
export * from './chart';
export * from './recommend-question';
export * from './dashboardCacheBackgroundTracker';
</file>

<file path="src/apollo/server/backgrounds/recommend-question.ts">
import { IProjectRepository } from '../repositories/projectRepository';
import { RecommendationQuestionStatus } from '@server/models/adaptor';
import { IWrenAIAdaptor } from '../adaptors/wrenAIAdaptor';
import { IThreadRepository, Project, Thread } from '../repositories';
import {
  ITelemetry,
  TelemetryEvent,
  WrenService,
} from '../telemetry/telemetry';
import { getLogger } from '../utils/logger';
import { Logger } from 'log4js';

// PRQ background tracker : project recommend question background tracker
const loggerPrefix = 'PRQBT:';

const isFinalized = (status: RecommendationQuestionStatus) => {
  return [
    RecommendationQuestionStatus.FINISHED,
    RecommendationQuestionStatus.FAILED,
  ].includes(status);
};

export class ProjectRecommendQuestionBackgroundTracker {
  // tasks is a kv pair of task id and thread response
  private tasks: Record<number, Project> = {};
  private intervalTime: number;
  private wrenAIAdaptor: IWrenAIAdaptor;
  private projectRepository: IProjectRepository;
  private runningJobs = new Set();
  private telemetry: ITelemetry;
  private logger: Logger;

  constructor({
    telemetry,
    wrenAIAdaptor,
    projectRepository,
  }: {
    telemetry: ITelemetry;
    wrenAIAdaptor: IWrenAIAdaptor;
    projectRepository: IProjectRepository;
  }) {
    this.logger = getLogger('PRQ Background Tracker');
    this.logger.level = 'debug';
    this.telemetry = telemetry;
    this.wrenAIAdaptor = wrenAIAdaptor;
    this.projectRepository = projectRepository;
    this.intervalTime = 1000;
    this.start();
  }

  public start() {
    this.logger.info('Recommend question background tracker started');
    setInterval(() => {
      const jobs = Object.values(this.tasks).map((project) => async () => {
        // check if same job is running
        if (this.runningJobs.has(this.taskKey(project))) {
          return;
        }

        // mark the job as running
        this.runningJobs.add(this.taskKey(project));

        // get the latest result from AI service

        const result =
          await this.wrenAIAdaptor.getRecommendationQuestionsResult(
            project.queryId,
          );

        // check if status change
        if (
          project.questionsStatus === result.status &&
          result.response?.questions.length === (project.questions || []).length
        ) {
          // mark the job as finished
          this.logger.debug(
            `${loggerPrefix}job ${this.taskKey(project)} status not changed, returning question count: ${result.response?.questions.length || 0}`,
          );
          this.runningJobs.delete(this.taskKey(project));
          return;
        }

        // update database
        if (
          result.status !== project.questionsStatus ||
          result.response?.questions.length !== (project.questions || []).length
        ) {
          this.logger.debug(
            `${loggerPrefix}job ${this.taskKey(project)} have changes, returning question count: ${result.response?.questions.length || 0}, updating`,
          );
          await this.projectRepository.updateOne(project.id, {
            questionsStatus: result.status.toUpperCase(),
            questions: result.response?.questions,
            questionsError: result.error,
          });
          project.questionsStatus = result.status;
          project.questions = result.response?.questions;
        }

        // remove the task from tracker if it is finalized
        if (isFinalized(result.status)) {
          const eventProperties = {
            projectId: project.id,
            projectType: project.type,
            status: result.status,
            questions: project.questions,
            error: result.error,
          };
          if (result.status === RecommendationQuestionStatus.FINISHED) {
            this.telemetry.sendEvent(
              TelemetryEvent.HOME_GENERATE_PROJECT_RECOMMENDATION_QUESTIONS,
              eventProperties,
            );
          } else {
            this.telemetry.sendEvent(
              TelemetryEvent.HOME_GENERATE_PROJECT_RECOMMENDATION_QUESTIONS,
              eventProperties,
              WrenService.AI,
              false,
            );
          }
          this.logger.debug(
            `${loggerPrefix}job ${this.taskKey(project)} is finalized, removing`,
          );
          delete this.tasks[this.taskKey(project)];
        }

        // mark the job as finished
        this.runningJobs.delete(this.taskKey(project));
      });

      // run the jobs
      Promise.allSettled(jobs.map((job) => job())).then((results) => {
        // show reason of rejection
        results.forEach((result, index) => {
          if (result.status === 'rejected') {
            this.logger.error(`Job ${index} failed: ${result.reason}`);
          }
        });
      });
    }, this.intervalTime);
  }

  public addTask(project: Project) {
    this.tasks[this.taskKey(project)] = project;
  }

  public getTasks() {
    return this.tasks;
  }

  public async initialize() {
    const projects = await this.projectRepository.findAll();
    for (const project of projects) {
      if (
        this.taskKey(project) &&
        !isFinalized(project.questionsStatus as RecommendationQuestionStatus)
      ) {
        this.addTask(project);
      }
    }
  }

  public taskKey(project: Project) {
    return project.id;
  }

  public isExist(project: Project) {
    return this.tasks[this.taskKey(project)];
  }
}

export class ThreadRecommendQuestionBackgroundTracker {
  // tasks is a kv pair of task id and thread response
  private tasks: Record<number, Thread> = {};
  private intervalTime: number;
  private wrenAIAdaptor: IWrenAIAdaptor;
  private threadRepository: IThreadRepository;
  private runningJobs = new Set();
  private telemetry: ITelemetry;
  private logger: Logger;

  constructor({
    telemetry,
    wrenAIAdaptor,
    threadRepository,
  }: {
    telemetry: ITelemetry;
    wrenAIAdaptor: IWrenAIAdaptor;
    threadRepository: IThreadRepository;
  }) {
    this.logger = getLogger('TRQ Background Tracker');
    this.logger.level = 'debug';
    this.telemetry = telemetry;
    this.wrenAIAdaptor = wrenAIAdaptor;
    this.threadRepository = threadRepository;
    this.intervalTime = 1000;
    this.start();
  }

  public start() {
    this.logger.info('Recommend question background tracker started');
    setInterval(() => {
      const jobs = Object.values(this.tasks).map((thread) => async () => {
        // check if same job is running
        if (this.runningJobs.has(this.taskKey(thread))) {
          return;
        }

        // mark the job as running
        this.runningJobs.add(this.taskKey(thread));

        // get the latest result from AI service

        const result =
          await this.wrenAIAdaptor.getRecommendationQuestionsResult(
            thread.queryId,
          );

        // check if status change
        if (
          thread.questionsStatus === result.status &&
          result.response?.questions.length === (thread.questions || []).length
        ) {
          // mark the job as finished
          this.logger.debug(
            `${loggerPrefix}job ${this.taskKey(thread)} status not changed, returning question count: ${result.response?.questions.length || 0}`,
          );
          this.runningJobs.delete(this.taskKey(thread));
          return;
        }

        // update database
        if (
          result.status !== thread.questionsStatus ||
          result.response?.questions.length !== (thread.questions || []).length
        ) {
          this.logger.debug(
            `${loggerPrefix}job ${this.taskKey(thread)} have changes, returning question count: ${result.response?.questions.length || 0}, updating`,
          );
          await this.threadRepository.updateOne(thread.id, {
            questionsStatus: result.status.toUpperCase(),
            questions: result.response?.questions,
            questionsError: result.error,
          });
          thread.questionsStatus = result.status;
          thread.questions = result.response?.questions;
        }

        // remove the task from tracker if it is finalized
        if (isFinalized(result.status)) {
          const eventProperties = {
            thread_id: thread.id,
            status: result.status,
            questions: thread.questions,
            error: result.error,
          };
          if (result.status === RecommendationQuestionStatus.FINISHED) {
            this.telemetry.sendEvent(
              TelemetryEvent.HOME_GENERATE_THREAD_RECOMMENDATION_QUESTIONS,
              eventProperties,
            );
          } else {
            this.telemetry.sendEvent(
              TelemetryEvent.HOME_GENERATE_THREAD_RECOMMENDATION_QUESTIONS,
              eventProperties,
              WrenService.AI,
              false,
            );
          }
          this.logger.debug(
            `${loggerPrefix}job ${this.taskKey(thread)} is finalized, removing`,
          );
          delete this.tasks[this.taskKey(thread)];
        }

        // mark the job as finished
        this.runningJobs.delete(this.taskKey(thread));
      });

      // run the jobs
      Promise.allSettled(jobs.map((job) => job())).then((results) => {
        // show reason of rejection
        results.forEach((result, index) => {
          if (result.status === 'rejected') {
            this.logger.error(`Job ${index} failed: ${result.reason}`);
          }
        });
      });
    }, this.intervalTime);
  }

  public addTask(thread: Thread) {
    this.tasks[this.taskKey(thread)] = thread;
  }

  public getTasks() {
    return this.tasks;
  }

  public async initialize() {
    const threads = await this.threadRepository.findAll();
    for (const thread of threads) {
      if (
        !this.tasks[this.taskKey(thread)] &&
        thread.queryId &&
        !isFinalized(thread.questionsStatus as RecommendationQuestionStatus)
      ) {
        this.addTask(thread);
      }
    }
  }

  public taskKey(thread: Thread) {
    return thread.id;
  }

  public isExist(thread: Thread) {
    return this.tasks[this.taskKey(thread)];
  }
}
</file>

<file path="src/apollo/server/backgrounds/textBasedAnswerBackgroundTracker.ts">
import { IWrenAIAdaptor } from '../adaptors';
import {
  WrenAILanguage,
  TextBasedAnswerResult,
  TextBasedAnswerStatus,
} from '../models/adaptor';
import { ThreadResponse, IThreadResponseRepository } from '../repositories';
import {
  IProjectService,
  IDeployService,
  IQueryService,
  ThreadResponseAnswerStatus,
  PreviewDataResponse,
} from '../services';
import { getLogger } from '@server/utils';

const logger = getLogger('TextBasedAnswerBackgroundTracker');
logger.level = 'debug';

export class TextBasedAnswerBackgroundTracker {
  // tasks is a kv pair of task id and thread response
  private tasks: Record<number, ThreadResponse> = {};
  private intervalTime: number;
  private wrenAIAdaptor: IWrenAIAdaptor;
  private threadResponseRepository: IThreadResponseRepository;
  private projectService: IProjectService;
  private deployService: IDeployService;
  private queryService: IQueryService;
  private runningJobs = new Set();

  constructor({
    wrenAIAdaptor,
    threadResponseRepository,
    projectService,
    deployService,
    queryService,
  }: {
    wrenAIAdaptor: IWrenAIAdaptor;
    threadResponseRepository: IThreadResponseRepository;
    projectService: IProjectService;
    deployService: IDeployService;
    queryService: IQueryService;
  }) {
    this.wrenAIAdaptor = wrenAIAdaptor;
    this.threadResponseRepository = threadResponseRepository;
    this.projectService = projectService;
    this.deployService = deployService;
    this.queryService = queryService;
    this.intervalTime = 1000;
    this.start();
  }

  private start() {
    setInterval(async () => {
      const jobs = Object.values(this.tasks).map(
        (threadResponse) => async () => {
          if (
            this.runningJobs.has(threadResponse.id) ||
            !threadResponse.answerDetail
          ) {
            return;
          }
          this.runningJobs.add(threadResponse.id);

          // update the status to fetching data
          await this.threadResponseRepository.updateOne(threadResponse.id, {
            answerDetail: {
              ...threadResponse.answerDetail,
              status: ThreadResponseAnswerStatus.FETCHING_DATA,
            },
          });

          // get sql data
          const project = await this.projectService.getCurrentProject();
          const deployment = await this.deployService.getLastDeployment(
            project.id,
          );
          const mdl = deployment.manifest;
          let data: PreviewDataResponse;
          try {
            data = (await this.queryService.preview(threadResponse.sql, {
              project,
              manifest: mdl,
              modelingOnly: false,
              limit: 500,
            })) as PreviewDataResponse;
          } catch (error) {
            logger.error(`Error when query sql data: ${error}`);
            await this.threadResponseRepository.updateOne(threadResponse.id, {
              answerDetail: {
                ...threadResponse.answerDetail,
                status: ThreadResponseAnswerStatus.FAILED,
                error: error?.extensions || error,
              },
            });
            throw error;
          }

          // request AI service
          const response = await this.wrenAIAdaptor.createTextBasedAnswer({
            query: threadResponse.question,
            sql: threadResponse.sql,
            sqlData: data,
            threadId: threadResponse.threadId.toString(),
            configurations: {
              language: WrenAILanguage[project.language] || WrenAILanguage.EN,
            },
          });

          // update the status to preprocessing
          await this.threadResponseRepository.updateOne(threadResponse.id, {
            answerDetail: {
              ...threadResponse.answerDetail,
              status: ThreadResponseAnswerStatus.PREPROCESSING,
            },
          });

          // polling query id to check the status
          let result: TextBasedAnswerResult;
          do {
            result = await this.wrenAIAdaptor.getTextBasedAnswerResult(
              response.queryId,
            );
            if (result.status === TextBasedAnswerStatus.PREPROCESSING) {
              await new Promise((resolve) => setTimeout(resolve, 500));
            }
          } while (result.status === TextBasedAnswerStatus.PREPROCESSING);

          // update the status to final
          const updatedAnswerDetail = {
            queryId: response.queryId,
            status:
              result.status === TextBasedAnswerStatus.SUCCEEDED
                ? ThreadResponseAnswerStatus.STREAMING
                : ThreadResponseAnswerStatus.FAILED,
            numRowsUsedInLLM: result.numRowsUsedInLLM,
            error: result.error,
          };
          await this.threadResponseRepository.updateOne(threadResponse.id, {
            answerDetail: updatedAnswerDetail,
          });

          delete this.tasks[threadResponse.id];

          // Mark the job as finished
          this.runningJobs.delete(threadResponse.id);
        },
      );

      // Run the jobs
      Promise.allSettled(jobs.map((job) => job())).then((results) => {
        // Show reason of rejection
        results.forEach((result, index) => {
          if (result.status === 'rejected') {
            logger.error(`Job ${index} failed: ${result.reason}`);
          }
        });
      });
    }, this.intervalTime);
  }

  public addTask(threadResponse: ThreadResponse) {
    this.tasks[threadResponse.id] = threadResponse;
  }

  public getTasks() {
    return this.tasks;
  }
}
</file>

<file path="src/apollo/server/config.ts">
import { pickBy } from 'lodash';

export interface IConfig {
  // wren ui
  otherServiceUsingDocker: boolean;

  // database
  dbType: string;
  // pg
  pgUrl?: string;
  debug?: boolean;
  // sqlite
  sqliteFile?: string;

  persistCredentialDir?: string;

  // wren engine
  wrenEngineEndpoint: string;

  // wren AI
  wrenAIEndpoint: string;
  generationModel?: string;

  // ibis server
  experimentalEngineRustVersion?: boolean;
  ibisServerEndpoint: string;

  // encryption
  encryptionPassword: string;
  encryptionSalt: string;

  // telemetry
  telemetryEnabled?: boolean;
  posthogApiKey?: string;
  posthogHost?: string;
  userUUID?: string;

  // versions
  wrenUIVersion?: string;
  wrenEngineVersion?: string;
  wrenAIVersion?: string;
  wrenProductVersion?: string;

  // generate recommendation questions max categories
  projectRecommendationQuestionMaxCategories?: number;
  projectRecommendationQuestionsMaxQuestions?: number;
  threadRecommendationQuestionMaxCategories?: number;
  threadRecommendationQuestionsMaxQuestions?: number;
}

const defaultConfig = {
  // wren ui
  otherServiceUsingDocker: false,

  // database
  dbType: 'sqlite',

  // pg
  pgUrl: 'postgres://postgres:postgres@localhost:5432/admin_ui',
  debug: false,

  // sqlite
  sqliteFile: './db.sqlite3',

  persistCredentialDir: `${process.cwd()}/.tmp`,

  // wren engine
  wrenEngineEndpoint: 'http://localhost:8080',

  // wren AI
  wrenAIEndpoint: 'http://localhost:5555',

  // ibis server
  experimentalEngineRustVersion: true,
  ibisServerEndpoint: 'http://127.0.0.1:8000',

  // encryption
  encryptionPassword: 'sementic',
  encryptionSalt: 'layer',
};

const config = {
  // node
  otherServiceUsingDocker: process.env.OTHER_SERVICE_USING_DOCKER === 'true',

  // database
  dbType: process.env.DB_TYPE,
  // pg
  pgUrl: process.env.PG_URL,
  debug: process.env.DEBUG === 'true',
  // sqlite
  sqliteFile: process.env.SQLITE_FILE,

  persistCredentialDir: (() => {
    if (
      process.env.PERSIST_CREDENTIAL_DIR &&
      process.env.PERSIST_CREDENTIAL_DIR.length > 0
    ) {
      return process.env.PERSIST_CREDENTIAL_DIR;
    }
    return undefined;
  })(),

  // wren engine
  wrenEngineEndpoint: process.env.WREN_ENGINE_ENDPOINT,

  // wren AI
  wrenAIEndpoint: process.env.WREN_AI_ENDPOINT,
  generationModel: process.env.GENERATION_MODEL,

  // ibis server
  experimentalEngineRustVersion:
    process.env.EXPERIMENTAL_ENGINE_RUST_VERSION === 'true',
  ibisServerEndpoint: process.env.IBIS_SERVER_ENDPOINT,

  // encryption
  encryptionPassword: process.env.ENCRYPTION_PASSWORD,
  encryptionSalt: process.env.ENCRYPTION_SALT,

  // telemetry
  telemetryEnabled:
    process.env.TELEMETRY_ENABLED &&
    process.env.TELEMETRY_ENABLED.toLocaleLowerCase() === 'true',
  posthogApiKey: process.env.POSTHOG_API_KEY,
  posthogHost: process.env.POSTHOG_HOST,
  userUUID: process.env.USER_UUID,

  // versions
  wrenUIVersion: process.env.WREN_UI_VERSION,
  wrenEngineVersion: process.env.WREN_ENGINE_VERSION,
  wrenAIVersion: process.env.WREN_AI_SERVICE_VERSION,
  wrenProductVersion: process.env.WREN_PRODUCT_VERSION,

  // generate recommendation questions max questions
  projectRecommendationQuestionMaxCategories: process.env
    .PROJECT_RECOMMENDATION_QUESTION_MAX_CATEGORIES
    ? parseInt(process.env.PROJECT_RECOMMENDATION_QUESTION_MAX_CATEGORIES)
    : 3,
  projectRecommendationQuestionsMaxQuestions: process.env
    .PROJECT_RECOMMENDATION_QUESTIONS_MAX_QUESTIONS
    ? parseInt(process.env.PROJECT_RECOMMENDATION_QUESTIONS_MAX_QUESTIONS)
    : 3,
  threadRecommendationQuestionMaxCategories: process.env
    .THREAD_RECOMMENDATION_QUESTION_MAX_CATEGORIES
    ? parseInt(process.env.THREAD_RECOMMENDATION_QUESTION_MAX_CATEGORIES)
    : 3,
  threadRecommendationQuestionsMaxQuestions: process.env
    .THREAD_RECOMMENDATION_QUESTIONS_MAX_QUESTIONS
    ? parseInt(process.env.THREAD_RECOMMENDATION_QUESTIONS_MAX_QUESTIONS)
    : 1,
};

export function getConfig(): IConfig {
  return { ...defaultConfig, ...pickBy(config) };
}
</file>

<file path="src/apollo/server/data/index.ts">
export * from './sample';
export * from './type';
</file>

<file path="src/apollo/server/data/sample.ts">
import { RelationType } from '../types';
import { SampleDatasetName } from './type';

export interface SampleDatasetColumn {
  name: string;
  properties?: Record<string, any>;
}

export interface SampleDatasetSchema {
  columnName: string;
  dataType: string;
}
export interface SampleDatasetTable {
  filePath: string;
  tableName: string;
  primaryKey?: string;
  // the column order in schema definition should be the same as the column in csv file
  schema?: SampleDatasetSchema[];
  columns?: SampleDatasetColumn[];
  properties?: Record<string, any>;
}

export interface SampleDatasetRelationship {
  fromModelName: string;
  fromColumnName: string;
  toModelName: string;
  toColumnName: string;
  type: RelationType;
  description?: string;
}
export interface SuggestedQuestion {
  question: string;
  label: string;
}

export interface SampleDataset {
  name: string; // SampleDatasetName
  tables: SampleDatasetTable[];
  questions?: SuggestedQuestion[];
  relations?: SampleDatasetRelationship[];
}

export const sampleDatasets: Record<string, SampleDataset> = {
  hr: {
    name: SampleDatasetName.HR,
    tables: [
      {
        tableName: 'salaries',
        filePath:
          'https://assets.getwren.ai/sample_data/employees/salaries.parquet',
        schema: [
          { columnName: 'emp_no', dataType: 'INTEGER' },
          { columnName: 'salary', dataType: 'INTEGER' },
          { columnName: 'from_date', dataType: 'DATE' },
          { columnName: 'to_date', dataType: 'DATE' },
        ],
        columns: [
          {
            name: 'emp_no',
            properties: {
              description: 'The employee number',
              displayName: 'emp_no',
            },
          },
          {
            name: 'salary',
            properties: {
              description: 'The salary of the employee.',
              displayName: 'salary',
            },
          },
          {
            name: 'from_date',
            properties: {
              description: 'The start date of the salary period.',
              displayName: 'from_date',
            },
          },
          {
            name: 'to_date',
            properties: {
              description: 'The end date of the salary period.',
              displayName: 'to_date',
            },
          },
        ],
        properties: {
          description:
            'Tracks the salary of employees, including the period during which each salary was valid.',
          displayName: 'salaries',
        },
      },
      {
        tableName: 'titles',
        filePath:
          'https://assets.getwren.ai/sample_data/employees/titles.parquet',
        schema: [
          { columnName: 'emp_no', dataType: 'INTEGER' },
          { columnName: 'title', dataType: 'VARCHAR' },
          { columnName: 'from_date', dataType: 'DATE' },
          { columnName: 'to_date', dataType: 'DATE' },
        ],
        columns: [
          {
            name: 'emp_no',
            properties: {
              description: 'The employee number',
              displayName: 'emp_no',
            },
          },
          {
            name: 'title',
            properties: {
              description:
                'The title or position held by the employee. Limited to a maximum of 50 characters.',
              displayName: 'title',
            },
          },
          {
            name: 'from_date',
            properties: {
              description: 'The start date when the employee held this title',
              displayName: 'from_date',
            },
          },
          {
            name: 'to_date',
            properties: {
              description:
                'The end date when the employee held this title. This can be NULL if the employee currently holds the title.',
              displayName: 'to_date',
            },
          },
        ],
        properties: {
          description:
            'Tracks the titles (positions) held by employees, including the period during which they held each title.',
          displayName: 'titles',
        },
      },
      {
        tableName: 'dept_emp',
        filePath:
          'https://assets.getwren.ai/sample_data/employees/dept_emp.parquet',
        schema: [
          { columnName: 'emp_no', dataType: 'INTEGER' },
          { columnName: 'dept_no', dataType: 'VARCHAR' },
          { columnName: 'from_date', dataType: 'DATE' },
          { columnName: 'to_date', dataType: 'DATE' },
        ],
        columns: [
          {
            name: 'emp_no',
            properties: {
              description: 'The employee number.',
              displayName: 'emp_no',
            },
          },
          {
            name: 'dept_no',
            properties: {
              description:
                'The department number the employee is associated with, referencing the dept_no in the departments table.',
              displayName: 'dept_no',
            },
          },
          {
            name: 'from_date',
            properties: {
              description:
                "The start date of the employee's association with the department.",
              displayName: 'from_date',
            },
          },
          {
            name: 'to_date',
            properties: {
              description:
                "The end date of the employee's association with the department",
              displayName: 'to_date',
            },
          },
        ],
        properties: {
          displayName: 'dept_emp',
        },
      },
      {
        tableName: 'departments',
        filePath:
          'https://assets.getwren.ai/sample_data/employees/departments.parquet',
        schema: [
          { columnName: 'dept_name', dataType: 'VARCHAR' },
          { columnName: 'dept_no', dataType: 'VARCHAR' },
        ],
        columns: [
          {
            name: 'dept_name',
            properties: {
              description:
                'The name of the department. Limited to a maximum of 40 characters. This column is also unique across the table, ensuring no two departments share the same name',
              displayName: 'dept_name',
            },
          },
          {
            name: 'dept_no',
            properties: {
              description:
                'A unique identifier for each department. It serves as the primary key of the table.',
              displayName: 'dept_no',
            },
          },
        ],
        properties: {
          displayName: 'departments',
        },
      },
      {
        tableName: 'employees',
        filePath:
          'https://assets.getwren.ai/sample_data/employees/employees.parquet',
        schema: [
          { columnName: 'birth_date', dataType: 'DATE' },
          { columnName: 'first_name', dataType: 'VARCHAR' },
          { columnName: 'last_name', dataType: 'VARCHAR' },
          { columnName: 'gender', dataType: 'VARCHAR' },
          { columnName: 'hire_date', dataType: 'DATE' },
          { columnName: 'emp_no', dataType: 'INTEGER' },
        ],
        columns: [
          {
            name: 'birth_date',
            properties: {
              description: 'The birth date of the employee.',
              displayName: 'birth_date',
            },
          },
          {
            name: 'first_name',
            properties: {
              description:
                'The first name of the employee. Limited to a maximum of 14 characters.',
              displayName: 'first_name',
            },
          },
          {
            name: 'last_name',
            properties: {
              description:
                'The last name of the employee. Limited to a maximum of 16 characters.',
              displayName: 'last_name',
            },
          },
          {
            name: 'gender',
            properties: {
              description:
                "The gender of the employee, with possible values 'M' (Male) or 'F' (Female).",
              displayName: 'gender',
            },
          },
          {
            name: 'hire_date',
            properties: {
              description: 'The date when the employee was hired.',
              displayName: 'hire_date',
            },
          },
          {
            name: 'emp_no',
            properties: {
              description:
                'A unique identifier for each employee. It serves as the primary key of the table',
              displayName: 'emp_no',
            },
          },
        ],
        properties: {
          description:
            'Stores basic information about employees such as their employee number, name, gender, birth date, and hire date',
          displayName: 'employees',
        },
      },
      {
        tableName: 'dept_manager',
        filePath:
          'https://assets.getwren.ai/sample_data/employees/dept_manager.parquet',
        schema: [
          { columnName: 'from_date', dataType: 'DATE' },
          { columnName: 'to_date', dataType: 'DATE' },
          { columnName: 'emp_no', dataType: 'INTEGER' },
          { columnName: 'dept_no', dataType: 'VARCHAR' },
        ],
        columns: [
          {
            name: 'from_date',
            properties: {
              description:
                'The start date of the employee’s managerial role in the department.',
              displayName: 'from_date',
            },
          },
          {
            name: 'to_date',
            properties: {
              description:
                'The end date of the employee’s managerial role in the department.',
              displayName: 'to_date',
            },
          },
          {
            name: 'emp_no',
            properties: {
              description: 'The employee number of the department manager',
              displayName: 'emp_no',
            },
          },
          {
            name: 'dept_no',
            properties: {
              description:
                'The department number that the manager is assigned to, referencing the dept_no in the departments table.',
              displayName: 'dept_no',
            },
          },
        ],
        properties: {
          description:
            'Tracks the assignment of managers to departments, including the period during which they managed a department',
          displayName: 'dept_manager',
        },
      },
    ],
    relations: [
      {
        fromModelName: 'employees',
        fromColumnName: 'emp_no',
        toModelName: 'titles',
        toColumnName: 'emp_no',
        type: RelationType.ONE_TO_MANY,
        description:
          'Each entry represents a title held by an employee during a specific time period.',
      },
      {
        fromModelName: 'departments',
        fromColumnName: 'dept_no',
        toModelName: 'dept_emp',
        toColumnName: 'dept_no',
        type: RelationType.ONE_TO_MANY,
      },
      {
        fromModelName: 'employees',
        fromColumnName: 'emp_no',
        toModelName: 'salaries',
        toColumnName: 'emp_no',
        type: RelationType.ONE_TO_MANY,
      },
      {
        fromModelName: 'dept_manager',
        fromColumnName: 'emp_no',
        toModelName: 'employees',
        toColumnName: 'emp_no',
        type: RelationType.MANY_TO_ONE,
      },
      {
        fromModelName: 'dept_emp',
        fromColumnName: 'emp_no',
        toModelName: 'employees',
        toColumnName: 'emp_no',
        type: RelationType.MANY_TO_ONE,
        description:
          'meaning an employee can be associated with multiple departments, titles, and salaries over time.',
      },
      {
        fromModelName: 'departments',
        fromColumnName: 'dept_no',
        toModelName: 'dept_manager',
        toColumnName: 'dept_no',
        type: RelationType.ONE_TO_MANY,
      },
    ],
    questions: [
      {
        question: 'What is the average salary for each position?',
        label: 'Aggregation',
      },
      {
        question:
          'Compare the average salary of male and female employees in each department.',
        label: 'Comparison',
      },
      {
        question:
          'What are the names of the managers and the departments they manage?',
        label: 'Associating',
      },
    ],
  },
  music: {
    name: SampleDatasetName.MUSIC,
    tables: [
      {
        tableName: 'album',
        filePath: 'https://wrenai-public.s3.amazonaws.com/demo/Music/Album.csv',
        schema: [
          { columnName: 'AlbumId', dataType: 'INT' },
          { columnName: 'Title', dataType: 'varchar' },
          { columnName: 'ArtistId', dataType: 'INT' },
        ],
      },
      {
        tableName: 'artist',
        filePath:
          'https://wrenai-public.s3.amazonaws.com/demo/Music/Artist.csv',
        schema: [
          { columnName: 'ArtistId', dataType: 'INT' },
          { columnName: 'Name', dataType: 'varchar' },
        ],
      },
      {
        tableName: 'customer',
        filePath:
          'https://wrenai-public.s3.amazonaws.com/demo/Music/Customer.csv',
        schema: [
          { columnName: 'CustomerId', dataType: 'BIGINT' },
          { columnName: 'FirstName', dataType: 'VARCHAR' },
          { columnName: 'LastName', dataType: 'VARCHAR' },
          { columnName: 'Company', dataType: 'VARCHAR' },
          { columnName: 'Address', dataType: 'VARCHAR' },
          { columnName: 'City', dataType: 'VARCHAR' },
          { columnName: 'State', dataType: 'VARCHAR' },
          { columnName: 'Country', dataType: 'VARCHAR' },
          { columnName: 'PostalCode', dataType: 'VARCHAR' },
          { columnName: 'Phone', dataType: 'VARCHAR' },
          { columnName: 'Fax', dataType: 'VARCHAR' },
          { columnName: 'Email', dataType: 'VARCHAR' },
          { columnName: 'SupportRepId', dataType: 'BIGINT' },
        ],
      },
      {
        tableName: 'genre',
        filePath: 'https://wrenai-public.s3.amazonaws.com/demo/Music/Genre.csv',
        schema: [
          { columnName: 'GenreId', dataType: 'BIGINT' },
          { columnName: 'Name', dataType: 'VARCHAR' },
        ],
      },
      {
        tableName: 'invoice',
        filePath:
          'https://wrenai-public.s3.amazonaws.com/demo/Music/Invoice.csv',
        schema: [
          { columnName: 'InvoiceId', dataType: 'BIGINT' },
          { columnName: 'CustomerId', dataType: 'BIGINT' },
          { columnName: 'InvoiceDate', dataType: 'Date' },
          { columnName: 'BillingAddress', dataType: 'VARCHAR' },
          { columnName: 'BillingCity', dataType: 'VARCHAR' },
          { columnName: 'BillingState', dataType: 'VARCHAR' },
          { columnName: 'BillingCountry', dataType: 'VARCHAR' },
          { columnName: 'BillingPostalCode', dataType: 'VARCHAR' },
          { columnName: 'Total', dataType: 'DOUBLE' },
        ],
      },
      {
        tableName: 'invoiceLine',
        filePath:
          'https://wrenai-public.s3.amazonaws.com/demo/Music/InvoiceLine.csv',
        schema: [
          { columnName: 'InvoiceLineId', dataType: 'BIGINT' },
          { columnName: 'InvoiceId', dataType: 'BIGINT' },
          { columnName: 'TrackId', dataType: 'BIGINT' },
          { columnName: 'UnitPrice', dataType: 'DOUBLE' },
          { columnName: 'Quantity', dataType: 'BIGINT' },
        ],
      },
      {
        tableName: 'track',
        filePath: 'https://wrenai-public.s3.amazonaws.com/demo/Music/Track.csv',
        schema: [
          { columnName: 'TrackId', dataType: 'BIGINT' },
          { columnName: 'Name', dataType: 'VARCHAR' },
          { columnName: 'AlbumId', dataType: 'BIGINT' },
          { columnName: 'MediaTypeId', dataType: 'BIGINT' },
          { columnName: 'GenreId', dataType: 'BIGINT' },
          { columnName: 'Composer', dataType: 'VARCHAR' },
          { columnName: 'Milliseconds', dataType: 'BIGINT' },
          { columnName: 'Bytes', dataType: 'BIGINT' },
          { columnName: 'UnitPrice', dataType: 'DOUBLE' },
        ],
      },
    ],
    questions: [
      {
        question: 'What are the top 5 selling albums in the US?',
        label: 'Ranking',
      },
      {
        question: 'What is the total revenue generated from each genre?',
        label: 'Aggregation',
      },
      {
        question:
          'Which customers have made purchases of tracks from albums in each genre?',
        label: 'General',
      },
    ],
    relations: [
      {
        fromModelName: 'album',
        fromColumnName: 'ArtistId',
        toModelName: 'artist',
        toColumnName: 'ArtistId',
        type: RelationType.MANY_TO_ONE,
      },
      {
        fromModelName: 'customer',
        fromColumnName: 'CustomerId',
        toModelName: 'invoice',
        toColumnName: 'CustomerId',
        type: RelationType.ONE_TO_MANY,
      },
      {
        fromModelName: 'genre',
        fromColumnName: 'GenreId',
        toModelName: 'track',
        toColumnName: 'GenreId',
        type: RelationType.ONE_TO_MANY,
      },
      {
        fromModelName: 'invoice',
        fromColumnName: 'InvoiceId',
        toModelName: 'invoiceLine',
        toColumnName: 'InvoiceId',
        type: RelationType.ONE_TO_MANY,
      },
      {
        fromModelName: 'track',
        fromColumnName: 'TrackId',
        toModelName: 'invoiceLine',
        toColumnName: 'TrackId',
        type: RelationType.ONE_TO_MANY,
      },
      // album -> track
      {
        fromModelName: 'album',
        fromColumnName: 'AlbumId',
        toModelName: 'track',
        toColumnName: 'AlbumId',
        type: RelationType.ONE_TO_MANY,
      },
    ],
  },
  ecommerce: {
    name: SampleDatasetName.ECOMMERCE,
    tables: [
      {
        tableName: 'olist_customers_dataset',
        primaryKey: 'customer_id',
        filePath:
          'https://assets.getwren.ai/sample_data/brazilian-ecommerce/olist_customers_dataset.parquet',
        properties: {
          displayName: 'customers',
        },
        columns: [
          {
            name: 'customer_city',
            properties: {
              description: 'Name of the city where the customer is located',
              displayName: 'customer_city',
            },
          },
          {
            name: 'customer_id',
            properties: {
              description: null,
              displayName: 'customer_id',
            },
          },
          {
            name: 'customer_state',
            properties: {
              description: 'Name of the state where the customer is located',
              displayName: 'customer_state',
            },
          },
          {
            name: 'customer_unique_id',
            properties: {
              description: 'Unique id of the customer',
              displayName: 'customer_unique_id',
            },
          },
          {
            name: 'customer_zip_code_prefix',
            properties: {
              description: 'First 5 digits of customer zip code',
              displayName: 'customer_zip_code_prefix',
            },
          },
        ],
        schema: [
          { columnName: 'customer_city', dataType: 'VARCHAR' },
          { columnName: 'customer_id', dataType: 'VARCHAR' },
          { columnName: 'customer_state', dataType: 'VARCHAR' },
          { columnName: 'customer_unique_id', dataType: 'VARCHAR' },
          { columnName: 'customer_zip_code_prefix', dataType: 'VARCHAR' },
        ],
      },
      {
        tableName: 'olist_order_items_dataset',
        primaryKey: 'order_item_id',
        filePath:
          'https://assets.getwren.ai/sample_data/brazilian-ecommerce/olist_order_items_dataset.parquet',
        properties: {
          displayName: 'order items',
          description:
            'This table contains the information related to a specific order containing its shipping cost, products, cost, number of order items, and the seller.',
        },
        columns: [
          {
            name: 'freight_value',
            properties: {
              description:
                'Cost of shipping associated with the specific order item',
              displayName: 'freight_value',
            },
          },
          {
            name: 'order_id',
            properties: {
              description:
                'Unique identifier for the order across the platform',
              displayName: 'order_id',
            },
          },
          {
            name: 'order_item_id',
            properties: {
              description:
                'Unique identifier for each item within a specific order',
              displayName: 'order_item_id',
            },
          },
          {
            name: 'price',
            properties: {
              description: 'Price of the individual item within the order',
              displayName: 'price',
            },
          },
          {
            name: 'product_id',
            properties: {
              description:
                'Unique identifier for the product sold in the order.',
              displayName: 'product_id',
            },
          },
          {
            name: 'seller_id',
            properties: {
              description:
                'Unique identifier of the seller who fulfilled the order item.',
              displayName: 'seller_id',
            },
          },
          {
            name: 'shipping_limit_date',
            properties: {
              description:
                'Deadline for the order item to be shipped by the seller.',
              displayName: 'shipping_limit_date',
            },
          },
        ],
        schema: [
          { columnName: 'freight_value', dataType: 'DOUBLE' },
          { columnName: 'order_id', dataType: 'VARCHAR' },
          { columnName: 'order_item_id', dataType: 'BIGINT' },
          { columnName: 'price', dataType: 'DOUBLE' },
          { columnName: 'product_id', dataType: 'VARCHAR' },
          { columnName: 'seller_id', dataType: 'VARCHAR' },
          { columnName: 'shipping_limit_date', dataType: 'TIMESTAMP' },
        ],
      },
      {
        tableName: 'olist_orders_dataset',
        primaryKey: 'order_id',
        filePath:
          'https://assets.getwren.ai/sample_data/brazilian-ecommerce/olist_orders_dataset.parquet',
        properties: {
          displayName: 'orders',
          description:
            'This table contains detailed information about customer orders, including timestamps for various stages of the order process (approval, shipping, delivery), as well as the order status and customer identification. It helps track the lifecycle of an order from purchase to delivery.',
        },
        columns: [
          {
            name: 'customer_id',
            properties: {
              description:
                'Unique identifier for the customer who placed the order.',
              displayName: 'customer_id',
            },
          },
          {
            name: 'order_approved_at',
            properties: {
              description:
                'Date and time when the order was approved for processing.',
              displayName: 'order_approved_at',
            },
          },
          {
            name: 'order_delivered_carrier_date',
            properties: {
              description:
                'Date when the order was handed over to the carrier or freight forwarder for delivery.',
              displayName: 'order_delivered_carrier_date',
            },
          },
          {
            name: 'order_delivered_customer_date',
            properties: {
              description: 'Date when the order was delivered to the customer.',
              displayName: 'order_delivered_customer_date',
            },
          },
          {
            name: 'order_estimated_delivery_date',
            properties: {
              description:
                'Expected delivery date based on the initial estimate.',
              displayName: 'order_estimated_delivery_date',
            },
          },
          {
            name: 'order_id',
            properties: {
              description: 'Unique identifier for the specific order',
              displayName: 'order_id',
            },
          },
          {
            name: 'order_purchase_timestamp',
            properties: {
              description:
                'Date and time when the order was placed by the customer.',
              displayName: 'order_purchase_timestamp',
            },
          },
          {
            name: 'order_status',
            properties: {
              description:
                'Current status of the order (e.g., delivered, shipped, canceled).',
              displayName: 'order_status',
            },
          },
        ],
        schema: [
          { columnName: 'customer_id', dataType: 'VARCHAR' },
          { columnName: 'order_approved_at', dataType: 'TIMESTAMP' },
          { columnName: 'order_delivered_carrier_date', dataType: 'TIMESTAMP' },
          {
            columnName: 'order_delivered_customer_date',
            dataType: 'TIMESTAMP',
          },
          {
            columnName: 'order_estimated_delivery_date',
            dataType: 'TIMESTAMP',
          },
          { columnName: 'order_id', dataType: 'VARCHAR' },
          { columnName: 'order_purchase_timestamp', dataType: 'TIMESTAMP' },
          { columnName: 'order_status', dataType: 'VARCHAR' },
        ],
      },
      {
        tableName: 'olist_order_payments_dataset',
        primaryKey: 'order_id',
        filePath:
          'https://assets.getwren.ai/sample_data/brazilian-ecommerce/olist_order_payments_dataset.parquet',
        properties: {
          displayName: 'order payments',
          description:
            'This table contains information about payment details for each order, including payment methods, amounts, installment plans, and payment sequences, helping to track how orders were paid and processed within the e-commerce platform.',
        },
        columns: [
          {
            name: 'order_id',
            properties: {
              description:
                'Unique identifier for the order associated with the payment.',
              displayName: 'order_id',
            },
          },
          {
            name: 'payment_installments',
            properties: {
              description:
                'Number of installments the payment is divided into for the order.',
              displayName: 'payment_installments',
            },
          },
          {
            name: 'payment_sequential',
            properties: {
              description:
                'Sequence number for tracking multiple payments within the same order.',
              displayName: 'payment_sequential',
            },
          },
          {
            name: 'payment_type',
            properties: {
              description:
                'Method used for the payment, such as credit card, debit, or voucher.',
              displayName: 'payment_type',
            },
          },
          {
            name: 'payment_value',
            properties: {
              description: 'Total amount paid in the specific transaction.',
              displayName: 'payment_value',
            },
          },
        ],
        schema: [
          { columnName: 'order_id', dataType: 'VARCHAR' },
          { columnName: 'payment_installments', dataType: 'BIGINT' },
          { columnName: 'payment_sequential', dataType: 'BIGINT' },
          { columnName: 'payment_type', dataType: 'VARCHAR' },
          { columnName: 'payment_value', dataType: 'DOUBLE' },
        ],
      },
      {
        tableName: 'olist_products_dataset',
        primaryKey: 'product_id',
        filePath:
          'https://assets.getwren.ai/sample_data/brazilian-ecommerce/olist_products_dataset.parquet',
        properties: {
          displayName: 'products',
          description:
            'This table provides detailed information about products, including their category, dimensions, weight, description length, and the number of photos. This helps in managing product details and enhancing the shopping experience on the e-commerce platform.',
        },
        columns: [
          {
            name: 'product_category_name',
            properties: {
              description:
                'Name of the product category to which the item belongs.',
              displayName: 'product_category_name',
            },
          },
          {
            name: 'product_description_lenght',
            properties: {
              description: 'Length of the product description in characters.',
              displayName: 'product_description_lenght',
            },
          },
          {
            name: 'product_height_cm',
            properties: {
              description: 'Height of the product in centimeters.',
              displayName: 'product_height_cm',
            },
          },
          {
            name: 'product_id',
            properties: {
              description: 'Unique identifier for the product',
              displayName: 'product_id',
            },
          },
          {
            name: 'product_length_cm',
            properties: {
              description: 'Length of the product in centimeters',
              displayName: 'product_length_cm',
            },
          },
          {
            name: 'product_name_lenght',
            properties: {
              description: 'Length of the product name in characters',
              displayName: 'product_name_lenght',
            },
          },
          {
            name: 'product_photos_qty',
            properties: {
              description: 'Number of photos available for the product',
              displayName: 'product_photos_qty',
            },
          },
          {
            name: 'product_weight_g',
            properties: {
              description: 'Weight of the product in grams',
              displayName: 'product_weight_g',
            },
          },
          {
            name: 'product_width_cm',
            properties: {
              description: 'Width of the product in centimeters',
              displayName: 'product_width_cm',
            },
          },
        ],
        schema: [
          { columnName: 'product_category_name', dataType: 'VARCHAR' },
          { columnName: 'product_description_lenght', dataType: 'BIGINT' },
          { columnName: 'product_height_cm', dataType: 'BIGINT' },
          { columnName: 'product_id', dataType: 'VARCHAR' },
          { columnName: 'product_length_cm', dataType: 'BIGINT' },
          { columnName: 'product_name_lenght', dataType: 'BIGINT' },
          { columnName: 'product_photos_qty', dataType: 'BIGINT' },
          { columnName: 'product_weight_g', dataType: 'BIGINT' },
          { columnName: 'product_width_cm', dataType: 'BIGINT' },
        ],
      },
      {
        tableName: 'olist_order_reviews_dataset',
        primaryKey: 'review_id',
        filePath:
          'https://assets.getwren.ai/sample_data/brazilian-ecommerce/olist_order_reviews_dataset.parquet',
        properties: {
          displayName: 'order reviews',
          description:
            'This table contains customer reviews for each order, including feedback comments, ratings, and timestamps for when the review was submitted and responded to. It helps track customer satisfaction and review management on the e-commerce platform.',
        },
        columns: [
          {
            name: 'order_id',
            properties: {
              description:
                'Unique identifier linking the review to the corresponding order.',
              displayName: 'order_id',
            },
          },
          {
            name: 'review_answer_timestamp',
            properties: {
              description:
                'Date and time when the review was responded to by the seller',
              displayName: 'review_answer_timestamp',
            },
          },
          {
            name: 'review_comment_message',
            properties: {
              description:
                'Detailed feedback or comments provided by the customer regarding the order.',
              displayName: 'review_comment_message',
            },
          },
          {
            name: 'review_comment_title',
            properties: {
              description: "Summary or title of the customer's review",
              displayName: 'review_comment_title',
            },
          },
          {
            name: 'review_creation_date',
            properties: {
              description:
                'Date and time when the customer initially submitted the review.',
              displayName: 'review_creation_date',
            },
          },
          {
            name: 'review_id',
            properties: {
              description: 'Unique identifier for the specific review entry.',
              displayName: 'review_id',
            },
          },
          {
            name: 'review_score',
            properties: {
              description:
                'Numeric rating given by the customer, typically ranging from 1 (worst) to 5 (best).',
              displayName: 'review_score',
            },
          },
        ],
        schema: [
          { columnName: 'order_id', dataType: 'VARCHAR' },
          { columnName: 'review_answer_timestamp', dataType: 'TIMESTAMP' },
          { columnName: 'review_comment_message', dataType: 'VARCHAR' },
          { columnName: 'review_comment_title', dataType: 'VARCHAR' },
          { columnName: 'review_creation_date', dataType: 'TIMESTAMP' },
          { columnName: 'review_id', dataType: 'VARCHAR' },
          { columnName: 'review_score', dataType: 'BIGINT' },
        ],
      },
      {
        tableName: 'olist_geolocation_dataset',
        primaryKey: '',
        filePath:
          'https://assets.getwren.ai/sample_data/brazilian-ecommerce/olist_geolocation_dataset.parquet',
        properties: {
          displayName: 'geolocation',
          description:
            'This table contains detailed information about Brazilian zip codes and their corresponding latitude and longitude coordinates. It can be used to plot maps, calculate distances between sellers and customers, and perform geographic analysis.',
        },
        columns: [
          {
            name: 'geolocation_city',
            properties: {
              displayName: 'geolocation_city',
              description: 'The city name of the geolocation',
            },
          },
          {
            name: 'geolocation_lat',
            properties: {
              displayName: 'geolocation_lat',
              description: 'The coordinations for the locations latitude',
            },
          },
          {
            name: 'geolocation_lng',
            properties: {
              displayName: 'geolocation_lng',
              description: 'The coordinations for the locations longitude',
            },
          },
          {
            name: 'geolocation_state',
            properties: {
              displayName: 'geolocation_state',
              description: 'The state of the geolocation',
            },
          },
          {
            name: 'geolocation_zip_code_prefix',
            properties: {
              displayName: 'geolocation_zip_code_prefix',
              description: 'First 5 digits of zip code',
            },
          },
        ],
        schema: [
          { columnName: 'geolocation_city', dataType: 'VARCHAR' },
          { columnName: 'geolocation_lat', dataType: 'DOUBLE' },
          { columnName: 'geolocation_lng', dataType: 'DOUBLE' },
          { columnName: 'geolocation_state', dataType: 'VARCHAR' },
          { columnName: 'geolocation_zip_code_prefix', dataType: 'VARCHAR' },
        ],
      },
      {
        tableName: 'olist_sellers_dataset',
        primaryKey: '',
        filePath:
          'https://assets.getwren.ai/sample_data/brazilian-ecommerce/olist_sellers_dataset.parquet',
        properties: {
          displayName: 'sellers',
          description:
            'This table includes data about the sellers that fulfilled orders made. Use it to find the seller location and to identify which seller fulfilled each product.',
        },
        columns: [
          {
            name: 'seller_city',
            properties: {
              description: 'The Brazilian city where the seller is located',
              displayName: 'seller_city',
            },
          },
          {
            name: 'seller_id',
            properties: {
              description: 'Unique identifier for the seller on the platform',
              displayName: 'seller_id',
            },
          },
          {
            name: 'seller_state',
            properties: {
              description: 'The Brazilian state where the seller is located',
              displayName: 'seller_state',
            },
          },
          {
            name: 'seller_zip_code_prefix',
            properties: {
              description: 'First 5 digits of seller zip code',
              displayName: 'seller_zip_code_prefix',
            },
          },
        ],
        schema: [
          { columnName: 'seller_city', dataType: 'VARCHAR' },
          { columnName: 'seller_id', dataType: 'VARCHAR' },
          { columnName: 'seller_state', dataType: 'VARCHAR' },
          { columnName: 'seller_zip_code_prefix', dataType: 'VARCHAR' },
        ],
      },
      {
        tableName: 'product_category_name_translation',
        primaryKey: 'product_category_name',
        filePath:
          'https://assets.getwren.ai/sample_data/brazilian-ecommerce/product_category_name_translation.parquet',
        properties: {
          displayName: 'product category name translation',
          description:
            'This table contains translations of product categories from Portuguese to English.',
        },
        columns: [
          {
            name: 'product_category_name',
            properties: {
              description:
                'Original name of the product category in Portuguese.',
              displayName: 'product_category_name',
            },
          },
          {
            name: 'product_category_name_english',
            properties: {
              description:
                'Translated name of the product category in English.',
              displayName: 'product_category_name_english',
            },
          },
        ],
        schema: [
          { columnName: 'product_category_name', dataType: 'VARCHAR' },
          { columnName: 'product_category_name_english', dataType: 'VARCHAR' },
        ],
      },
    ],
    questions: [
      {
        question:
          'Which are the top 3 cities with the highest number of orders?',
        label: 'Ranking',
      },
      {
        question:
          'What is the average score of reviews submitted for orders placed by customers in each city?',
        label: 'Aggregation',
      },
      {
        question:
          'What is the total value of payments made by customers from each state?',
        label: 'Aggregation',
      },
    ],
    relations: [
      // orders
      // orders -> customers
      {
        fromModelName: 'olist_orders_dataset',
        fromColumnName: 'customer_id',
        toModelName: 'olist_customers_dataset',
        toColumnName: 'customer_id',
        type: RelationType.MANY_TO_ONE,
      },
      // orders -> items
      {
        fromModelName: 'olist_orders_dataset',
        fromColumnName: 'order_id',
        toModelName: 'olist_order_items_dataset',
        toColumnName: 'order_id',
        type: RelationType.ONE_TO_MANY,
      },
      // orders -> reviews
      {
        fromModelName: 'olist_orders_dataset',
        fromColumnName: 'order_id',
        toModelName: 'olist_order_reviews_dataset',
        toColumnName: 'order_id',
        type: RelationType.ONE_TO_MANY,
      },
      // orders -> payments
      {
        fromModelName: 'olist_orders_dataset',
        fromColumnName: 'order_id',
        toModelName: 'olist_order_payments_dataset',
        toColumnName: 'order_id',
        type: RelationType.ONE_TO_MANY,
      },
      // items -> products
      {
        fromModelName: 'olist_order_items_dataset',
        fromColumnName: 'product_id',
        toModelName: 'olist_products_dataset',
        toColumnName: 'product_id',
        type: RelationType.MANY_TO_ONE,
      },
      // items -> sellers
      {
        fromModelName: 'olist_order_items_dataset',
        fromColumnName: 'seller_id',
        toModelName: 'olist_sellers_dataset',
        toColumnName: 'seller_id',
        type: RelationType.MANY_TO_ONE,
      },
      // geolocation -> customers (zip code prefix)
      {
        fromModelName: 'olist_geolocation_dataset',
        fromColumnName: 'geolocation_zip_code_prefix',
        toModelName: 'olist_customers_dataset',
        toColumnName: 'customer_zip_code_prefix',
        type: RelationType.ONE_TO_MANY,
      },
      // geolocation -> sellers (zip code prefix)
      {
        fromModelName: 'olist_geolocation_dataset',
        fromColumnName: 'geolocation_zip_code_prefix',
        toModelName: 'olist_sellers_dataset',
        toColumnName: 'seller_zip_code_prefix',
        type: RelationType.ONE_TO_MANY,
      },
      // product category name translation -> products
      {
        fromModelName: 'product_category_name_translation',
        fromColumnName: 'product_category_name',
        toModelName: 'olist_products_dataset',
        toColumnName: 'product_category_name',
        type: RelationType.ONE_TO_MANY,
      },
    ],
  },
  nba: {
    name: SampleDatasetName.NBA,
    tables: [
      {
        tableName: 'game',
        primaryKey: 'Id',
        filePath:
          'https://wrenai-public.s3.amazonaws.com/demo/v0.3.0/NBA/game.csv',
        columns: [
          {
            name: 'Id',
          },
          {
            name: 'SeasonId',
          },
          {
            name: 'TeamIdHome',
          },
          {
            name: 'WlHome',
          },
          {
            name: 'Min',
          },
          {
            name: 'FgmHome',
            properties: {
              description: 'number of field goals made by the home team.',
            },
          },
          {
            name: 'FgaHome',
            properties: {
              description: 'number of field goals attempted by the home team.',
            },
          },
          {
            name: 'threepHome',
            properties: {
              description:
                'number of three point field goals made by the home team.',
            },
          },
          {
            name: 'threepaHome',
            properties: {
              description:
                'number of three point field goals attempted by the home team.',
            },
          },
          {
            name: 'FtmHome',
            properties: {
              description: 'number of free throws made by the home team.',
            },
          },
          {
            name: 'FtaHome',
            properties: {
              description: 'number of free throws attempted by the home team.',
            },
          },
          {
            name: 'OrebHome',
            properties: {
              description: 'number of offensive rebounds by the home team.',
            },
          },
          {
            name: 'DrebHome',
            properties: {
              description: 'number of defensive rebounds by the home team.',
            },
          },
          {
            name: 'RebHome',
            properties: { description: 'number of rebounds by the home team.' },
          },
          {
            name: 'AstHome',
            properties: { description: 'number of assists by the home team.' },
          },
          {
            name: 'StlHome',
            properties: { description: 'number of steels by the home team.' },
          },
          {
            name: 'BlkHome',
            properties: { description: 'number of blocks by the home team.' },
          },
          {
            name: 'TovHome',
            properties: {
              description: 'number of turnovers by the home team.',
            },
          },
          {
            name: 'PfHome',
            properties: {
              description: 'number of personal fouls by the home team.',
            },
          },
          {
            name: 'PtsHome',
            properties: { description: 'Total score of the home team.' },
          },
          {
            name: 'PlusMimusHome',
          },
          {
            name: 'TeamIdAway',
          },
          {
            name: 'WlAway',
          },
          {
            name: 'FgmAway',
            properties: {
              description: 'number of field goals made by the away team.',
            },
          },
          {
            name: 'FgaAway',
            properties: {
              description: 'number of field goals attempted by the away team.',
            },
          },
          {
            name: 'threepAway',
            properties: {
              description:
                'number of three point field goals made by the away team.',
            },
          },
          {
            name: 'threepaAway',
            properties: {
              description:
                'number of three point field goals attempted by the away team.',
            },
          },
          {
            name: 'FtmAway',
            properties: {
              description: 'number of free throws made by the away team.',
            },
          },
          {
            name: 'FtaAway',
            properties: {
              description: 'number of free throws attempted by the away team.',
            },
          },
          {
            name: 'OrebAway',
            properties: {
              description: 'number of offensive rebounds by the away team.',
            },
          },
          {
            name: 'DrebAway',
            properties: {
              description: 'number of defensive rebounds by the away team.',
            },
          },
          {
            name: 'RebAway',
            properties: { description: 'number of rebounds by the away team.' },
          },
          {
            name: 'AstAway',
            properties: { description: 'number of assists by the away team.' },
          },
          {
            name: 'StlAway',
            properties: { description: 'number of steels by the away team.' },
          },
          {
            name: 'BlkAway',
            properties: { description: 'number of blocks by the away team.' },
          },
          {
            name: 'TovAway',
            properties: {
              description: 'number of turnovers by the away team.',
            },
          },
          {
            name: 'PfAway',
            properties: {
              description: 'number of personal fouls by the away team.',
            },
          },
          {
            name: 'PtsAway',
            properties: { description: 'Total score of the away team.' },
          },
          {
            name: 'PlusMimusAway',
          },
          {
            name: 'seasonType',
          },
        ],
        schema: [
          { columnName: 'SeasonId', dataType: 'BIGINT' },
          { columnName: 'TeamIdHome', dataType: 'BIGINT' },
          { columnName: 'Id', dataType: 'BIGINT' },
          { columnName: 'GameDate', dataType: 'DATE' },
          { columnName: 'WlHome', dataType: 'VARCHAR' },
          { columnName: 'Min', dataType: 'BIGINT' },
          { columnName: 'FgmHome', dataType: 'BIGINT' },
          { columnName: 'FgaHome', dataType: 'BIGINT' },
          { columnName: 'FgPct_home', dataType: 'DOUBLE' },
          { columnName: 'threepHome', dataType: 'BIGINT' },
          { columnName: 'threepaHome', dataType: 'BIGINT' },
          { columnName: 'fg3_pct_home', dataType: 'DOUBLE' },
          { columnName: 'FtmHome', dataType: 'BIGINT' },
          { columnName: 'FtaHome', dataType: 'BIGINT' },
          { columnName: 'ft_pct_home', dataType: 'DOUBLE' },
          { columnName: 'OrebHome', dataType: 'BIGINT' },
          { columnName: 'DrebHome', dataType: 'BIGINT' },
          { columnName: 'RebHome', dataType: 'BIGINT' },
          { columnName: 'AstHome', dataType: 'BIGINT' },
          { columnName: 'StlHome', dataType: 'BIGINT' },
          { columnName: 'BlkHome', dataType: 'BIGINT' },
          { columnName: 'TovHome', dataType: 'BIGINT' },
          { columnName: 'PfHome', dataType: 'BIGINT' },
          { columnName: 'PtsHome', dataType: 'BIGINT' },
          { columnName: 'PlusMinusHome', dataType: 'BIGINT' },
          { columnName: 'TeamIdAway', dataType: 'BIGINT' },
          { columnName: 'WlAway', dataType: 'VARCHAR' },
          { columnName: 'FgmAway', dataType: 'BIGINT' },
          { columnName: 'FgaAway', dataType: 'BIGINT' },
          { columnName: 'fg_pct_away', dataType: 'DOUBLE' },
          { columnName: 'threepAway', dataType: 'BIGINT' },
          { columnName: 'threepaAway', dataType: 'BIGINT' },
          { columnName: 'Fg3_pct_away', dataType: 'DOUBLE' },
          { columnName: 'FtmAway', dataType: 'BIGINT' },
          { columnName: 'FtaAway', dataType: 'BIGINT' },
          { columnName: 'Ft_pct_away', dataType: 'DOUBLE' },
          { columnName: 'OrebAway', dataType: 'BIGINT' },
          { columnName: 'DrebAway', dataType: 'BIGINT' },
          { columnName: 'RebAway', dataType: 'BIGINT' },
          { columnName: 'AstAway', dataType: 'BIGINT' },
          { columnName: 'StlAway', dataType: 'BIGINT' },
          { columnName: 'BlkAway', dataType: 'BIGINT' },
          { columnName: 'TovAway', dataType: 'BIGINT' },
          { columnName: 'PfAway', dataType: 'BIGINT' },
          { columnName: 'PtsAway', dataType: 'BIGINT' },
          { columnName: 'PlusMinusAway', dataType: 'BIGINT' },
          { columnName: 'SeasonType', dataType: 'VARCHAR' },
        ],
        properties: {
          description:
            'This table describes the game statistics for both the home and away teams in each NBA game. Turnover percentage is the number of possessions that end in a turnover. The formula for turnover percentage (TOV%) is "TOV% = (Tov ÷ (FGA + (0.44 x FTA) + Tov)) x 100%".',
        },
      },
      {
        tableName: 'line_score',
        primaryKey: 'GameId',
        filePath:
          'https://wrenai-public.s3.amazonaws.com/demo/v0.3.0/NBA/line_score.csv',
        columns: [
          {
            name: 'GameId',
          },
          {
            name: 'GameDate',
          },
          {
            name: 'GameSequence',
          },
          {
            name: 'TeamIdHome',
          },
          {
            name: 'TeamWinsLossesHome',
          },
          {
            name: 'PtsQtr1Home',
            properties: {
              description: 'The score of the home team in the first quarter.',
            },
          },
          {
            name: 'PtsQtr2Home',
            properties: {
              description: 'The score of the home team in the second quarter.',
            },
          },
          {
            name: 'PtsQtr3Home',
            properties: {
              description: 'The score of the home team in the third quarter.',
            },
          },
          {
            name: 'PtsQtr4Home',
            properties: {
              description: 'The score of the home team in the fourth quarter.',
            },
          },
          {
            name: 'PtsOt1Home',
            properties: {
              description:
                'The score of the home team in the overtime. The value of 0 indicates that the game did not go into overtime.',
            },
          },
          {
            name: 'PtsHome',
            properties: { description: 'Total score of the home team.' },
          },
          {
            name: 'TeamIdAway',
          },
          {
            name: 'TeamWinsLossesAway',
          },
          {
            name: 'PtsQtr1Away',
            properties: {
              description: 'The score of the away team in the first quarter.',
            },
          },
          {
            name: 'PtsQtr2Away',
            properties: {
              description: 'The score of the away team in the second quarter.',
            },
          },
          {
            name: 'PtsQtr3Away',
            properties: {
              description: 'The score of the away team in the third quarter.',
            },
          },
          {
            name: 'PtsQtr4Away',
            properties: {
              description: 'The score of the away team in the fourth quarter.',
            },
          },
          {
            name: 'PtsOt1Away',
            properties: {
              description:
                'The score of the away team in the overtime. The value of 0 indicates that the game did not go into overtime.',
            },
          },
          {
            name: 'PtsAway',
            properties: { description: 'Total score of the away team.' },
          },
        ],
        schema: [
          { columnName: 'GameDate', dataType: 'DATE' },
          { columnName: 'GameSequence', dataType: 'BIGINT' },
          { columnName: 'GameId', dataType: 'BIGINT' },
          { columnName: 'TeamIdHome', dataType: 'BIGINT' },
          { columnName: 'TeamWinsLossesHome', dataType: 'VARCHAR' },
          { columnName: 'PtsQtr1Home', dataType: 'BIGINT' },
          { columnName: 'PtsQtr2Home', dataType: 'BIGINT' },
          { columnName: 'PtsQtr3Home', dataType: 'BIGINT' },
          { columnName: 'PtsQtr4Home', dataType: 'BIGINT' },
          { columnName: 'PtsOt1Home', dataType: 'BIGINT' },
          { columnName: 'PtsHome', dataType: 'BIGINT' },
          { columnName: 'TeamIdAway', dataType: 'BIGINT' },
          { columnName: 'TeamWinsLossesAway', dataType: 'VARCHAR' },
          { columnName: 'PtsQtr1Away', dataType: 'BIGINT' },
          { columnName: 'PtsQtr2Away', dataType: 'BIGINT' },
          { columnName: 'PtsQtr3Away', dataType: 'BIGINT' },
          { columnName: 'PtsQtr4Away', dataType: 'BIGINT' },
          { columnName: 'PtsOt1Away', dataType: 'BIGINT' },
          { columnName: 'PtsAway', dataType: 'BIGINT' },
        ],
        properties: {
          description:
            'This table describes the scores and total score for each quarter or overtime of an NBA game, detailing the scores for both the home team and the away team.',
        },
      },
      {
        tableName: 'player_games',
        primaryKey: 'Id',
        filePath:
          'https://wrenai-public.s3.amazonaws.com/demo/v0.3.0/NBA/player_game.csv',
        columns: [
          {
            name: 'Id',
          },
          {
            name: 'GameId',
          },
          {
            name: 'PlayerId',
          },
          {
            name: 'Date',
          },
          {
            name: 'Age',
            properties: { description: 'player age. The format is "age-days"' },
          },
          {
            name: 'Tm',
            properties: { description: 'team affiliation.' },
          },
          {
            name: 'Opp',
            properties: { description: 'opposing team.' },
          },
          {
            name: 'MP',
            properties: { description: 'minutes played' },
          },
          {
            name: 'FG',
            properties: {
              description: 'number of two point field goals made.',
            },
          },
          {
            name: 'FGA',
            properties: {
              description:
                'number of two point field goals attempted (do not include free throws).',
            },
          },
          {
            name: 'threeP',
            properties: {
              description: 'number of three point field goals made.',
            },
          },
          {
            name: 'threePA',
            properties: {
              description: 'number of three point field goals attempted.',
            },
          },
          {
            name: 'FT',
            properties: { description: 'number of free throws made.' },
          },
          {
            name: 'FTA',
            properties: { description: 'number of free throws attempted.' },
          },
          {
            name: 'ORB',
            properties: { description: 'number of offensive rebounds.' },
          },
          {
            name: 'DRB',
            properties: { description: 'number of defensive rebounds.' },
          },
          {
            name: 'AST',
            properties: { description: 'number of assists.' },
          },
          {
            name: 'STL',
            properties: { description: 'number of Steals.' },
          },
          {
            name: 'BLK',
            properties: { description: 'number of blocks.' },
          },
          {
            name: 'TOV',
            properties: { description: 'number of turnovers allowed' },
          },
          {
            name: 'PF',
            properties: { description: 'number of personal fouls' },
          },
          {
            name: 'PTS',
            properties: { description: 'total score' },
          },
        ],
        schema: [
          { columnName: 'Id', dataType: 'BIGINT' },
          { columnName: 'PlayerID', dataType: 'BIGINT' },
          { columnName: 'GameID', dataType: 'BIGINT' },
          { columnName: 'Date', dataType: 'DATE' },
          { columnName: 'Age', dataType: 'VARCHAR' }, // 35-032
          { columnName: 'Tm', dataType: 'VARCHAR' },
          { columnName: 'Opp', dataType: 'VARCHAR' },
          { columnName: 'MP', dataType: 'VARCHAR' }, // 37:25:00
          { columnName: 'FG', dataType: 'BIGINT' },
          { columnName: 'FGA', dataType: 'BIGINT' },
          { columnName: 'threeP', dataType: 'BIGINT' },
          { columnName: 'threePA', dataType: 'BIGINT' },
          { columnName: 'FT', dataType: 'BIGINT' },
          { columnName: 'FTA', dataType: 'BIGINT' },
          { columnName: 'ORB', dataType: 'BIGINT' },
          { columnName: 'DRB', dataType: 'BIGINT' },
          { columnName: 'TRB', dataType: 'BIGINT' },
          { columnName: 'AST', dataType: 'BIGINT' },
          { columnName: 'STL', dataType: 'BIGINT' },
          { columnName: 'BLK', dataType: 'BIGINT' },
          { columnName: 'TOV', dataType: 'BIGINT' },
          { columnName: 'PF', dataType: 'BIGINT' },
          { columnName: 'PTS', dataType: 'BIGINT' },
        ],
        properties: {
          description:
            'This table describes the game statistics for each NBA player in every game. Turnover percentage is the number of possessions that end in a turnover. The formula for turnover percentage (TOV%) is "TOV% = (Tov ÷ (FGA + (0.44 x FTA) + Tov)) x 100%".',
        },
      },
      {
        tableName: 'player',
        primaryKey: 'Id',
        filePath:
          'https://wrenai-public.s3.amazonaws.com/demo/v0.3.0/NBA/player.csv',
        columns: [
          {
            name: 'Id',
          },
          {
            name: 'TeamId',
          },
          {
            name: 'FullName',
          },
          {
            name: 'FirstName',
          },
          {
            name: 'LastName',
          },
        ],
        schema: [
          { columnName: 'Id', dataType: 'BIGINT' },
          { columnName: 'TeamId', dataType: 'BIGINT' },
          { columnName: 'FullName', dataType: 'VARCHAR' },
          { columnName: 'FirstName', dataType: 'VARCHAR' },
          { columnName: 'LastName', dataType: 'VARCHAR' },
        ],
        properties: {
          description:
            'This table describes NBA players by their ID, name, and team affiliation.',
        },
      },
      {
        tableName: 'team',
        primaryKey: 'Id',
        filePath:
          'https://wrenai-public.s3.amazonaws.com/demo/v0.3.0/NBA/team.csv',
        columns: [
          {
            name: 'Id',
          },
          {
            name: 'FullName',
          },
          {
            name: 'Abbreviation',
          },
          {
            name: 'Nickname',
          },
          {
            name: 'City',
          },
          {
            name: 'State',
          },
          {
            name: 'YearFounded',
          },
        ],
        schema: [
          { columnName: 'Id', dataType: 'BIGINT' },
          { columnName: 'FullName', dataType: 'VARCHAR' },
          { columnName: 'Abbreviation', dataType: 'VARCHAR' },
          { columnName: 'Nickname', dataType: 'VARCHAR' },
          { columnName: 'City', dataType: 'VARCHAR' },
          { columnName: 'State', dataType: 'VARCHAR' },
          { columnName: 'YearFounded', dataType: 'INT' },
        ],
        properties: {
          description:
            'This table describes NBA teams by their ID, team name, team abbreviation, and founding date.',
        },
      },
    ],
    questions: [
      {
        question:
          'How many three-pointers were made by each player in each game?',
        label: 'Aggregation',
      },
      {
        question:
          'What is the differences in turnover rates between teams with high and low average scores?',
        label: 'Comparison',
      },
      {
        question:
          'Which teams had the highest average points scored per game throughout the season?',
        label: 'Ranking',
      },
    ],
    relations: [
      {
        fromModelName: 'game',
        fromColumnName: 'Id',
        toModelName: 'line_score',
        toColumnName: 'GameId',
        type: RelationType.ONE_TO_MANY,
      },
      {
        fromModelName: 'line_score',
        fromColumnName: 'GameId',
        toModelName: 'player_games',
        toColumnName: 'GameID',
        type: RelationType.ONE_TO_MANY,
      },
      {
        fromModelName: 'player',
        fromColumnName: 'TeamId',
        toModelName: 'team',
        toColumnName: 'Id',
        type: RelationType.ONE_TO_ONE,
      },
      {
        fromModelName: 'team',
        fromColumnName: 'Id',
        toModelName: 'game',
        toColumnName: 'TeamIdHome',
        type: RelationType.ONE_TO_MANY,
      },
    ],
  },
};

export const buildInitSql = (datasetName: SampleDatasetName) => {
  const selectedDataset = sampleDatasets[datasetName.toLowerCase()];

  return selectedDataset.tables
    .map((table) => {
      const schema = table.schema
        ?.map(({ columnName, dataType }) => `'${columnName}': '${dataType}'`)
        .join(', ');
      const fileExtension = table.filePath.split('.').pop();
      const createTableStatement = (fileType: string, schema?: string) => {
        if (fileType !== 'csv' && fileType !== 'parquet') {
          throw new Error(`Unsupported file type: ${fileType}`);
        }
        const baseStatement = `CREATE TABLE ${table.tableName} AS select * FROM read_${fileType}('${table.filePath}'`;
        const schemaPart =
          fileType === 'csv' && schema ? `, columns={${schema}}` : '';
        const headerPart = fileType === 'csv' ? ',header=true' : '';
        return `${baseStatement}${headerPart}${schemaPart});`;
      };

      return createTableStatement(fileExtension, schema);
    })
    .join('\n');
};

export const getRelations = (datasetName: SampleDatasetName) => {
  const selectedDataset = sampleDatasets[datasetName.toLowerCase()];
  return selectedDataset.relations;
};

export const getSampleAskQuestions = (datasetName: SampleDatasetName) => {
  const selectedDataset = sampleDatasets[datasetName.toLowerCase()];
  return selectedDataset.questions;
};
</file>

<file path="src/apollo/server/data/type.ts">
export enum SampleDatasetName {
  MUSIC = 'MUSIC',
  NBA = 'NBA',
  ECOMMERCE = 'ECOMMERCE',
  HR = 'HR',
}
</file>

<file path="src/apollo/server/dataSource.ts">
import {
  IbisBigQueryConnectionInfo,
  IbisPostgresConnectionInfo,
  HostBasedConnectionInfo,
  UrlBasedConnectionInfo,
  IbisSnowflakeConnectionInfo,
  IbisTrinoConnectionInfo,
  IbisAthenaConnectionInfo,
  IbisRedshiftConnectionType,
  IbisRedshiftConnectionInfo,
} from './adaptors/ibisAdaptor';
import {
  ATHENA_CONNECTION_INFO,
  BIG_QUERY_CONNECTION_INFO,
  DUCKDB_CONNECTION_INFO,
  MYSQL_CONNECTION_INFO,
  POSTGRES_CONNECTION_INFO,
  MS_SQL_CONNECTION_INFO,
  WREN_AI_CONNECTION_INFO,
  CLICK_HOUSE_CONNECTION_INFO,
  TRINO_CONNECTION_INFO,
  SNOWFLAKE_CONNECTION_INFO,
  ORACLE_CONNECTION_INFO,
  REDSHIFT_CONNECTION_INFO,
  REDSHIFT_IAM_AUTH,
  REDSHIFT_PASSWORD_AUTH,
} from './repositories';
import { DataSourceName } from './types';
import { getConfig } from './config';
import { Encryptor } from './utils';

const config = getConfig();
const encryptor = new Encryptor(config);

export function encryptConnectionInfo(
  dataSourceType: DataSourceName,
  connectionInfo: WREN_AI_CONNECTION_INFO,
) {
  return dataSource[dataSourceType].sensitiveProps.reduce(
    (acc, prop: string) => {
      const value = connectionInfo[prop];
      if (value) {
        const encryption = encryptor.encrypt(
          JSON.parse(JSON.stringify({ [prop]: value })),
        );
        return { ...acc, [prop]: encryption };
      }
      return acc;
    },
    connectionInfo,
  );
}

export function toIbisConnectionInfo(dataSourceType, connectionInfo) {
  return dataSource[dataSourceType].toIbisConnectionInfo(connectionInfo);
}

export function toMultipleIbisConnectionInfos(dataSourceType, connectionInfo) {
  if (!dataSource[dataSourceType].toMultipleIbisConnectionInfos) {
    return null;
  }
  return dataSource[dataSourceType].toMultipleIbisConnectionInfos(
    connectionInfo,
  );
}

interface IDataSourceConnectionInfo<C, I> {
  sensitiveProps: string[];
  toIbisConnectionInfo(connectionInfo: C): I;
  toMultipleIbisConnectionInfos?(connectionInfo: C): I[];
}

const dataSource = {
  // Athena
  [DataSourceName.ATHENA]: {
    sensitiveProps: ['awsSecretKey'],
    toIbisConnectionInfo(connectionInfo) {
      const decryptedConnectionInfo = decryptConnectionInfo(
        DataSourceName.ATHENA,
        connectionInfo,
      );
      const { awsAccessKey, awsRegion, awsSecretKey, s3StagingDir, schema } =
        decryptedConnectionInfo as ATHENA_CONNECTION_INFO;
      const res: IbisAthenaConnectionInfo = {
        aws_access_key_id: awsAccessKey,
        aws_secret_access_key: awsSecretKey,
        region_name: awsRegion,
        s3_staging_dir: s3StagingDir,
        schema_name: schema,
      };
      return res;
    },
  } as IDataSourceConnectionInfo<
    ATHENA_CONNECTION_INFO,
    IbisAthenaConnectionInfo
  >,

  // BigQuery
  [DataSourceName.BIG_QUERY]: {
    sensitiveProps: ['credentials'],
    toIbisConnectionInfo(connectionInfo) {
      const decryptedConnectionInfo = decryptConnectionInfo(
        DataSourceName.BIG_QUERY,
        connectionInfo,
      );
      const { projectId, datasetId, credentials } =
        decryptedConnectionInfo as BIG_QUERY_CONNECTION_INFO;
      const base64Credentials = Buffer.from(
        JSON.stringify(credentials),
      ).toString('base64');
      const res: IbisBigQueryConnectionInfo = {
        project_id: projectId,
        dataset_id: datasetId,
        credentials: base64Credentials,
      };
      return res;
    },
  } as IDataSourceConnectionInfo<
    BIG_QUERY_CONNECTION_INFO,
    IbisBigQueryConnectionInfo
  >,

  // Postgres
  [DataSourceName.POSTGRES]: {
    sensitiveProps: ['password'],
    toIbisConnectionInfo(connectionInfo) {
      const decryptedConnectionInfo = decryptConnectionInfo(
        DataSourceName.POSTGRES,
        connectionInfo,
      );
      const { host, port, database, user, password, ssl } =
        decryptedConnectionInfo as POSTGRES_CONNECTION_INFO;

      // url encode password
      const encodedPassword = encodeURIComponent(password);
      let connectionUrl = `postgresql://${user}:${encodedPassword}@${host}:${port}/${database}?`;
      if (ssl) {
        connectionUrl += 'sslmode=require';
      }
      return {
        connectionUrl,
      };
    },
  } as IDataSourceConnectionInfo<
    POSTGRES_CONNECTION_INFO,
    IbisPostgresConnectionInfo
  >,

  // mysql
  [DataSourceName.MYSQL]: {
    sensitiveProps: ['password'],
    toIbisConnectionInfo(connectionInfo) {
      const decryptedConnectionInfo = decryptConnectionInfo(
        DataSourceName.MYSQL,
        connectionInfo,
      );
      const { host, port, database, user, password, ssl } =
        decryptedConnectionInfo as MYSQL_CONNECTION_INFO;
      return {
        host,
        port,
        database,
        user,
        password,
        sslMode: ssl ? 'ENABLED' : 'DISABLED',
      };
    },
  } as IDataSourceConnectionInfo<
    MYSQL_CONNECTION_INFO,
    HostBasedConnectionInfo
  >,

  // Oracle
  [DataSourceName.ORACLE]: {
    sensitiveProps: ['password', 'dsn'],
    toIbisConnectionInfo(connectionInfo) {
      const decryptedConnectionInfo = decryptConnectionInfo(
        DataSourceName.ORACLE,
        connectionInfo,
      );
      const { host, port, database, user, password, dsn } =
        decryptedConnectionInfo as ORACLE_CONNECTION_INFO;
      return Object.entries({
        host,
        port,
        database,
        user,
        password,
        dsn,
      }).reduce((acc, [key, value]) => {
        if (value !== undefined && value !== '') {
          acc[key] = value;
        }
        return acc;
      }, {});
    },
  } as IDataSourceConnectionInfo<
    ORACLE_CONNECTION_INFO,
    HostBasedConnectionInfo
  >,

  // SQL Server
  [DataSourceName.MSSQL]: {
    sensitiveProps: ['password'],
    toIbisConnectionInfo(connectionInfo) {
      const decryptedConnectionInfo = decryptConnectionInfo(
        DataSourceName.MSSQL,
        connectionInfo,
      );
      const { host, port, database, user, password, trustServerCertificate } =
        decryptedConnectionInfo as MS_SQL_CONNECTION_INFO;

      return {
        host,
        port,
        database,
        user,
        password,
        ...(trustServerCertificate && {
          kwargs: { trustServerCertificate: 'YES' },
        }),
      };
    },
  } as IDataSourceConnectionInfo<
    MS_SQL_CONNECTION_INFO,
    HostBasedConnectionInfo
  >,

  // Click House
  [DataSourceName.CLICK_HOUSE]: {
    sensitiveProps: ['password'],
    toIbisConnectionInfo(connectionInfo) {
      const decryptedConnectionInfo = decryptConnectionInfo(
        DataSourceName.CLICK_HOUSE,
        connectionInfo,
      );
      const { host, port, database, user, password, ssl } =
        decryptedConnectionInfo as CLICK_HOUSE_CONNECTION_INFO;
      const encodedPassword = encodeURIComponent(password);
      let connectionUrl = `clickhouse://${user}:${encodedPassword}@${host}:${port}/${database}?`;
      if (ssl) {
        connectionUrl += 'secure=1';
      }
      return { connectionUrl };
    },
  } as IDataSourceConnectionInfo<
    CLICK_HOUSE_CONNECTION_INFO,
    UrlBasedConnectionInfo
  >,
  [DataSourceName.TRINO]: {
    sensitiveProps: ['password'],
    toIbisConnectionInfo(connectionInfo) {
      const { host, password, port, schemas, username, ssl } =
        decryptConnectionInfo(
          DataSourceName.TRINO,
          connectionInfo,
        ) as TRINO_CONNECTION_INFO;
      // pick first schema from schemas
      const [catalog, schema] = schemas.split(',')?.[0]?.split('.') ?? [];
      if (!catalog || !schema) {
        throw new Error('Invalid schema format, expected catalog.schema');
      }
      return {
        host: ssl ? `https://${host}` : `http://${host}`,
        port,
        catalog,
        schema,
        user: username,
        password,
      };
    },
    toMultipleIbisConnectionInfos(connectionInfo) {
      const { host, port, schemas, username, password, ssl } =
        decryptConnectionInfo(
          DataSourceName.TRINO,
          connectionInfo,
        ) as TRINO_CONNECTION_INFO;

      // Helper function to parse and validate schema
      const parseSchema = (schemaStr: string) => {
        const trimmed = schemaStr.trim();
        const [catalog, schema] = trimmed.split('.');
        if (!catalog || !schema) {
          throw new Error(
            `Invalid schema format: "${trimmed}". Expected format: catalog.schema`,
          );
        }
        return { catalog, schema };
      };

      // schemas format will be `catalog.schema, catalog.schema, ...`
      const schemasArray = schemas.split(',').filter(Boolean);
      if (schemasArray.length === 0) {
        throw new Error(
          'No valid schemas provided. Expected format: catalog.schema[, catalog.schema, ...]',
        );
      }

      return schemasArray.map((schema) => {
        const { catalog, schema: schemaName } = parseSchema(schema);

        return {
          host: ssl ? `https://${host}` : `http://${host}`,
          port,
          catalog,
          schema: schemaName,
          user: username,
          password,
        };
      });
    },
  } as IDataSourceConnectionInfo<
    TRINO_CONNECTION_INFO,
    IbisTrinoConnectionInfo
  >,

  // Snowflake
  [DataSourceName.SNOWFLAKE]: {
    sensitiveProps: ['password'],
    toIbisConnectionInfo(connectionInfo) {
      const decryptedConnectionInfo = decryptConnectionInfo(
        DataSourceName.SNOWFLAKE,
        connectionInfo,
      );
      const { user, password, account, database, schema } =
        decryptedConnectionInfo as SNOWFLAKE_CONNECTION_INFO;
      return { user, password, account, database, schema };
    },
  } as IDataSourceConnectionInfo<
    SNOWFLAKE_CONNECTION_INFO,
    IbisSnowflakeConnectionInfo
  >,

  // DuckDB
  [DataSourceName.DUCKDB]: {
    sensitiveProps: [],
    toIbisConnectionInfo(_connectionInfo) {
      throw new Error('Not implemented');
    },
  } as IDataSourceConnectionInfo<DUCKDB_CONNECTION_INFO, unknown>,

  // Redshift
  [DataSourceName.REDSHIFT]: {
    sensitiveProps: ['password', 'awsSecretKey'],
    toIbisConnectionInfo(connectionInfo) {
      const decryptedConnectionInfo = decryptConnectionInfo(
        DataSourceName.REDSHIFT,
        connectionInfo,
      );

      const { redshiftType } =
        decryptedConnectionInfo as REDSHIFT_CONNECTION_INFO;

      // using password authentication
      if (redshiftType === IbisRedshiftConnectionType.REDSHIFT) {
        const { host, port, database, user, password } =
          decryptedConnectionInfo as REDSHIFT_PASSWORD_AUTH;
        return {
          redshift_type: redshiftType,
          host,
          port,
          database,
          user,
          password,
        };
      }

      // using IAM authentication
      if (redshiftType === IbisRedshiftConnectionType.REDSHIFT_IAM) {
        const {
          clusterIdentifier,
          user,
          database,
          awsRegion,
          awsAccessKey,
          awsSecretKey,
        } = decryptedConnectionInfo as REDSHIFT_IAM_AUTH;

        return {
          redshift_type: redshiftType,
          cluster_identifier: clusterIdentifier,
          user,
          database,
          region: awsRegion,
          access_key_id: awsAccessKey,
          access_key_secret: awsSecretKey,
        };
      }

      throw new Error(
        'Invalid Redshift connection info: must use either password or IAM authentication',
      );
    },
  } as IDataSourceConnectionInfo<
    REDSHIFT_CONNECTION_INFO,
    IbisRedshiftConnectionInfo
  >,
};

function decryptConnectionInfo(
  dataSourceType: DataSourceName,
  connectionInfo: WREN_AI_CONNECTION_INFO,
): WREN_AI_CONNECTION_INFO {
  return dataSource[dataSourceType].sensitiveProps.reduce(
    (acc, prop: string) => {
      const value = connectionInfo[prop];
      if (value) {
        const decryption = encryptor.decrypt(value);
        const decryptedValue = JSON.parse(decryption)[prop];
        return { ...acc, [prop]: decryptedValue };
      }
      return acc;
    },
    connectionInfo,
  );
}
</file>

<file path="src/apollo/server/index.ts">
export * from './schema';
export * from './resolvers';
</file>

<file path="src/apollo/server/managers/dataSourceSchemaDetector.ts">
import { camelCase, differenceWith, isEmpty, isEqual, uniqBy } from 'lodash';
import { IContext } from '@server/types';
import { getLogger } from 'log4js';
import { SchemaChange } from '@server/repositories/schemaChangeRepository';
import { Model, ModelColumn, RelationInfo } from '../repositories';

const logger = getLogger('DataSourceSchemaDetector');
logger.level = 'debug';

export type DataSourceSchema = {
  name: string;
  columns: {
    name: string;
    type: string;
  }[];
};

export type DataSourceSchemaChange = {
  [SchemaChangeType.DELETED_TABLES]?: DataSourceSchema[];
  [SchemaChangeType.DELETED_COLUMNS]?: DataSourceSchema[];
  [SchemaChangeType.MODIFIED_COLUMNS]?: DataSourceSchema[];
};

export type DataSourceSchemaResolve = {
  [SchemaChangeType.DELETED_TABLES]?: boolean;
  [SchemaChangeType.DELETED_COLUMNS]?: boolean;
  [SchemaChangeType.MODIFIED_COLUMNS]?: boolean;
};

export enum SchemaChangeType {
  // the tables has been deleted
  DELETED_TABLES = 'deletedTables',
  // the columns has been deleted
  DELETED_COLUMNS = 'deletedColumns',
  // the columns type has been changed
  MODIFIED_COLUMNS = 'modifiedColumns',
}

interface AffectedResources {
  sourceTableName: string;
  referenceName: string;
  displayName: string;
  modelId: number;
  columns: Array<{
    sourceColumnName: string;
    displayName: string;
    type: string;
  }>;
  relationships: Array<{
    id: number;
    displayName: string;
    referenceName: string;
  }>;
  calculatedFields: ModelColumn[];
}

export interface IDataSourceSchemaDetector {
  detectSchemaChange(): Promise<boolean>;
  resolveSchemaChange(type: string): Promise<void>;
  getAffectedResources(
    changes: DataSourceSchema[],
    {
      models,
      modelColumns,
      modelRelationships,
    }: {
      models: Model[];
      modelColumns: ModelColumn[];
      modelRelationships: RelationInfo[];
    },
  ): AffectedResources[];
}

export default class DataSourceSchemaDetector
  implements IDataSourceSchemaDetector
{
  public ctx: IContext;
  public projectId: number;

  constructor({ ctx, projectId }: { ctx: IContext; projectId: number }) {
    this.ctx = ctx;
    this.projectId = projectId;
  }

  public async detectSchemaChange() {
    const diffSchema = await this.getDiffSchema();
    if (diffSchema) {
      await this.addSchemaChange(diffSchema);
    } else {
      // Mark resolve all in last schema change if it has unresolved flag when no schema change detected.
      const lastSchemaChange =
        await this.ctx.schemaChangeRepository.findLastSchemaChange(
          this.projectId,
        );
      if (lastSchemaChange !== null) {
        const hasUnresolved = Object.values(lastSchemaChange.resolve).some(
          (resolve) => !resolve,
        );
        if (hasUnresolved) {
          await this.updateResolveToSchemaChange(
            lastSchemaChange,
            Object.values(SchemaChangeType),
          );
        }
      }
    }

    return !!diffSchema;
  }

  public async resolveSchemaChange(type: string) {
    const schemaChangeType = camelCase(type) as SchemaChangeType;
    const supportedTypes = [
      SchemaChangeType.DELETED_TABLES,
      SchemaChangeType.DELETED_COLUMNS,
    ];
    if (!supportedTypes.includes(schemaChangeType)) {
      throw new Error('Resolved scheme change type is not supported.');
    }

    const lastSchemaChange =
      await this.ctx.schemaChangeRepository.findLastSchemaChange(
        this.projectId,
      );
    const changes = lastSchemaChange?.change[schemaChangeType];
    const isResolved = lastSchemaChange?.resolve[schemaChangeType];

    if (isResolved) {
      throw new Error(
        `Schema change "${schemaChangeType}" has nothing to resolve.`,
      );
    }

    const models = await this.ctx.modelRepository.findAllBy({
      projectId: this.projectId,
    });

    const modelIds = models.map((model) => model.id);
    const modelColumns =
      await this.ctx.modelColumnRepository.findColumnsByModelIds(modelIds);

    const modelRelationships =
      await this.ctx.relationRepository.findRelationInfoBy({
        modelIds,
      });

    const affectedResources = this.getAffectedResources(changes, {
      models,
      modelColumns,
      modelRelationships,
    });

    /**
     * Handle resolve scheme change for DELETED_TABLES / DELETED_COLUMNS
     *  1. Remove all affected calculated fields
     *  2. Remove all affected columns if DELETED_COLUMNS
     *  3. Remove all affected tables if DELETED_TABLES
     *
     *  Considering that we have set up foreign keys, some data will be automatically deleted in cascade,
     *  so there is no need to perform additional deletions. (E.g., relationships, model's column)
     */
    await Promise.all(
      affectedResources.map(async (resource) => {
        // both DELETED_TABLES and DELETED_COLUMNS need to remove all affected calculated fields
        logger.debug(
          `Start to remove all affected calculated fields "${resource.calculatedFields.map(
            (column) => `${column.displayName} (${column.referenceName})`,
          )}".`,
        );

        const columnIds = resource.calculatedFields.map((column) => column.id);
        await this.ctx.modelColumnRepository.deleteAllByColumnIds(columnIds);

        // remove columns if SchemaChangeType is DELETED_COLUMNS
        if (schemaChangeType === SchemaChangeType.DELETED_COLUMNS) {
          const affectedColumnNames = resource.columns.map(
            (column) => column.sourceColumnName,
          );

          logger.debug(
            `Start to remove columns "${affectedColumnNames}" from model "${resource.referenceName}".`,
          );

          await this.ctx.modelColumnRepository.deleteAllBySourceColumnNames(
            resource.modelId,
            affectedColumnNames,
          );
        }
        return;
      }),
    );

    // remove tables if SchemaChangeType is DELETED_TABLES
    if (schemaChangeType === SchemaChangeType.DELETED_TABLES) {
      // delete models
      const affectedTableNames = changes.map((table) => table.name);

      logger.debug(
        `Start to remove tables "${affectedTableNames}" from models.`,
      );

      await this.ctx.modelRepository.deleteAllBySourceTableNames(
        affectedTableNames,
      );
    }

    // update resolve flag
    await this.updateResolveToSchemaChange(lastSchemaChange, [
      schemaChangeType,
    ]);
  }

  /**
   * According to affected models and column data, we also need to find affected resources, including calculated fields and relationships.
   *
   * Find all affected resources include:
   *  - columns (called "affected column")
   *  - relationships (called "affected relationship")
   *  - calculated fields:
   *    - calculated fields which were affected by affected columns
   *    - calculated fields which were affected by affected relationships
   */
  public getAffectedResources(
    changes: DataSourceSchema[],
    {
      models,
      modelColumns,
      modelRelationships,
    }: {
      models: Model[];
      modelColumns: ModelColumn[];
      modelRelationships: RelationInfo[];
    },
  ) {
    const affectedModels = models.filter(
      (model) =>
        changes.findIndex((table) => table.name === model.sourceTableName) !==
        -1,
    );

    const affectedResources = affectedModels.map((model) => {
      const affectedColumns = changes.find(
        (table) => table.name === model.sourceTableName,
      ).columns;

      const allCalculatedFields = modelColumns.filter(
        (column) => column.isCalculated,
      );

      const affectedMaterials = affectedColumns.reduce(
        (result, column) => {
          const affectedColumn = modelColumns.find(
            (modelColumn) =>
              modelColumn.sourceColumnName === column.name &&
              modelColumn.modelId === model.id,
          );

          result.columns.push({
            sourceColumnName: column.name,
            displayName: affectedColumn.displayName,
            type: column.type,
          });

          // collect affected calculated fields if it's target column
          const affectedCalculatedFieldsByColumnId = allCalculatedFields.filter(
            (calculatedField) => {
              const lineage = JSON.parse(calculatedField.lineage);
              return (
                lineage && lineage[lineage.length - 1] === affectedColumn.id
              );
            },
          );

          result.calculatedFields.push(...affectedCalculatedFieldsByColumnId);

          // collect affected relationships
          const affectedRelationships = modelRelationships
            .map((relationship) =>
              [relationship.fromColumnId, relationship.toColumnId].includes(
                affectedColumn.id,
              )
                ? relationship
                : null,
            )
            .filter((relationship) => !!relationship);

          affectedRelationships.forEach((relationship) => {
            const referenceName =
              model.referenceName === relationship.fromModelName
                ? relationship.toModelName
                : relationship.fromModelName;

            const displayName = models.find(
              (model) => model.referenceName === referenceName,
            )?.displayName;

            result.relationships.push({
              displayName,
              id: relationship.id,
              referenceName,
            });

            // collect affected calculated fields if the relationship is in use
            const affectedCalculatedFieldsByRelationshipId =
              allCalculatedFields.filter((calculatedField) => {
                const lineage = JSON.parse(calculatedField.lineage);

                // pop the column ID from the lineage
                lineage.pop();
                return lineage && lineage.includes(relationship.id);
              });

            result.calculatedFields.push(
              ...affectedCalculatedFieldsByRelationshipId,
            );
          });

          return result;
        },
        { columns: [], relationships: [], calculatedFields: [] },
      );

      // unique calculated fields by id since it can be duplicated
      const calculatedFields = uniqBy(affectedMaterials.calculatedFields, 'id');

      return {
        sourceTableName: model.sourceTableName,
        displayName: model.displayName,
        referenceName: model.referenceName,
        modelId: model.id,
        ...affectedMaterials,
        calculatedFields,
      };
    });

    return affectedResources;
  }

  private async getDiffSchema() {
    logger.info('Start to detect Data Source Schema changes.');
    const currentSchema = await this.getCurrentSchema();
    const latestSchema = await this.getLatestSchema();

    const diffSchema = currentSchema.reduce((result, currentTable) => {
      const lastestTable = latestSchema.find(
        (table) => table.name === currentTable.name,
      );
      // If the table is not found in the latest schema, it means the table has been deleted.
      if (!lastestTable) {
        result[SchemaChangeType.DELETED_TABLES] = [
          ...(result[SchemaChangeType.DELETED_TABLES] || []),
          currentTable,
        ];
        return result;
      }

      // If the table is found in the latest schema, we need to diff the columns.
      const diffColumns = differenceWith(
        currentTable.columns,
        lastestTable.columns,
        isEqual,
      );
      if (diffColumns.length > 0) {
        const deletedColumnChange = { name: currentTable.name, columns: [] };
        const modifiedColumnChange = { name: currentTable.name, columns: [] };

        for (const currentColumn of diffColumns) {
          const latestColumn = lastestTable.columns.find(
            (column) => column.name === currentColumn.name,
          );
          // If the column is not found in the latest schema, it means the column has been deleted.
          if (!latestColumn) {
            deletedColumnChange.columns.push(currentColumn);
            continue;
          }
          // If the column is found in the latest schema, it means the column has been modified.
          // save latest column as modified column
          modifiedColumnChange.columns.push(latestColumn);
        }

        // If there are any deleted or modified columns, we need to add them to the result.
        if (deletedColumnChange.columns.length > 0) {
          result[SchemaChangeType.DELETED_COLUMNS] = [
            ...(result[SchemaChangeType.DELETED_COLUMNS] || []),
            deletedColumnChange,
          ];
        }
        if (modifiedColumnChange.columns.length > 0) {
          result[SchemaChangeType.MODIFIED_COLUMNS] = [
            ...(result[SchemaChangeType.MODIFIED_COLUMNS] || []),
            modifiedColumnChange,
          ];
        }
      }

      return result;
    }, {});

    if (!isEmpty(diffSchema)) {
      logger.debug('Diff Schema:', JSON.stringify(diffSchema));
      logger.info('Data Source Schema has changed.');
      return diffSchema as DataSourceSchemaChange;
    }

    logger.info('No changes in Data Source Schema.');
    return null;
  }

  private async addSchemaChange(diffSchema: DataSourceSchemaChange) {
    const getResolveState = (change) => (!!change ? false : undefined);

    const lastSchemaChange =
      await this.ctx.schemaChangeRepository.findLastSchemaChange(
        this.projectId,
      );
    // If the schema change is the same as the last one, we don't need to create a new one.
    const isNewSchemaChange =
      JSON.stringify(lastSchemaChange?.change) !== JSON.stringify(diffSchema);

    if (isNewSchemaChange) {
      await this.ctx.schemaChangeRepository.createOne({
        projectId: this.projectId,
        change: diffSchema,
        // Set the resolve to false if there are any changes. It will set resolve to true once the schema has been synced.
        resolve: {
          [SchemaChangeType.DELETED_TABLES]: getResolveState(
            diffSchema[SchemaChangeType.DELETED_TABLES],
          ),
          [SchemaChangeType.DELETED_COLUMNS]: getResolveState(
            diffSchema[SchemaChangeType.DELETED_COLUMNS],
          ),
          [SchemaChangeType.MODIFIED_COLUMNS]: getResolveState(
            diffSchema[SchemaChangeType.MODIFIED_COLUMNS],
          ),
        },
      });
    }
  }

  private async getCurrentSchema(): Promise<DataSourceSchema[]> {
    const models = await this.ctx.modelRepository.findAllBy({
      projectId: this.projectId,
    });
    const modelIds = models.map((model) => model.id);
    const modelColumns =
      await this.ctx.modelColumnRepository.findColumnsByModelIds(modelIds);
    const result = models.map((model) => {
      return {
        name: model.sourceTableName,
        columns: modelColumns
          .filter(
            (column) => column.modelId === model.id && !column.isCalculated,
          )
          .map((column) => ({
            name: column.sourceColumnName,
            type: column.type,
          })),
      };
    });
    return result;
  }

  private async getLatestSchema(): Promise<DataSourceSchema[]> {
    const project = await this.ctx.projectRepository.findOneBy({
      id: this.projectId,
    });
    const latestDataSourceTables =
      await this.ctx.projectService.getProjectDataSourceTables(project);
    const result = latestDataSourceTables.map((table) => {
      return {
        name: table.name,
        columns: table.columns.map((column) => {
          return {
            name: column.name,
            type: column.type,
          };
        }),
      };
    });
    return result;
  }

  private async updateResolveToSchemaChange(
    lastSchemaChange: SchemaChange,
    schemaChangeTypes: SchemaChangeType[],
  ) {
    await this.ctx.schemaChangeRepository.updateOne(lastSchemaChange.id, {
      resolve: {
        ...lastSchemaChange.resolve,
        ...schemaChangeTypes.reduce(
          (result, type) => ({ ...result, [type]: true }),
          {},
        ),
      },
    });
    logger.info(`Schema change "${schemaChangeTypes}" resolved successfully.`);
  }
}
</file>

<file path="src/apollo/server/mdl/mdlBuilder.ts">
import { isEmpty, isNil, pickBy } from 'lodash';
import {
  Model,
  ModelColumn,
  ModelNestedColumn,
  Project,
  RelationInfo,
  View,
} from '../repositories';
import {
  Manifest,
  ModelMDL,
  TableReference,
  WrenEngineDataSourceType,
} from './type';
import { getLogger } from '@server/utils';
import { getConfig } from '@server/config';
import { DataSourceName } from '../types';

const logger = getLogger('MDLBuilder');
logger.level = 'debug';

const config = getConfig();

export interface MDLBuilderBuildFromOptions {
  project: Project;
  models: Model[];
  columns?: ModelColumn[];
  nestedColumns?: ModelNestedColumn[];
  relations?: RelationInfo[];
  views: View[];
  relatedModels?: Model[];
  relatedColumns?: ModelColumn[];
  relatedRelations?: RelationInfo[];
}

export interface IMDLBuilder {
  build(): Manifest; //facade method to build the manifest json
}

// responsible to generate a valid manifest json
export class MDLBuilder implements IMDLBuilder {
  private manifest: Manifest;

  private project: Project;
  private readonly models: Model[];
  private readonly columns: ModelColumn[];
  private readonly nestedColumns: ModelNestedColumn[];
  private readonly relations: RelationInfo[];
  private readonly views: View[];

  // related models, columns, and relations are used as the reference to build calculatedField expression or other
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  private readonly relatedModels: Model[];
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  private readonly relatedColumns: ModelColumn[];
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  private readonly relatedRelations: RelationInfo[];

  constructor(builderOptions: MDLBuilderBuildFromOptions) {
    const {
      project,
      models,
      columns,
      nestedColumns,
      relations,
      views,
      relatedModels,
      relatedColumns,
      relatedRelations,
    } = builderOptions;
    this.project = project;
    this.models = models.sort((a, b) => a.id - b.id);
    this.columns = columns.sort((a, b) => a.id - b.id);
    this.nestedColumns = nestedColumns;
    this.relations = relations.sort((a, b) => a.id - b.id);
    this.views = views || [];
    this.relatedModels = relatedModels;
    this.relatedColumns = relatedColumns;
    this.relatedRelations = relatedRelations;

    // init manifest
    this.manifest = {};
  }

  public build(): Manifest {
    this.addProject();
    this.addModel();
    this.addNormalField();
    this.addRelation();
    this.addCalculatedField();
    this.addView();
    this.postProcessManifest();
    return this.getManifest();
  }

  public getManifest(): Manifest {
    return this.manifest;
  }

  public addModel(): void {
    if (!isEmpty(this.manifest.models)) {
      return;
    }
    this.manifest.models = this.models.map((model: Model) => {
      const properties = model.properties ? JSON.parse(model.properties) : {};
      // put displayName in properties
      if (model.displayName) {
        properties.displayName = model.displayName;
      }
      const tableReference = this.buildTableReference(model);

      return {
        name: model.referenceName,
        columns: [],
        tableReference,
        // can only have one of refSql or tableReference
        refSql: this.useRustWrenEngine()
          ? null
          : tableReference
            ? null
            : model.refSql,
        cached: model.cached ? true : false,
        refreshTime: model.refreshTime,
        properties: {
          displayName: model.displayName,
          description: properties.description,
        },
        primaryKey: '', // will be modified in addColumn
      } as ModelMDL;
    });
  }

  public addView(): void {
    if (!isEmpty(this.manifest.views)) {
      return;
    }
    this.manifest.views = this.views.map((view: View) => {
      const properties = JSON.parse(view.properties) || {};

      // filter out properties that are not null or undefined
      // and are in the list of properties that are allowed
      const viewProperties = pickBy(properties, (value, key) => {
        return (
          !isNil(value) &&
          ['displayName', 'description', 'question', 'summary'].includes(key)
        );
      });

      return {
        name: view.name,
        statement: view.statement,
        properties: {
          ...viewProperties,

          // viewId will be passed back in other APIs
          // to identify the view
          viewId: view.id.toString(),
        },
      };
    });
  }

  public addNormalField(): void {
    // should addModel first
    if (isEmpty(this.manifest.models)) {
      logger.debug('No model in manifest, should build model first');
      return;
    }
    this.columns
      .filter(({ isCalculated }) => !isCalculated)
      .forEach((column: ModelColumn) => {
        // validate manifest.model exist
        const modelRefName = this.models.find(
          (model: any) => model.id === column.modelId,
        )?.referenceName;
        if (!modelRefName) {
          logger.debug(
            `Build MDL Column Error: can not find model, modelId ${column.modelId}, columnId: ${column.id}`,
          );
          return;
        }
        const model = this.manifest.models.find(
          (model: any) => model.name === modelRefName,
        );

        // modify model primary key
        if (column.isPk) {
          model.primaryKey = column.referenceName;
        }

        // add column into model
        if (!model.columns) {
          model.columns = [];
        }
        const properties = column.properties
          ? JSON.parse(column.properties)
          : {};
        // put displayName in properties
        if (column.displayName) {
          properties.displayName = column.displayName;
        }
        // put nested columns in properties
        if (column.type.includes('STRUCT')) {
          const nestedColumns = this.nestedColumns.filter(
            (nestedColumn) => nestedColumn.columnId === column.id,
          );
          nestedColumns.forEach((column) => {
            if (column.displayName) {
              properties[`nestedDisplayName.${column.sourceColumnName}`] =
                column.displayName;
            }
            if (column.properties?.description) {
              properties[`nestedDescription.${column.sourceColumnName}`] =
                column.properties.description;
            }
          }, {});
        }
        const expression = this.getColumnExpression(column, model);
        model.columns.push({
          name: column.referenceName,
          type: column.type,
          isCalculated: column.isCalculated ? true : false,
          notNull: column.notNull ? true : false,
          expression,
          properties: properties,
        });
      });
  }

  public addCalculatedField(): void {
    // should addModel first
    if (isEmpty(this.manifest.models)) {
      logger.debug('No model in manifest, should build model first');
      return;
    }
    this.columns
      .filter(({ isCalculated }) => isCalculated)
      .forEach((column: ModelColumn) => {
        // validate manifest.model exist
        const relatedModel = this.relatedModels.find(
          (model: any) => model.id === column.modelId,
        );
        const model = this.manifest.models.find(
          (model: any) => model.name === relatedModel.referenceName,
        );
        if (!model) {
          logger.debug(
            `Build MDL Column Error: can not find model, modelId "${column.modelId}", columnId: "${column.id}"`,
          );
          return;
        }
        const expression = this.getColumnExpression(column, model);
        const columnValue = {
          name: column.referenceName,
          type: column.type,
          isCalculated: true,
          expression,
          notNull: column.notNull ? true : false,
          properties: JSON.parse(column.properties),
        };
        model.columns.push(columnValue);
      });
  }

  public insertCalculatedField(
    modelName: string,
    calculatedField: ModelColumn,
  ) {
    const model = this.manifest.models.find(
      (model: any) => model.name === modelName,
    );
    if (!model) {
      logger.debug(`Can not find model "${modelName}" to add calculated field`);
      return;
    }
    // if calculated field is already in the model, skip
    if (
      model.columns.find(
        (column: any) => column.name === calculatedField.referenceName,
      )
    ) {
      return;
    }
    const expression = this.getColumnExpression(calculatedField, model);
    const columnValue = {
      name: calculatedField.referenceName,
      type: calculatedField.type,
      isCalculated: true,
      expression,
      notNull: calculatedField.notNull ? true : false,
      properties: JSON.parse(calculatedField.properties),
    };
    model.columns.push(columnValue);
  }

  public addRelation(): void {
    this.manifest.relationships = this.relations.map(
      (relation: RelationInfo) => {
        const {
          name,
          joinType,
          fromModelName,
          fromColumnName,
          toModelName,
          toColumnName,
        } = relation;
        const condition = this.getRelationCondition(relation);
        this.addRelationColumn(fromModelName, {
          modelReferenceName: toModelName,
          columnReferenceName: toColumnName,
          relation: name,
        });
        this.addRelationColumn(toModelName, {
          modelReferenceName: fromModelName,
          columnReferenceName: fromColumnName,
          relation: name,
        });

        const properties = relation.properties
          ? JSON.parse(relation.properties)
          : {};

        return {
          name: name,
          models: [fromModelName, toModelName],
          joinType: joinType,
          condition,
          properties,
        };
      },
    );
  }

  public addProject(): void {
    this.manifest.schema = this.project.schema;
    this.manifest.catalog = this.project.catalog;
    const dataSource = this.buildDataSource();
    if (dataSource) {
      this.manifest.dataSource = dataSource;
    }
  }

  protected addRelationColumn(
    modelName: string,
    columnData: {
      modelReferenceName: string;
      columnReferenceName: string;
      relation: string;
    },
  ) {
    const model = this.manifest.models.find(
      (model: any) => model.name === modelName,
    );
    if (!model) {
      logger.debug(`Can not find model "${modelName}" to add relation column`);
      return;
    }
    if (!model.columns) {
      model.columns = [];
    }
    // check if the modelReferenceName is already in the model column
    const modelNameDuplicated = model.columns.find(
      (column: any) => column.name === columnData.modelReferenceName,
    );
    const column = {
      name: modelNameDuplicated
        ? `${columnData.modelReferenceName}_${columnData.columnReferenceName}`
        : columnData.modelReferenceName,
      type: columnData.modelReferenceName,
      properties: null,
      relationship: columnData.relation,
      isCalculated: false,
      notNull: false,
    };
    model.columns.push(column);
  }

  protected getColumnExpression(
    column: ModelColumn,
    currentModel?: Partial<ModelMDL>,
  ): string {
    if (!column.isCalculated) {
      // columns existed in the data source.
      // Provide original column name in expression to MDL if referenceName has converted.
      if (column.sourceColumnName !== column.referenceName) {
        return `"${column.sourceColumnName}"`;
      }
      return '';
    }
    // calculated field
    const lineage = JSON.parse(column.lineage) as number[];
    // lineage = [relationId1, relationId2, ..., columnId]
    const fieldExpression = Object.entries<number>(lineage).reduce(
      (acc, [index, id]) => {
        const isLast = parseInt(index) == lineage.length - 1;
        if (isLast) {
          // id is columnId
          const columnReferenceName = this.relatedColumns.find(
            (relatedColumn) => relatedColumn.id === id,
          )?.referenceName;
          acc.push(`\"${columnReferenceName}\"`);
          return acc;
        }
        // id is relationId
        const usedRelation = this.relatedRelations.find(
          (relatedRelation) => relatedRelation.id === id,
        );
        const relationColumnName = currentModel!.columns.find(
          (c) => c.relationship === usedRelation.name,
        ).name;
        // move to next model
        const nextModelName =
          currentModel.name === usedRelation.fromModelName
            ? usedRelation.toModelName
            : usedRelation.fromModelName;
        const nextModel = this.manifest.models.find(
          (model) => model.name === nextModelName,
        );
        currentModel = nextModel;
        acc.push(relationColumnName);
        return acc;
      },
      [],
    );
    return `${column.aggregation}(${fieldExpression.join('.')})`;
  }

  protected getRelationCondition(relation: RelationInfo): string {
    //TODO phase2: implement the expression for relation condition
    const { fromColumnName, toColumnName, fromModelName, toModelName } =
      relation;
    return `"${fromModelName}".${fromColumnName} = "${toModelName}".${toColumnName}`;
  }

  private buildTableReference(model: Model): TableReference | null {
    const modelProps =
      model.properties && typeof model.properties === 'string'
        ? JSON.parse(model.properties)
        : {};
    if (!modelProps.table) {
      return null;
    }
    return {
      catalog: modelProps.catalog || null,
      schema: modelProps.schema || null,
      table: modelProps.table,
    };
  }
  private postProcessManifest() {
    if (this.useRustWrenEngine()) {
      // 1. remove all the key that the value is null
      this.manifest.models = this.manifest.models?.map((model) => {
        model.columns.map((column) => {
          column.properties = pickBy(
            column.properties,
            (value) => value !== null,
          );
          return column;
        });
        return pickBy(model, (value) => value !== null);
      });
      this.manifest.views = this.manifest.views?.map((view) => {
        return pickBy(view, (value) => value !== null);
      });
      this.manifest.relationships = this.manifest.relationships?.map(
        (relationship) => {
          return pickBy(relationship, (value) => value !== null);
        },
      );
      this.manifest.enumDefinitions = this.manifest.enumDefinitions?.map(
        (enumDefinition) => {
          return pickBy(enumDefinition, (value) => value !== null);
        },
      );
      // 2. remove expression if it's empty string
      this.manifest.models?.forEach((model) => {
        model.columns?.forEach((column) => {
          if (column.expression === '') {
            delete column.expression;
          }
        });
      });
    }
  }
  private useRustWrenEngine(): boolean {
    return !!config.experimentalEngineRustVersion;
  }
  private buildDataSource(): WrenEngineDataSourceType {
    const type = this.project.type;
    if (!type) {
      return;
    }
    switch (type) {
      case DataSourceName.ATHENA:
        return WrenEngineDataSourceType.ATHENA;
      case DataSourceName.BIG_QUERY:
        return WrenEngineDataSourceType.BIGQUERY;
      case DataSourceName.DUCKDB:
        return WrenEngineDataSourceType.DUCKDB;
      case DataSourceName.POSTGRES:
        return WrenEngineDataSourceType.POSTGRES;
      case DataSourceName.MYSQL:
        return WrenEngineDataSourceType.MYSQL;
      case DataSourceName.ORACLE:
        return WrenEngineDataSourceType.ORACLE;
      case DataSourceName.MSSQL:
        return WrenEngineDataSourceType.MSSQL;
      case DataSourceName.CLICK_HOUSE:
        return WrenEngineDataSourceType.CLICKHOUSE;
      case DataSourceName.TRINO:
        return WrenEngineDataSourceType.TRINO;
      case DataSourceName.SNOWFLAKE:
        return WrenEngineDataSourceType.SNOWFLAKE;
      case DataSourceName.REDSHIFT:
        return WrenEngineDataSourceType.REDSHIFT;
      default:
        throw new Error(
          `Unsupported data source type: ${type} found when building manifest`,
        );
    }
  }
}
</file>

<file path="src/apollo/server/mdl/test/mdlBuilder.test.ts">
import { DataSourceName } from '@server/types';
import {
  Model,
  Project,
  ModelColumn,
  ModelNestedColumn,
  RelationInfo,
  View,
  BIG_QUERY_CONNECTION_INFO,
} from '../../repositories';
import { MDLBuilder, MDLBuilderBuildFromOptions } from '../mdlBuilder';
import { ModelMDL, RelationMDL, ViewMDL } from '../type';

describe('MDLBuilder', () => {
  let mdlBuilder: MDLBuilder;

  describe('build', () => {
    it('should return a manifest', () => {
      const builderOptions = {
        project: {},
        models: [],
        columns: [],
        nestedColumns: [],
        relations: [],
        relatedModels: [],
        relatedColumns: [],
        relatedRelations: [],
      } as MDLBuilderBuildFromOptions;
      mdlBuilder = new MDLBuilder(builderOptions);

      const manifest = mdlBuilder.build();
      expect(manifest).toBeDefined();
    });

    it('should return a manifest with models & columns & relations.', () => {
      // Arrange
      const project = {
        id: 1,
        type: DataSourceName.BIG_QUERY,
        displayName: 'my project',
        connectionInfo: {
          projectId: 'bq-project-id',
          datasetId: 'bq-project-id.my-dataset',
          credentials: 'my-credential',
        } as BIG_QUERY_CONNECTION_INFO,
        catalog: 'wrenai',
        schema: 'public',
        sampleDataset: null,
      } as Project;
      const models = [
        {
          id: 1,
          projectId: 1,
          displayName: 'order',
          sourceTableName: 'order',
          referenceName: 'order',
          refSql: 'SELECT * FROM order',
          cached: false,
          refreshTime: null,
          properties: JSON.stringify({
            description: 'foo table',
            schema: 'my-dataset',
            catalog: 'bq-project-id',
            table: 'order',
          }),
        },
        {
          id: 2,
          projectId: 1,
          displayName: 'customer',
          sourceTableName: 'customer',
          referenceName: 'customer',
          refSql: 'SELECT * FROM customer',
          cached: false,
          refreshTime: null,
          properties: JSON.stringify({
            schema: null,
            catalog: null,
            table: 'customer',
          }),
        },
      ] as Model[];
      const columns = [
        {
          id: 1,
          modelId: 1,
          isCalculated: false,
          displayName: 'orderKey',
          referenceName: 'orderKey',
          sourceColumnName: 'orderKey',
          aggregation: null,
          lineage: null,
          customExpression: null,
          type: 'STRING',
          notNull: true,
          isPk: true,
          properties: JSON.stringify({ description: 'bar' }),
        },
        {
          id: 2,
          modelId: 2,
          isCalculated: false,
          displayName: 'orderKey',
          referenceName: 'orderKey',
          sourceColumnName: 'orderKey',
          aggregation: null,
          lineage: null,
          customExpression: null,
          type: 'STRING',
          notNull: true,
          isPk: false,
          properties: null,
        },
        {
          id: 3,
          modelId: 2,
          isCalculated: false,
          displayName: 'event_params',
          referenceName: 'event_params',
          sourceColumnName: 'event_params',
          aggregation: null,
          lineage: null,
          customExpression: null,
          type: 'ARRAY<STRUCT<key STRING>>',
          notNull: true,
          isPk: false,
          properties: null,
        },
      ] as ModelColumn[];
      const nestedColumns = [
        {
          id: 1,
          modelId: 2,
          columnId: 3,
          columnPath: ['event_params', 'key'],
          displayName: 'event_params.key',
          referenceName: 'event_params.key',
          sourceColumnName: 'event_params.key',
          type: 'STRING',
          properties: { description: 'bar' },
        },
      ] as ModelNestedColumn[];
      const relations = [
        {
          id: 1,
          projectId: 1,
          name: 'OrderCustomer',
          fromColumnId: 1,
          toColumnId: 2,
          joinType: 'oneToMany',
          fromModelId: 1,
          fromModelName: 'order',
          fromColumnName: 'orderKey',
          toModelId: 2,
          toModelName: 'customer',
          toColumnName: 'orderKey',
          properties: JSON.stringify({
            description: 'the relationship between orders and customers',
          }),
        },
      ] as RelationInfo[];
      const builderOptions = {
        project,
        models,
        columns,
        nestedColumns,
        relations,
        relatedModels: [],
        relatedColumns: [],
        relatedRelations: [],
      } as MDLBuilderBuildFromOptions;
      mdlBuilder = new MDLBuilder(builderOptions);

      // Act
      const manifest = mdlBuilder.build();

      // Assert
      const expectedModels = [
        {
          name: 'order',
          tableReference: {
            schema: 'my-dataset',
            catalog: 'bq-project-id',
            table: 'order',
          },
          refSql: null,
          columns: [
            {
              name: 'orderKey',
              expression: '',
              type: 'STRING',
              isCalculated: false,
              notNull: true,
              properties: { description: 'bar', displayName: 'orderKey' },
            },
            {
              name: 'customer',
              type: 'customer',
              isCalculated: false,
              relationship: 'OrderCustomer',
              properties: null,
              notNull: false,
            },
          ],
          cached: false,
          refreshTime: null,
          primaryKey: 'orderKey',
          properties: {
            description: 'foo table',
            displayName: 'order',
          },
        },
        {
          name: 'customer',
          tableReference: {
            schema: null,
            catalog: null,
            table: 'customer',
          },
          refSql: null,
          columns: [
            {
              name: 'orderKey',
              expression: '',
              type: 'STRING',
              isCalculated: false,
              notNull: true,
              properties: { displayName: 'orderKey' },
            },
            {
              name: 'event_params',
              expression: '',
              type: 'ARRAY<STRUCT<key STRING>>',
              isCalculated: false,
              notNull: true,
              properties: {
                displayName: 'event_params',
                'nestedDisplayName.event_params.key': 'event_params.key',
                'nestedDescription.event_params.key': 'bar',
              },
            },
            {
              name: 'order',
              type: 'order',
              isCalculated: false,
              relationship: 'OrderCustomer',
              notNull: false,
              properties: null,
            },
          ],
          primaryKey: '',
          cached: false,
          refreshTime: null,
          properties: {
            description: undefined,
            displayName: 'customer',
          },
        },
      ] as ModelMDL[];

      const expectedRelationships = [
        {
          name: 'OrderCustomer',
          models: ['order', 'customer'],
          joinType: 'oneToMany',
          condition: '"order".orderKey = "customer".orderKey',
          properties: {
            description: 'the relationship between orders and customers',
          },
        },
      ] as RelationMDL[];

      expect(manifest.models).toEqual(expectedModels);
      expect(manifest.relationships).toEqual(expectedRelationships);
    });
  });

  it('should return a manifest with models & columns & nestedColumns & relations & views.', () => {
    // Arrange
    const project = {
      id: 1,
      type: DataSourceName.BIG_QUERY,
      displayName: 'my project',
      connectionInfo: {
        projectId: 'bq-project-id',
        datasetId: 'my-dataset',
        credentials: 'my-credential',
      } as BIG_QUERY_CONNECTION_INFO,
      catalog: 'wrenai',
      schema: 'public',
      sampleDataset: null,
    } as Project;
    const models = [
      {
        id: 1,
        projectId: 1,
        displayName: 'order',
        sourceTableName: 'order',
        referenceName: 'order',
        refSql: 'SELECT * FROM order',
        cached: false,
        refreshTime: null,
        properties: JSON.stringify({
          description: 'foo table',
          catalog: 'bq-project-id',
          schema: 'my-dataset',
          table: 'order',
        }),
      },
      {
        id: 2,
        projectId: 1,
        displayName: 'customer',
        sourceTableName: 'customer',
        referenceName: 'customer',
        refSql: 'SELECT * FROM customer',
        cached: false,
        refreshTime: null,
        properties: JSON.stringify({
          catalog: 'bq-project-id',
          schema: 'my-dataset',
          table: 'customer',
        }),
      },
    ] as Model[];
    const columns = [
      {
        id: 1,
        modelId: 1,
        isCalculated: false,
        displayName: 'orderKey',
        referenceName: 'orderKey',
        sourceColumnName: 'orderKey',
        aggregation: null,
        lineage: null,
        customExpression: null,
        type: 'STRING',
        notNull: true,
        isPk: true,
        properties: JSON.stringify({ description: 'bar' }),
      },
      {
        id: 2,
        modelId: 2,
        isCalculated: false,
        displayName: 'orderKey',
        referenceName: 'orderKey',
        sourceColumnName: 'orderKey',
        aggregation: null,
        lineage: null,
        customExpression: null,
        type: 'STRING',
        notNull: true,
        isPk: false,
        properties: null,
      },
      {
        id: 3,
        modelId: 2,
        isCalculated: false,
        displayName: 'event_params',
        referenceName: 'event_params',
        sourceColumnName: 'event_params',
        aggregation: null,
        lineage: null,
        customExpression: null,
        type: 'ARRAY<STRUCT<key STRING>>',
        notNull: true,
        isPk: false,
        properties: null,
      },
    ] as ModelColumn[];
    const nestedColumns = [
      {
        id: 1,
        modelId: 2,
        columnId: 3,
        columnPath: ['event_params', 'key'],
        displayName: 'event_params.key',
        referenceName: 'event_params.key',
        sourceColumnName: 'event_params.key',
        type: 'STRING',
        properties: { description: 'bar' },
      },
    ] as ModelNestedColumn[];
    const relations = [
      {
        id: 1,
        projectId: 1,
        name: 'OrderCustomer',
        fromColumnId: 1,
        toColumnId: 2,
        joinType: 'oneToMany',
        fromModelId: 1,
        fromModelName: 'order',
        fromColumnName: 'orderKey',
        toModelId: 2,
        toModelName: 'customer',
        toColumnName: 'orderKey',
        properties: JSON.stringify({
          description: 'the relationship between orders and customers',
        }),
      },
    ] as RelationInfo[];
    const views = [
      {
        id: 1,
        projectId: 1,
        name: 'view',
        statement: 'select * from order',
        cached: false,
        properties: JSON.stringify({
          description: 'foo view',
          displayName: 'view',
        }),
      },
    ] as View[];

    const builderOptions = {
      project,
      models,
      views,
      columns,
      nestedColumns,
      relations,
      relatedModels: [],
      relatedColumns: [],
      relatedRelations: [],
    } as MDLBuilderBuildFromOptions;
    mdlBuilder = new MDLBuilder(builderOptions);

    // Act
    const manifest = mdlBuilder.build();

    // Assert
    const expectedModels = [
      {
        name: 'order',
        refSql: null,
        tableReference: {
          schema: 'my-dataset',
          catalog: 'bq-project-id',
          table: 'order',
        },
        columns: [
          {
            name: 'orderKey',
            expression: '',
            type: 'STRING',
            isCalculated: false,
            notNull: true,
            properties: { description: 'bar', displayName: 'orderKey' },
          },
          {
            name: 'customer',
            type: 'customer',
            isCalculated: false,
            relationship: 'OrderCustomer',
            notNull: false,
            properties: null,
          },
        ],
        cached: false,
        refreshTime: null,
        primaryKey: 'orderKey',
        properties: { description: 'foo table', displayName: 'order' },
      },
      {
        name: 'customer',
        refSql: null,
        tableReference: {
          schema: 'my-dataset',
          catalog: 'bq-project-id',
          table: 'customer',
        },
        columns: [
          {
            name: 'orderKey',
            expression: '',
            type: 'STRING',
            isCalculated: false,
            notNull: true,
            properties: { displayName: 'orderKey' },
          },
          {
            name: 'event_params',
            expression: '',
            type: 'ARRAY<STRUCT<key STRING>>',
            isCalculated: false,
            notNull: true,
            properties: {
              displayName: 'event_params',
              'nestedDisplayName.event_params.key': 'event_params.key',
              'nestedDescription.event_params.key': 'bar',
            },
          },
          {
            name: 'order',
            type: 'order',
            isCalculated: false,
            relationship: 'OrderCustomer',
            notNull: false,
            properties: null,
          },
        ],
        primaryKey: '',
        cached: false,
        refreshTime: null,
        properties: { description: undefined, displayName: 'customer' },
      },
    ] as ModelMDL[];

    const expectedRelationships = [
      {
        name: 'OrderCustomer',
        models: ['order', 'customer'],
        joinType: 'oneToMany',
        condition: '"order".orderKey = "customer".orderKey',
        properties: {
          description: 'the relationship between orders and customers',
        },
      },
    ] as RelationMDL[];

    const expectedViews = [
      {
        name: 'view',
        statement: 'select * from order',
        properties: {
          description: 'foo view',
          displayName: 'view',
          viewId: '1',
        },
      },
    ] as ViewMDL[];

    expect(manifest.models).toEqual(expectedModels);
    expect(manifest.relationships).toEqual(expectedRelationships);
    expect(manifest.views).toEqual(expectedViews);
  });

  it('should return correct expression in calculated field.', () => {
    const models = [
      // customer model
      {
        id: 1,
        projectId: 1,
        displayName: 'customer',
        sourceTableName: 'customer',
        referenceName: 'customer',
        refSql: 'SELECT * FROM customer',
        cached: false,
        refreshTime: null,
        properties: null,
      },
      // order model
      {
        id: 2,
        projectId: 1,
        displayName: 'order',
        sourceTableName: 'order',
        referenceName: 'order',
        refSql: 'SELECT * FROM order',
        cached: false,
        refreshTime: null,
        properties: null,
      },
      // payment model
      {
        id: 3,
        projectId: 1,
        displayName: 'payment',
        sourceTableName: 'payment',
        referenceName: 'payment',
        refSql: 'SELECT * FROM payment',
        cached: false,
        refreshTime: null,
        properties: null,
      },
    ] as Model[];
    const columns = [
      // customer columns: id, name, total_payment
      {
        id: 1,
        modelId: 1,
        isCalculated: false,
        displayName: 'id',
        referenceName: 'id',
        sourceColumnName: 'id',
        aggregation: null,
        lineage: null,
        customExpression: null,
        type: 'STRING',
        notNull: true,
        isPk: true,
        properties: null,
      },
      {
        id: 2,
        modelId: 1,
        isCalculated: false,
        displayName: 'name',
        referenceName: 'name',
        sourceColumnName: 'name',
        aggregation: null,
        lineage: null,
        customExpression: null,
        type: 'STRING',
        notNull: true,
        isPk: false,
        properties: null,
      },
      {
        id: 3,
        modelId: 1,
        isCalculated: true,
        displayName: 'total_payment',
        referenceName: 'total_payment',
        sourceColumnName: 'total_payment',
        aggregation: 'sum',
        lineage: JSON.stringify([1, 2, 8]),
        customExpression: null,
        type: 'FLOAT',
        notNull: true,
        isPk: false,
        properties: null,
      },
      // order columns: id, customer_id, payment_id
      {
        id: 4,
        modelId: 2,
        isCalculated: false,
        displayName: 'id',
        referenceName: 'id',
        sourceColumnName: 'id',
        aggregation: null,
        lineage: null,
        customExpression: null,
        type: 'STRING',
        notNull: true,
        isPk: true,
        properties: null,
      },
      {
        id: 5,
        modelId: 2,
        isCalculated: false,
        displayName: 'customer_id',
        referenceName: 'customer_id',
        sourceColumnName: 'customer_id',
        aggregation: null,
        lineage: null,
        customExpression: null,
        type: 'STRING',
        notNull: true,
        isPk: false,
        properties: null,
      },
      {
        id: 6,
        modelId: 2,
        isCalculated: false,
        displayName: 'payment_id',
        referenceName: 'payment_id',
        sourceColumnName: 'payment_id',
        aggregation: null,
        lineage: null,
        customExpression: null,
        type: 'STRING',
        notNull: true,
        isPk: false,
        properties: null,
      },
      // payment columns: id, amount
      {
        id: 7,
        modelId: 3,
        isCalculated: false,
        displayName: 'id',
        referenceName: 'id',
        sourceColumnName: 'id',
        aggregation: null,
        lineage: null,
        customExpression: null,
        type: 'STRING',
        notNull: true,
        isPk: true,
        properties: null,
      },
      {
        id: 8,
        modelId: 3,
        isCalculated: false,
        displayName: 'amount',
        referenceName: 'amount',
        sourceColumnName: 'amount',
        aggregation: null,
        lineage: null,
        customExpression: null,
        type: 'FLOAT',
        notNull: true,
        isPk: false,
        properties: null,
      },
    ] as ModelColumn[];
    const relations = [
      {
        id: 1,
        projectId: 1,
        name: 'OrderCustomer',
        joinType: 'ManyToOne',
        fromModelId: 2,
        fromModelName: 'order',
        fromColumnId: 5,
        fromColumnName: 'customer_id',
        toModelId: 1,
        toModelName: 'customer',
        toColumnId: 1,
        toColumnName: 'id',
      },
      {
        id: 2,
        projectId: 1,
        name: 'OrderPayment',
        joinType: 'oneToMany',
        fromModelId: 2,
        fromModelName: 'order',
        fromColumnId: 6,
        fromColumnName: 'payment_id',
        toModelId: 3,
        toModelName: 'payment',
        toColumnId: 7,
        toColumnName: 'id',
      },
    ];
    const builderOptions = {
      project: {
        schema: 'public',
        catalog: 'wrenai',
      },
      models,
      columns,
      relations,
      relatedModels: models,
      relatedColumns: columns,
      relatedRelations: relations,
    } as MDLBuilderBuildFromOptions;
    mdlBuilder = new MDLBuilder(builderOptions);

    const manifest = mdlBuilder.build();

    const customerModel = manifest.models.find((m) => m.name === 'customer');
    const totalPaymentColumn = customerModel.columns.find(
      (c) => c.name === 'total_payment',
    );
    expect(totalPaymentColumn.expression).toEqual(
      'sum(order.payment."amount")',
    );
  });

  it.each(Object.values(DataSourceName))(
    `should return correct data source type`,
    (type) => {
      const project = {
        id: 1,
        type,
        displayName: 'my project',
        connectionInfo: {
          projectId: 'bq-project-id',
          datasetId: 'bq-project-id.my-dataset',
          credentials: 'my-credential',
        } as BIG_QUERY_CONNECTION_INFO,
        catalog: 'wrenai',
        schema: 'public',
        sampleDataset: null,
      } as Project;
      const models = [] as Model[];
      const columns = [] as ModelColumn[];
      const nestedColumns = [] as ModelNestedColumn[];
      const relations = [] as RelationInfo[];
      const views = [] as View[];
      const builderOptions = {
        project,
        models,
        columns,
        nestedColumns,
        relations,
        views,
      } as MDLBuilderBuildFromOptions;
      mdlBuilder = new MDLBuilder(builderOptions);
      const manifest = mdlBuilder.build();
      expect(manifest.dataSource).toBeDefined();
      expect(manifest.dataSource).not.toBeNull();
    },
  );
});
</file>

<file path="src/apollo/server/mdl/type.ts">
export interface ColumnMDL {
  name: string; // eg: "orderkey", "custkey", "orderstatus"
  type?: string; // eg: "integer", "string", "relationName"
  isCalculated: boolean; // eg: true, false
  notNull?: boolean; // eg: true, false
  relationship?: string; //eg: OrdersCustomer
  properties?: {
    description?: string; // eg: "the key of each order"
    displayName?: string; // eg: "Order Key"
  };
  expression?: string; // eg: "SUM(orders.totalprice)"
}

export interface ModelMDL {
  name: string; // eg: "OrdersModel", "LineitemModel"
  refSql?: string; // eg: "select * from orders", "select * from lineitem"
  tableReference?: TableReference;
  columns?: ColumnMDL[];
  primaryKey?: string; // eg: "orderkey", "custkey"
  cached: boolean; // eg true, false
  refreshTime?: string; // eg: "30.00m"
  properties?: {
    description?: string; // eg: "tpch tiny orders table"
    displayName?: string; // eg: "Orders"
  };
}

export interface RelationMDL {
  name: string; // eg: "OrdersCustomer"
  models: string[]; // eg: ["OrdersModel", "CustomerModel"]
  joinType: string; // eg: "MANY_TO_ONE"
  condition: string; // eg: "OrdersModel.custkey = CustomerModel.custkey"
  manySideSortKeys?: {
    name: string; // eg: "orderkey"
    descending: boolean; // eg: false
  }[];
  description?: string; // eg: "the relationship between orders and customers"
  properties?: {
    description?: string; // eg: "the relationship between orders and customers"
  };
}

export interface EnumDefinition {
  name: string; // eg: "OrderStatus"
  values: {
    name: string; // eg: "PENDING", "PROCESSING"
    value: string; // eg: "pending", "processing"
    properties?: {
      description?: string; // eg: "pending"
    };
  }[];
  description?: string; // eg: "the status of an order"
  properties?: {
    description?: string; // eg: "the status of an order"
  };
}

export interface ViewMDL {
  name: string;
  statement: string;
  properties?: {
    displayName?: string;
    description?: string;
    viewId?: string;
    question?: string;
    summary?: string;
  };
}

export interface Manifest {
  catalog?: string; // eg: "test-catalog"
  schema?: string; // eg: "test-schema"
  dataSource?: WrenEngineDataSourceType;
  models?: Partial<ModelMDL>[]; // use partial since Rust version doesn't support null values, we need to remove all the null values
  relationships?: Partial<RelationMDL>[]; // use partial since Rust version doesn't support null values, we need to remove all the null values
  enumDefinitions?: Partial<EnumDefinition>[]; // use partial since Rust version doesn't support null values, we need to remove all the null values
  views?: Partial<ViewMDL>[]; // use partial since Rust version doesn't support null values, we need to remove all the null values
}

export interface TableReference {
  schema?: string;
  catalog?: string;
  table: string;
}

export enum WrenEngineDataSourceType {
  ATHENA = 'ATHENA',
  BIGQUERY = 'BIGQUERY',
  CANNER = 'CANNER',
  CLICKHOUSE = 'CLICKHOUSE',
  MSSQL = 'MSSQL',
  ORACLE = 'ORACLE',
  MYSQL = 'MYSQL',
  POSTGRES = 'POSTGRES',
  SNOWFLAKE = 'SNOWFLAKE',
  TRINO = 'TRINO',
  DUCKDB = 'DUCKDB',
  REDSHIFT = 'REDSHIFT',
  // accepted by the wren engine, but not supported by the wren ui
  DATAFUSION = 'DATAFUSION',
}
</file>

<file path="src/apollo/server/models/adaptor.ts">
import * as Errors from '@server/utils/error';
import { Manifest } from '@server/mdl/type';
import { ThreadResponse } from '../repositories';

// Add branded types for SQL strings
type Brand<T, B> = T & { __brand: B };

export type DialectSQL = Brand<string, 'DialectSQL'>;
export type WrenSQL = Brand<string, 'WrenSQL'>;

export interface WrenAIError {
  code: Errors.GeneralErrorCodes;
  message: string;
}

export enum WrenAIDeployStatusEnum {
  SUCCESS = 'SUCCESS',
  FAILED = 'FAILED',
}

export interface WrenAIDeployResponse {
  status: WrenAIDeployStatusEnum;
  error?: string;
}

export enum WrenAISystemStatus {
  INDEXING = 'INDEXING',
  FINISHED = 'FINISHED',
  FAILED = 'FAILED',
}

export enum WrenAILanguage {
  EN = 'English',
  ES = 'Spanish',
  FR = 'French',
  ZH_TW = 'Traditional Chinese',
  ZH_CN = 'Simplified Chinese',
  DE = 'German',
  PT = 'Portuguese',
  RU = 'Russian',
  JA = 'Japanese',
  KO = 'Korean',
}

export interface DeployData {
  manifest: Manifest;
  hash: string;
}

// ask
export interface AskStep {
  summary: string;
  sql: string;
  cteName: string;
}

export interface AskHistory {
  sql: string;
  question: string;
}

export interface ProjectConfigurations {
  language?: string;
  timezone?: { name: string };
}

export interface AskInput {
  query: string;
  deployId: string;
  histories?: ThreadResponse[];
  configurations?: ProjectConfigurations;
}

export interface AsyncQueryResponse {
  queryId: string;
}

export enum AskResultStatus {
  UNDERSTANDING = 'UNDERSTANDING',
  SEARCHING = 'SEARCHING',
  PLANNING = 'PLANNING',
  GENERATING = 'GENERATING',
  CORRECTING = 'CORRECTING',
  FINISHED = 'FINISHED',
  FAILED = 'FAILED',
  STOPPED = 'STOPPED',
}

export enum AskResultType {
  GENERAL = 'GENERAL',
  TEXT_TO_SQL = 'TEXT_TO_SQL',
  MISLEADING_QUERY = 'MISLEADING_QUERY',
}

// if it's view, viewId will be returned as well. It means the candidate is originally saved in mdl as a view.
// if it's llm, viewId will not be returned. It means the candidate is generated by AI service.
// if it's sql_pair, sqlpairId will be returned as well. It means the candidate is generated by sql_pair.
export enum AskCandidateType {
  VIEW = 'VIEW',
  LLM = 'LLM',
  SQL_PAIR = 'SQL_PAIR',
}

export interface AskResponse<R, S> {
  type: AskResultType | null;
  status: S;
  response: R | null;
  error: WrenAIError | null;
}

export interface AskDetailInput {
  query: string;
  sql: string;
  configurations?: ProjectConfigurations;
}

export type AskDetailResult = AskResponse<
  {
    description: string;
    steps: AskStep[];
  },
  AskResultStatus
>;

export type AskResult = AskResponse<
  Array<{
    type: AskCandidateType;
    sql: string;
    viewId?: number | null;
    sqlpairId?: number | null;
  }>,
  AskResultStatus
> & {
  rephrasedQuestion?: string;
  intentReasoning?: string;
  sqlGenerationReasoning?: string;
  retrievedTables?: string[];
  invalidSql?: string;
  traceId?: string;
};

export enum RecommendationQuestionStatus {
  GENERATING = 'GENERATING',
  FINISHED = 'FINISHED',
  FAILED = 'FAILED',
}

export type RecommendationQuestionsInput = {
  // JSON string of the MDL (Model Definition Language)
  manifest: Manifest;
  // Optional list of previous questions
  previousQuestions?: string[];
  // Optional project ID
  projectId?: string;
  // Optional max number of questions to generate (default: 5)
  maxQuestions?: number;
  // Optional max number of categories (default: 3)
  maxCategories?: number;
  regenerate?: boolean; // Optional regenerate questions (default: false)
  // Optional configuration settings
  configuration?: ProjectConfigurations;
};

export type RecommendationQuestion = {
  question: string;
  category: string; // category for the question
  sql: string; // validated sql for this question, can be used in generateAskDetail
};

export type RecommendationQuestionsResult = AskResponse<
  {
    questions: RecommendationQuestion[];
  },
  RecommendationQuestionStatus
>;

// text-based answer
export interface TextBasedAnswerInput {
  query: string;
  sql: string;
  sqlData: any;
  threadId?: string;
  userId?: string;
  configurations?: ProjectConfigurations;
}

export enum TextBasedAnswerStatus {
  PREPROCESSING = 'PREPROCESSING',
  SUCCEEDED = 'SUCCEEDED',
  FAILED = 'FAILED',
}

export interface TextBasedAnswerResult {
  status: TextBasedAnswerStatus;
  numRowsUsedInLLM?: number;
  error?: WrenAIError;
}

export enum ChartStatus {
  FETCHING = 'FETCHING',
  GENERATING = 'GENERATING',
  FINISHED = 'FINISHED',
  FAILED = 'FAILED',
  STOPPED = 'STOPPED',
}

export enum ChartType {
  BAR = 'bar',
  GROUPED_BAR = 'grouped_bar',
  STACKED_BAR = 'stacked_bar',
  LINE = 'line',
  MULTI_LINE = 'multi_line',
  PIE = 'pie',
  AREA = 'area',
}

export interface ChartInput {
  query: string;
  sql: string;
  projectId?: string;
  configurations?: ProjectConfigurations;
}

export interface ChartAdjustmentOption {
  chartType: ChartType;
  xAxis?: string;
  yAxis?: string;
  xOffset?: string;
  color?: string;
  theta?: string;
}

export interface ChartAdjustmentInput {
  query: string;
  sql: string;
  adjustmentOption: ChartAdjustmentOption;
  chartSchema: Record<string, any>;
  projectId?: string;
  configurations?: ProjectConfigurations;
}

export interface ChartResponse {
  reasoning: string;
  chartType: ChartType;
  chartSchema: Record<string, any>;
}

export interface ChartResult {
  status: ChartStatus;
  response?: ChartResponse;
  error?: WrenAIError;
}

export enum SqlPairStatus {
  INDEXING = 'INDEXING',
  FINISHED = 'FINISHED',
  FAILED = 'FAILED',
}
export interface SqlPairResult {
  status: SqlPairStatus;
  error?: WrenAIError;
}

export interface QuestionInput {
  sqls: string[];
  projectId: number;
  configurations?: ProjectConfigurations;
}

export enum QuestionsStatus {
  GENERATING = 'GENERATING',
  SUCCEEDED = 'SUCCEEDED',
  FAILED = 'FAILED',
}

export interface QuestionsResult {
  status: QuestionsStatus;
  error?: WrenAIError;
  questions?: string[];
  trace_id?: string;
}

export interface GenerateInstructionInput {
  id: number;
  projectId: number;
  instruction: string;
  questions: string[];
  isDefault: boolean;
}

export enum InstructionStatus {
  INDEXING = 'INDEXING',
  FINISHED = 'FINISHED',
  FAILED = 'FAILED',
}
export interface InstructionResult {
  status: InstructionStatus;
  error?: WrenAIError;
}

// ask feedback
export interface AskFeedbackInput {
  question: string;
  tables: string[];
  sqlGenerationReasoning: string;
  sql: string;
  projectId: number;
  configurations?: ProjectConfigurations;
}

export enum AskFeedbackStatus {
  UNDERSTANDING = 'UNDERSTANDING',
  GENERATING = 'GENERATING',
  CORRECTING = 'CORRECTING',
  FINISHED = 'FINISHED',
  FAILED = 'FAILED',
  STOPPED = 'STOPPED',
}

export interface AskFeedbackResult {
  status: AskFeedbackStatus;
  error?: WrenAIError;
  response: Array<{
    type: AskCandidateType.LLM;
    sql: string;
  }>;
  traceId?: string;
  invalidSql?: string;
}
</file>

<file path="src/apollo/server/models/dashboard.ts">
import { DashboardItem } from '@server/repositories';

export interface PreviewItemResponse {
  data: Record<string, any>[];
  cacheHit: boolean;
  cacheCreatedAt: string | null;
  cacheOverrodeAt: string | null;
  override: boolean;
}

export enum ScheduleFrequencyEnum {
  WEEKLY = 'WEEKLY',
  DAILY = 'DAILY',
  CUSTOM = 'CUSTOM',
  NEVER = 'NEVER',
}

export enum CacheScheduleDayEnum {
  SUN = 'SUN',
  MON = 'MON',
  TUE = 'TUE',
  WED = 'WED',
  THU = 'THU',
  FRI = 'FRI',
  SAT = 'SAT',
}

export interface DashboardSchedule {
  frequency: ScheduleFrequencyEnum;
  timezone: string;
  day: CacheScheduleDayEnum;
  hour: number;
  minute: number;
  cron: string;
}

export interface SetDashboardCacheData {
  cacheEnabled: boolean;
  schedule: DashboardSchedule | null;
}

export interface DetailedDashboard {
  id: number;
  projectId: number;
  name: string;
  cacheEnabled: boolean;
  scheduleFrequency: ScheduleFrequencyEnum | null;
  timezone: string | null; // e.g. 'America/New_York', 'Asia/Taipei'
  scheduleCron: string | null; // cron expression string
  nextScheduledAt: string | null; // Next scheduled run timestamp
  items: DashboardItem[];
}

export const DAYS = [
  CacheScheduleDayEnum.SUN,
  CacheScheduleDayEnum.MON,
  CacheScheduleDayEnum.TUE,
  CacheScheduleDayEnum.WED,
  CacheScheduleDayEnum.THU,
  CacheScheduleDayEnum.FRI,
  CacheScheduleDayEnum.SAT,
];
</file>

<file path="src/apollo/server/models/index.ts">
export * from './model';
export * from './instruction';
export * from './adaptor';
export * from './dashboard';
</file>

<file path="src/apollo/server/models/instruction.ts">
export interface InstructionInput {
  projectId: number;
  instruction: string;
  questions: string[];
  isDefault: boolean;
}

export interface UpdateInstructionInput {
  id: number;
  projectId: number;
  instruction: string;
  questions: string[];
  isDefault: boolean;
}
</file>

<file path="src/apollo/server/models/model.ts">
export interface CreateModelData {
  sourceTableName: string;
  fields: [string];
  primaryKey: string;
}

export interface UpdateModelData {
  fields: [string];
  primaryKey: string;
}

export interface NestedColumnMetadataInput {
  id: number;
  displayName: string;
  description: string;
}

export interface ColumnMetadataInput {
  id: number;
  displayName: string;
  description: string;
}

export interface CalculatedFieldMetadataInput {
  id: number;
  description: string;
}

export interface RelationshipMetadataInput {
  id: number;
  description: string;
}

export interface ViewColumnMetadataInput {
  referenceName: string;
  description: string;
}

export interface UpdateModelMetadataInput {
  displayName: string;
  description: string;
  columns: Array<ColumnMetadataInput>;
  nestedColumns: Array<NestedColumnMetadataInput>;
  calculatedFields: Array<CalculatedFieldMetadataInput>;
  relationships: Array<RelationshipMetadataInput>;
}

export interface UpdateViewMetadataInput {
  displayName: string;
  description: string;
  columns: Array<ViewColumnMetadataInput>;
}

export enum ExpressionName {
  ABS = 'ABS',
  AVG = 'AVG',
  COUNT = 'COUNT',
  MAX = 'MAX',
  MIN = 'MIN',
  SUM = 'SUM',
  CBRT = 'CBRT',
  CEIL = 'CEIL',
  EXP = 'EXP',
  FLOOR = 'FLOOR',
  LN = 'LN',
  LOG10 = 'LOG10',
  ROUND = 'ROUND',
  SIGN = 'SIGN',
  LENGTH = 'LENGTH',
  REVERSE = 'REVERSE',
}

export interface CreateCalculatedFieldData {
  modelId: number;
  name: string; //displayName
  expression: ExpressionName;
  lineage: number[];
}

export interface UpdateCalculatedFieldData {
  name: string; //displayName
  expression: ExpressionName;
  lineage: number[];
}

export interface CheckCalculatedFieldCanQueryData {
  referenceName: string;
  expression: ExpressionName;
  lineage: number[];
}

export interface PreviewSQLData {
  sql: string;
  projectId?: string;
  limit?: number;
  dryRun?: boolean;
}
</file>

<file path="src/apollo/server/repositories/apiHistoryRepository.ts">
import { camelCase, isPlainObject, mapKeys, mapValues } from 'lodash';
import { BaseRepository, IBasicRepository } from './baseRepository';
import { Knex } from 'knex';

export enum ApiType {
  GENERATE_SQL = 'GENERATE_SQL',
  RUN_SQL = 'RUN_SQL',
  GENERATE_VEGA_CHART = 'GENERATE_VEGA_CHART',
}

export interface ApiHistory {
  id?: string;
  projectId: number;
  apiType: ApiType;
  threadId?: string;
  headers?: Record<string, string>;
  requestPayload?: Record<string, any>;
  responsePayload?: Record<string, any>;
  statusCode?: number;
  durationMs?: number;
  createdAt?: string;
  updatedAt?: string;
}

export interface PaginationOptions {
  offset: number;
  limit: number;
  orderBy?: Record<string, 'asc' | 'desc'>;
}

export interface IApiHistoryRepository extends IBasicRepository<ApiHistory> {
  count(
    filter?: Partial<ApiHistory>,
    dateFilter?: { startDate?: Date; endDate?: Date },
  ): Promise<number>;
  findAllWithPagination(
    filter?: Partial<ApiHistory>,
    dateFilter?: { startDate?: Date; endDate?: Date },
    pagination?: PaginationOptions,
  ): Promise<ApiHistory[]>;
}

export class ApiHistoryRepository
  extends BaseRepository<ApiHistory>
  implements IApiHistoryRepository
{
  private readonly jsonbColumns = [
    'headers',
    'requestPayload',
    'responsePayload',
  ];

  constructor(knexPg: Knex) {
    super({ knexPg, tableName: 'api_history' });
  }

  /**
   * Count API history records with filtering
   */
  public async count(
    filter?: Partial<ApiHistory>,
    dateFilter?: { startDate?: Date; endDate?: Date },
  ): Promise<number> {
    let query = this.knex(this.tableName).count('id as count');

    if (filter) {
      query = query.where(this.transformToDBData(filter));
    }

    if (dateFilter) {
      if (dateFilter.startDate) {
        query = query.where('created_at', '>=', dateFilter.startDate);
      }

      if (dateFilter.endDate) {
        query = query.where('created_at', '<=', dateFilter.endDate);
      }
    }

    const result = await query;
    return parseInt(result[0].count as string, 10);
  }

  /**
   * Find API history records with pagination
   */
  public async findAllWithPagination(
    filter?: Partial<ApiHistory>,
    dateFilter?: { startDate?: Date; endDate?: Date },
    pagination?: PaginationOptions,
  ): Promise<ApiHistory[]> {
    let query = this.knex(this.tableName).select('*');

    if (filter) {
      query = query.where(this.transformToDBData(filter));
    }

    if (dateFilter) {
      if (dateFilter.startDate) {
        query = query.where('created_at', '>=', dateFilter.startDate);
      }

      if (dateFilter.endDate) {
        query = query.where('created_at', '<=', dateFilter.endDate);
      }
    }

    if (pagination) {
      if (pagination.orderBy) {
        Object.entries(pagination.orderBy).forEach(([field, direction]) => {
          query = query.orderBy(this.camelToSnakeCase(field), direction);
        });
      } else {
        // Default sort by created_at desc
        query = query.orderBy('created_at', 'desc');
      }

      query = query.offset(pagination.offset).limit(pagination.limit);
    }

    const result = await query;
    return result.map(this.transformFromDBData);
  }

  protected override transformFromDBData = (data: any): ApiHistory => {
    if (!isPlainObject(data)) {
      throw new Error('Unexpected dbdata');
    }
    const camelCaseData = mapKeys(data, (_value, key) => camelCase(key));
    const formattedData = mapValues(camelCaseData, (value, key) => {
      if (this.jsonbColumns.includes(key)) {
        // The value from Sqlite will be string type, while the value from PG is JSON object
        if (typeof value === 'string') {
          if (!value) return value;
          try {
            return JSON.parse(value);
          } catch (error) {
            console.error(`Failed to parse JSON for ${key}:`, error);
            return value; // Return raw value if parsing fails
          }
        } else {
          return value;
        }
      }
      return value;
    }) as ApiHistory;
    return formattedData;
  };

  /**
   * Convert camelCase to snake_case for DB column names
   */
  private camelToSnakeCase(str: string): string {
    return str.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);
  }
}
</file>

<file path="src/apollo/server/repositories/askingTaskRepository.ts">
import { Knex } from 'knex';
import { BaseRepository, IBasicRepository } from './baseRepository';
import {
  camelCase,
  isPlainObject,
  mapKeys,
  mapValues,
  snakeCase,
} from 'lodash';
import { AskFeedbackResult, AskResult } from '../models/adaptor';

export type AskingTaskDetail =
  | AskResult
  | (AskFeedbackResult & {
      adjustment?: boolean;
    });

export interface AskingTask {
  id: number;
  queryId: string;
  question?: string;
  detail?: AskingTaskDetail;
  threadId?: number;
  threadResponseId?: number;
  createdAt: Date;
  updatedAt: Date;
}

export interface IAskingTaskRepository extends IBasicRepository<AskingTask> {
  findByQueryId(queryId: string): Promise<AskingTask | null>;
}

export class AskingTaskRepository
  extends BaseRepository<AskingTask>
  implements IAskingTaskRepository
{
  private readonly jsonbColumns = ['detail'];

  constructor(knexPg: Knex) {
    super({ knexPg, tableName: 'asking_task' });
  }

  public async findByQueryId(queryId: string): Promise<AskingTask | null> {
    return this.findOneBy({ queryId });
  }

  protected override transformFromDBData = (data: any) => {
    if (!isPlainObject(data)) {
      throw new Error('Unexpected dbdata');
    }
    const camelCaseData = mapKeys(data, (_value, key) => camelCase(key));
    const transformData = mapValues(camelCaseData, (value, key) => {
      if (this.jsonbColumns.includes(key)) {
        if (typeof value === 'string') {
          return value ? JSON.parse(value) : value;
        }
        return value;
      }
      return value;
    });
    return transformData as AskingTask;
  };

  protected override transformToDBData = (data: any) => {
    if (!isPlainObject(data)) {
      throw new Error('Unexpected dbdata');
    }
    const transformedData = mapValues(data, (value, key) => {
      if (this.jsonbColumns.includes(key)) {
        return JSON.stringify(value);
      } else {
        return value;
      }
    });
    return mapKeys(transformedData, (_value, key) => snakeCase(key));
  };
}
</file>

<file path="src/apollo/server/repositories/baseRepository.ts">
import { Knex } from 'knex';
import { camelCase, isPlainObject, mapKeys, snakeCase } from 'lodash';

export interface IQueryOptions {
  tx?: Knex.Transaction;
  order?: string;
  limit?: number;
}

export interface IBasicRepository<T> {
  transaction: () => Promise<Knex.Transaction>;
  commit: (tx: Knex.Transaction) => Promise<void>;
  rollback: (tx: Knex.Transaction) => Promise<void>;
  findOneBy: (
    filter: Partial<T>,
    queryOptions?: IQueryOptions,
  ) => Promise<T | null>;
  findAllBy: (filter: Partial<T>, queryOptions?: IQueryOptions) => Promise<T[]>;
  findAll: (queryOptions?: IQueryOptions) => Promise<T[]>;
  createOne: (data: Partial<T>, queryOptions?: IQueryOptions) => Promise<T>;
  createMany: (
    data: Partial<T>[],
    queryOptions?: IQueryOptions,
  ) => Promise<T[]>;
  updateOne: (
    id: string | number,
    data: Partial<T>,
    queryOptions?: IQueryOptions,
  ) => Promise<T>;
  deleteOne: (
    id: string | number,
    queryOptions?: IQueryOptions,
  ) => Promise<number>;
  deleteMany: (
    ids: (string | number)[],
    queryOptions?: IQueryOptions,
  ) => Promise<number>;
  deleteAllBy: (
    where: Partial<T>,
    queryOptions?: IQueryOptions,
  ) => Promise<number>;
}

export class BaseRepository<T> implements IBasicRepository<T> {
  protected knex: Knex;
  protected tableName: string;

  constructor({ knexPg, tableName }: { knexPg: Knex; tableName: string }) {
    this.knex = knexPg;
    this.tableName = tableName;
  }

  public async transaction() {
    return await this.knex.transaction();
  }

  public async commit(tx: Knex.Transaction) {
    await tx.commit();
  }

  public async rollback(tx: Knex.Transaction) {
    await tx.rollback();
  }

  public async findOneBy(filter: Partial<T>, queryOptions?: IQueryOptions) {
    const executer = queryOptions?.tx ? queryOptions.tx : this.knex;
    const query = executer(this.tableName).where(
      this.transformToDBData(filter),
    );
    if (queryOptions?.limit) {
      query.limit(queryOptions.limit);
    }
    const result = await query;
    return result && result.length > 0
      ? this.transformFromDBData(result[0])
      : null;
  }

  public async findAllBy(filter: Partial<T>, queryOptions?: IQueryOptions) {
    const executer = queryOptions?.tx ? queryOptions.tx : this.knex;
    // format filter keys to snake_case

    const query = executer(this.tableName).where(
      this.transformToDBData(filter),
    );
    if (queryOptions?.order) {
      query.orderBy(queryOptions.order);
    }
    const result = await query;
    return result.map(this.transformFromDBData);
  }

  public async findAll(queryOptions?: IQueryOptions) {
    const executer = queryOptions?.tx ? queryOptions.tx : this.knex;
    const query = executer(this.tableName);
    if (queryOptions?.order) {
      query.orderBy(queryOptions.order);
    }
    if (queryOptions?.limit) {
      query.limit(queryOptions.limit);
    }
    const result = await query;
    return result.map(this.transformFromDBData);
  }

  public async createOne(data: Partial<T>, queryOptions?: IQueryOptions) {
    const executer = queryOptions?.tx ? queryOptions.tx : this.knex;
    const [result] = await executer(this.tableName)
      .insert(this.transformToDBData(data))
      .returning('*');
    return this.transformFromDBData(result);
  }

  public async createMany(data: Partial<T>[], queryOptions?: IQueryOptions) {
    const executer = queryOptions?.tx ? queryOptions.tx : this.knex;
    const batchSize = 100;
    const batchCount = Math.ceil(data.length / batchSize);
    const result = [];
    for (let i = 0; i < batchCount; i++) {
      const start = i * batchSize;
      const end = Math.min((i + 1) * batchSize, data.length);
      const batchValues = data.slice(start, end);
      const chunk = await executer(this.tableName)
        .insert(batchValues.map(this.transformToDBData))
        .returning('*');
      result.push(...chunk);
    }

    return result.map((data) => this.transformFromDBData(data));
  }

  public async updateOne(
    id: string | number,
    data: Partial<T>,
    queryOptions?: IQueryOptions,
  ) {
    const executer = queryOptions?.tx ? queryOptions.tx : this.knex;
    const [result] = await executer(this.tableName)
      .where({ id })
      .update(this.transformToDBData(data))
      .returning('*');
    return this.transformFromDBData(result);
  }

  public async deleteOne(id: string, queryOptions?: IQueryOptions) {
    const executer = queryOptions?.tx ? queryOptions.tx : this.knex;
    const builder = executer.from(this.tableName).where({ id }).delete();
    return await builder;
  }

  public async deleteMany(
    ids: (string | number)[],
    queryOptions?: IQueryOptions,
  ) {
    const executer = queryOptions?.tx ? queryOptions.tx : this.knex;
    const builder = executer.from(this.tableName).whereIn('id', ids).delete();
    return await builder;
  }

  public deleteAllBy = async (
    where: Partial<T>,
    queryOptions?: IQueryOptions,
  ) => {
    const executer = queryOptions?.tx ? queryOptions.tx : this.knex;
    const builder = executer(this.tableName)
      .where(this.transformToDBData(where))
      .delete();
    return await builder;
  };

  protected transformToDBData = (data: Partial<T>) => {
    if (!isPlainObject(data)) {
      throw new Error('Unexpected dbdata');
    }
    return mapKeys(data, (_value, key) => snakeCase(key));
  };

  protected transformFromDBData = (data: any): T => {
    if (!isPlainObject(data)) {
      throw new Error('Unexpected dbdata');
    }
    const camelCaseData = mapKeys(data, (_value, key) => camelCase(key));
    return camelCaseData as T;
  };
}
</file>

<file path="src/apollo/server/repositories/dashboardItemRefreshJobRepository.ts">
import { Knex } from 'knex';
import { BaseRepository, IBasicRepository } from './baseRepository';

export enum DashboardCacheRefreshStatus {
  IN_PROGRESS = 'in_progress',
  SUCCESS = 'success',
  FAILED = 'failed',
}

export interface DashboardItemRefreshJob {
  id: number;
  hash: string;
  dashboardId: number;
  dashboardItemId: number;
  startedAt: Date;
  finishedAt: Date | null;
  status: DashboardCacheRefreshStatus;
  errorMessage: string | null;
  createdAt: Date;
  updatedAt: Date;
}

export interface IDashboardItemRefreshJobRepository
  extends IBasicRepository<DashboardItemRefreshJob> {}

export class DashboardItemRefreshJobRepository
  extends BaseRepository<DashboardItemRefreshJob>
  implements IDashboardItemRefreshJobRepository
{
  constructor(knexPg: Knex) {
    super({ knexPg, tableName: 'dashboard_item_refresh_job' });
  }
}
</file>

<file path="src/apollo/server/repositories/dashboardItemRepository.ts">
import { Knex } from 'knex';
import { BaseRepository, IBasicRepository } from './baseRepository';
import {
  camelCase,
  isPlainObject,
  mapKeys,
  mapValues,
  snakeCase,
} from 'lodash';

export enum DashboardItemType {
  // AI chart types, refer to ChartType in adaptor.ts
  AREA = 'AREA',
  BAR = 'BAR',
  GROUPED_BAR = 'GROUPED_BAR',
  LINE = 'LINE',
  PIE = 'PIE',
  STACKED_BAR = 'STACKED_BAR',
  // other types
  TABLE = 'TABLE',
  NUMBER = 'NUMBER',
}

export interface DashboardItemLayout {
  x: number;
  y: number;
  w: number;
  h: number;
}

export interface DashboardItemDetail {
  sql: string;
  chartSchema?: Record<string, any>;
}

export interface DashboardItem {
  id: number;
  dashboardId: number;
  type: DashboardItemType;
  layout: DashboardItemLayout;
  detail: DashboardItemDetail;
  displayName?: string;
}

export interface IDashboardItemRepository
  extends IBasicRepository<DashboardItem> {}

export class DashboardItemRepository
  extends BaseRepository<DashboardItem>
  implements IDashboardItemRepository
{
  private readonly jsonbColumns = ['layout', 'detail'];

  constructor(knexPg: Knex) {
    super({ knexPg, tableName: 'dashboard_item' });
  }

  protected override transformFromDBData = (data: any) => {
    if (!isPlainObject(data)) {
      throw new Error('Unexpected dbdata');
    }
    const camelCaseData = mapKeys(data, (_value, key) => camelCase(key));
    const transformData = mapValues(camelCaseData, (value, key) => {
      if (this.jsonbColumns.includes(key)) {
        if (typeof value === 'string') {
          return value ? JSON.parse(value) : value;
        } else {
          return value;
        }
      }
      return value;
    });
    return transformData as DashboardItem;
  };

  protected override transformToDBData = (data: any) => {
    if (!isPlainObject(data)) {
      throw new Error('Unexpected dbdata');
    }
    const transformedData = mapValues(data, (value, key) => {
      if (this.jsonbColumns.includes(key)) {
        return JSON.stringify(value);
      } else {
        return value;
      }
    });
    return mapKeys(transformedData, (_value, key) => snakeCase(key));
  };
}
</file>

<file path="src/apollo/server/repositories/dashboardRepository.ts">
import { Knex } from 'knex';
import { BaseRepository, IBasicRepository } from './baseRepository';
import { ScheduleFrequencyEnum } from '@server/models/dashboard';

export interface Dashboard {
  id: number;
  projectId: number;
  name: string;
  cacheEnabled: boolean;
  scheduleFrequency: ScheduleFrequencyEnum | null;
  scheduleTimezone: string | null; // e.g. 'America/New_York', 'Asia/Taipei'
  scheduleCron: string | null; // cron expression string
  nextScheduledAt: Date | null; // Next scheduled run timestamp
}

export interface IDashboardRepository extends IBasicRepository<Dashboard> {}

export class DashboardRepository
  extends BaseRepository<Dashboard>
  implements IDashboardRepository
{
  constructor(knexPg: Knex) {
    super({ knexPg, tableName: 'dashboard' });
  }
}
</file>

<file path="src/apollo/server/repositories/deployLogRepository.ts">
import { Knex } from 'knex';
import { BaseRepository, IBasicRepository } from './baseRepository';
import { camelCase, isPlainObject, mapKeys, mapValues } from 'lodash';

export interface Deploy {
  id: number; // ID
  projectId: number; // Reference to project.id
  manifest: object; // Model manifest
  hash: string;
  status: string; // Deploy status
  error: string; // Error message
}

export enum DeployStatusEnum {
  IN_PROGRESS = 'IN_PROGRESS',
  SUCCESS = 'SUCCESS',
  FAILED = 'FAILED',
}

export interface IDeployLogRepository extends IBasicRepository<Deploy> {
  findLastProjectDeployLog(projectId: number): Promise<Deploy | null>;
  findInProgressProjectDeployLog(projectId: number): Promise<Deploy | null>;
}

export class DeployLogRepository
  extends BaseRepository<Deploy>
  implements IDeployLogRepository
{
  constructor(knexPg: Knex) {
    super({ knexPg, tableName: 'deploy_log' });
  }

  public async findLastProjectDeployLog(projectId: number) {
    const res = await this.knex
      .select('*')
      .from(this.tableName)
      .where(
        this.transformToDBData({ projectId, status: DeployStatusEnum.SUCCESS }),
      )
      .orderBy('created_at', 'desc')
      .first();
    return (res && this.transformFromDBData(res)) || null;
  }

  public async findInProgressProjectDeployLog(projectId: number) {
    const res = await this.knex
      .select('*')
      .from(this.tableName)
      .where(
        this.transformToDBData({
          projectId,
          status: DeployStatusEnum.IN_PROGRESS,
        }),
      )
      .orderBy('created_at', 'desc')
      .first();
    return (res && this.transformFromDBData(res)) || null;
  }

  public override transformFromDBData: (data: any) => Deploy = (data: any) => {
    if (!isPlainObject(data)) {
      throw new Error('Unexpected dbdata');
    }
    const camelCaseData = mapKeys(data, (_value, key) => camelCase(key));
    const formattedData = mapValues(camelCaseData, (value, key) => {
      if (['manifest'].includes(key)) {
        // sqlite return a string for json field, but postgres return an object
        return typeof value === 'string' ? JSON.parse(value) : value;
      }
      return value;
    });
    return formattedData as Deploy;
  };
}
</file>

<file path="src/apollo/server/repositories/index.ts">
export * from './baseRepository';
export * from './learningRepository';
export * from './modelRepository';
export * from './projectRepository';
export * from './modelColumnRepository';
export * from './modelNestedColumnRepository';
export * from './relationshipRepository';
export * from './metricsRepository';
export * from './metricsMeasureRepository';
export * from './deployLogRepository';
export * from './viewRepository';
export * from './threadRepository';
export * from './threadResponseRepository';
export * from './schemaChangeRepository';
export * from './dashboardRepository';
export * from './dashboardItemRepository';
export * from './sqlPairRepository';
export * from './askingTaskRepository';
export * from './instructionRepository';
export * from './apiHistoryRepository';
export * from './dashboardItemRefreshJobRepository';
</file>

<file path="src/apollo/server/repositories/instructionRepository.ts">
import { Knex } from 'knex';
import { BaseRepository, IBasicRepository } from './baseRepository';
import {
  camelCase,
  isPlainObject,
  mapKeys,
  mapValues,
  snakeCase,
} from 'lodash';

export interface Instruction {
  id: number;
  projectId: number;
  instruction: string;
  questions: string[];
  isDefault: boolean;
  createdAt: string;
  updatedAt: string;
}

export interface IInstructionRepository extends IBasicRepository<Instruction> {}

export class InstructionRepository
  extends BaseRepository<Instruction>
  implements IInstructionRepository
{
  private readonly jsonbColumns = ['questions'];

  constructor(knexPg: Knex) {
    super({ knexPg, tableName: 'instruction' });
  }

  protected override transformFromDBData = (data: any) => {
    if (!isPlainObject(data)) {
      throw new Error('Unexpected dbdata');
    }
    const camelCaseData = mapKeys(data, (_value, key) => camelCase(key));
    const transformData = mapValues(camelCaseData, (value, key) => {
      if (this.jsonbColumns.includes(key)) {
        if (typeof value === 'string') {
          return value ? JSON.parse(value) : value;
        } else {
          return value;
        }
      }
      return value;
    });
    return transformData as Instruction;
  };

  protected override transformToDBData = (data: any) => {
    if (!isPlainObject(data)) {
      throw new Error('Unexpected dbdata');
    }
    const transformedData = mapValues(data, (value, key) => {
      if (this.jsonbColumns.includes(key)) {
        return JSON.stringify(value);
      } else {
        return value;
      }
    });
    return mapKeys(transformedData, (_value, key) => snakeCase(key));
  };
}
</file>

<file path="src/apollo/server/repositories/learningRepository.ts">
import { Knex } from 'knex';
import { BaseRepository, IBasicRepository } from './baseRepository';
import {
  camelCase,
  isPlainObject,
  mapKeys,
  mapValues,
  snakeCase,
} from 'lodash';

export interface Learning {
  id: number; // ID
  userId: string; // Reference to config userUUID
  paths: string[]; // The learning paths, array of learning stories
}

export interface ILearningRepository extends IBasicRepository<Learning> {}

export class LearningRepository
  extends BaseRepository<Learning>
  implements ILearningRepository
{
  constructor(knexPg: Knex) {
    super({ knexPg, tableName: 'learning' });
  }

  protected override transformToDBData = (data: any) => {
    if (!isPlainObject(data)) {
      throw new Error('Unexpected dbdata');
    }
    const transformedData = mapValues(data, (value, key) => {
      if (['paths'].includes(key)) {
        return value ? JSON.stringify(value) : null;
      }
      return value;
    });
    return mapKeys(transformedData, (_value, key) => snakeCase(key));
  };

  protected override transformFromDBData = (data: any): Learning => {
    if (!isPlainObject(data)) {
      throw new Error('Unexpected dbdata');
    }
    const camelCaseData = mapKeys(data, (_value, key) => camelCase(key));
    const formattedData = mapValues(camelCaseData, (value, key) => {
      if (['paths'].includes(key)) {
        // The value from Sqlite will be string type, while the value from PG is JSON object
        if (typeof value === 'string') {
          return value ? JSON.parse(value) : value;
        } else {
          return value;
        }
      }
      return value;
    }) as Learning;
    return formattedData;
  };
}
</file>

<file path="src/apollo/server/repositories/metricsMeasureRepository.ts">
import { Knex } from 'knex';
import { BaseRepository, IBasicRepository } from './baseRepository';

export interface MetricMeasure {
  id: number; // ID
  metricId: number; // Reference to metric ID
  name: string; // Measure name
  expression: string; // Expression for the measure
  granularity?: string; // Granularity for the measure, eg: "day", "hour", "minute", "year"
}

export interface IMetricMeasureRepository
  extends IBasicRepository<MetricMeasure> {}

export class MetricMeasureRepository
  extends BaseRepository<MetricMeasure>
  implements IMetricMeasureRepository
{
  constructor(knexPg: Knex) {
    super({ knexPg, tableName: 'metric_measure' });
  }
}
</file>

<file path="src/apollo/server/repositories/metricsRepository.ts">
import { Knex } from 'knex';
import { BaseRepository, IBasicRepository } from './baseRepository';

export interface Metric {
  id: number; // ID
  projectId: number; // Reference to project.id
  name: string; // Metric name
  type: string; // Metric type, ex: "simple" or "cumulative"
  cached: boolean; // Model is cached or not
  refreshTime?: string; // Contain a number followed by a time unit (ns, us, ms, s, m, h, d). For example, "2h"

  // metric can based on model or another metric
  modelId?: number; // Reference to model.id
  metricId?: number; // Reference to metric.id
  properties?: string; // Metric properties, a json string, the description and displayName should be stored here
}

export interface IMetricRepository extends IBasicRepository<Metric> {}

export class MetricRepository
  extends BaseRepository<Metric>
  implements IMetricRepository
{
  constructor(knexPg: Knex) {
    super({ knexPg, tableName: 'metric' });
  }
}
</file>

<file path="src/apollo/server/repositories/modelColumnRepository.ts">
import { Knex } from 'knex';
import {
  BaseRepository,
  IBasicRepository,
  IQueryOptions,
} from './baseRepository';

export interface ModelColumn {
  id: number; // ID
  modelId: number; // Reference to model ID
  isCalculated: boolean; // Is calculated field
  displayName: string; // Column name displayed in UI
  referenceName: string; // The name used in the MDL structure and when querying the data
  sourceColumnName: string; // The column name in the datasource
  aggregation?: string; // Expression for the column, could be custom field or calculated field expression
  lineage?: string; // The selected field in calculated field, array of ids
  customExpression?: string; // For custom field or custom expression of calculated field
  type: string; // Data type, refer to the column type in the datasource
  notNull: boolean; // Is not null
  isPk: boolean; // Is primary key of the table
  properties?: string; // Column properties, a json string, the description and displayName should be stored here
}

export interface IModelColumnRepository extends IBasicRepository<ModelColumn> {
  findColumnsByModelIds(
    modelIds: number[],
    queryOptions?: IQueryOptions,
  ): Promise<ModelColumn[]>;
  findColumnsByIds(
    ids: number[],
    queryOptions?: IQueryOptions,
  ): Promise<ModelColumn[]>;
  deleteByModelIds(
    modelIds: number[],
    queryOptions?: IQueryOptions,
  ): Promise<void>;
  resetModelPrimaryKey(modelId: number): Promise<void>;
  setModelPrimaryKey(modelId: number, sourceColumnName: string): Promise<void>;
  deleteAllBySourceColumnNames(
    modelId: number,
    sourceColumnNames: string[],
    queryOptions?: IQueryOptions,
  ): Promise<number>;
  deleteAllByColumnIds(
    columnIds: number[],
    queryOptions?: IQueryOptions,
  ): Promise<void>;
}

export class ModelColumnRepository
  extends BaseRepository<ModelColumn>
  implements IModelColumnRepository
{
  constructor(knexPg: Knex) {
    super({ knexPg, tableName: 'model_column' });
  }

  public async findColumnsByModelIds(modelIds, queryOptions?: IQueryOptions) {
    if (queryOptions && queryOptions.tx) {
      const { tx } = queryOptions;
      const result = await tx(this.tableName)
        .whereIn('model_id', modelIds)
        .select('*');
      return result.map((r) => this.transformFromDBData(r));
    }
    const result = await this.knex<ModelColumn>('model_column')
      .whereIn('model_id', modelIds)
      .select('*');
    return result.map((r) => this.transformFromDBData(r));
  }

  public async findColumnsByIds(ids: number[], queryOptions?: IQueryOptions) {
    if (queryOptions && queryOptions.tx) {
      const { tx } = queryOptions;
      const result = await tx(this.tableName).whereIn('id', ids).select('*');
      return result.map((r) => this.transformFromDBData(r));
    }
    const result = await this.knex<ModelColumn>('model_column')
      .whereIn('id', ids)
      .select('*');
    return result.map((r) => this.transformFromDBData(r));
  }

  public async deleteByModelIds(
    modelIds: number[],
    queryOptions?: IQueryOptions,
  ) {
    if (queryOptions && queryOptions.tx) {
      const { tx } = queryOptions;
      await tx(this.tableName).whereIn('model_id', modelIds).delete();
      return;
    }
    await this.knex<ModelColumn>('model_column')
      .whereIn('model_id', modelIds)
      .delete();
  }

  public async resetModelPrimaryKey(modelId: number) {
    await this.knex<ModelColumn>('model_column')
      .where(this.transformToDBData({ modelId }))
      .update(this.transformToDBData({ isPk: false }));
  }
  public async setModelPrimaryKey(modelId: number, sourceColumnName: string) {
    await this.knex<ModelColumn>('model_column')
      .where(this.transformToDBData({ modelId, sourceColumnName }))
      .update(this.transformToDBData({ isPk: true }));
  }

  public async deleteAllBySourceColumnNames(
    modelId: number,
    sourceColumnNames: string[],
    queryOptions?: IQueryOptions,
  ): Promise<number> {
    const executer = queryOptions?.tx ? queryOptions.tx : this.knex;
    const builder = executer(this.tableName)
      .where(this.transformToDBData({ modelId }))
      .whereIn('source_column_name', sourceColumnNames)
      .delete();
    return await builder;
  }

  public async deleteAllByColumnIds(
    columnIds: number[],
    queryOptions?: IQueryOptions,
  ): Promise<void> {
    const executer = queryOptions?.tx ? queryOptions.tx : this.knex;
    await executer<ModelColumn>(this.tableName)
      .whereIn('id', columnIds)
      .delete();
  }
}
</file>

<file path="src/apollo/server/repositories/modelNestedColumnRepository.ts">
import { Knex } from 'knex';
import { BaseRepository, IBasicRepository } from './baseRepository';
import {
  camelCase,
  isPlainObject,
  mapKeys,
  mapValues,
  snakeCase,
} from 'lodash';

export interface ModelNestedColumn {
  id: number; // ID
  modelId: number; // Reference to model ID
  columnId: number; // Reference to column ID
  columnPath: string[];
  displayName: string; // Nested column name displayed in UI
  referenceName: string; // The name used in the MDL structure and when querying the data
  sourceColumnName: string; // The nested column name in the datasource
  type: string; // Data type, refer to the nested column type in the datasource
  properties?: Record<string, any>; // Nested column properties, a json string, the description should be stored here
}

export interface IModelNestedColumnRepository
  extends IBasicRepository<ModelNestedColumn> {
  findNestedColumnsByModelIds(modelIds: number[]): Promise<ModelNestedColumn[]>;
  findNestedColumnsByIds(ids: number[]): Promise<ModelNestedColumn[]>;
}

export class ModelNestedColumnRepository
  extends BaseRepository<ModelNestedColumn>
  implements IModelNestedColumnRepository
{
  constructor(knexPg: Knex) {
    super({ knexPg, tableName: 'model_nested_column' });
  }

  public findNestedColumnsByModelIds = async (modelIds: number[]) => {
    const result = await this.knex(this.tableName)
      .select('*')
      .whereIn('model_id', modelIds);
    return result.map((r) => this.transformFromDBData(r));
  };

  public findNestedColumnsByIds = async (ids: number[]) => {
    const result = await this.knex(this.tableName)
      .select('*')
      .whereIn('id', ids);
    return result.map((r) => this.transformFromDBData(r));
  };

  protected override transformToDBData = (data: any) => {
    if (!isPlainObject(data)) {
      throw new Error('Unexpected dbdata');
    }
    const transformedData = mapValues(data, (value, key) => {
      if (['columnPath', 'properties'].includes(key)) {
        return value ? JSON.stringify(value) : null;
      }
      return value;
    });
    return mapKeys(transformedData, (_value, key) => snakeCase(key));
  };

  protected override transformFromDBData = (data: any): ModelNestedColumn => {
    if (!isPlainObject(data)) {
      throw new Error('Unexpected dbdata');
    }
    const camelCaseData = mapKeys(data, (_value, key) => camelCase(key));
    const formattedData = mapValues(camelCaseData, (value, key) => {
      if (['columnPath', 'properties'].includes(key)) {
        // The value from Sqlite will be string type, while the value from PG is JSON object
        if (typeof value === 'string') {
          return value ? JSON.parse(value) : value;
        } else {
          return value;
        }
      }
      return value;
    }) as ModelNestedColumn;
    return formattedData;
  };
}
</file>

<file path="src/apollo/server/repositories/modelRepository.ts">
import { Knex } from 'knex';
import {
  BaseRepository,
  IBasicRepository,
  IQueryOptions,
} from './baseRepository';

export interface Model {
  id: number; // ID
  projectId: number; // Reference to project.id
  displayName: string; // Model name displayed in UI
  sourceTableName: string; // the table name in the datasource
  referenceName: string; // the name used in the MDL structure
  refSql: string; // Reference SQL
  cached: boolean; // Model is cached or not
  refreshTime: string | null; // Contain a number followed by a time unit (ns, us, ms, s, m, h, d). For example, "2h"
  properties: string | null; // Model properties, a json string, the description and displayName should be stored here
}

export interface IModelRepository extends IBasicRepository<Model> {
  findAllByIds(ids: number[]): Promise<Model[]>;
  deleteAllBySourceTableNames(
    sourceTableNames: string[],
    queryOptions?: IQueryOptions,
  ): Promise<number>;
}

export class ModelRepository
  extends BaseRepository<Model>
  implements IModelRepository
{
  constructor(knexPg: Knex) {
    super({ knexPg, tableName: 'model' });
  }
  public async findAllByIds(ids: number[]) {
    const res = await this.knex<Model>(this.tableName).whereIn('id', ids);
    return res.map((r) => this.transformFromDBData(r));
  }

  public async deleteAllBySourceTableNames(
    sourceTableNames: string[],
    queryOptions?: IQueryOptions,
  ) {
    const executer = queryOptions?.tx ? queryOptions.tx : this.knex;
    const builder = executer(this.tableName)
      .whereIn('source_table_name', sourceTableNames)
      .delete();
    return await builder;
  }
}
</file>

<file path="src/apollo/server/repositories/projectRepository.ts">
import { Knex } from 'knex';
import { BaseRepository, IBasicRepository } from './baseRepository';
import {
  camelCase,
  isPlainObject,
  mapKeys,
  mapValues,
  snakeCase,
  isEmpty,
} from 'lodash';
import { DataSourceName } from '@server/types';
import { IbisRedshiftConnectionType } from '@server/adaptors/ibisAdaptor';

export interface BIG_QUERY_CONNECTION_INFO {
  projectId: string;
  datasetId: string;
  credentials: string;
}
export interface POSTGRES_CONNECTION_INFO {
  host: string;
  port: number;
  user: string;
  password: string;
  database: string;
  ssl: boolean;
}

export interface MYSQL_CONNECTION_INFO {
  host: string;
  port: number;
  user: string;
  password: string;
  database: string;
  ssl: boolean;
}

export interface ORACLE_CONNECTION_INFO {
  user: string;
  password: string;
  host?: string;
  port?: number;
  database?: string;
  dsn?: string;
}

export interface MS_SQL_CONNECTION_INFO {
  host: string;
  port: number;
  user: string;
  password: string;
  database: string;
  trustServerCertificate: boolean;
}

export interface CLICK_HOUSE_CONNECTION_INFO {
  host: string;
  port: number;
  user: string;
  password: string;
  database: string;
  ssl: boolean;
}

export interface TRINO_CONNECTION_INFO {
  host: string;
  port: number;
  schemas: string;
  username: string;
  password: string;
  ssl: boolean;
}

export interface SNOWFLAKE_CONNECTION_INFO {
  user: string;
  password: string;
  account: string;
  database: string;
  schema: string;
}

export interface DUCKDB_CONNECTION_INFO {
  initSql: string;
  extensions: Array<string>;
  configurations: Record<string, any>;
}

export interface ATHENA_CONNECTION_INFO {
  database: string;
  schema: string;
  s3StagingDir: string;
  awsRegion: string;
  awsAccessKey: string;
  awsSecretKey: string;
}

export interface REDSHIFT_PASSWORD_AUTH {
  host: string;
  port: number;
  user: string;
  password: string;
  database: string;
  redshiftType: IbisRedshiftConnectionType;
}

export interface REDSHIFT_IAM_AUTH {
  clusterIdentifier: string;
  user: string;
  database: string;
  awsRegion: string;
  awsAccessKey: string;
  awsSecretKey: string;
  redshiftType: IbisRedshiftConnectionType;
}

export type REDSHIFT_CONNECTION_INFO =
  | REDSHIFT_PASSWORD_AUTH
  | REDSHIFT_IAM_AUTH;

export type WREN_AI_CONNECTION_INFO =
  | ATHENA_CONNECTION_INFO
  | BIG_QUERY_CONNECTION_INFO
  | POSTGRES_CONNECTION_INFO
  | MYSQL_CONNECTION_INFO
  | ORACLE_CONNECTION_INFO
  | DUCKDB_CONNECTION_INFO
  | MS_SQL_CONNECTION_INFO
  | CLICK_HOUSE_CONNECTION_INFO
  | TRINO_CONNECTION_INFO
  | SNOWFLAKE_CONNECTION_INFO
  | REDSHIFT_CONNECTION_INFO;

export interface RecommendationQuestionResult {
  question: string;
  category: string; // category for the question
  sql: string; // validated sql for this question, can be used in generateAskDetail
}

export interface Project {
  id: number; // ID
  type: DataSourceName; // Project datasource type. ex: bigquery, mysql, postgresql, mongodb, etc
  version: string; // Project datasource version
  displayName: string; // Project display name
  catalog: string; // Catalog name
  schema: string; // Schema name
  sampleDataset: string; // Sample dataset name
  connectionInfo: WREN_AI_CONNECTION_INFO;
  language?: string; // Project language

  // The recommended questions generated by AI
  queryId?: string;
  questions?: RecommendationQuestionResult[];
  questionsStatus?: string;
  questionsError?: object;
}

export interface IProjectRepository extends IBasicRepository<Project> {
  getCurrentProject: () => Promise<Project>;
}

export class ProjectRepository
  extends BaseRepository<Project>
  implements IProjectRepository
{
  private jsonTypeColumns = ['questions', 'questions_error', 'connection_info'];

  constructor(knexPg: Knex) {
    super({ knexPg, tableName: 'project' });
  }

  public async getCurrentProject() {
    const projects = await this.findAll({
      order: 'id',
      limit: 1,
    });
    if (!projects.length) {
      throw new Error('No project found');
    }
    return projects[0];
  }

  public override transformFromDBData: (data: any) => Project = (data: any) => {
    if (!isPlainObject(data)) {
      throw new Error('Unexpected db data');
    }
    const formattedData = mapValues(data, (value, key) => {
      if (this.jsonTypeColumns.includes(key) && typeof value === 'string') {
        // should return {} if value is null / {}, use value ? {} : JSON.parse(value) will throw error when value is null
        return isEmpty(value) ? {} : JSON.parse(value);
      }
      if (key === 'type') {
        return DataSourceName[value];
      }
      return value;
    });
    const camelCaseData = mapKeys(formattedData, (_value, key) =>
      camelCase(key),
    );
    return camelCaseData as Project;
  };

  public override transformToDBData: (data: Project) => any = (
    data: Project,
  ) => {
    if (!isPlainObject(data)) {
      throw new Error('Unexpected db data');
    }
    const snakeCaseData = mapKeys(data, (_value, key) => snakeCase(key));
    const formattedData = mapValues(snakeCaseData, (value, key) => {
      if (this.jsonTypeColumns.includes(key) && typeof value !== 'string') {
        return JSON.stringify(value);
      }
      return value;
    });
    return formattedData;
  };
}
</file>

<file path="src/apollo/server/repositories/relationshipRepository.ts">
import { Knex } from 'knex';
import {
  BaseRepository,
  IBasicRepository,
  IQueryOptions,
} from './baseRepository';
import { RelationData } from '../types';

export interface Relation {
  id: number; // ID
  projectId: number; // Reference to project.id
  name: string; // Relation name
  joinType: string; // Join type, eg:"MANY_TO_ONE", "ONE_TO_MANY", "MANY_TO_MANY"
  condition: string; // Join condition, ex: "OrdersModel.custkey = CustomerModel.custkey"
  fromColumnId: number; // from column id, "{fromColumn} {joinType} {toColumn}"
  toColumnId: number; // to column id, "{fromColumn} {joinType} {toColumn}"
  properties: string | null; // Model properties, a json string, the description should be stored here
}

export interface ExtraRelationInfo {
  fromModelId: number;
  fromModelName: string;
  fromModelDisplayName: string;
  fromColumnName: string;
  fromColumnDisplayName: string;
  toModelId: number;
  toModelName: string;
  toModelDisplayName: string;
  toColumnName: string;
  toColumnDisplayName: string;
}

export type RelationInfo = Relation & ExtraRelationInfo;

export interface IRelationRepository extends IBasicRepository<Relation> {
  findRelationsBy(
    filter: { columnIds?: number[]; modelIds?: number[] },
    queryOptions?: IQueryOptions,
  ): Promise<Relation[]>;
  findRelationsByIds(
    ids: number[],
    queryOptions?: IQueryOptions,
  ): Promise<Relation[]>;
  deleteRelationsByColumnIds(
    columnIds: number[],
    queryOptions?: IQueryOptions,
  ): Promise<void>;
  findRelationInfoBy(
    filter: {
      projectId?: number;
      columnIds?: number[];
      modelIds?: number[];
    },
    queryOptions?: IQueryOptions,
  ): Promise<RelationInfo[]>;
  findExistedRelationBetweenModels(
    relation: RelationData,
  ): Promise<RelationInfo[]>;
}

export class RelationRepository
  extends BaseRepository<Relation>
  implements IRelationRepository
{
  constructor(knexPg: Knex) {
    super({ knexPg, tableName: 'relation' });
  }

  public async findRelationsBy(
    { columnIds, modelIds },
    queryOptions?: IQueryOptions,
  ) {
    let executer = this.knex;
    if (queryOptions && queryOptions.tx) {
      const { tx } = queryOptions;
      executer = tx;
    }
    // select the leftModel name and rightModel name along with relation
    const builder = executer(this.tableName)
      .join(
        'model_column AS fmc',
        `${this.tableName}.from_column_id`,
        '=',
        'fmc.id',
      )
      .join(
        'model_column AS tmc',
        `${this.tableName}.to_column_id`,
        '=',
        'tmc.id',
      );
    if (columnIds && columnIds.length > 0) {
      builder
        .whereIn(`${this.tableName}.from_column_id`, columnIds)
        .orWhereIn(`${this.tableName}.to_column_id`, columnIds);
    }
    if (modelIds && modelIds.length > 0) {
      builder
        .whereIn('fmc.model_id', modelIds)
        .orWhereIn('tmc.model_id', modelIds);
    }

    const result = await builder.select(
      `${this.tableName}.*`,
      'fmc.model_id AS fromModelId',
      'tmc.model_id AS toModelId',
    );
    return result.map((r) => this.transformFromDBData(r));
  }

  public async findRelationsByIds(ids: number[], queryOptions?: IQueryOptions) {
    let executer = this.knex;
    if (queryOptions && queryOptions.tx) {
      const { tx } = queryOptions;
      executer = tx;
    }

    const result = await executer(this.tableName)
      .whereIn('id', ids)
      .select('*');
    return result.map((r) => this.transformFromDBData(r));
  }

  public async deleteRelationsByColumnIds(
    columnIds: number[],
    queryOptions?: IQueryOptions,
  ) {
    if (queryOptions && queryOptions.tx) {
      const { tx } = queryOptions;
      await tx(this.tableName)
        .whereIn('from_column_id', columnIds)
        .orWhereIn('to_column_id', columnIds)
        .delete();
      return;
    }
    await this.knex(this.tableName)
      .whereIn('from_column_id', columnIds)
      .orWhereIn('to_column_id', columnIds)
      .delete();
  }

  public async findRelationInfoBy(filter, queryOptions) {
    const { projectId, columnIds, modelIds } = filter;
    let executer = this.knex;
    if (queryOptions && queryOptions.tx) {
      const { tx } = queryOptions;
      executer = tx;
    }
    // select the leftModel name and rightModel name along with relation
    const builder = executer(this.tableName)
      .join(
        'model_column AS fmc',
        `${this.tableName}.from_column_id`,
        '=',
        'fmc.id',
      )
      .join(
        'model_column AS tmc',
        `${this.tableName}.to_column_id`,
        '=',
        'tmc.id',
      )
      .join('model AS fm', 'fmc.model_id', '=', 'fm.id')
      .join('model AS tm', 'tmc.model_id', '=', 'tm.id');

    if (projectId) {
      builder.where(`${this.tableName}.project_id`, projectId);
    } else if (columnIds && columnIds.length > 0) {
      builder
        .whereIn(`${this.tableName}.from_column_id`, columnIds)
        .orWhereIn(`${this.tableName}.to_column_id`, columnIds);
    } else if (modelIds && modelIds.length > 0) {
      builder
        .whereIn('fmc.model_id', modelIds)
        .orWhereIn('tmc.model_id', modelIds);
    }

    const result = await builder.select(
      `${this.tableName}.*`,
      'fm.id AS fromModelId',
      'fm.reference_name AS fromModelName',
      'fm.display_name AS fromModelDisplayName',
      'tm.id AS toModelId',
      'tm.reference_name AS toModelName',
      'tm.display_name AS toModelDisplayName',
      'fmc.reference_name AS fromColumnName',
      'fmc.display_name AS fromColumnDisplayName',
      'tmc.reference_name AS toColumnName',
      'tmc.display_name AS toColumnDisplayName',
    );
    return result.map((r) => this.transformFromDBData(r)) as RelationInfo[];
  }

  public async findExistedRelationBetweenModels(relation: RelationData) {
    const { fromModelId, fromColumnId, toModelId, toColumnId } = relation;
    const query = this.knex(this.tableName)
      .join(
        'model_column AS fmc',
        `${this.tableName}.from_column_id`,
        '=',
        'fmc.id',
      )
      .join(
        'model_column AS tmc',
        `${this.tableName}.to_column_id`,
        '=',
        'tmc.id',
      )
      // duplicate relationship check
      .whereRaw(
        `fmc.model_id = ? And ${this.tableName}.from_column_id = ? And tmc.model_id = ? And ${this.tableName}.to_column_id = ?`,
        [fromModelId, fromColumnId, toModelId, toColumnId],
      )
      // reverse relationship check
      .orWhereRaw(
        `fmc.model_id = ? And ${this.tableName}.from_column_id = ? And tmc.model_id = ? And ${this.tableName}.to_column_id = ?`,
        [toModelId, toColumnId, fromModelId, fromColumnId],
      )
      .select(`${this.tableName}.*`);
    const result = await query;
    return result.map((r) => this.transformFromDBData(r)) as RelationInfo[];
  }
}
</file>

<file path="src/apollo/server/repositories/schemaChangeRepository.ts">
import { Knex } from 'knex';
import { BaseRepository, IBasicRepository } from './baseRepository';
import {
  camelCase,
  isPlainObject,
  mapKeys,
  mapValues,
  snakeCase,
} from 'lodash';
import {
  DataSourceSchemaChange,
  DataSourceSchemaResolve,
} from '@server/managers/dataSourceSchemaDetector';

export interface SchemaChange {
  id: number; // ID
  projectId: number; // Reference to project.id
  change: DataSourceSchemaChange; // Schema change
  resolve: DataSourceSchemaResolve; // Save resolve
  createdAt: string; // Created at
  updateAt: string; // Updated at
}

export interface ISchemaChangeRepository
  extends IBasicRepository<SchemaChange> {
  findLastSchemaChange(projectId: number): Promise<SchemaChange | null>;
}

export class SchemaChangeRepository
  extends BaseRepository<SchemaChange>
  implements ISchemaChangeRepository
{
  constructor(knexPg: Knex) {
    super({ knexPg, tableName: 'schema_change' });
  }

  public async findLastSchemaChange(projectId: number) {
    const res = await this.knex
      .select('*')
      .from(this.tableName)
      .where(this.transformToDBData({ projectId }))
      .orderBy('created_at', 'desc')
      .first();
    return (res && this.transformFromDBData(res)) || null;
  }

  protected override transformToDBData = (data: any) => {
    if (!isPlainObject(data)) {
      throw new Error('Unexpected dbdata');
    }
    const transformedData = mapValues(data, (value, key) => {
      if (['change', 'resolve'].includes(key)) {
        return value ? JSON.stringify(value) : null;
      }
      return value;
    });
    return mapKeys(transformedData, (_value, key) => snakeCase(key));
  };

  protected override transformFromDBData = (data: any): SchemaChange => {
    if (!isPlainObject(data)) {
      throw new Error('Unexpected dbdata');
    }
    const camelCaseData = mapKeys(data, (_value, key) => camelCase(key));
    const formattedData = mapValues(camelCaseData, (value, key) => {
      if (['change', 'resolve'].includes(key)) {
        // The value from Sqlite will be string type, while the value from PG is JSON object
        if (typeof value === 'string') {
          return value ? JSON.parse(value) : value;
        } else {
          return value;
        }
      }
      return value;
    }) as SchemaChange;
    return formattedData;
  };
}
</file>

<file path="src/apollo/server/repositories/sqlPairRepository.ts">
import { Knex } from 'knex';
import { BaseRepository, IBasicRepository } from './baseRepository';

export interface SqlPair {
  id: number; // ID
  projectId: number; // Reference to project.id
  sql: string; // SQL query
  question: string; // Natural language question
  createdAt?: string; // Date and time when the SQL pair was created
  updatedAt?: string; // Date and time when the SQL pair was last updated
}

export interface ISqlPairRepository extends IBasicRepository<SqlPair> {}

export class SqlPairRepository
  extends BaseRepository<SqlPair>
  implements ISqlPairRepository
{
  constructor(knexPg: Knex) {
    super({ knexPg, tableName: 'sql_pair' });
  }
}
</file>

<file path="src/apollo/server/repositories/threadRepository.ts">
import { Knex } from 'knex';
import { BaseRepository, IBasicRepository } from './baseRepository';
import {
  camelCase,
  isPlainObject,
  mapKeys,
  mapValues,
  snakeCase,
} from 'lodash';

export interface ThreadRecommendationQuestionResult {
  question: string;
  category: string;
  sql: string;
}

export interface Thread {
  id: number; // ID
  projectId: number; // Reference to project.id
  summary: string; // Thread summary

  // recommend question
  queryId?: string; // Query ID
  questions?: ThreadRecommendationQuestionResult[]; // Recommended questions
  questionsStatus?: string; // Status of the recommended questions
  questionsError?: object; // Error of the recommended questions
}

export interface IThreadRepository extends IBasicRepository<Thread> {
  listAllTimeDescOrder(projectId: number): Promise<Thread[]>;
}

export class ThreadRepository
  extends BaseRepository<Thread>
  implements IThreadRepository
{
  private readonly jsonbColumns = ['questions', 'questionsError'];

  constructor(knexPg: Knex) {
    super({ knexPg, tableName: 'thread' });
  }

  public async listAllTimeDescOrder(projectId: number): Promise<Thread[]> {
    const threads = await this.knex(this.tableName)
      .where(this.transformToDBData({ projectId }))
      .orderBy('created_at', 'desc');
    return threads.map((thread) => this.transformFromDBData(thread));
  }

  protected override transformFromDBData = (data: any): Thread => {
    if (!isPlainObject(data)) {
      throw new Error('Unexpected dbdata');
    }
    const camelCaseData = mapKeys(data, (_value, key) => camelCase(key));
    const transformData = mapValues(camelCaseData, (value, key) => {
      if (this.jsonbColumns.includes(key)) {
        if (typeof value === 'string') {
          return value ? JSON.parse(value) : value;
        } else {
          return value;
        }
      }
      return value;
    });
    return transformData as Thread;
  };

  protected override transformToDBData = (data: any) => {
    if (!isPlainObject(data)) {
      throw new Error('Unexpected dbdata');
    }
    const transformedData = mapValues(data, (value, key) => {
      if (this.jsonbColumns.includes(key)) {
        return JSON.stringify(value);
      } else {
        return value;
      }
    });
    return mapKeys(transformedData, (_value, key) => snakeCase(key));
  };
}
</file>

<file path="src/apollo/server/repositories/threadResponseRepository.ts">
import { Knex } from 'knex';
import {
  BaseRepository,
  IBasicRepository,
  IQueryOptions,
} from './baseRepository';
import { camelCase, isPlainObject, mapKeys, mapValues } from 'lodash';
import { AskResultStatus } from '@server/models/adaptor';

export interface DetailStep {
  summary: string;
  sql: string;
  cteName: string;
}

export interface ThreadResponseBreakdownDetail {
  queryId: string;
  status: string;
  error?: object;
  description?: string;
  steps?: Array<DetailStep>;
}

export interface ThreadResponseAnswerDetail {
  queryId?: string;
  status: string;
  error?: object;
  numRowsUsedInLLM?: number;
  content?: string;
}

export interface ThreadResponseChartDetail {
  queryId?: string;
  status: string;
  error?: object;
  description?: string;
  chartType?: string;
  chartSchema?: Record<string, any>;
  adjustment?: boolean;
}

export enum ThreadResponseAdjustmentType {
  REASONING = 'REASONING',
  APPLY_SQL = 'APPLY_SQL',
}

export type ThreadResponseAdjustmentReasoningPayload = {
  originalThreadResponseId?: number;
  retrievedTables?: string[];
  sqlGenerationReasoning?: string;
};

export type ThreadResponseAdjustmentApplySqlPayload = {
  originalThreadResponseId?: number;
  sql?: string;
};

export interface ThreadResponseAdjustment {
  type: ThreadResponseAdjustmentType;
  // todo: I think we could use a better way to do this instead of using a union type
  payload: ThreadResponseAdjustmentReasoningPayload &
    ThreadResponseAdjustmentApplySqlPayload;
}

export interface ThreadResponse {
  id: number; // ID
  askingTaskId?: number; // Reference to asking_task.id
  viewId?: number; // View ID, if the response is from a view
  threadId: number; // Reference to thread.id
  question: string; // Thread response question
  sql?: string; // SQL query generated by AI service
  answerDetail?: ThreadResponseAnswerDetail; // AI generated text-based answer detail
  breakdownDetail?: ThreadResponseBreakdownDetail; // Thread response breakdown detail
  chartDetail?: ThreadResponseChartDetail; // Thread response chart detail
  adjustment?: ThreadResponseAdjustment; // Thread response adjustment
}

export interface IThreadResponseRepository
  extends IBasicRepository<ThreadResponse> {
  getResponsesWithThread(
    threadId: number,
    limit?: number,
  ): Promise<ThreadResponse[]>;
}

export class ThreadResponseRepository
  extends BaseRepository<ThreadResponse>
  implements IThreadResponseRepository
{
  private readonly jsonbColumns = [
    'answerDetail',
    'breakdownDetail',
    'chartDetail',
    'adjustment',
  ];

  constructor(knexPg: Knex) {
    super({ knexPg, tableName: 'thread_response' });
  }

  public async getResponsesWithThread(threadId: number, limit?: number) {
    const query = this.knex(this.tableName)
      .select('thread_response.*')
      .where({ thread_id: threadId })
      .leftJoin('thread', 'thread.id', 'thread_response.thread_id');

    if (limit) {
      query.orderBy('created_at', 'desc').limit(limit);
    }

    return (await query)
      .map((res) => {
        // turn object keys into camelCase
        return mapKeys(res, (_, key) => camelCase(key));
      })
      .map((res) => {
        // JSON.parse detail and error
        const answerDetail =
          res.answerDetail && typeof res.answerDetail === 'string'
            ? JSON.parse(res.answerDetail)
            : res.answerDetail;
        const breakdownDetail =
          res.breakdownDetail && typeof res.breakdownDetail === 'string'
            ? JSON.parse(res.breakdownDetail)
            : res.breakdownDetail;
        const chartDetail =
          res.chartDetail && typeof res.chartDetail === 'string'
            ? JSON.parse(res.chartDetail)
            : res.chartDetail;
        const adjustment =
          res.adjustment && typeof res.adjustment === 'string'
            ? JSON.parse(res.adjustment)
            : res.adjustment;
        return {
          ...res,
          answerDetail: answerDetail || null,
          breakdownDetail: breakdownDetail || null,
          chartDetail: chartDetail || null,
          adjustment: adjustment || null,
        };
      }) as ThreadResponse[];
  }

  public async updateOne(
    id: string | number,
    data: Partial<{
      status: AskResultStatus;
      sql: string;
      viewId: number;
      answerDetail: ThreadResponseAnswerDetail;
      breakdownDetail: ThreadResponseBreakdownDetail;
      chartDetail: ThreadResponseChartDetail;
      adjustment: ThreadResponseAdjustment;
    }>,
    queryOptions?: IQueryOptions,
  ) {
    const transformedData = {
      status: data.status ? data.status : undefined,
      sql: data.sql ? data.sql : undefined,
      viewId: data.viewId ? data.viewId : undefined,
      answerDetail: data.answerDetail
        ? JSON.stringify(data.answerDetail)
        : undefined,
      breakdownDetail: data.breakdownDetail
        ? JSON.stringify(data.breakdownDetail)
        : undefined,
      chartDetail: data.chartDetail
        ? JSON.stringify(data.chartDetail)
        : undefined,
      adjustment: data.adjustment ? JSON.stringify(data.adjustment) : undefined,
    };
    const executer = queryOptions?.tx ? queryOptions.tx : this.knex;
    const [result] = await executer(this.tableName)
      .where({ id })
      .update(this.transformToDBData(transformedData as any))
      .returning('*');
    return this.transformFromDBData(result);
  }

  protected override transformFromDBData = (data: any): ThreadResponse => {
    if (!isPlainObject(data)) {
      throw new Error('Unexpected dbdata');
    }
    const camelCaseData = mapKeys(data, (_value, key) => camelCase(key));
    const formattedData = mapValues(camelCaseData, (value, key) => {
      if (this.jsonbColumns.includes(key)) {
        // The value from Sqlite will be string type, while the value from PG is JSON object
        if (typeof value === 'string') {
          return value ? JSON.parse(value) : value;
        } else {
          return value;
        }
      }
      return value;
    }) as ThreadResponse;
    return formattedData;
  };
}
</file>

<file path="src/apollo/server/repositories/viewRepository.ts">
import { Knex } from 'knex';
import { BaseRepository, IBasicRepository } from './baseRepository';

export interface View {
  id: number; // ID
  projectId: number; // Reference to project.id
  name: string; // The view name
  statement: string; // The SQL statement of this view
  cached: boolean; // View is cached or not
  refreshTime?: string; // Contain a number followed by a time unit (ns, us, ms, s, m, h, d). For example, "2h"
  properties?: string; // View properties, a json string, the description and displayName should be stored here
}

export interface IViewRepository extends IBasicRepository<View> {}

export class ViewRepository
  extends BaseRepository<View>
  implements IViewRepository
{
  constructor(knexPg: Knex) {
    super({ knexPg, tableName: 'view' });
  }
}
</file>

<file path="src/apollo/server/resolvers.ts">
import GraphQLJSON from 'graphql-type-json';
import { ProjectResolver } from './resolvers/projectResolver';
import { ModelResolver } from './resolvers/modelResolver';
import { AskingResolver } from './resolvers/askingResolver';
import { DiagramResolver } from './resolvers/diagramResolver';
import { LearningResolver } from './resolvers/learningResolver';
import { DashboardResolver } from './resolvers/dashboardResolver';
import { SqlPairResolver } from './resolvers/sqlPairResolver';
import { InstructionResolver } from './resolvers/instructionResolver';
import { ApiHistoryResolver } from './resolvers/apiHistoryResolver';
import { convertColumnType } from '@server/utils';
import { DialectSQLScalar } from './scalars';

const projectResolver = new ProjectResolver();
const modelResolver = new ModelResolver();
const askingResolver = new AskingResolver();
const diagramResolver = new DiagramResolver();
const learningResolver = new LearningResolver();
const dashboardResolver = new DashboardResolver();
const sqlPairResolver = new SqlPairResolver();
const instructionResolver = new InstructionResolver();
const apiHistoryResolver = new ApiHistoryResolver();
const resolvers = {
  JSON: GraphQLJSON,
  DialectSQL: DialectSQLScalar,
  Query: {
    listDataSourceTables: projectResolver.listDataSourceTables,
    autoGenerateRelation: projectResolver.autoGenerateRelation,
    listModels: modelResolver.listModels,
    model: modelResolver.getModel,
    onboardingStatus: projectResolver.getOnboardingStatus,
    modelSync: modelResolver.checkModelSync,
    diagram: diagramResolver.getDiagram,
    schemaChange: projectResolver.getSchemaChange,

    // Ask
    askingTask: askingResolver.getAskingTask,
    suggestedQuestions: askingResolver.getSuggestedQuestions,
    instantRecommendedQuestions: askingResolver.getInstantRecommendedQuestions,

    // Adjustment
    adjustmentTask: askingResolver.getAdjustmentTask,

    // Thread
    thread: askingResolver.getThread,
    threads: askingResolver.listThreads,
    threadResponse: askingResolver.getResponse,
    nativeSql: modelResolver.getNativeSql,

    // Views
    listViews: modelResolver.listViews,
    view: modelResolver.getView,

    // Settings
    settings: projectResolver.getSettings,
    getMDL: modelResolver.getMDL,

    // Learning
    learningRecord: learningResolver.getLearningRecord,

    // Recommendation questions
    getThreadRecommendationQuestions:
      askingResolver.getThreadRecommendationQuestions,
    getProjectRecommendationQuestions:
      projectResolver.getProjectRecommendationQuestions,

    // Dashboard
    dashboardItems: dashboardResolver.getDashboardItems,
    dashboard: dashboardResolver.getDashboard,

    // SQL Pairs
    sqlPairs: sqlPairResolver.getProjectSqlPairs,
    // Instructions
    instructions: instructionResolver.getInstructions,

    // API History
    apiHistory: apiHistoryResolver.getApiHistory,
  },
  Mutation: {
    deploy: modelResolver.deploy,
    saveDataSource: projectResolver.saveDataSource,
    startSampleDataset: projectResolver.startSampleDataset,
    saveTables: projectResolver.saveTables,
    saveRelations: projectResolver.saveRelations,
    createModel: modelResolver.createModel,
    updateModel: modelResolver.updateModel,
    deleteModel: modelResolver.deleteModel,
    previewModelData: modelResolver.previewModelData,
    updateModelMetadata: modelResolver.updateModelMetadata,
    triggerDataSourceDetection: projectResolver.triggerDataSourceDetection,
    resolveSchemaChange: projectResolver.resolveSchemaChange,

    // calculated field
    createCalculatedField: modelResolver.createCalculatedField,
    validateCalculatedField: modelResolver.validateCalculatedField,
    updateCalculatedField: modelResolver.updateCalculatedField,
    deleteCalculatedField: modelResolver.deleteCalculatedField,

    // relation
    createRelation: modelResolver.createRelation,
    updateRelation: modelResolver.updateRelation,
    deleteRelation: modelResolver.deleteRelation,

    // Ask
    createAskingTask: askingResolver.createAskingTask,
    cancelAskingTask: askingResolver.cancelAskingTask,
    createInstantRecommendedQuestions:
      askingResolver.createInstantRecommendedQuestions,
    rerunAskingTask: askingResolver.rerunAskingTask,

    // Adjustment
    adjustThreadResponse: askingResolver.adjustThreadResponse,
    cancelAdjustmentTask: askingResolver.cancelAdjustThreadResponseAnswer,
    rerunAdjustmentTask: askingResolver.rerunAdjustThreadResponseAnswer,

    // Thread
    createThread: askingResolver.createThread,
    updateThread: askingResolver.updateThread,
    deleteThread: askingResolver.deleteThread,
    createThreadResponse: askingResolver.createThreadResponse,
    updateThreadResponse: askingResolver.updateThreadResponse,
    previewData: askingResolver.previewData,
    previewBreakdownData: askingResolver.previewBreakdownData,

    // Generate Thread Response Breakdown
    generateThreadResponseBreakdown:
      askingResolver.generateThreadResponseBreakdown,

    // Generate Thread Response Answer
    generateThreadResponseAnswer: askingResolver.generateThreadResponseAnswer,

    // Generate Thread Response Chart
    generateThreadResponseChart: askingResolver.generateThreadResponseChart,

    // Adjust Thread Response Chart
    adjustThreadResponseChart: askingResolver.adjustThreadResponseChart,

    // Views
    createView: modelResolver.createView,
    deleteView: modelResolver.deleteView,
    previewViewData: modelResolver.previewViewData,
    validateView: modelResolver.validateView,
    updateViewMetadata: modelResolver.updateViewMetadata,

    // Settings
    resetCurrentProject: projectResolver.resetCurrentProject,
    updateCurrentProject: projectResolver.updateCurrentProject,
    updateDataSource: projectResolver.updateDataSource,

    // preview
    previewSql: modelResolver.previewSql,

    // Learning
    saveLearningRecord: learningResolver.saveLearningRecord,

    // Recommendation questions
    generateThreadRecommendationQuestions:
      askingResolver.generateThreadRecommendationQuestions,
    generateProjectRecommendationQuestions:
      askingResolver.generateProjectRecommendationQuestions,

    // Dashboard
    updateDashboardItemLayouts: dashboardResolver.updateDashboardItemLayouts,
    createDashboardItem: dashboardResolver.createDashboardItem,
    updateDashboardItem: dashboardResolver.updateDashboardItem,
    deleteDashboardItem: dashboardResolver.deleteDashboardItem,
    previewItemSQL: dashboardResolver.previewItemSQL,
    setDashboardSchedule: dashboardResolver.setDashboardSchedule,

    // SQL Pairs
    createSqlPair: sqlPairResolver.createSqlPair,
    updateSqlPair: sqlPairResolver.updateSqlPair,
    deleteSqlPair: sqlPairResolver.deleteSqlPair,
    generateQuestion: sqlPairResolver.generateQuestion,
    modelSubstitute: sqlPairResolver.modelSubstitute,
    // Instructions
    createInstruction: instructionResolver.createInstruction,
    updateInstruction: instructionResolver.updateInstruction,
    deleteInstruction: instructionResolver.deleteInstruction,
  },
  ThreadResponse: askingResolver.getThreadResponseNestedResolver(),
  DetailStep: askingResolver.getDetailStepNestedResolver(),
  ResultCandidate: askingResolver.getResultCandidateNestedResolver(),

  // Handle struct type to record for UI
  DiagramModelField: { type: convertColumnType },
  DiagramModelNestedField: { type: convertColumnType },
  CompactColumn: { type: convertColumnType },
  FieldInfo: { type: convertColumnType },
  DetailedColumn: { type: convertColumnType },
  DetailedNestedColumn: { type: convertColumnType },
  DetailedChangeColumn: { type: convertColumnType },

  // Add this line to include the SqlPair nested resolver
  SqlPair: sqlPairResolver.getSqlPairNestedResolver(),

  // Add ApiHistoryResponse nested resolvers
  ApiHistoryResponse: apiHistoryResolver.getApiHistoryNestedResolver(),
};

export default resolvers;
</file>

<file path="src/apollo/server/resolvers/apiHistoryResolver.ts">
import { ApiType, ApiHistory } from '@server/repositories/apiHistoryRepository';
import { IContext } from '@server/types';

export interface ApiHistoryFilter {
  apiType?: ApiType;
  statusCode?: number;
  threadId?: string;
  projectId?: number;
  startDate?: string;
  endDate?: string;
}

export interface ApiHistoryPagination {
  offset: number;
  limit: number;
}

/**
 * Sanitize response payload to remove large data fields
 * This prevents excessive data transfer when displaying API history
 * @param payload The response payload to sanitize
 * @param apiType The type of API that generated this response
 */
const sanitizeResponsePayload = (payload: any, apiType?: ApiType): any => {
  if (!payload) return payload;

  const sanitized = { ...payload };

  // Handle specifically RUN_SQL responses that contain large record sets
  if (apiType === ApiType.RUN_SQL) {
    // Remove records array but keep metadata about how many records were returned
    if (sanitized.records && Array.isArray(sanitized.records)) {
      const recordCount = sanitized.records.length;
      sanitized.records = [`${recordCount} records omitted`];
    }
  }

  // Handle specifically GENERATE_VEGA_CHART responses that contain large data values
  if (apiType === ApiType.GENERATE_VEGA_CHART) {
    // Remove vegaSpec.data.values array but keep the structure
    if (
      sanitized.vegaSpec?.data?.values &&
      Array.isArray(sanitized.vegaSpec.data.values)
    ) {
      const dataCount = sanitized.vegaSpec.data.values.length;
      sanitized.vegaSpec.data.values = [`${dataCount} data points omitted`];
    }
  }

  return sanitized;
};

export class ApiHistoryResolver {
  constructor() {
    this.getApiHistory = this.getApiHistory.bind(this);
  }

  /**
   * Get API history with filtering and pagination
   */
  public async getApiHistory(
    _root: unknown,
    args: {
      filter?: ApiHistoryFilter;
      pagination: ApiHistoryPagination;
    },
    ctx: IContext,
  ) {
    const { filter, pagination } = args;
    const { offset, limit } = pagination;

    // Build filter criteria
    const filterCriteria: Partial<ApiHistory> = {};

    if (filter) {
      if (filter.apiType) {
        filterCriteria.apiType = filter.apiType;
      }

      if (filter.statusCode) {
        filterCriteria.statusCode = filter.statusCode;
      }

      if (filter.threadId) {
        filterCriteria.threadId = filter.threadId;
      }

      if (filter.projectId) {
        filterCriteria.projectId = filter.projectId;
      }
    }

    // Handle date filtering
    const dateFilter: { startDate?: Date; endDate?: Date } = {};
    if (filter?.startDate) {
      dateFilter.startDate = new Date(filter.startDate);
    }
    if (filter?.endDate) {
      dateFilter.endDate = new Date(filter.endDate);
    }

    // Get total count for pagination info
    const total = await ctx.apiHistoryRepository.count(
      filterCriteria,
      dateFilter,
    );

    if (total === 0 || total <= offset) {
      return {
        items: [],
        total,
        hasMore: false,
      };
    }

    // Get paginated items
    const items = await ctx.apiHistoryRepository.findAllWithPagination(
      filterCriteria,
      dateFilter,
      {
        offset,
        limit,
        orderBy: { createdAt: 'desc' },
      },
    );

    return {
      items,
      total,
      hasMore: offset + limit < total,
    };
  }

  /**
   * Resolver for ApiHistoryResponse fields
   */
  public getApiHistoryNestedResolver = () => ({
    createdAt: (apiHistory: ApiHistory) => {
      return apiHistory.createdAt
        ? new Date(apiHistory.createdAt).toISOString()
        : null;
    },
    updatedAt: (apiHistory: ApiHistory) => {
      return apiHistory.updatedAt
        ? new Date(apiHistory.updatedAt).toISOString()
        : null;
    },
    responsePayload: (apiHistory: ApiHistory) => {
      if (!apiHistory.responsePayload) return null;
      return sanitizeResponsePayload(
        apiHistory.responsePayload,
        apiHistory.apiType,
      );
    },
  });
}
</file>

<file path="src/apollo/server/resolvers/askingResolver.ts">
import {
  WrenAIError,
  WrenAILanguage,
  AskResultStatus,
  AskResultType,
  RecommendationQuestionStatus,
  ChartAdjustmentOption,
  AskFeedbackStatus,
} from '@server/models/adaptor';
import { Thread } from '../repositories/threadRepository';
import {
  DetailStep,
  ThreadResponse,
} from '../repositories/threadResponseRepository';
import { reduce } from 'lodash';
import { IContext } from '../types';
import { getLogger } from '@server/utils';
import { format } from 'sql-formatter';
import {
  AskingDetailTaskInput,
  constructCteSql,
  ThreadRecommendQuestionResult,
} from '../services/askingService';
import {
  SuggestedQuestion,
  SampleDatasetName,
  getSampleAskQuestions,
} from '../data';
import { TelemetryEvent, WrenService } from '../telemetry/telemetry';
import { TrackedAskingResult } from '../services';

const logger = getLogger('AskingResolver');
logger.level = 'debug';

export interface SuggestedQuestionResponse {
  questions: SuggestedQuestion[];
}

export interface Task {
  id: string;
}

export interface AdjustmentTask {
  queryId: string;
  status: AskFeedbackStatus;
  error: WrenAIError | null;
  sql: string;
  traceId: string;
  invalidSql?: string;
}

export interface AskingTask {
  type: AskResultType | null;
  status: AskResultStatus;
  candidates: Array<{
    sql: string;
  }>;
  error: WrenAIError | null;
  rephrasedQuestion?: string;
  intentReasoning?: string;
  sqlGenerationReasoning?: string;
  retrievedTables?: string[];
  invalidSql?: string;
  traceId?: string;
  queryId?: string;
}

// DetailedThread is a type that represents a detailed thread, which is a thread with responses.
export interface DetailedThread {
  id: number; // ID
  sql: string; // SQL
  responses: ThreadResponse[];
}

export interface RecommendedQuestionsTask {
  questions: {
    question: string;
    category: string;
    sql: string;
  }[];
  status: RecommendationQuestionStatus;
  error: WrenAIError | null;
}

export class AskingResolver {
  constructor() {
    this.createAskingTask = this.createAskingTask.bind(this);
    this.cancelAskingTask = this.cancelAskingTask.bind(this);
    this.rerunAskingTask = this.rerunAskingTask.bind(this);
    this.getAskingTask = this.getAskingTask.bind(this);
    this.createThread = this.createThread.bind(this);
    this.getThread = this.getThread.bind(this);
    this.updateThread = this.updateThread.bind(this);
    this.deleteThread = this.deleteThread.bind(this);
    this.listThreads = this.listThreads.bind(this);
    this.createThreadResponse = this.createThreadResponse.bind(this);
    this.updateThreadResponse = this.updateThreadResponse.bind(this);
    this.getResponse = this.getResponse.bind(this);
    this.previewData = this.previewData.bind(this);
    this.previewBreakdownData = this.previewBreakdownData.bind(this);
    this.getSuggestedQuestions = this.getSuggestedQuestions.bind(this);
    this.createInstantRecommendedQuestions =
      this.createInstantRecommendedQuestions.bind(this);
    this.getInstantRecommendedQuestions =
      this.getInstantRecommendedQuestions.bind(this);
    this.generateThreadRecommendationQuestions =
      this.generateThreadRecommendationQuestions.bind(this);
    this.generateProjectRecommendationQuestions =
      this.generateProjectRecommendationQuestions.bind(this);

    this.getThreadRecommendationQuestions =
      this.getThreadRecommendationQuestions.bind(this);
    this.generateThreadResponseBreakdown =
      this.generateThreadResponseBreakdown.bind(this);
    this.generateThreadResponseAnswer =
      this.generateThreadResponseAnswer.bind(this);
    this.generateThreadResponseChart =
      this.generateThreadResponseChart.bind(this);
    this.adjustThreadResponseChart = this.adjustThreadResponseChart.bind(this);
    this.transformAskingTask = this.transformAskingTask.bind(this);

    this.adjustThreadResponse = this.adjustThreadResponse.bind(this);
    this.cancelAdjustThreadResponseAnswer =
      this.cancelAdjustThreadResponseAnswer.bind(this);
    this.rerunAdjustThreadResponseAnswer =
      this.rerunAdjustThreadResponseAnswer.bind(this);
    this.getAdjustmentTask = this.getAdjustmentTask.bind(this);
  }

  public async generateProjectRecommendationQuestions(
    _root: any,
    _args: any,
    ctx: IContext,
  ): Promise<boolean> {
    await ctx.projectService.generateProjectRecommendationQuestions();
    return true;
  }

  public async generateThreadRecommendationQuestions(
    _root: any,
    args: { threadId: number },
    ctx: IContext,
  ): Promise<boolean> {
    const { threadId } = args;
    const askingService = ctx.askingService;
    await askingService.generateThreadRecommendationQuestions(threadId);
    return true;
  }

  public async getThreadRecommendationQuestions(
    _root: any,
    args: { threadId: number },
    ctx: IContext,
  ): Promise<ThreadRecommendQuestionResult> {
    const { threadId } = args;
    const askingService = ctx.askingService;
    return askingService.getThreadRecommendationQuestions(threadId);
  }

  public async getSuggestedQuestions(
    _root: any,
    _args: any,
    ctx: IContext,
  ): Promise<SuggestedQuestionResponse> {
    const project = await ctx.projectService.getCurrentProject();
    const { sampleDataset } = project;
    if (!sampleDataset) {
      return { questions: [] };
    }
    const questions = getSampleAskQuestions(sampleDataset as SampleDatasetName);
    return { questions };
  }

  public async createAskingTask(
    _root: any,
    args: { data: { question: string; threadId?: number } },
    ctx: IContext,
  ): Promise<Task> {
    const { question, threadId } = args.data;
    const project = await ctx.projectService.getCurrentProject();

    const askingService = ctx.askingService;
    const data = { question };
    const task = await askingService.createAskingTask(data, {
      threadId,
      language: WrenAILanguage[project.language] || WrenAILanguage.EN,
    });
    ctx.telemetry.sendEvent(TelemetryEvent.HOME_ASK_CANDIDATE, {
      question,
      taskId: task.id,
    });
    return task;
  }

  public async cancelAskingTask(
    _root: any,
    args: { taskId: string },
    ctx: IContext,
  ): Promise<boolean> {
    const { taskId } = args;
    const askingService = ctx.askingService;
    await askingService.cancelAskingTask(taskId);
    return true;
  }

  public async getAskingTask(
    _root: any,
    args: { taskId: string },
    ctx: IContext,
  ): Promise<AskingTask> {
    const { taskId } = args;
    const askingService = ctx.askingService;
    const askResult = await askingService.getAskingTask(taskId);

    if (!askResult) {
      return null;
    }

    // telemetry
    const eventName = TelemetryEvent.HOME_ASK_CANDIDATE;
    if (askResult.status === AskResultStatus.FINISHED) {
      ctx.telemetry.sendEvent(eventName, {
        taskId,
        status: askResult.status,
        candidates: askResult.response,
      });
    }
    if (askResult.status === AskResultStatus.FAILED) {
      ctx.telemetry.sendEvent(
        eventName,
        {
          taskId,
          status: askResult.status,
          error: askResult.error,
        },
        WrenService.AI,
        false,
      );
    }

    return this.transformAskingTask(askResult, ctx);
  }

  public async createThread(
    _root: any,
    args: {
      data: {
        question?: string;
        taskId?: string;
        // if we use recommendation questions, sql will be provided
        sql?: string;
      };
    },
    ctx: IContext,
  ): Promise<Thread> {
    const { data } = args;

    const askingService = ctx.askingService;

    // if taskId is provided, use the result from the asking task
    // otherwise, use the input data
    let threadInput: AskingDetailTaskInput;
    if (data.taskId) {
      const askingTask = await askingService.getAskingTask(data.taskId);
      if (!askingTask) {
        throw new Error(`Asking task ${data.taskId} not found`);
      }

      threadInput = {
        question: askingTask.question,
        trackedAskingResult: askingTask,
      };
    } else {
      // when we use recommendation questions, there's no task to track
      threadInput = data;
    }

    const eventName = TelemetryEvent.HOME_CREATE_THREAD;
    try {
      const thread = await askingService.createThread(threadInput);
      ctx.telemetry.sendEvent(eventName, {});
      return thread;
    } catch (err: any) {
      ctx.telemetry.sendEvent(
        eventName,
        { error: err.message },
        err.extensions?.service,
        false,
      );
      throw err;
    }
    // telemetry
  }

  public async getThread(
    _root: any,
    args: { threadId: number },
    ctx: IContext,
  ): Promise<DetailedThread> {
    const { threadId } = args;

    const askingService = ctx.askingService;
    const responses = await askingService.getResponsesWithThread(threadId);
    // reduce responses to group by thread id
    const thread = reduce(
      responses,
      (acc, response) => {
        if (!acc.id) {
          acc.id = response.threadId;
          acc.sql = response.sql;
          acc.responses = [];
        }

        acc.responses.push({
          id: response.id,
          viewId: response.viewId,
          threadId: response.threadId,
          question: response.question,
          sql: response.sql,
          askingTaskId: response.askingTaskId,
          breakdownDetail: response.breakdownDetail,
          answerDetail: response.answerDetail,
          chartDetail: response.chartDetail,
          adjustment: response.adjustment,
        });

        return acc;
      },
      {} as any,
    );

    return thread;
  }

  public async updateThread(
    _root: any,
    args: { where: { id: number }; data: { summary: string } },
    ctx: IContext,
  ): Promise<Thread> {
    const { where, data } = args;

    const askingService = ctx.askingService;
    const eventName = TelemetryEvent.HOME_UPDATE_THREAD_SUMMARY;
    const newSummary = data.summary;
    try {
      const thread = await askingService.updateThread(where.id, data);
      // telemetry
      ctx.telemetry.sendEvent(eventName, {
        new_summary: newSummary,
      });
      return thread;
    } catch (err: any) {
      ctx.telemetry.sendEvent(
        eventName,
        {
          new_summary: newSummary,
        },
        err.extensions?.service,
        false,
      );
      throw err;
    }
  }

  public async deleteThread(
    _root: any,
    args: { where: { id: number } },
    ctx: IContext,
  ): Promise<boolean> {
    const { where } = args;

    const askingService = ctx.askingService;
    await askingService.deleteThread(where.id);
    return true;
  }

  public async listThreads(
    _root: any,
    _args: any,
    ctx: IContext,
  ): Promise<Thread[]> {
    const threads = await ctx.askingService.listThreads();
    return threads;
  }

  public async createThreadResponse(
    _root: any,
    args: {
      threadId: number;
      data: {
        question?: string;
        taskId?: string;
        // if we use recommendation questions, sql will be provided
        sql?: string;
      };
    },
    ctx: IContext,
  ): Promise<ThreadResponse> {
    const { threadId, data } = args;

    const askingService = ctx.askingService;
    const eventName = TelemetryEvent.HOME_ASK_FOLLOWUP_QUESTION;

    // if taskId is provided, use the result from the asking task
    // otherwise, use the input data
    let threadResponseInput: AskingDetailTaskInput;
    if (data.taskId) {
      const askingTask = await askingService.getAskingTask(data.taskId);
      if (!askingTask) {
        throw new Error(`Asking task ${data.taskId} not found`);
      }

      threadResponseInput = {
        question: askingTask.question,
        trackedAskingResult: askingTask,
      };
    } else {
      // when we use recommendation questions, there's no task to track
      threadResponseInput = data;
    }

    try {
      const response = await askingService.createThreadResponse(
        threadResponseInput,
        threadId,
      );
      ctx.telemetry.sendEvent(eventName, { data });
      return response;
    } catch (err: any) {
      ctx.telemetry.sendEvent(
        eventName,
        { data, error: err.message },
        err.extensions?.service,
        false,
      );
      throw err;
    }
  }

  public async updateThreadResponse(
    _root: any,
    args: { where: { id: number }; data: { sql: string } },
    ctx: IContext,
  ): Promise<ThreadResponse> {
    const { where, data } = args;
    const askingService = ctx.askingService;
    const response = await askingService.updateThreadResponse(where.id, data);
    return response;
  }

  public async rerunAskingTask(
    _root: any,
    args: { responseId: number },
    ctx: IContext,
  ): Promise<Task> {
    const { responseId } = args;
    const askingService = ctx.askingService;
    const project = await ctx.projectService.getCurrentProject();

    const task = await askingService.rerunAskingTask(responseId, {
      language: WrenAILanguage[project.language] || WrenAILanguage.EN,
    });
    ctx.telemetry.sendEvent(TelemetryEvent.HOME_RERUN_ASKING_TASK, {
      responseId,
    });
    return task;
  }

  public async adjustThreadResponse(
    _root: any,
    args: {
      responseId: number;
      data: {
        tables?: string[];
        sqlGenerationReasoning?: string;
        sql?: string;
      };
    },
    ctx: IContext,
  ): Promise<ThreadResponse> {
    const { responseId, data } = args;
    const askingService = ctx.askingService;
    const project = await ctx.projectService.getCurrentProject();

    if (data.sql) {
      const response = await askingService.adjustThreadResponseWithSQL(
        responseId,
        {
          sql: data.sql,
        },
      );
      ctx.telemetry.sendEvent(
        TelemetryEvent.HOME_ADJUST_THREAD_RESPONSE_WITH_SQL,
        {
          sql: data.sql,
          responseId,
        },
      );
      return response;
    }

    return askingService.adjustThreadResponseAnswer(
      responseId,
      {
        projectId: project.id,
        tables: data.tables,
        sqlGenerationReasoning: data.sqlGenerationReasoning,
      },
      {
        language: WrenAILanguage[project.language] || WrenAILanguage.EN,
      },
    );
  }

  public async cancelAdjustThreadResponseAnswer(
    _root: any,
    args: { taskId: string },
    ctx: IContext,
  ): Promise<boolean> {
    const { taskId } = args;
    const askingService = ctx.askingService;
    await askingService.cancelAdjustThreadResponseAnswer(taskId);
    return true;
  }

  public async rerunAdjustThreadResponseAnswer(
    _root: any,
    args: { responseId: number },
    ctx: IContext,
  ): Promise<boolean> {
    const { responseId } = args;
    const askingService = ctx.askingService;
    const project = await ctx.projectService.getCurrentProject();
    await askingService.rerunAdjustThreadResponseAnswer(
      responseId,
      project.id,
      {
        language: WrenAILanguage[project.language] || WrenAILanguage.EN,
      },
    );
    return true;
  }

  public async getAdjustmentTask(
    _root: any,
    args: { taskId: string },
    ctx: IContext,
  ): Promise<AdjustmentTask> {
    const { taskId } = args;
    const askingService = ctx.askingService;
    const adjustmentTask = await askingService.getAdjustmentTask(taskId);
    return {
      queryId: adjustmentTask?.queryId,
      status: adjustmentTask?.status,
      error: adjustmentTask?.error,
      sql: adjustmentTask?.response?.[0]?.sql,
      traceId: adjustmentTask?.traceId,
      invalidSql: adjustmentTask?.invalidSql,
    };
  }

  public async generateThreadResponseBreakdown(
    _root: any,
    args: { responseId: number },
    ctx: IContext,
  ): Promise<ThreadResponse> {
    const project = await ctx.projectService.getCurrentProject();
    const { responseId } = args;
    const askingService = ctx.askingService;
    const breakdownDetail = await askingService.generateThreadResponseBreakdown(
      responseId,
      { language: WrenAILanguage[project.language] || WrenAILanguage.EN },
    );
    return breakdownDetail;
  }

  public async generateThreadResponseAnswer(
    _root: any,
    args: { responseId: number },
    ctx: IContext,
  ): Promise<ThreadResponse> {
    const project = await ctx.projectService.getCurrentProject();
    const { responseId } = args;
    const askingService = ctx.askingService;
    return askingService.generateThreadResponseAnswer(responseId, {
      language: WrenAILanguage[project.language] || WrenAILanguage.EN,
    });
  }

  public async generateThreadResponseChart(
    _root: any,
    args: { responseId: number },
    ctx: IContext,
  ): Promise<ThreadResponse> {
    const project = await ctx.projectService.getCurrentProject();
    const { responseId } = args;
    const askingService = ctx.askingService;
    return askingService.generateThreadResponseChart(responseId, {
      language: WrenAILanguage[project.language] || WrenAILanguage.EN,
    });
  }

  public async adjustThreadResponseChart(
    _root: any,
    args: { responseId: number; data: ChartAdjustmentOption },
    ctx: IContext,
  ): Promise<ThreadResponse> {
    const project = await ctx.projectService.getCurrentProject();
    const { responseId, data } = args;
    const askingService = ctx.askingService;
    return askingService.adjustThreadResponseChart(responseId, data, {
      language: WrenAILanguage[project.language] || WrenAILanguage.EN,
    });
  }

  public async getResponse(
    _root: any,
    args: { responseId: number },
    ctx: IContext,
  ): Promise<ThreadResponse> {
    const { responseId } = args;
    const askingService = ctx.askingService;
    const response = await askingService.getResponse(responseId);

    return response;
  }

  public async previewData(
    _root: any,
    args: { where: { responseId: number; stepIndex?: number; limit?: number } },
    ctx: IContext,
  ): Promise<any> {
    const { responseId, limit } = args.where;
    const askingService = ctx.askingService;
    const data = await askingService.previewData(responseId, limit);
    return data;
  }

  public async previewBreakdownData(
    _root: any,
    args: { where: { responseId: number; stepIndex?: number; limit?: number } },
    ctx: IContext,
  ): Promise<any> {
    const { responseId, stepIndex, limit } = args.where;
    const askingService = ctx.askingService;
    const data = await askingService.previewBreakdownData(
      responseId,
      stepIndex,
      limit,
    );
    return data;
  }

  public async createInstantRecommendedQuestions(
    _root: any,
    args: { data: { previousQuestions?: string[] } },
    ctx: IContext,
  ): Promise<Task> {
    const { data } = args;
    const askingService = ctx.askingService;
    return askingService.createInstantRecommendedQuestions(data);
  }

  public async getInstantRecommendedQuestions(
    _root: any,
    args: { taskId: string },
    ctx: IContext,
  ): Promise<RecommendedQuestionsTask> {
    const { taskId } = args;
    const askingService = ctx.askingService;
    const result = await askingService.getInstantRecommendedQuestions(taskId);
    return {
      questions: result.response?.questions || [],
      status: result.status,
      error: result.error,
    };
  }

  /**
   * Nested resolvers
   */
  public getThreadResponseNestedResolver = () => ({
    view: async (parent: ThreadResponse, _args: any, ctx: IContext) => {
      const viewId = parent.viewId;
      if (!viewId) return null;
      const view = await ctx.viewRepository.findOneBy({ id: viewId });
      const displayName = view.properties
        ? JSON.parse(view.properties)?.displayName
        : view.name;
      return { ...view, displayName };
    },
    answerDetail: (parent: ThreadResponse, _args: any, _ctx: IContext) => {
      if (!parent?.answerDetail) return null;

      const { content, ...rest } = parent.answerDetail;

      if (!content) return parent.answerDetail;

      const formattedContent = content
        // replace the \\n to \n
        .replace(/\\n/g, '\n')
        // replace the \\\" to \",
        .replace(/\\"/g, '"');

      return {
        ...rest,
        content: formattedContent,
      };
    },
    sql: (parent: ThreadResponse, _args: any, _ctx: IContext) => {
      if (parent.breakdownDetail && parent.breakdownDetail.steps) {
        // construct sql from breakdownDetail
        return format(constructCteSql(parent.breakdownDetail.steps));
      }
      return parent.sql ? format(parent.sql) : null;
    },
    askingTask: async (parent: ThreadResponse, _args: any, ctx: IContext) => {
      if (parent.adjustment) {
        return null;
      }
      const askingService = ctx.askingService;
      const askingTask = await askingService.getAskingTaskById(
        parent.askingTaskId,
      );
      if (!askingTask) return null;
      return this.transformAskingTask(askingTask, ctx);
    },
    adjustmentTask: async (
      parent: ThreadResponse,
      _args: any,
      ctx: IContext,
    ): Promise<AdjustmentTask> => {
      if (!parent.adjustment) {
        return null;
      }
      const askingService = ctx.askingService;
      const adjustmentTask = await askingService.getAdjustmentTaskById(
        parent.askingTaskId,
      );
      if (!adjustmentTask) return null;
      return {
        queryId: adjustmentTask?.queryId,
        status: adjustmentTask?.status,
        error: adjustmentTask?.error,
        sql: adjustmentTask?.response?.[0]?.sql,
        traceId: adjustmentTask?.traceId,
        invalidSql: adjustmentTask?.invalidSql,
      };
    },
  });

  public getDetailStepNestedResolver = () => ({
    sql: (parent: DetailStep, _args: any, _ctx: IContext) => {
      return format(parent.sql);
    },
  });

  public getResultCandidateNestedResolver = () => ({
    sql: (parent: any, _args: any, _ctx: IContext) => {
      return format(parent.sql);
    },
    view: async (parent: any, _args: any, ctx: IContext) => {
      const viewId = parent.view?.id;
      if (!viewId) return parent.view;
      const view = await ctx.viewRepository.findOneBy({ id: viewId });

      const displayName = view.properties
        ? JSON.parse(view.properties).displayName
        : view.name;
      return {
        ...parent.view,
        displayName,
      };
    },
  });

  private async transformAskingTask(
    askingTask: TrackedAskingResult,
    ctx: IContext,
  ): Promise<AskingTask> {
    // construct candidates from response
    const candidates = await Promise.all(
      (askingTask.response || []).map(async (response) => {
        const view = response.viewId
          ? await ctx.viewRepository.findOneBy({ id: response.viewId })
          : null;
        const sqlPair = response.sqlpairId
          ? await ctx.sqlPairRepository.findOneBy({ id: response.sqlpairId })
          : null;
        return {
          type: response.type,
          sql: response.sql,
          view,
          sqlPair,
        };
      }),
    );

    // When the task got cancelled, the type is not set
    // we set it to TEXT_TO_SQL as default
    const type =
      askingTask?.status === AskResultStatus.STOPPED && !askingTask.type
        ? AskResultType.TEXT_TO_SQL
        : askingTask.type;
    return {
      type,
      status: askingTask.status,
      error: askingTask.error,
      candidates,
      queryId: askingTask.queryId,
      rephrasedQuestion: askingTask.rephrasedQuestion,
      intentReasoning: askingTask.intentReasoning,
      sqlGenerationReasoning: askingTask.sqlGenerationReasoning,
      retrievedTables: askingTask.retrievedTables,
      invalidSql: askingTask.invalidSql ? format(askingTask.invalidSql) : null,
      traceId: askingTask.traceId,
    };
  }
}
</file>

<file path="src/apollo/server/resolvers/dashboardResolver.ts">
import { IContext } from '@server/types';
import { ChartType } from '@server/models/adaptor';
import {
  UpdateDashboardItemLayouts,
  PreviewDataResponse,
  DEFAULT_PREVIEW_LIMIT,
} from '@server/services';
import {
  Dashboard,
  DashboardItem,
  DashboardItemType,
} from '@server/repositories';
import { getLogger } from '@server/utils';
import {
  SetDashboardCacheData,
  DashboardSchedule,
  PreviewItemResponse,
} from '@server/models/dashboard';

const logger = getLogger('DashboardResolver');
logger.level = 'debug';

export class DashboardResolver {
  constructor() {
    this.getDashboard = this.getDashboard.bind(this);
    this.getDashboardItems = this.getDashboardItems.bind(this);
    this.createDashboardItem = this.createDashboardItem.bind(this);
    this.updateDashboardItem = this.updateDashboardItem.bind(this);
    this.deleteDashboardItem = this.deleteDashboardItem.bind(this);
    this.updateDashboardItemLayouts =
      this.updateDashboardItemLayouts.bind(this);
    this.previewItemSQL = this.previewItemSQL.bind(this);
    this.setDashboardSchedule = this.setDashboardSchedule.bind(this);
  }

  public async getDashboard(
    _root: any,
    _args: any,
    ctx: IContext,
  ): Promise<
    Omit<Dashboard, 'nextScheduledAt'> & {
      schedule: DashboardSchedule;
      items: DashboardItem[];
      nextScheduledAt: string | null;
    }
  > {
    const dashboard = await ctx.dashboardService.getCurrentDashboard();
    if (!dashboard) {
      throw new Error('Dashboard not found.');
    }
    const schedule = ctx.dashboardService.parseCronExpression(dashboard);
    const items = await ctx.dashboardService.getDashboardItems(dashboard.id);
    return {
      ...dashboard,
      nextScheduledAt: dashboard.nextScheduledAt
        ? new Date(dashboard.nextScheduledAt).toISOString()
        : null,
      schedule,
      items,
    };
  }

  public async getDashboardItems(
    _root: any,
    _args: any,
    ctx: IContext,
  ): Promise<DashboardItem[]> {
    const dashboard = await ctx.dashboardService.getCurrentDashboard();
    if (!dashboard) {
      throw new Error('Dashboard not found.');
    }
    return await ctx.dashboardService.getDashboardItems(dashboard.id);
  }

  public async createDashboardItem(
    _root: any,
    args: { data: { itemType: DashboardItemType; responseId: number } },
    ctx: IContext,
  ): Promise<DashboardItem> {
    const { responseId, itemType } = args.data;
    const dashboard = await ctx.dashboardService.getCurrentDashboard();
    const response = await ctx.askingService.getResponse(responseId);

    if (!response) {
      throw new Error(`Thread response not found. responseId: ${responseId}`);
    }
    if (!Object.keys(ChartType).includes(itemType)) {
      throw new Error(`Chart type not supported. responseId: ${responseId}`);
    }
    if (!response.chartDetail?.chartSchema) {
      throw new Error(
        `Chart schema not found in thread response. responseId: ${responseId}`,
      );
    }

    // query with cache enabled
    const project = await ctx.projectService.getCurrentProject();
    const deployment = await ctx.deployService.getLastDeployment(project.id);
    const mdl = deployment.manifest;
    await ctx.queryService.preview(response.sql, {
      project,
      manifest: mdl,
      limit: DEFAULT_PREVIEW_LIMIT,
      cacheEnabled: true,
      refresh: true,
    });

    return await ctx.dashboardService.createDashboardItem({
      dashboardId: dashboard.id,
      type: itemType,
      sql: response.sql,
      chartSchema: response.chartDetail?.chartSchema,
    });
  }

  public async updateDashboardItem(
    _root: any,
    args: { where: { id: number }; data: { displayName: string } },
    ctx: IContext,
  ): Promise<DashboardItem> {
    const { id } = args.where;
    const { displayName } = args.data;
    const item = await ctx.dashboardService.getDashboardItem(id);
    if (!item) {
      throw new Error(`Dashboard item not found. id: ${id}`);
    }
    return await ctx.dashboardService.updateDashboardItem(id, { displayName });
  }

  public async deleteDashboardItem(
    _root: any,
    args: { where: { id: number } },
    ctx: IContext,
  ): Promise<boolean> {
    const { id } = args.where;
    const item = await ctx.dashboardService.getDashboardItem(id);
    if (!item) {
      throw new Error(`Dashboard item not found. id: ${id}`);
    }
    return await ctx.dashboardService.deleteDashboardItem(id);
  }

  public async updateDashboardItemLayouts(
    _root: any,
    args: { data: { layouts: UpdateDashboardItemLayouts } },
    ctx: IContext,
  ): Promise<DashboardItem[]> {
    const { layouts } = args.data;
    if (layouts.length === 0) {
      throw new Error('Layouts are required.');
    }
    return await ctx.dashboardService.updateDashboardItemLayouts(layouts);
  }

  public async previewItemSQL(
    _root: any,
    args: { data: { itemId: number; limit?: number; refresh?: boolean } },
    ctx: IContext,
  ): Promise<PreviewItemResponse> {
    const { itemId, limit, refresh } = args.data;
    try {
      const item = await ctx.dashboardService.getDashboardItem(itemId);
      const { cacheEnabled } = await ctx.dashboardService.getCurrentDashboard();
      const project = await ctx.projectService.getCurrentProject();
      const deployment = await ctx.deployService.getLastDeployment(project.id);
      const mdl = deployment.manifest;
      const data = (await ctx.queryService.preview(item.detail.sql, {
        project,
        manifest: mdl,
        limit: limit || DEFAULT_PREVIEW_LIMIT,
        cacheEnabled,
        refresh: refresh || false,
      })) as PreviewDataResponse;

      // handle data to [{ column1: value1, column2: value2, ... }]
      const values = data.data.map((val) => {
        return data.columns.reduce((acc, col, index) => {
          acc[col.name] = val[index];
          return acc;
        }, {});
      });
      return {
        cacheHit: data.cacheHit || false,
        cacheCreatedAt: data.cacheCreatedAt || null,
        cacheOverrodeAt: data.cacheOverrodeAt || null,
        override: data.override || false,
        data: values,
      } as PreviewItemResponse;
    } catch (error) {
      logger.error(`Error previewing SQL item ${itemId}: ${error}`);
      throw error;
    }
  }

  public async setDashboardSchedule(
    _root: any,
    args: { data: SetDashboardCacheData },
    ctx: IContext,
  ): Promise<Dashboard> {
    try {
      const dashboard = await ctx.dashboardService.getCurrentDashboard();
      if (!dashboard) {
        throw new Error('Dashboard not found.');
      }

      return await ctx.dashboardService.setDashboardSchedule(
        dashboard.id,
        args.data,
      );
    } catch (error) {
      logger.error(`Failed to set dashboard schedule: ${error.message}`);
      throw error;
    }
  }
}
</file>

<file path="src/apollo/server/resolvers/diagramResolver.ts">
import { v4 as uuidv4 } from 'uuid';
import {
  Model,
  ModelColumn,
  ModelNestedColumn,
  RelationInfo,
  View,
} from '@server/repositories';
import {
  Diagram,
  DiagramModel,
  DiagramModelField,
  DiagramModelRelationField,
  NodeType,
  IContext,
  RelationType,
  DiagramView,
} from '@server/types';
import { ColumnMDL, Manifest } from '@server/mdl/type';
import { getLogger } from '@server/utils';
import { MDLBuilder } from '../mdl/mdlBuilder';

const logger = getLogger('DiagramResolver');
logger.level = 'debug';

export class DiagramResolver {
  constructor() {
    this.getDiagram = this.getDiagram.bind(this);
  }

  public async getDiagram(
    _root: any,
    _args: any,
    ctx: IContext,
  ): Promise<Diagram> {
    const project = await ctx.projectRepository.getCurrentProject();
    const models = await ctx.modelRepository.findAllBy({
      projectId: project.id,
    });

    const modelIds = models.map((model) => model.id);
    const modelColumns =
      await ctx.modelColumnRepository.findColumnsByModelIds(modelIds);
    const modelNestedColumns =
      await ctx.modelNestedColumnRepository.findNestedColumnsByModelIds(
        modelIds,
      );
    const modelRelations = await ctx.relationRepository.findRelationInfoBy({
      columnIds: modelColumns.map((column) => column.id),
    });
    const views = await ctx.viewRepository.findAllBy({
      projectId: project.id,
    });

    const builder = new MDLBuilder({
      project,
      models,
      columns: modelColumns,
      nestedColumns: modelNestedColumns,
      relations: modelRelations,
      views,
      relatedModels: models,
      relatedColumns: modelColumns,
      relatedRelations: modelRelations,
    });

    const manifest = builder.build();

    return this.buildDiagram(
      models,
      modelColumns,
      modelNestedColumns,
      modelRelations,
      views,
      manifest,
    );
  }

  private buildDiagram(
    models: Model[],
    modelColumns: ModelColumn[],
    modelNestedColumns: ModelNestedColumn[],
    relations: RelationInfo[],
    views: View[],
    manifest: Manifest,
  ): Diagram {
    const diagramModels = models.map((model) => {
      const transformedModel = this.transformModel(model);
      const allColumns = modelColumns.filter(
        (column) => column.modelId === model.id,
      );
      const modelMDL = manifest.models.find(
        (modelMDL) => modelMDL.name === model.referenceName,
      );
      allColumns.forEach((column) => {
        const columnRelations = relations
          .map((relation) =>
            [relation.fromColumnId, relation.toColumnId].includes(column.id)
              ? relation
              : null,
          )
          .filter((relation) => !!relation);

        if (columnRelations.length > 0) {
          columnRelations.forEach((relation) => {
            const transformedRelationField = this.transformModelRelationField({
              relation,
              currentModel: model,
              models,
            });
            transformedModel.relationFields.push(transformedRelationField);
          });
        }

        if (column.isCalculated) {
          transformedModel.calculatedFields.push(
            this.transformCalculatedField(column, modelMDL.columns),
          );
        } else {
          const nestedColumns = modelNestedColumns.filter(
            (nestedColumn) => nestedColumn.columnId === column.id,
          );
          transformedModel.fields.push(
            this.transformNormalField(column, nestedColumns),
          );
        }
      });
      return transformedModel;
    });

    const diagramViews = views.map(this.transformView);
    return { models: diagramModels, views: diagramViews };
  }

  private transformModel(model: Model): DiagramModel {
    const properties = JSON.parse(model.properties);
    return {
      id: uuidv4(),
      modelId: model.id,
      nodeType: NodeType.MODEL,
      displayName: model.displayName,
      referenceName: model.referenceName,
      sourceTableName: model.sourceTableName,
      refSql: model.refSql,
      refreshTime: model.refreshTime,
      cached: model.cached,
      description: properties?.description,
      fields: [],
      calculatedFields: [],
      relationFields: [],
    };
  }

  private transformNormalField(
    column: ModelColumn,
    nestedColumns: ModelNestedColumn[],
  ): DiagramModelField {
    const properties = JSON.parse(column.properties);
    return {
      id: uuidv4(),
      columnId: column.id,
      nodeType: column.isCalculated
        ? NodeType.CALCULATED_FIELD
        : NodeType.FIELD,
      type: column.type,
      displayName: column.displayName,
      referenceName: column.referenceName,
      description: properties?.description,
      isPrimaryKey: column.isPk,
      expression: column.aggregation,
      nestedFields: nestedColumns.length
        ? nestedColumns.map((nestedColumn) => ({
            id: uuidv4(),
            nestedColumnId: nestedColumn.id,
            columnPath: nestedColumn.columnPath,
            type: nestedColumn.type,
            displayName: nestedColumn.displayName,
            referenceName: nestedColumn.referenceName,
            description: nestedColumn.properties?.description,
          }))
        : null,
    };
  }

  private transformCalculatedField(
    column: ModelColumn,
    columnsMDL: ColumnMDL[],
  ): DiagramModelField {
    const properties = JSON.parse(column.properties);
    const lineage = JSON.parse(column.lineage);
    const columnMDL = columnsMDL.find(
      ({ name }) => name === column.referenceName,
    );
    return {
      id: uuidv4(),
      columnId: column.id,
      nodeType: NodeType.CALCULATED_FIELD,
      aggregation: column.aggregation,
      lineage,
      type: column.type,
      displayName: column.displayName,
      referenceName: column.referenceName,
      description: properties?.description,
      isPrimaryKey: column.isPk,
      expression: columnMDL.expression,
    };
  }

  private transformModelRelationField({
    relation,
    currentModel,
    models,
  }: {
    relation: RelationInfo;
    currentModel: Model;
    models: Model[];
  }): DiagramModelRelationField {
    const referenceName =
      currentModel.referenceName === relation.fromModelName
        ? relation.toModelName
        : relation.fromModelName;
    const displayName = models.find(
      (model) => model.referenceName === referenceName,
    )?.displayName;
    const properties = relation.properties
      ? JSON.parse(relation.properties)
      : null;
    return {
      id: uuidv4(),
      relationId: relation.id,
      nodeType: NodeType.RELATION,
      displayName,
      referenceName,
      type: relation.joinType as RelationType,
      fromModelId: relation.fromModelId,
      fromModelName: relation.fromModelName,
      fromModelDisplayName: relation.fromModelDisplayName,
      fromColumnId: relation.fromColumnId,
      fromColumnName: relation.fromColumnName,
      fromColumnDisplayName: relation.fromColumnDisplayName,
      toModelId: relation.toModelId,
      toModelName: relation.toModelName,
      toModelDisplayName: relation.toModelDisplayName,
      toColumnId: relation.toColumnId,
      toColumnName: relation.toColumnName,
      toColumnDisplayName: relation.toColumnDisplayName,
      description: properties?.description,
    };
  }

  private transformView(view: View): DiagramView {
    const properties = JSON.parse(view.properties);
    const fields = (properties?.columns || []).map((column: any) => ({
      id: uuidv4(),
      nodeType: NodeType.FIELD,
      type: column.type,
      displayName: column.name,
      referenceName: column.name,
      description: column?.properties?.description,
    }));

    return {
      id: uuidv4(),
      viewId: view.id,
      nodeType: NodeType.VIEW,
      statement: view.statement,
      referenceName: view.name,
      displayName: properties?.displayName || view.name,
      fields,
      description: properties?.description,
    };
  }
}
</file>

<file path="src/apollo/server/resolvers/instructionResolver.ts">
import { IContext } from '@server/types';
import { UpdateInstructionInput } from '@server/models';
import { Instruction } from '@server/repositories/instructionRepository';
import { getLogger } from '@server/utils';
import { TelemetryEvent, TrackTelemetry } from '@server/telemetry/telemetry';

const logger = getLogger('InstructionResolver');
logger.level = 'debug';

export class InstructionResolver {
  constructor() {
    this.getInstructions = this.getInstructions.bind(this);
    this.createInstruction = this.createInstruction.bind(this);
    this.updateInstruction = this.updateInstruction.bind(this);
    this.deleteInstruction = this.deleteInstruction.bind(this);
  }

  public async getInstructions(
    _root: any,
    _args: any,
    ctx: IContext,
  ): Promise<Instruction[]> {
    try {
      const project = await ctx.projectService.getCurrentProject();
      return await ctx.instructionService.getInstructions(project.id);
    } catch (error) {
      logger.error(`Error getting instructions: ${error}`);
      throw error;
    }
  }

  @TrackTelemetry(TelemetryEvent.KNOWLEDGE_CREATE_INSTRUCTION)
  public async createInstruction(
    _root: any,
    args: {
      data: {
        instruction: string;
        questions: string[];
        isDefault: boolean;
      };
    },
    ctx: IContext,
  ): Promise<Instruction> {
    const { instruction, questions, isDefault } = args.data;
    const project = await ctx.projectService.getCurrentProject();
    return await ctx.instructionService.createInstruction({
      instruction,
      questions,
      isDefault,
      projectId: project.id,
    });
  }

  @TrackTelemetry(TelemetryEvent.KNOWLEDGE_UPDATE_INSTRUCTION)
  public async updateInstruction(
    _root: any,
    args: {
      data: Pick<
        UpdateInstructionInput,
        'instruction' | 'questions' | 'isDefault'
      >;
      where: { id: number };
    },
    ctx: IContext,
  ): Promise<Instruction> {
    const { id } = args.where;
    const { instruction, questions, isDefault } = args.data;
    if (!id) {
      throw new Error('Instruction ID is required.');
    }
    const project = await ctx.projectService.getCurrentProject();
    return await ctx.instructionService.updateInstruction({
      id,
      projectId: project.id,
      instruction,
      questions,
      isDefault,
    });
  }

  @TrackTelemetry(TelemetryEvent.KNOWLEDGE_DELETE_INSTRUCTION)
  public async deleteInstruction(
    _root: any,
    args: { where: { id: number } },
    ctx: IContext,
  ): Promise<boolean> {
    const { id } = args.where;
    const project = await ctx.projectService.getCurrentProject();
    await ctx.instructionService.deleteInstruction(id, project.id);
    return true;
  }
}
</file>

<file path="src/apollo/server/resolvers/learningResolver.ts">
import { IContext } from '@server/types';
import { getConfig } from '@server/config';

import { getLogger } from '@server/utils';
import { uniq } from 'lodash';

const config = getConfig();

const logger = getLogger('LearingResolver');
logger.level = 'debug';

export class LearningResolver {
  constructor() {
    this.getLearningRecord = this.getLearningRecord.bind(this);
    this.saveLearningRecord = this.saveLearningRecord.bind(this);
  }

  public async getLearningRecord(
    _root: any,
    _args: any,
    ctx: IContext,
  ): Promise<any> {
    const result = await ctx.learningRepository.findAll();
    return { paths: result[0]?.paths || [] };
  }

  public async saveLearningRecord(
    _root: any,
    args: any,
    ctx: IContext,
  ): Promise<any> {
    const { path } = args.data;
    const result = await ctx.learningRepository.findAll();

    if (!result.length) {
      return await ctx.learningRepository.createOne({
        userId: config?.userUUID,
        paths: [path],
      });
    }

    const [record] = result;
    return await ctx.learningRepository.updateOne(record.id, {
      userId: config?.userUUID,
      paths: uniq([...record.paths, path]),
    });
  }
}
</file>

<file path="src/apollo/server/resolvers/modelResolver.ts">
import {
  CreateModelData,
  UpdateModelData,
  UpdateModelMetadataInput,
  CreateCalculatedFieldData,
  UpdateCalculatedFieldData,
  UpdateViewMetadataInput,
  PreviewSQLData,
} from '../models';
import {
  DataSourceName,
  IContext,
  RelationData,
  UpdateRelationData,
} from '../types';
import { getLogger, transformInvalidColumnName } from '@server/utils';
import { DeployResponse } from '../services/deployService';
import { format } from 'sql-formatter';
import { isEmpty, isNil } from 'lodash';
import { replaceAllowableSyntax, validateDisplayName } from '../utils/regex';
import { Model, ModelColumn } from '../repositories';
import {
  findColumnsToUpdate,
  getPreviewColumnsStr,
  handleNestedColumns,
  replaceInvalidReferenceName,
  updateModelPrimaryKey,
} from '../utils/model';
import { CompactTable, PreviewDataResponse } from '@server/services';
import { TelemetryEvent } from '../telemetry/telemetry';

const logger = getLogger('ModelResolver');
logger.level = 'debug';

export enum SyncStatusEnum {
  IN_PROGRESS = 'IN_PROGRESS',
  SYNCRONIZED = 'SYNCRONIZED',
  UNSYNCRONIZED = 'UNSYNCRONIZED',
}

export class ModelResolver {
  constructor() {
    // model & model column
    this.listModels = this.listModels.bind(this);
    this.getModel = this.getModel.bind(this);
    this.createModel = this.createModel.bind(this);
    this.updateModel = this.updateModel.bind(this);
    this.deleteModel = this.deleteModel.bind(this);
    this.updateModelMetadata = this.updateModelMetadata.bind(this);
    this.deploy = this.deploy.bind(this);
    this.getMDL = this.getMDL.bind(this);
    this.checkModelSync = this.checkModelSync.bind(this);

    // view
    this.listViews = this.listViews.bind(this);
    this.getView = this.getView.bind(this);
    this.validateView = this.validateView.bind(this);
    this.createView = this.createView.bind(this);
    this.deleteView = this.deleteView.bind(this);
    this.updateViewMetadata = this.updateViewMetadata.bind(this);

    // preview
    this.previewModelData = this.previewModelData.bind(this);
    this.previewViewData = this.previewViewData.bind(this);
    this.previewSql = this.previewSql.bind(this);
    this.getNativeSql = this.getNativeSql.bind(this);

    // calculated field
    this.createCalculatedField = this.createCalculatedField.bind(this);
    this.validateCalculatedField = this.validateCalculatedField.bind(this);
    this.updateCalculatedField = this.updateCalculatedField.bind(this);
    this.deleteCalculatedField = this.deleteCalculatedField.bind(this);

    // relation
    this.createRelation = this.createRelation.bind(this);
    this.updateRelation = this.updateRelation.bind(this);
    this.deleteRelation = this.deleteRelation.bind(this);
  }

  public async createRelation(
    _root: any,
    args: { data: RelationData },
    ctx: IContext,
  ) {
    const { data } = args;

    const eventName = TelemetryEvent.MODELING_CREATE_RELATION;
    try {
      const relation = await ctx.modelService.createRelation(data);
      ctx.telemetry.sendEvent(eventName, { data });
      return relation;
    } catch (err: any) {
      ctx.telemetry.sendEvent(
        eventName,
        { data: data, error: err.message },
        err.extensions?.service,
        false,
      );
      throw err;
    }
  }

  public async updateRelation(
    _root: any,
    args: { data: UpdateRelationData; where: { id: number } },
    ctx: IContext,
  ) {
    const { data, where } = args;
    const eventName = TelemetryEvent.MODELING_UPDATE_RELATION;
    try {
      const relation = await ctx.modelService.updateRelation(data, where.id);
      ctx.telemetry.sendEvent(eventName, { data });
      return relation;
    } catch (err: any) {
      ctx.telemetry.sendEvent(
        eventName,
        { data: data, error: err.message },
        err.extensions?.service,
        false,
      );
      throw err;
    }
  }

  public async deleteRelation(
    _root: any,
    args: { where: { id: number } },
    ctx: IContext,
  ) {
    const relationId = args.where.id;
    await ctx.modelService.deleteRelation(relationId);
    return true;
  }

  public async createCalculatedField(
    _root: any,
    _args: { data: CreateCalculatedFieldData },
    ctx: IContext,
  ) {
    const eventName = TelemetryEvent.MODELING_CREATE_CF;
    try {
      const column = await ctx.modelService.createCalculatedField(_args.data);
      ctx.telemetry.sendEvent(eventName, { data: _args.data });
      return column;
    } catch (err: any) {
      ctx.telemetry.sendEvent(
        eventName,
        { data: _args.data, error: err.message },
        err.extensions?.service,
        false,
      );
      throw err;
    }
  }

  public async validateCalculatedField(_root: any, args: any, ctx: IContext) {
    const { name, modelId, columnId } = args.data;
    return await ctx.modelService.validateCalculatedFieldNaming(
      name,
      modelId,
      columnId,
    );
  }

  public async updateCalculatedField(
    _root: any,
    _args: { data: UpdateCalculatedFieldData; where: { id: number } },
    ctx: IContext,
  ) {
    const { data, where } = _args;

    const eventName = TelemetryEvent.MODELING_UPDATE_CF;
    try {
      const column = await ctx.modelService.updateCalculatedField(
        data,
        where.id,
      );
      ctx.telemetry.sendEvent(eventName, { data });
      return column;
    } catch (err: any) {
      ctx.telemetry.sendEvent(
        eventName,
        { data: data, error: err.message },
        err.extensions?.service,
        false,
      );
      throw err;
    }
  }

  public async deleteCalculatedField(_root: any, args: any, ctx: IContext) {
    const columnId = args.where.id;
    // check column exist and is calculated field
    const column = await ctx.modelColumnRepository.findOneBy({ id: columnId });
    if (!column || !column.isCalculated) {
      throw new Error('Calculated field not found');
    }
    await ctx.modelColumnRepository.deleteOne(columnId);
    return true;
  }

  public async checkModelSync(_root: any, _args: any, ctx: IContext) {
    const { id } = await ctx.projectService.getCurrentProject();
    const { manifest } = await ctx.mdlService.makeCurrentModelMDL();
    const currentHash = ctx.deployService.createMDLHash(manifest, id);
    const lastDeploy = await ctx.deployService.getLastDeployment(id);
    const lastDeployHash = lastDeploy?.hash;
    const inProgressDeployment =
      await ctx.deployService.getInProgressDeployment(id);
    if (inProgressDeployment) {
      return { status: SyncStatusEnum.IN_PROGRESS };
    }
    return currentHash == lastDeployHash
      ? { status: SyncStatusEnum.SYNCRONIZED }
      : { status: SyncStatusEnum.UNSYNCRONIZED };
  }

  public async deploy(
    _root: any,
    args: { force: boolean },
    ctx: IContext,
  ): Promise<DeployResponse> {
    const project = await ctx.projectService.getCurrentProject();
    if (!project.version && project.type !== DataSourceName.DUCKDB) {
      const version =
        await ctx.projectService.getProjectDataSourceVersion(project);
      await ctx.projectService.updateProject(project.id, {
        version,
      });
    }
    const { manifest } = await ctx.mdlService.makeCurrentModelMDL();
    const deployRes = await ctx.deployService.deploy(
      manifest,
      project.id,
      args.force,
    );

    // only generating for user's data source
    if (project.sampleDataset === null) {
      await ctx.projectService.generateProjectRecommendationQuestions();
    }
    return deployRes;
  }

  public async getMDL(_root: any, args: { hash: string }, ctx: IContext) {
    const mdl = await ctx.deployService.getMDLByHash(args.hash);
    return {
      hash: args.hash,
      mdl,
    };
  }

  public async listModels(_root: any, _args: any, ctx: IContext) {
    const { id: projectId } = await ctx.projectService.getCurrentProject();
    const models = await ctx.modelRepository.findAllBy({ projectId });
    const modelIds = models.map((m) => m.id);
    const modelColumnList =
      await ctx.modelColumnRepository.findColumnsByModelIds(modelIds);
    const modelNestedColumnList =
      await ctx.modelNestedColumnRepository.findNestedColumnsByModelIds(
        modelIds,
      );
    const result = [];
    for (const model of models) {
      const modelFields = modelColumnList
        .filter((c) => c.modelId === model.id)
        .map((c) => ({
          ...c,
          properties: JSON.parse(c.properties),
          nestedColumns: c.type.includes('STRUCT')
            ? modelNestedColumnList.filter((nc) => nc.columnId === c.id)
            : undefined,
        }));
      const fields = modelFields.filter((c) => !c.isCalculated);
      const calculatedFields = modelFields.filter((c) => c.isCalculated);
      result.push({
        ...model,
        fields,
        calculatedFields,
        properties: {
          ...JSON.parse(model.properties),
        },
      });
    }
    return result;
  }

  public async getModel(_root: any, args: any, ctx: IContext) {
    const modelId = args.where.id;
    const model = await ctx.modelRepository.findOneBy({ id: modelId });
    if (!model) {
      throw new Error('Model not found');
    }

    const modelColumns = await ctx.modelColumnRepository.findColumnsByModelIds([
      model.id,
    ]);
    const modelNestedColumns = await ctx.modelNestedColumnRepository.findAllBy({
      modelId: model.id,
    });

    const columns = modelColumns.map((c) => ({
      ...c,
      properties: JSON.parse(c.properties),
      nestedColumns: c.type.includes('STRUCT')
        ? modelNestedColumns.filter((nc) => nc.columnId === c.id)
        : undefined,
    }));
    const relations = (
      await ctx.relationRepository.findRelationsBy({
        columnIds: modelColumns.map((c) => c.id),
      })
    ).map((r) => ({
      ...r,
      type: r.joinType,
      properties: r.properties ? JSON.parse(r.properties) : {},
    }));

    return {
      ...model,
      fields: columns.filter((c) => !c.isCalculated),
      calculatedFields: columns.filter((c) => c.isCalculated),
      relations,
      properties: {
        ...JSON.parse(model.properties),
      },
    };
  }

  public async createModel(
    _root: any,
    args: { data: CreateModelData },
    ctx: IContext,
  ) {
    const { sourceTableName, fields, primaryKey } = args.data;
    try {
      const model = await this.handleCreateModel(
        ctx,
        sourceTableName,
        fields,
        primaryKey,
      );
      ctx.telemetry.sendEvent(TelemetryEvent.MODELING_CREATE_MODEL, {
        data: args.data,
      });
      return model;
    } catch (error: any) {
      ctx.telemetry.sendEvent(
        TelemetryEvent.MODELING_CREATE_MODEL,
        { data: args.data, error },
        error.extensions?.service,
        false,
      );
      throw error;
    }
  }

  private async handleCreateModel(
    ctx: IContext,
    sourceTableName: string,
    fields: [string],
    primaryKey: string,
  ) {
    const project = await ctx.projectService.getCurrentProject();
    const dataSourceTables =
      await ctx.projectService.getProjectDataSourceTables(project);
    this.validateTableExist(sourceTableName, dataSourceTables);
    this.validateColumnsExist(sourceTableName, fields, dataSourceTables);

    // create model
    const dataSourceTable = dataSourceTables.find(
      (table) => table.name === sourceTableName,
    );
    if (!dataSourceTable) {
      throw new Error('Table not found in the data source');
    }
    const properties = dataSourceTable?.properties;
    const modelValue = {
      projectId: project.id,
      displayName: sourceTableName, //use table name as displayName, referenceName and tableName
      referenceName: replaceInvalidReferenceName(sourceTableName),
      sourceTableName: sourceTableName,
      cached: false,
      refreshTime: null,
      properties: properties ? JSON.stringify(properties) : null,
    } as Partial<Model>;
    const model = await ctx.modelRepository.createOne(modelValue);

    // create columns
    const compactColumns = dataSourceTable.columns.filter((c) =>
      fields.includes(c.name),
    );
    const columnValues = compactColumns.map(
      (column) =>
        ({
          modelId: model.id,
          isCalculated: false,
          displayName: column.name,
          referenceName: transformInvalidColumnName(column.name),
          sourceColumnName: column.name,
          type: column.type || 'string',
          notNull: column.notNull || false,
          isPk: primaryKey === column.name,
          properties: column.properties
            ? JSON.stringify(column.properties)
            : null,
        }) as Partial<ModelColumn>,
    );
    const columns = await ctx.modelColumnRepository.createMany(columnValues);

    // create nested columns
    const nestedColumnValues = compactColumns.flatMap((compactColumn) => {
      const column = columns.find(
        (c) => c.sourceColumnName === compactColumn.name,
      );
      if (!column) return [];
      return handleNestedColumns(compactColumn, {
        modelId: column.modelId,
        columnId: column.id,
        sourceColumnName: column.sourceColumnName,
      });
    });
    await ctx.modelNestedColumnRepository.createMany(nestedColumnValues);
    logger.info(`Model created: ${JSON.stringify(model)}`);

    return model;
  }

  public async updateModel(
    _root: any,
    args: { data: UpdateModelData; where: { id: number } },
    ctx: IContext,
  ) {
    const { fields, primaryKey } = args.data;
    try {
      const model = await this.handleUpdateModel(ctx, args, fields, primaryKey);
      ctx.telemetry.sendEvent(TelemetryEvent.MODELING_UPDATE_MODEL, {
        data: args.data,
      });
      return model;
    } catch (err: any) {
      ctx.telemetry.sendEvent(
        TelemetryEvent.MODELING_UPDATE_MODEL,
        { data: args.data, error: err.message },
        err.extensions?.service,
        false,
      );
      throw err;
    }
  }

  private async handleUpdateModel(
    ctx: IContext,
    args: { data: UpdateModelData; where: { id: number } },
    fields: [string],
    primaryKey: string,
  ) {
    const project = await ctx.projectService.getCurrentProject();
    const dataSourceTables =
      await ctx.projectService.getProjectDataSourceTables(project);
    const model = await ctx.modelRepository.findOneBy({ id: args.where.id });
    const existingColumns = await ctx.modelColumnRepository.findAllBy({
      modelId: model.id,
      isCalculated: false,
    });
    const { sourceTableName } = model;
    this.validateTableExist(sourceTableName, dataSourceTables);
    this.validateColumnsExist(sourceTableName, fields, dataSourceTables);

    const sourceTableColumns = dataSourceTables.find(
      (table) => table.name === sourceTableName,
    )?.columns;
    const { toDeleteColumnIds, toCreateColumns, toUpdateColumns } =
      findColumnsToUpdate(fields, existingColumns, sourceTableColumns);
    await updateModelPrimaryKey(
      ctx.modelColumnRepository,
      model.id,
      primaryKey,
    );

    // delete columns
    if (toDeleteColumnIds.length) {
      await ctx.modelColumnRepository.deleteMany(toDeleteColumnIds);
    }

    // create columns
    if (toCreateColumns.length) {
      const compactColumns = sourceTableColumns.filter((sourceColumn) =>
        toCreateColumns.includes(sourceColumn.name),
      );
      const columnValues = compactColumns.map((column) => {
        const columnValue = {
          modelId: model.id,
          isCalculated: false,
          displayName: column.name,
          sourceColumnName: column.name,
          referenceName: transformInvalidColumnName(column.name),
          type: column.type || 'string',
          notNull: column.notNull,
          isPk: primaryKey === column.name,
          properties: column.properties
            ? JSON.stringify(column.properties)
            : null,
        } as Partial<ModelColumn>;
        return columnValue;
      });
      const columns = await ctx.modelColumnRepository.createMany(columnValues);

      // create nested columns
      const nestedColumnValues = compactColumns.flatMap((compactColumn) => {
        const column = columns.find(
          (c) => c.sourceColumnName === compactColumn.name,
        );
        return handleNestedColumns(compactColumn, {
          modelId: column.modelId,
          columnId: column.id,
          sourceColumnName: column.sourceColumnName,
        });
      });
      await ctx.modelNestedColumnRepository.createMany(nestedColumnValues);
    }

    // update columns
    if (toUpdateColumns.length) {
      for (const { id, sourceColumnName, type } of toUpdateColumns) {
        const column = await ctx.modelColumnRepository.updateOne(id, { type });

        // if the struct type is changed, need to re-create nested columns
        if (type.includes('STRUCT')) {
          const sourceColumn = sourceTableColumns.find(
            (sourceColumn) => sourceColumn.name === sourceColumnName,
          );
          await ctx.modelNestedColumnRepository.deleteAllBy({
            columnId: column.id,
          });
          await ctx.modelNestedColumnRepository.createMany(
            handleNestedColumns(sourceColumn, {
              modelId: column.modelId,
              columnId: column.id,
              sourceColumnName: sourceColumnName,
            }),
          );
        }
      }
    }

    logger.info(`Model updated: ${JSON.stringify(model)}`);
    return model;
  }

  // delete model
  public async deleteModel(_root: any, args: any, ctx: IContext) {
    const modelId = args.where.id;
    const model = await ctx.modelRepository.findOneBy({ id: modelId });
    if (!model) {
      throw new Error('Model not found');
    }

    // related columns and relationships will be deleted in cascade
    await ctx.modelRepository.deleteOne(modelId);
    return true;
  }

  // update model metadata
  public async updateModelMetadata(
    _root: any,
    args: { where: { id: number }; data: UpdateModelMetadataInput },
    ctx: IContext,
  ): Promise<boolean> {
    const modelId = args.where.id;
    const data = args.data;

    // check if model exists
    const model = await ctx.modelRepository.findOneBy({ id: modelId });
    if (!model) {
      throw new Error('Model not found');
    }
    const eventName = TelemetryEvent.MODELING_UPDATE_MODEL_METADATA;
    try {
      // update model metadata
      await this.handleUpdateModelMetadata(data, model, ctx, modelId);

      // todo: considering using update ... from statement to do a batch update
      // update column metadata
      if (!isEmpty(data.columns)) {
        // find the columns that match the user requested columns
        await this.handleUpdateColumnMetadata(data, ctx);
      }

      // update nested column metadata
      if (!isEmpty(data.nestedColumns)) {
        await this.handleUpdateNestedColumnMetadata(data, ctx);
      }

      // update calculated field metadata
      if (!isEmpty(data.calculatedFields)) {
        await this.handleUpdateCFMetadata(data, ctx);
      }

      // update relationship metadata
      if (!isEmpty(data.relationships)) {
        await this.handleUpdateRelationshipMetadata(data, ctx);
      }

      ctx.telemetry.sendEvent(eventName, { data });
      return true;
    } catch (err: any) {
      ctx.telemetry.sendEvent(
        eventName,
        { data: data, error: err.message },
        err.extensions?.service,
        false,
      );
      throw err;
    }
  }

  private async handleUpdateModelMetadata(
    data: UpdateModelMetadataInput,
    model: Model,
    ctx: IContext,
    modelId: number,
  ) {
    const modelMetadata: any = {};

    // if displayName is not null, or undefined, update the displayName
    if (!isNil(data.displayName)) {
      modelMetadata.displayName = this.determineMetadataValue(data.displayName);
    }

    // if description is not null, or undefined, update the description in properties
    if (!isNil(data.description)) {
      const properties = isNil(model.properties)
        ? {}
        : JSON.parse(model.properties);

      properties.description = this.determineMetadataValue(data.description);
      modelMetadata.properties = JSON.stringify(properties);
    }

    if (!isEmpty(modelMetadata)) {
      await ctx.modelRepository.updateOne(modelId, modelMetadata);
    }
  }

  private async handleUpdateRelationshipMetadata(
    data: UpdateModelMetadataInput,
    ctx: IContext,
  ) {
    const relationshipIds = data.relationships.map((r) => r.id);
    const relationships =
      await ctx.relationRepository.findRelationsByIds(relationshipIds);
    for (const rel of relationships) {
      const requestedMetadata = data.relationships.find((r) => r.id === rel.id);

      const relationMetadata: any = {};

      if (!isNil(requestedMetadata.description)) {
        const properties = rel.properties ? JSON.parse(rel.properties) : {};
        properties.description = this.determineMetadataValue(
          requestedMetadata.description,
        );
        relationMetadata.properties = JSON.stringify(properties);
      }

      if (!isEmpty(relationMetadata)) {
        await ctx.relationRepository.updateOne(rel.id, relationMetadata);
      }
    }
  }

  private async handleUpdateCFMetadata(
    data: UpdateModelMetadataInput,
    ctx: IContext,
  ) {
    const calculatedFieldIds = data.calculatedFields.map((c) => c.id);
    const modelColumns =
      await ctx.modelColumnRepository.findColumnsByIds(calculatedFieldIds);
    for (const col of modelColumns) {
      const requestedMetadata = data.calculatedFields.find(
        (c) => c.id === col.id,
      );

      const columnMetadata: any = {};
      // check if description is empty
      // if description is empty, skip the update
      // if description is not empty, update the description in properties
      if (!isNil(requestedMetadata.description)) {
        const properties = col.properties ? JSON.parse(col.properties) : {};
        properties.description = this.determineMetadataValue(
          requestedMetadata.description,
        );
        columnMetadata.properties = JSON.stringify(properties);
      }

      if (!isEmpty(columnMetadata)) {
        await ctx.modelColumnRepository.updateOne(col.id, columnMetadata);
      }
    }
  }

  private async handleUpdateColumnMetadata(
    data: UpdateModelMetadataInput,
    ctx: IContext,
  ) {
    const columnIds = data.columns.map((c) => c.id);
    const modelColumns =
      await ctx.modelColumnRepository.findColumnsByIds(columnIds);
    for (const col of modelColumns) {
      const requestedMetadata = data.columns.find((c) => c.id === col.id);

      // update metadata
      const columnMetadata: any = {};

      if (!isNil(requestedMetadata.displayName)) {
        columnMetadata.displayName = this.determineMetadataValue(
          requestedMetadata.displayName,
        );
      }

      if (!isNil(requestedMetadata.description)) {
        const properties = col.properties ? JSON.parse(col.properties) : {};
        properties.description = this.determineMetadataValue(
          requestedMetadata.description,
        );
        columnMetadata.properties = JSON.stringify(properties);
      }

      if (!isEmpty(columnMetadata)) {
        await ctx.modelColumnRepository.updateOne(col.id, columnMetadata);
      }
    }
  }

  private async handleUpdateNestedColumnMetadata(
    data: UpdateModelMetadataInput,
    ctx: IContext,
  ) {
    const nestedColumnIds = data.nestedColumns.map((nc) => nc.id);
    const modelNestedColumns =
      await ctx.modelNestedColumnRepository.findNestedColumnsByIds(
        nestedColumnIds,
      );
    for (const col of modelNestedColumns) {
      const requestedMetadata = data.nestedColumns.find((c) => c.id === col.id);

      const nestedColumnMetadata: any = {};

      if (!isNil(requestedMetadata.displayName)) {
        nestedColumnMetadata.displayName = this.determineMetadataValue(
          requestedMetadata.displayName,
        );
      }

      if (!isNil(requestedMetadata.description)) {
        nestedColumnMetadata.properties = {
          ...col.properties,
          description: this.determineMetadataValue(
            requestedMetadata.description,
          ),
        };
      }

      if (!isEmpty(nestedColumnMetadata)) {
        await ctx.modelNestedColumnRepository.updateOne(
          col.id,
          nestedColumnMetadata,
        );
      }
    }
  }

  // list views
  public async listViews(_root: any, _args: any, ctx: IContext) {
    const { id } = await ctx.projectService.getCurrentProject();
    const views = await ctx.viewRepository.findAllBy({ projectId: id });
    return views.map((view) => ({
      ...view,
      displayName: view.properties
        ? JSON.parse(view.properties)?.displayName
        : view.name,
    }));
  }

  public async getView(_root: any, args: any, ctx: IContext) {
    const viewId = args.where.id;
    const view = await ctx.viewRepository.findOneBy({ id: viewId });
    if (!view) {
      throw new Error('View not found');
    }
    const displayName = view.properties
      ? JSON.parse(view.properties)?.displayName
      : view.name;
    return { ...view, displayName };
  }

  // validate a view name
  public async validateView(_root: any, args: any, ctx: IContext) {
    const { name } = args.data;
    return this.validateViewName(name, ctx);
  }

  // create view from sql of a response
  public async createView(_root: any, args: any, ctx: IContext) {
    const { name: displayName, responseId } = args.data;

    // validate view name
    const validateResult = await this.validateViewName(displayName, ctx);
    if (!validateResult.valid) {
      throw new Error(validateResult.message);
    }

    // create view
    const project = await ctx.projectService.getCurrentProject();
    const { manifest } = await ctx.deployService.getLastDeployment(project.id);

    // get sql statement of a response
    const response = await ctx.askingService.getResponse(responseId);
    if (!response) {
      throw new Error(`Thread response ${responseId} not found`);
    }

    // construct cte sql and format it
    const statement = format(response.sql);

    // describe columns
    const { columns } = await ctx.queryService.describeStatement(statement, {
      project,
      limit: 1,
      modelingOnly: false,
      manifest,
    });

    if (isEmpty(columns)) {
      throw new Error('Failed to describe statement');
    }

    // properties
    const properties = {
      displayName,
      columns,

      // properties from the thread response
      responseId, // helpful for mapping back to the thread response
      question: response.question,
    };

    const eventName = TelemetryEvent.HOME_CREATE_VIEW;
    const eventProperties = {
      statement,
      displayName,
    };
    // create view
    try {
      const name = replaceAllowableSyntax(displayName);
      const view = await ctx.viewRepository.createOne({
        projectId: project.id,
        name,
        statement,
        properties: JSON.stringify(properties),
      });

      // telemetry
      ctx.telemetry.sendEvent(eventName, eventProperties);

      return { ...view, displayName };
    } catch (err: any) {
      ctx.telemetry.sendEvent(
        eventName,
        {
          ...eventProperties,
          error: err,
        },
        err.extensions?.service,
        false,
      );

      throw err;
    }
  }

  // delete view
  public async deleteView(_root: any, args: any, ctx: IContext) {
    const viewId = args.where.id;
    const view = await ctx.viewRepository.findOneBy({ id: viewId });
    if (!view) {
      throw new Error('View not found');
    }
    await ctx.viewRepository.deleteOne(viewId);
    return true;
  }

  public async previewModelData(_root: any, args: any, ctx: IContext) {
    const modelId = args.where.id;
    const model = await ctx.modelRepository.findOneBy({ id: modelId });
    if (!model) {
      throw new Error('Model not found');
    }
    const project = await ctx.projectService.getCurrentProject();
    const { manifest } = await ctx.mdlService.makeCurrentModelMDL();
    const modelColumns = await ctx.modelColumnRepository.findColumnsByModelIds([
      model.id,
    ]);
    const sql = `select ${getPreviewColumnsStr(modelColumns)} from "${model.referenceName}"`;

    const data = (await ctx.queryService.preview(sql, {
      project,
      modelingOnly: false,
      manifest,
    })) as PreviewDataResponse;

    return data;
  }

  public async previewViewData(_root: any, args: any, ctx: IContext) {
    const { id: viewId, limit } = args.where;
    const view = await ctx.viewRepository.findOneBy({ id: viewId });
    if (!view) {
      throw new Error('View not found');
    }
    const { manifest } = await ctx.mdlService.makeCurrentModelMDL();
    const project = await ctx.projectService.getCurrentProject();

    const data = (await ctx.queryService.preview(view.statement, {
      project,
      limit,
      manifest,
      modelingOnly: false,
    })) as PreviewDataResponse;
    return data;
  }

  // Notice: this is used by AI service.
  // any change to this resolver should be synced with AI service.
  public async previewSql(
    _root: any,
    args: { data: PreviewSQLData },
    ctx: IContext,
  ) {
    const { sql, projectId, limit, dryRun } = args.data;
    const project = projectId
      ? await ctx.projectService.getProjectById(parseInt(projectId))
      : await ctx.projectService.getCurrentProject();
    const { manifest } = await ctx.deployService.getLastDeployment(project.id);
    return await ctx.queryService.preview(sql, {
      project,
      limit: limit,
      modelingOnly: false,
      manifest,
      dryRun,
    });
  }

  public async getNativeSql(
    _root: any,
    args: { responseId: number },
    ctx: IContext,
  ): Promise<string> {
    const { responseId } = args;

    // If using a sample dataset, native SQL is not supported
    const project = await ctx.projectService.getCurrentProject();
    if (project.sampleDataset) {
      throw new Error(`Doesn't support Native SQL`);
    }
    const { manifest } = await ctx.mdlService.makeCurrentModelMDL();

    // get sql statement of a response
    const response = await ctx.askingService.getResponse(responseId);
    if (!response) {
      throw new Error(`Thread response ${responseId} not found`);
    }

    // construct cte sql and format it
    let nativeSql: string;
    if (project.type === DataSourceName.DUCKDB) {
      logger.info(`Getting native sql from wren engine`);
      nativeSql = await ctx.wrenEngineAdaptor.getNativeSQL(response.sql, {
        manifest,
        modelingOnly: false,
      });
    } else {
      logger.info(`Getting native sql from ibis server`);
      nativeSql = await ctx.ibisServerAdaptor.getNativeSql({
        dataSource: project.type,
        sql: response.sql,
        mdl: manifest,
      });
    }
    const language = project.type === DataSourceName.MSSQL ? 'tsql' : undefined;
    return format(nativeSql, { language });
  }

  public async updateViewMetadata(
    _root: any,
    args: { where: { id: number }; data: UpdateViewMetadataInput },
    ctx: IContext,
  ): Promise<boolean> {
    const viewId = args.where.id;
    const data = args.data;

    // check if view exists
    const view = await ctx.viewRepository.findOneBy({ id: viewId });
    if (!view) {
      throw new Error('View not found');
    }

    // update view metadata
    const properties = JSON.parse(view.properties);
    let newName = view.name;
    // if displayName is not null, or undefined, update the displayName
    if (!isNil(data.displayName)) {
      await this.validateViewName(data.displayName, ctx, viewId);
      newName = replaceAllowableSyntax(data.displayName);
      properties.displayName = this.determineMetadataValue(data.displayName);
    }

    // if description is not null, or undefined, update the description in properties
    if (!isNil(data.description)) {
      properties.description = this.determineMetadataValue(data.description);
    }

    // view column metadata
    if (!isEmpty(data.columns)) {
      const viewColumns = properties.columns;
      for (const col of viewColumns) {
        const requestedMetadata = data.columns.find(
          (c) => c.referenceName === col.name,
        );

        if (!isNil(requestedMetadata.description)) {
          col.properties = col.properties || {};
          col.properties.description = this.determineMetadataValue(
            requestedMetadata.description,
          );
        }
      }

      properties.columns = viewColumns;
    }

    await ctx.viewRepository.updateOne(viewId, {
      name: newName,
      properties: JSON.stringify(properties),
    });

    return true;
  }

  private determineMetadataValue(value: string) {
    // if it's empty string, meaning users want to remove the value
    // so we return null
    if (value === '') {
      return null;
    }

    // otherwise, return the value
    return value;
  }

  // validate view name
  private async validateViewName(
    viewDisplayName: string,
    ctx: IContext,
    selfView?: number,
  ): Promise<{ valid: boolean; message?: string }> {
    // check if view name is valid
    // a-z, A-Z, 0-9, _, - are allowed and cannot start with number
    const { valid, message } = validateDisplayName(viewDisplayName);
    if (!valid) {
      return {
        valid: false,
        message,
      };
    }
    const referenceName = replaceAllowableSyntax(viewDisplayName);
    // check if view name is duplicated
    const { id } = await ctx.projectService.getCurrentProject();
    const views = await ctx.viewRepository.findAllBy({ projectId: id });
    if (views.find((v) => v.name === referenceName && v.id !== selfView)) {
      return {
        valid: false,
        message: `Generated view name "${referenceName}" is duplicated`,
      };
    }

    return {
      valid: true,
    };
  }

  private validateTableExist(
    tableName: string,
    dataSourceTables: CompactTable[],
  ) {
    if (!dataSourceTables.find((c) => c.name === tableName)) {
      throw new Error(`Table ${tableName} not found in the data Source`);
    }
  }

  private validateColumnsExist(
    tableName: string,
    fields: string[],
    dataSourceTables: CompactTable[],
  ) {
    const tableColumns = dataSourceTables.find(
      (c) => c.name === tableName,
    )?.columns;
    for (const field of fields) {
      if (!tableColumns.find((c) => c.name === field)) {
        throw new Error(
          `Column "${field}" not found in table "${tableName}" in the data Source`,
        );
      }
    }
  }
}
</file>

<file path="src/apollo/server/resolvers/projectResolver.ts">
import {
  AnalysisRelationInfo,
  DataSource,
  DataSourceName,
  DataSourceProperties,
  IContext,
  RelationData,
  RelationType,
  SampleDatasetData,
} from '../types';
import {
  trim,
  getLogger,
  replaceInvalidReferenceName,
  transformInvalidColumnName,
  handleNestedColumns,
} from '@server/utils';
import {
  DUCKDB_CONNECTION_INFO,
  Model,
  ModelColumn,
  Project,
} from '../repositories';
import {
  SampleDatasetName,
  SampleDatasetRelationship,
  buildInitSql,
  getRelations,
  sampleDatasets,
} from '@server/data';
import { snakeCase } from 'lodash';
import { CompactTable, ProjectData } from '../services';
import { DuckDBPrepareOptions } from '@server/adaptors/wrenEngineAdaptor';
import DataSourceSchemaDetector, {
  SchemaChangeType,
} from '@server/managers/dataSourceSchemaDetector';
import { encryptConnectionInfo } from '../dataSource';
import { TelemetryEvent } from '../telemetry/telemetry';

const logger = getLogger('DataSourceResolver');
logger.level = 'debug';

export enum OnboardingStatusEnum {
  NOT_STARTED = 'NOT_STARTED',
  DATASOURCE_SAVED = 'DATASOURCE_SAVED',
  ONBOARDING_FINISHED = 'ONBOARDING_FINISHED',
  WITH_SAMPLE_DATASET = 'WITH_SAMPLE_DATASET',
}

export class ProjectResolver {
  constructor() {
    this.getSettings = this.getSettings.bind(this);
    this.updateCurrentProject = this.updateCurrentProject.bind(this);
    this.resetCurrentProject = this.resetCurrentProject.bind(this);
    this.saveDataSource = this.saveDataSource.bind(this);
    this.updateDataSource = this.updateDataSource.bind(this);
    this.listDataSourceTables = this.listDataSourceTables.bind(this);
    this.saveTables = this.saveTables.bind(this);
    this.autoGenerateRelation = this.autoGenerateRelation.bind(this);
    this.saveRelations = this.saveRelations.bind(this);
    this.getOnboardingStatus = this.getOnboardingStatus.bind(this);
    this.startSampleDataset = this.startSampleDataset.bind(this);
    this.triggerDataSourceDetection =
      this.triggerDataSourceDetection.bind(this);
    this.getSchemaChange = this.getSchemaChange.bind(this);
    this.getProjectRecommendationQuestions =
      this.getProjectRecommendationQuestions.bind(this);
  }

  public async getSettings(_root: any, _arg: any, ctx: IContext) {
    const project = await ctx.projectService.getCurrentProject();
    const generalConnectionInfo =
      ctx.projectService.getGeneralConnectionInfo(project);
    const dataSourceType = project.type;

    return {
      productVersion: ctx.config.wrenProductVersion || '',
      dataSource: {
        type: dataSourceType,
        properties: {
          displayName: project.displayName,
          ...generalConnectionInfo,
        } as DataSourceProperties,
        sampleDataset: project.sampleDataset,
      },
      language: project.language,
    };
  }

  public async getProjectRecommendationQuestions(
    _root: any,
    _arg: any,
    ctx: IContext,
  ) {
    return ctx.projectService.getProjectRecommendationQuestions();
  }

  public async updateCurrentProject(
    _root: any,
    arg: { data: { language: string } },
    ctx: IContext,
  ) {
    const { language } = arg.data;
    const project = await ctx.projectService.getCurrentProject();
    await ctx.projectRepository.updateOne(project.id, {
      language,
    });

    // only generating for user's data source
    if (project.sampleDataset === null) {
      await ctx.projectService.generateProjectRecommendationQuestions();
    }
    return true;
  }

  public async resetCurrentProject(_root: any, _arg: any, ctx: IContext) {
    let project;
    try {
      project = await ctx.projectService.getCurrentProject();
    } catch {
      // no project found
      return true;
    }
    const eventName = TelemetryEvent.SETTING_RESET_PROJECT;
    try {
      const id = project.id;
      await ctx.schemaChangeRepository.deleteAllBy({ projectId: id });
      await ctx.deployService.deleteAllByProjectId(id);
      await ctx.askingService.deleteAllByProjectId(id);
      await ctx.modelService.deleteAllViewsByProjectId(id);
      await ctx.modelService.deleteAllModelsByProjectId(id);
      await ctx.projectService.deleteProject(id);
      await ctx.wrenAIAdaptor.delete(id);

      // telemetry
      ctx.telemetry.sendEvent(eventName, {
        projectId: id,
        dataSourceType: project.type,
      });
    } catch (err: any) {
      ctx.telemetry.sendEvent(
        eventName,
        { dataSourceType: project.type, error: err.message },
        err.extensions?.service,
        false,
      );
      throw err;
    }

    return true;
  }

  public async startSampleDataset(
    _root: any,
    _arg: { data: SampleDatasetData },
    ctx: IContext,
  ) {
    const { name } = _arg.data;
    const dataset = sampleDatasets[snakeCase(name)];
    if (!dataset) {
      throw new Error('Sample dataset not found');
    }
    if (!(name in SampleDatasetName)) {
      throw new Error('Invalid sample dataset name');
    }
    const eventName = TelemetryEvent.CONNECTION_START_SAMPLE_DATASET;
    const eventProperties = {
      datasetName: name,
    };
    try {
      // create duckdb datasource
      const initSql = buildInitSql(name as SampleDatasetName);
      const duckdbDatasourceProperties = {
        initSql,
        extensions: [],
        configurations: {},
      };
      await this.saveDataSource(
        _root,
        {
          data: {
            type: DataSourceName.DUCKDB,
            properties: duckdbDatasourceProperties,
          } as DataSource,
        },
        ctx,
      );
      const project = await ctx.projectService.getCurrentProject();

      // list all the tables in the data source
      const tables = await this.listDataSourceTables(_root, _arg, ctx);
      const tableNames = tables.map((table) => table.name);

      // save tables as model and modelColumns
      await this.overwriteModelsAndColumns(tableNames, ctx, project);

      await ctx.modelService.updatePrimaryKeys(dataset.tables);
      await ctx.modelService.batchUpdateModelProperties(dataset.tables);
      await ctx.modelService.batchUpdateColumnProperties(dataset.tables);

      // save relations
      const relations = getRelations(name as SampleDatasetName);
      const models = await ctx.modelRepository.findAll();
      const columns = await ctx.modelColumnRepository.findAll();
      const mappedRelations = this.buildRelationInput(
        relations,
        models,
        columns,
      );
      await ctx.modelService.saveRelations(mappedRelations);

      // mark current project as using sample dataset
      await ctx.projectRepository.updateOne(project.id, {
        sampleDataset: name,
      });
      await this.deploy(ctx);
      // telemetry
      ctx.telemetry.sendEvent(eventName, eventProperties);
      return { name };
    } catch (err: any) {
      ctx.telemetry.sendEvent(
        eventName,
        { ...eventProperties, error: err.message },
        err.extensions?.service,
        false,
      );
      throw err;
    }
  }

  public async getOnboardingStatus(_root: any, _arg: any, ctx: IContext) {
    let project: Project | null;
    try {
      project = await ctx.projectRepository.getCurrentProject();
    } catch (_err: any) {
      return {
        status: OnboardingStatusEnum.NOT_STARTED,
      };
    }
    const { id, sampleDataset } = project;
    if (sampleDataset) {
      return {
        status: OnboardingStatusEnum.WITH_SAMPLE_DATASET,
      };
    }
    const models = await ctx.modelRepository.findAllBy({ projectId: id });
    if (!models.length) {
      return {
        status: OnboardingStatusEnum.DATASOURCE_SAVED,
      };
    } else {
      return {
        status: OnboardingStatusEnum.ONBOARDING_FINISHED,
      };
    }
  }

  public async saveDataSource(
    _root: any,
    args: {
      data: DataSource;
    },
    ctx: IContext,
  ) {
    const { type, properties } = args.data;
    // Currently only can create one project
    await this.resetCurrentProject(_root, args, ctx);

    const { displayName, ...connectionInfo } = properties;
    const project = await ctx.projectService.createProject({
      displayName,
      type,
      connectionInfo,
    } as ProjectData);
    logger.debug(`Project created.`);

    // init dashboard
    logger.debug('Dashboard init...');
    await ctx.dashboardService.initDashboard();
    logger.debug('Dashboard created.');

    const eventName = TelemetryEvent.CONNECTION_SAVE_DATA_SOURCE;
    const eventProperties = {
      dataSourceType: type,
    };

    // try to connect to the data source
    try {
      // handle duckdb connection
      if (type === DataSourceName.DUCKDB) {
        connectionInfo as DUCKDB_CONNECTION_INFO;
        await this.buildDuckDbEnvironment(ctx, {
          initSql: connectionInfo.initSql,
          extensions: connectionInfo.extensions,
          configurations: connectionInfo.configurations,
        });
      } else {
        // handle other data source
        await ctx.projectService.getProjectDataSourceTables(project);
        const version =
          await ctx.projectService.getProjectDataSourceVersion(project);
        await ctx.projectService.updateProject(project.id, {
          version,
        });
        logger.debug(`Data source tables fetched`);
      }
      // telemetry
      ctx.telemetry.sendEvent(eventName, eventProperties);
    } catch (err) {
      logger.error(
        'Failed to get project tables',
        JSON.stringify(err, null, 2),
      );
      await ctx.projectRepository.deleteOne(project.id);
      ctx.telemetry.sendEvent(
        eventName,
        { eventProperties, error: err.message },
        err.extensions?.service,
        false,
      );
      throw err;
    }

    return {
      type: project.type,
      properties: {
        displayName: project.displayName,
        ...ctx.projectService.getGeneralConnectionInfo(project),
      },
    };
  }

  public async updateDataSource(
    _root: any,
    args: { data: DataSource },
    ctx: IContext,
  ) {
    const { properties } = args.data;
    const { displayName, ...connectionInfo } = properties;
    const project = await ctx.projectService.getCurrentProject();
    const dataSourceType = project.type;

    // only new connection info needed to encrypt
    const toUpdateConnectionInfo = encryptConnectionInfo(
      dataSourceType,
      connectionInfo as any,
    );

    if (dataSourceType === DataSourceName.DUCKDB) {
      // prepare duckdb environment in wren-engine
      const { initSql, extensions, configurations } =
        toUpdateConnectionInfo as DUCKDB_CONNECTION_INFO;
      await this.buildDuckDbEnvironment(ctx, {
        initSql,
        extensions,
        configurations,
      });
    } else {
      const updatedProject = {
        ...project,
        displayName,
        connectionInfo: {
          ...project.connectionInfo,
          ...toUpdateConnectionInfo,
        },
      } as Project;

      await ctx.projectService.getProjectDataSourceTables(updatedProject);
      logger.debug(`Data source tables fetched`);
    }
    const updatedProject = await ctx.projectRepository.updateOne(project.id, {
      displayName,
      connectionInfo: { ...project.connectionInfo, ...toUpdateConnectionInfo },
    });
    return {
      type: updatedProject.type,
      properties: {
        displayName: updatedProject.displayName,
        ...ctx.projectService.getGeneralConnectionInfo(updatedProject),
      },
    };
  }

  public async listDataSourceTables(_root: any, _arg, ctx: IContext) {
    return await ctx.projectService.getProjectDataSourceTables();
  }

  public async saveTables(
    _root: any,
    arg: {
      data: { tables: string[] };
    },
    ctx: IContext,
  ) {
    const eventName = TelemetryEvent.CONNECTION_SAVE_TABLES;

    // get current project
    const project = await ctx.projectService.getCurrentProject();
    try {
      // delete existing models and columns
      const { models, columns } = await this.overwriteModelsAndColumns(
        arg.data.tables,
        ctx,
        project,
      );
      // telemetry
      ctx.telemetry.sendEvent(eventName, {
        dataSourceType: project.type,
        tablesCount: models.length,
        columnsCount: columns.length,
      });

      // async deploy to wren-engine and ai service
      this.deploy(ctx);
      return { models: models, columns };
    } catch (err: any) {
      ctx.telemetry.sendEvent(
        eventName,
        { dataSourceType: project.type, error: err.message },
        err.extensions?.service,
        false,
      );
      throw err;
    }
  }

  public async autoGenerateRelation(_root: any, _arg: any, ctx: IContext) {
    const project = await ctx.projectService.getCurrentProject();

    // get models and columns
    const models = await ctx.modelRepository.findAllBy({
      projectId: project.id,
    });
    const modelIds = models.map((m) => m.id);
    const columns =
      await ctx.modelColumnRepository.findColumnsByModelIds(modelIds);
    const constraints =
      await ctx.projectService.getProjectSuggestedConstraint(project);

    // generate relation
    const relations = [];
    for (const constraint of constraints) {
      const {
        constraintTable,
        constraintColumn,
        constraintedTable,
        constraintedColumn,
      } = constraint;
      // validate tables and columns exists in our models and model columns
      const fromModel = models.find(
        (m) => m.sourceTableName === constraintTable,
      );
      const toModel = models.find(
        (m) => m.sourceTableName === constraintedTable,
      );
      if (!fromModel || !toModel) {
        continue;
      }
      const fromColumn = columns.find(
        (c) =>
          c.modelId === fromModel.id && c.sourceColumnName === constraintColumn,
      );
      const toColumn = columns.find(
        (c) =>
          c.modelId === toModel.id && c.sourceColumnName === constraintedColumn,
      );
      if (!fromColumn || !toColumn) {
        continue;
      }
      // create relation
      const relation: AnalysisRelationInfo = {
        // upper case the first letter of the sourceTableName
        name: constraint.constraintName,
        fromModelId: fromModel.id,
        fromModelReferenceName: fromModel.referenceName,
        fromColumnId: fromColumn.id,
        fromColumnReferenceName: fromColumn.referenceName,
        toModelId: toModel.id,
        toModelReferenceName: toModel.referenceName,
        toColumnId: toColumn.id,
        toColumnReferenceName: toColumn.referenceName,
        // TODO: add join type
        type: RelationType.ONE_TO_MANY,
      };
      relations.push(relation);
    }
    // group by model
    return models.map(({ id, displayName, referenceName }) => ({
      id,
      displayName,
      referenceName,
      relations: relations.filter(
        (relation) =>
          relation.fromModelId === id &&
          // exclude self-referential relationship
          relation.toModelId !== relation.fromModelId,
      ),
    }));
  }

  public async saveRelations(
    _root: any,
    arg: { data: { relations: RelationData[] } },
    ctx: IContext,
  ) {
    const eventName = TelemetryEvent.CONNECTION_SAVE_RELATION;
    try {
      const savedRelations = await ctx.modelService.saveRelations(
        arg.data.relations,
      );
      // async deploy
      this.deploy(ctx);
      ctx.telemetry.sendEvent(eventName, {
        relationCount: savedRelations.length,
      });
      return savedRelations;
    } catch (err: any) {
      ctx.telemetry.sendEvent(
        eventName,
        { error: err.message },
        err.extensions?.service,
        false,
      );
      throw err;
    }
  }

  public async getSchemaChange(_root: any, _arg: any, ctx: IContext) {
    const project = await ctx.projectService.getCurrentProject();
    const lastSchemaChange =
      await ctx.schemaChangeRepository.findLastSchemaChange(project.id);

    if (!lastSchemaChange) {
      return {
        deletedTables: null,
        deletedColumns: null,
        modifiedColumns: null,
        lastSchemaChangeTime: null,
      };
    }

    const models = await ctx.modelRepository.findAllBy({
      projectId: project.id,
    });
    const modelIds = models.map((model) => model.id);
    const modelColumns =
      await ctx.modelColumnRepository.findColumnsByModelIds(modelIds);

    const modelRelationships = await ctx.relationRepository.findRelationInfoBy({
      modelIds,
    });

    const schemaDetector = new DataSourceSchemaDetector({
      ctx,
      projectId: project.id,
    });

    const resolves = lastSchemaChange.resolve;
    const unresolvedChanges = Object.keys(resolves).reduce((result, key) => {
      const isResolved = resolves[key];
      const changes = lastSchemaChange.change[key];
      // return if resolved or no changes
      if (isResolved || !changes) return result;

      // Mapping with affected models and columns and affected calculated fields and relationships data into schema change
      const affecteds = schemaDetector.getAffectedResources(changes, {
        models,
        modelColumns,
        modelRelationships,
      });

      const affectedChanges = affecteds.length ? affecteds : null;
      return { ...result, [key]: affectedChanges };
    }, {});

    return {
      ...unresolvedChanges,
      lastSchemaChangeTime: lastSchemaChange.createdAt,
    };
  }

  public async triggerDataSourceDetection(
    _root: any,
    _arg: any,
    ctx: IContext,
  ) {
    const project = await ctx.projectService.getCurrentProject();
    const schemaDetector = new DataSourceSchemaDetector({
      ctx,
      projectId: project.id,
    });
    const eventName = TelemetryEvent.MODELING_DETECT_SCHEMA_CHANGE;
    try {
      const hasSchemaChange = await schemaDetector.detectSchemaChange();
      ctx.telemetry.sendEvent(eventName, { hasSchemaChange });
      return hasSchemaChange;
    } catch (error: any) {
      ctx.telemetry.sendEvent(
        eventName,
        { error },
        error.extensions?.service,
        false,
      );
      throw error;
    }
  }

  public async resolveSchemaChange(
    _root: any,
    arg: { where: { type: SchemaChangeType } },
    ctx: IContext,
  ) {
    const { type } = arg.where;
    const project = await ctx.projectService.getCurrentProject();
    const schemaDetector = new DataSourceSchemaDetector({
      ctx,
      projectId: project.id,
    });
    const eventName = TelemetryEvent.MODELING_RESOLVE_SCHEMA_CHANGE;
    try {
      await schemaDetector.resolveSchemaChange(type);
      ctx.telemetry.sendEvent(eventName, { type });
    } catch (error) {
      ctx.telemetry.sendEvent(
        eventName,
        { type, error },
        error.extensions?.service,
        false,
      );
      throw error;
    }
    return true;
  }

  private async deploy(ctx: IContext) {
    const project = await ctx.projectService.getCurrentProject();
    const { manifest } = await ctx.mdlService.makeCurrentModelMDL();
    const deployRes = await ctx.deployService.deploy(manifest, project.id);

    // only generating for user's data source
    if (project.sampleDataset === null) {
      await ctx.projectService.generateProjectRecommendationQuestions();
    }
    return deployRes;
  }

  private buildRelationInput(
    relations: SampleDatasetRelationship[],
    models: Model[],
    columns: ModelColumn[],
  ) {
    const relationInput = relations.map((relation) => {
      const { fromModelName, fromColumnName, toModelName, toColumnName, type } =
        relation;
      const fromModelId = models.find(
        (model) => model.sourceTableName === fromModelName,
      )?.id;
      const toModelId = models.find(
        (model) => model.sourceTableName === toModelName,
      )?.id;
      if (!fromModelId || !toModelId) {
        throw new Error(
          `Model not found, fromModelName "${fromModelName}" to toModelName: "${toModelName}"`,
        );
      }

      const fromColumnId = columns.find(
        (column) =>
          column.referenceName === fromColumnName &&
          column.modelId === fromModelId,
      )?.id;
      const toColumnId = columns.find(
        (column) =>
          column.referenceName === toColumnName && column.modelId === toModelId,
      )?.id;
      if (!fromColumnId || !toColumnId) {
        throw new Error(
          `Column not found fromColumnName: ${fromColumnName} toColumnName: ${toColumnName}`,
        );
      }
      return {
        fromModelId,
        fromColumnId,
        toModelId,
        toColumnId,
        type,
        description: relation.description,
      } as RelationData;
    });
    return relationInput;
  }

  private async overwriteModelsAndColumns(
    tables: string[],
    ctx: IContext,
    project: Project,
  ) {
    // delete existing models and columns
    await ctx.modelService.deleteAllModelsByProjectId(project.id);

    const compactTables: CompactTable[] =
      await ctx.projectService.getProjectDataSourceTables(project);

    const selectedTables = compactTables.filter((table) =>
      tables.includes(table.name),
    );

    // create models
    const modelValues = selectedTables.map((table) => {
      const properties = table?.properties;
      // compactTable contain schema and catalog, these information are for building tableReference in mdl
      const model = {
        projectId: project.id,
        displayName: table.name, // use table name as displayName, referenceName and tableName
        referenceName: replaceInvalidReferenceName(table.name),
        sourceTableName: table.name,
        cached: false,
        refreshTime: null,
        properties: properties ? JSON.stringify(properties) : null,
      } as Partial<Model>;
      return model;
    });
    const models = await ctx.modelRepository.createMany(modelValues);

    // create columns
    const columnValues = selectedTables.flatMap((table) => {
      const compactColumns = table.columns;
      const primaryKey = table.primaryKey;
      const model = models.find((m) => m.sourceTableName === table.name);
      return compactColumns.map(
        (column) =>
          ({
            modelId: model.id,
            isCalculated: false,
            displayName: column.name,
            referenceName: transformInvalidColumnName(column.name),
            sourceColumnName: column.name,
            type: column.type || 'string',
            notNull: column.notNull || false,
            isPk: primaryKey === column.name,
            properties: column.properties
              ? JSON.stringify(column.properties)
              : null,
          }) as Partial<ModelColumn>,
      );
    });
    const columns = await ctx.modelColumnRepository.createMany(columnValues);

    // create nested columns
    const compactColumns = selectedTables.flatMap((table) => table.columns);
    const nestedColumnValues = compactColumns.flatMap((compactColumn) => {
      const column = columns.find(
        (c) => c.sourceColumnName === compactColumn.name,
      );
      return handleNestedColumns(compactColumn, {
        modelId: column.modelId,
        columnId: column.id,
        sourceColumnName: column.sourceColumnName,
      });
    });
    await ctx.modelNestedColumnRepository.createMany(nestedColumnValues);

    return { models, columns };
  }

  private concatInitSql(initSql: string, extensions: string[]) {
    const installExtensions = extensions
      .map((ext) => `INSTALL ${ext};`)
      .join('\n');
    return trim(`${installExtensions}\n${initSql}`);
  }

  private async buildDuckDbEnvironment(
    ctx: IContext,
    options: {
      initSql: string;
      extensions: string[];
      configurations: Record<string, any>;
    },
  ): Promise<void> {
    const { initSql, extensions, configurations } = options;
    const initSqlWithExtensions = this.concatInitSql(initSql, extensions);
    await ctx.wrenEngineAdaptor.prepareDuckDB({
      sessionProps: configurations,
      initSql: initSqlWithExtensions,
    } as DuckDBPrepareOptions);

    // check can list dataset table
    await ctx.wrenEngineAdaptor.listTables();

    // patch wren-engine config
    const config = {
      'wren.datasource.type': 'duckdb',
    };
    await ctx.wrenEngineAdaptor.patchConfig(config);
  }
}
</file>

<file path="src/apollo/server/resolvers/sqlPairResolver.ts">
import { IContext } from '@server/types/context';
import { SqlPair } from '@server/repositories';
import * as Errors from '@server/utils/error';
import { TelemetryEvent, TrackTelemetry } from '@server/telemetry/telemetry';
import { DialectSQL, WrenSQL } from '@server/models/adaptor';
import { format } from 'sql-formatter';

export class SqlPairResolver {
  constructor() {
    this.getProjectSqlPairs = this.getProjectSqlPairs.bind(this);
    this.createSqlPair = this.createSqlPair.bind(this);
    this.updateSqlPair = this.updateSqlPair.bind(this);
    this.deleteSqlPair = this.deleteSqlPair.bind(this);
    this.generateQuestion = this.generateQuestion.bind(this);
    this.modelSubstitute = this.modelSubstitute.bind(this);
  }

  public async getProjectSqlPairs(
    _root: unknown,
    _arg: any,
    ctx: IContext,
  ): Promise<SqlPair[]> {
    const project = await ctx.projectService.getCurrentProject();
    return ctx.sqlPairService.getProjectSqlPairs(project.id);
  }

  @TrackTelemetry(TelemetryEvent.KNOWLEDGE_CREATE_SQL_PAIR)
  public async createSqlPair(
    _root: unknown,
    arg: {
      data: {
        sql: string;
        question: string;
      };
    },
    ctx: IContext,
  ): Promise<SqlPair> {
    const project = await ctx.projectService.getCurrentProject();
    await this.validateSql(arg.data.sql, ctx);
    return await ctx.sqlPairService.createSqlPair(project.id, arg.data);
  }

  @TrackTelemetry(TelemetryEvent.KNOWLEDGE_UPDATE_SQL_PAIR)
  public async updateSqlPair(
    _root: unknown,
    arg: {
      data: {
        sql?: string;
        question?: string;
      };
      where: {
        id: number;
      };
    },
    ctx: IContext,
  ): Promise<SqlPair> {
    const project = await ctx.projectService.getCurrentProject();
    await this.validateSql(arg.data.sql, ctx);
    return ctx.sqlPairService.editSqlPair(project.id, arg.where.id, arg.data);
  }

  @TrackTelemetry(TelemetryEvent.KNOWLEDGE_DELETE_SQL_PAIR)
  public async deleteSqlPair(
    _root: unknown,
    arg: {
      where: {
        id: number;
      };
    },
    ctx: IContext,
  ): Promise<boolean> {
    const project = await ctx.projectService.getCurrentProject();
    return ctx.sqlPairService.deleteSqlPair(project.id, arg.where.id);
  }

  public async generateQuestion(
    _root: unknown,
    arg: {
      data: {
        sql: string;
      };
    },
    ctx: IContext,
  ) {
    const project = await ctx.projectService.getCurrentProject();
    const questions = await ctx.sqlPairService.generateQuestions(project, [
      arg.data.sql,
    ]);
    return questions[0];
  }

  public async modelSubstitute(
    _root: unknown,
    arg: {
      data: {
        sql: DialectSQL;
      };
    },
    ctx: IContext,
  ): Promise<WrenSQL> {
    const project = await ctx.projectService.getCurrentProject();
    const lastDeployment = await ctx.deployService.getLastDeployment(
      project.id,
    );
    const manifest = lastDeployment.manifest;

    const wrenSQL = await ctx.sqlPairService.modelSubstitute(
      arg.data.sql as DialectSQL,
      {
        project,
        manifest,
      },
    );
    return format(wrenSQL, { language: 'postgresql' }) as WrenSQL;
  }

  private async validateSql(sql: string, ctx: IContext) {
    const project = await ctx.projectService.getCurrentProject();
    const lastDeployment = await ctx.deployService.getLastDeployment(
      project.id,
    );
    const manifest = lastDeployment.manifest;
    try {
      await ctx.queryService.preview(sql, {
        manifest,
        project,
        dryRun: true,
      });
    } catch (err) {
      throw Errors.create(Errors.GeneralErrorCodes.INVALID_SQL_ERROR, {
        customMessage: err.message,
      });
    }
  }

  public getSqlPairNestedResolver = () => ({
    createdAt: (sqlPair: SqlPair, _args: any, _ctx: IContext) => {
      return new Date(sqlPair.createdAt).toISOString();
    },
    updatedAt: (sqlPair: SqlPair, _args: any, _ctx: IContext) => {
      return new Date(sqlPair.updatedAt).toISOString();
    },
  });
}
</file>

<file path="src/apollo/server/scalars.ts">
import { GraphQLScalarType } from 'graphql';
import { DialectSQL } from '@server/models/adaptor';

export const DialectSQLScalar = new GraphQLScalarType({
  name: 'DialectSQL',
  description: 'A string representing a SQL query in a specific dialect',
  serialize(value: unknown): string {
    if (typeof value !== 'string') {
      throw new Error('DialectSQL must be a string');
    }
    return value;
  },
  parseValue(value: unknown): DialectSQL {
    if (typeof value !== 'string') {
      throw new Error('DialectSQL must be a string');
    }
    return value as DialectSQL;
  },
  parseLiteral(ast: any): DialectSQL {
    if (ast.kind !== 'StringValue') {
      throw new Error('DialectSQL must be a string');
    }
    return ast.value as DialectSQL;
  },
});
</file>

<file path="src/apollo/server/schema.ts">
import { gql } from 'apollo-server-micro';

export const typeDefs = gql`
  scalar JSON
  scalar DialectSQL

  enum ApiType {
    GENERATE_SQL
    RUN_SQL
    GENERATE_VEGA_CHART
  }

  input ApiHistoryFilterInput {
    apiType: ApiType
    statusCode: Int
    threadId: String
    projectId: Int
    startDate: String
    endDate: String
  }

  input ApiHistoryPaginationInput {
    offset: Int!
    limit: Int!
  }

  type ApiHistoryResponse {
    id: String!
    projectId: Int!
    apiType: ApiType!
    threadId: String
    headers: JSON
    requestPayload: JSON
    responsePayload: JSON
    statusCode: Int
    durationMs: Int
    createdAt: String!
    updatedAt: String!
  }

  type ApiHistoryPaginatedResponse {
    items: [ApiHistoryResponse!]!
    total: Int!
    hasMore: Boolean!
  }

  enum DataSourceName {
    ATHENA
    BIG_QUERY
    DUCKDB
    POSTGRES
    MYSQL
    ORACLE
    MSSQL
    CLICK_HOUSE
    TRINO
    SNOWFLAKE
    REDSHIFT
  }

  enum RedshiftConnectionType {
    redshift
    redshift_iam
  }

  enum ExpressionName {
    ABS
    AVG
    COUNT
    COUNT_IF
    MAX
    MIN
    SUM
    CBRT
    CEIL
    CEILING
    EXP
    FLOOR
    LN
    LOG10
    ROUND
    SIGN
    LENGTH
    REVERSE
  }

  enum SampleDatasetName {
    HR
    ECOMMERCE
    NBA
    MUSIC
  }

  enum SyncStatus {
    IN_PROGRESS
    SYNCRONIZED
    UNSYNCRONIZED
  }

  enum SchemaChangeType {
    DELETED_TABLES
    DELETED_COLUMNS
    MODIFIED_COLUMNS
  }

  enum ProjectLanguage {
    EN
    ES
    FR
    ZH_TW
    ZH_CN
    DE
    PT
    RU
    JA
    KO
  }

  type DataSource {
    type: DataSourceName!
    properties: JSON!
    # Show the name if the data source setup comes from a sample
    sampleDataset: SampleDatasetName
  }

  input WhereIdInput {
    id: Int!
  }

  input DataSourceInput {
    type: DataSourceName!
    properties: JSON!
  }

  input SampleDatasetInput {
    name: SampleDatasetName!
  }

  type CompactTable {
    name: String!
    columns: [CompactColumn!]!
    properties: JSON
  }

  input MDLModelSubmitInput {
    name: String!
    columns: [String!]!
  }

  enum RelationType {
    ONE_TO_ONE
    ONE_TO_MANY
    MANY_TO_ONE
  }

  enum OnboardingStatus {
    NOT_STARTED
    DATASOURCE_SAVED
    ONBOARDING_FINISHED
    WITH_SAMPLE_DATASET
  }

  enum NodeType {
    MODEL
    METRIC
    VIEW
    RELATION
    FIELD
    CALCULATED_FIELD
  }

  type Relation {
    fromModelId: Int!
    fromModelReferenceName: String!
    fromColumnId: Int!
    fromColumnReferenceName: String!
    toModelId: Int!
    toModelReferenceName: String!
    toColumnId: Int!
    toColumnReferenceName: String!
    type: RelationType!
    name: String!
  }

  type RecommendRelations {
    id: Int!
    displayName: String!
    referenceName: String!
    relations: [Relation]!
  }

  input RelationInput {
    fromModelId: Int!
    fromColumnId: Int!
    toModelId: Int!
    toColumnId: Int!
    type: RelationType!
  }

  input UpdateRelationInput {
    type: RelationType!
  }

  input SaveRelationInput {
    relations: [RelationInput]!
  }

  input SaveTablesInput {
    tables: [String!]!
  }

  type CompactColumn {
    name: String!
    type: String!
    properties: JSON
  }

  input CustomFieldInput {
    name: String!
    expression: String!
  }

  input CalculatedFieldInput {
    name: String!
    expression: String!
    lineage: [Int!]!
    diagram: JSON
  }

  input CreateModelInput {
    sourceTableName: String!
    fields: [String!]!
    primaryKey: String
  }

  input CreateCalculatedFieldInput {
    modelId: Int!
    name: String!
    expression: ExpressionName!
    lineage: [Int!]!
  }

  input UpdateCalculatedFieldInput {
    name: String!
    expression: ExpressionName!
    lineage: [Int!]!
  }

  input UpdateCalculatedFieldWhere {
    id: Int!
  }

  input ValidateCalculatedFieldInput {
    name: String!
    modelId: Int!
    columnId: Int
  }

  type CalculatedFieldValidationResponse {
    valid: Boolean!
    message: String
  }

  input ModelWhereInput {
    id: Int!
  }

  input UpdateModelInput {
    fields: [String!]!
    primaryKey: String
  }

  # Metadata related
  input UpdateNestedColumnMetadataInput {
    id: Int!
    displayName: String
    description: String
  }

  input UpdateColumnMetadataInput {
    id: Int!
    displayName: String
    description: String
  }

  input UpdateCalculatedFieldMetadataInput {
    id: Int!
    description: String
  }

  input UpdateRelationshipMetadataInput {
    id: Int!
    description: String
  }

  input UpdateViewColumnMetadataInput {
    referenceName: String!
    description: String
  }

  input UpdateModelMetadataInput {
    displayName: String # Model display name, i,e, the alias of the model
    description: String # Model description
    columns: [UpdateColumnMetadataInput!] # Update column metadata
    nestedColumns: [UpdateNestedColumnMetadataInput!] # Update nested column metadata
    calculatedFields: [UpdateCalculatedFieldMetadataInput!] # Update calculated field metadata
    relationships: [UpdateRelationshipMetadataInput!] # Update relationship metadata
  }

  input UpdateViewMetadataInput {
    displayName: String # View display name, i,e, the alias of the view
    description: String # View description
    columns: [UpdateViewColumnMetadataInput!]
  }

  type NestedFieldInfo {
    id: Int!
    displayName: String!
    referenceName: String!
    sourceColumnName: String!
    columnPath: [String!]!
    type: String!
    properties: JSON!
  }

  type FieldInfo {
    id: Int!
    displayName: String!
    referenceName: String!
    sourceColumnName: String!
    type: String
    isCalculated: Boolean!
    notNull: Boolean!
    expression: String
    properties: JSON
    nestedColumns: [NestedFieldInfo!]
  }

  type ModelInfo {
    id: Int!
    displayName: String!
    referenceName: String!
    sourceTableName: String!
    refSql: String
    primaryKey: String
    cached: Boolean!
    refreshTime: String
    description: String
    fields: [FieldInfo]!
    calculatedFields: [FieldInfo]!
    properties: JSON
  }

  type DetailedNestedColumn {
    id: Int!
    displayName: String!
    referenceName: String!
    sourceColumnName: String!
    columnPath: [String!]!
    type: String
    properties: JSON
  }

  type DetailedColumn {
    displayName: String!
    referenceName: String!
    sourceColumnName: String!
    type: String
    isCalculated: Boolean!
    notNull: Boolean!
    properties: JSON!
    nestedColumns: [DetailedNestedColumn!]
  }

  type DetailedRelation {
    fromModelId: Int!
    fromColumnId: Int!
    toModelId: Int!
    toColumnId: Int!
    type: RelationType!
    name: String!
    properties: JSON!
  }

  type DetailedModel {
    displayName: String!
    referenceName: String!
    sourceTableName: String!
    refSql: String!
    primaryKey: String
    cached: Boolean!
    refreshTime: String
    description: String
    fields: [DetailedColumn]
    calculatedFields: [DetailedColumn]
    relations: [DetailedRelation]
    properties: JSON!
  }

  # View
  type ViewInfo {
    id: Int!
    name: String!
    statement: String!
    displayName: String!
  }

  input ViewWhereUniqueInput {
    id: Int!
  }

  input PreviewViewDataInput {
    id: Int!
    # It will return default 500 rows if not specified limit
    # refer: DEFAULT_PREVIEW_LIMIT
    limit: Int
  }

  input CreateViewInput {
    name: String!
    responseId: Int!
  }

  input ValidateViewInput {
    name: String!
  }

  type ViewValidationResponse {
    valid: Boolean!
    message: String
  }

  # onboarding
  type OnboardingStatusResponse {
    status: OnboardingStatus
  }

  type ModelSyncResponse {
    status: SyncStatus!
  }

  type Diagram {
    models: [DiagramModel]!
    views: [DiagramView]!
  }

  type DiagramView {
    id: String!
    viewId: Int!
    nodeType: NodeType!
    statement: String!
    displayName: String!
    referenceName: String!
    fields: [DiagramViewField]!
    description: String
  }

  type DiagramViewField {
    id: String!
    displayName: String!
    referenceName: String!
    type: String!
    nodeType: NodeType!
    description: String
  }

  type DiagramModel {
    id: String!
    modelId: Int!
    nodeType: NodeType!
    displayName: String!
    referenceName: String!
    sourceTableName: String!
    refSql: String
    cached: Boolean!
    refreshTime: String
    description: String
    fields: [DiagramModelField]!
    calculatedFields: [DiagramModelField]!
    relationFields: [DiagramModelRelationField]!
  }

  type DiagramModelNestedField {
    id: String!
    nestedColumnId: Int!
    displayName: String!
    referenceName: String!
    columnPath: [String!]!
    type: String!
    description: String
  }

  type DiagramModelField {
    id: String!
    columnId: Int!
    nodeType: NodeType!
    type: String!
    displayName: String!
    referenceName: String!
    description: String
    isPrimaryKey: Boolean!
    expression: String
    aggregation: String
    lineage: [Int!]
    nestedFields: [DiagramModelNestedField!]
  }

  type DiagramModelRelationField {
    id: String!
    relationId: Int!
    nodeType: NodeType!
    type: RelationType!
    displayName: String!
    referenceName: String!
    description: String
    fromModelId: Int!
    fromModelName: String!
    fromModelDisplayName: String!
    fromColumnId: Int!
    fromColumnName: String!
    fromColumnDisplayName: String!
    toModelId: Int!
    toModelName: String!
    toModelDisplayName: String!
    toColumnId: Int!
    toColumnName: String!
    toColumnDisplayName: String!
  }

  input SimpleMeasureInput {
    name: String!
    type: String!
    isCalculated: Boolean!
    notNull: Boolean!
    properties: JSON!
  }

  input DimensionInput {
    name: String!
    type: String!
    isCalculated: Boolean!
    notNull: Boolean!
    properties: JSON!
  }

  input TimeGrainInput {
    name: String!
    refColumn: String!
    dateParts: [String!]!
  }

  input CreateSimpleMetricInput {
    name: String!
    displayName: String!
    description: String
    cached: Boolean!
    refreshTime: String
    model: String!
    properties: JSON!
    measure: [SimpleMeasureInput!]!
    dimension: [DimensionInput!]!
    timeGrain: [TimeGrainInput!]!
  }

  # Task
  type Task {
    id: String!
  }

  # Error
  type Error {
    code: String
    shortMessage: String
    message: String
    stacktrace: [String]
  }

  # Asking Task
  input AskingTaskInput {
    question: String!
    # Used for follow-up questions
    threadId: Int
  }

  enum AskingTaskStatus {
    UNDERSTANDING
    SEARCHING
    PLANNING
    GENERATING
    CORRECTING
    FINISHED
    FAILED
    STOPPED
  }

  enum AskingTaskType {
    GENERAL
    TEXT_TO_SQL
    MISLEADING_QUERY
  }

  enum ChartTaskStatus {
    FETCHING
    GENERATING
    FINISHED
    FAILED
    STOPPED
  }

  enum ChartType {
    BAR
    PIE
    LINE
    MULTI_LINE
    AREA
    GROUPED_BAR
    STACKED_BAR
  }

  enum ResultCandidateType {
    VIEW # View type candidate is provided basd on a saved view
    LLM # LLM type candidate is created by LLM
    SQL_PAIR # SQL pair type candidate is created by SQL pair
  }

  type ResultCandidate {
    type: ResultCandidateType!
    sql: String!
    view: ViewInfo
    sqlPair: SqlPair
  }

  type AskingTask {
    status: AskingTaskStatus!
    type: AskingTaskType
    error: Error
    candidates: [ResultCandidate!]!
    rephrasedQuestion: String
    intentReasoning: String
    sqlGenerationReasoning: String
    retrievedTables: [String!]
    invalidSql: String
    traceId: String
    queryId: String
  }

  input InstantRecommendedQuestionsInput {
    previousQuestions: [String!]
  }

  enum RecommendedQuestionsTaskStatus {
    NOT_STARTED
    GENERATING
    FINISHED
    FAILED
  }

  type ResultQuestion {
    question: String!
    category: String!
    sql: String!
  }

  type RecommendedQuestionsTask {
    status: RecommendedQuestionsTaskStatus!
    questions: [ResultQuestion!]!
    error: Error
  }

  # Thread
  input CreateThreadInput {
    question: String
    sql: String
    taskId: String
  }

  input CreateThreadResponseInput {
    question: String
    sql: String
    taskId: String
  }

  input ThreadUniqueWhereInput {
    id: Int!
  }

  input UpdateThreadInput {
    summary: String
  }

  input ThreadResponseUniqueWhereInput {
    id: Int!
  }

  input UpdateThreadResponseInput {
    sql: String
  }

  input AdjustThreadResponseChartInput {
    chartType: ChartType!
    xAxis: String
    yAxis: String
    xOffset: String
    color: String
    theta: String
  }

  input AdjustThreadResponseInput {
    tables: [String!]
    sqlGenerationReasoning: String
    sql: String
  }

  input PreviewDataInput {
    responseId: Int!
    # Optional, only used for preview data of a single step
    stepIndex: Int
    # It will return default 500 rows if not specified limit
    # refer: DEFAULT_PREVIEW_LIMIT
    limit: Int
  }

  type DetailStep {
    summary: String!
    sql: String!
    cteName: String
  }

  enum ThreadResponseAnswerStatus {
    NOT_STARTED
    FETCHING_DATA
    PREPROCESSING
    STREAMING
    FINISHED
    FAILED
    INTERRUPTED
  }

  type ThreadResponseAnswerDetail {
    queryId: String
    status: ThreadResponseAnswerStatus
    error: Error
    numRowsUsedInLLM: Int
    content: String
  }

  type ThreadResponseBreakdownDetail {
    queryId: String
    status: AskingTaskStatus!
    error: Error
    description: String
    steps: [DetailStep!]
  }

  type ThreadResponseChartDetail {
    queryId: String
    status: ChartTaskStatus!
    error: Error
    description: String
    chartType: ChartType
    chartSchema: JSON
    adjustment: Boolean
  }

  enum ThreadResponseAdjustmentType {
    REASONING
    APPLY_SQL
  }

  type ThreadResponseAdjustment {
    type: ThreadResponseAdjustmentType!
    payload: JSON
  }

  type AdjustmentTask {
    queryId: String
    status: AskingTaskStatus
    error: Error
    sql: String
    traceId: String
    invalidSql: String
  }

  type ThreadResponse {
    id: Int!
    threadId: Int!
    question: String!
    sql: String
    view: ViewInfo
    breakdownDetail: ThreadResponseBreakdownDetail
    answerDetail: ThreadResponseAnswerDetail
    chartDetail: ThreadResponseChartDetail
    askingTask: AskingTask
    adjustment: ThreadResponseAdjustment
    adjustmentTask: AdjustmentTask
  }

  # Thread only consists of basic information of a thread
  type Thread {
    id: Int!
    summary: String!
  }

  # Detailed thread consists of thread and thread responses
  type DetailedThread {
    id: Int!
    responses: [ThreadResponse!]!
  }

  type SuggestedQuestion {
    question: String!
    label: String!
  }
  # Ask Questions Responses
  type SuggestedQuestionResponse {
    questions: [SuggestedQuestion]!
  }

  # Settings
  input UpdateDataSourceInput {
    properties: JSON!
  }

  input UpdateCurrentProjectInput {
    language: ProjectLanguage!
  }

  type Settings {
    productVersion: String!
    dataSource: DataSource!
    language: ProjectLanguage!
  }

  type GetMDLResult {
    hash: String!
    mdl: String
  }

  input PreviewSQLDataInput {
    sql: String!
    projectId: String
    limit: Int
    dryRun: Boolean
  }

  # Schema Change
  type SchemaChange {
    deletedTables: [DetailedChangeTable!]
    deletedColumns: [DetailedChangeTable!]
    modifiedColumns: [DetailedChangeTable!]
    lastSchemaChangeTime: String
  }

  type DetailedChangeTable {
    sourceTableName: String!
    displayName: String!
    columns: [DetailedChangeColumn!]!
    calculatedFields: [DetailedAffectedCalculatedFields!]!
    relationships: [DetailedAffectedRelationships!]!
  }

  type DetailedChangeColumn {
    sourceColumnName: String!
    displayName: String!
    type: String!
  }

  type DetailedAffectedCalculatedFields {
    displayName: String!
    referenceName: String!
    type: String!
  }

  type DetailedAffectedRelationships {
    displayName: String!
    referenceName: String!
  }

  input ResolveSchemaChangeWhereInput {
    type: SchemaChangeType!
  }

  # Learning
  type LearningRecord {
    paths: [String!]!
  }

  input SaveLearningRecordInput {
    path: String!
  }

  # Dashboard
  enum DashboardItemType {
    BAR
    PIE
    LINE
    MULTI_LINE
    AREA
    GROUPED_BAR
    STACKED_BAR
    TABLE
    NUMBER
  }

  input DashboardItemWhereInput {
    id: Int!
  }

  input CreateDashboardItemInput {
    itemType: DashboardItemType!
    responseId: Int!
  }

  input UpdateDashboardItemInput {
    displayName: String!
  }

  input ItemLayoutInput {
    itemId: Int!
    x: Int!
    y: Int!
    w: Int!
    h: Int!
  }

  input UpdateDashboardItemLayoutsInput {
    layouts: [ItemLayoutInput!]!
  }

  input DeleteDashboardItemInput {
    itemId: Int!
  }

  input PreviewItemSQLInput {
    itemId: Int!
    limit: Int
    refresh: Boolean = false
  }

  type PreviewItemResponse {
    data: JSON!
    cacheHit: Boolean!
    cacheCreatedAt: String
    cacheOverrodeAt: String
    override: Boolean!
  }

  input SetDashboardScheduleInput {
    cacheEnabled: Boolean!
    schedule: SetDashboardScheduleData
  }

  type DashboardSchedule {
    frequency: ScheduleFrequencyEnum
    hour: Int
    minute: Int
    day: CacheScheduleDayEnum
    timezone: String
    cron: String
  }

  input SetDashboardScheduleData {
    frequency: ScheduleFrequencyEnum!
    hour: Int
    minute: Int
    day: CacheScheduleDayEnum
    timezone: String
    cron: String
  }

  enum ScheduleFrequencyEnum {
    DAILY
    WEEKLY
    CUSTOM
    NEVER
  }

  enum CacheScheduleDayEnum {
    SUN
    MON
    TUE
    WED
    THU
    FRI
    SAT
  }

  type DashboardItemLayout {
    x: Int!
    y: Int!
    w: Int!
    h: Int!
  }

  type DashboardItemDetail {
    sql: String!
    chartSchema: JSON
  }

  type DashboardItem {
    id: Int!
    dashboardId: Int!
    type: DashboardItemType!
    layout: DashboardItemLayout!
    detail: DashboardItemDetail!
    displayName: String
  }

  type Dashboard {
    id: Int!
    projectId: Int!
    name: String!
    cacheEnabled: Boolean!
    scheduleFrequency: ScheduleFrequencyEnum
    scheduleTimezone: String
    scheduleCron: String
    nextScheduledAt: String
  }

  type DetailedDashboard {
    id: Int!
    name: String!
    description: String
    cacheEnabled: Boolean!
    nextScheduledAt: String
    schedule: DashboardSchedule
    items: [DashboardItem!]!
  }

  type SqlPair {
    id: Int!
    projectId: Int!
    sql: String!
    question: String!
    createdAt: String
    updatedAt: String
  }

  input CreateSqlPairInput {
    sql: String!
    question: String!
  }

  input UpdateSqlPairInput {
    sql: String
    question: String
  }

  input SqlPairWhereUniqueInput {
    id: Int!
  }

  input GenerateQuestionInput {
    sql: String!
  }

  input ModelSubstituteInput {
    sql: DialectSQL!
  }

  type Instruction {
    id: Int!
    projectId: Int!
    instruction: String!
    questions: [String!]!
    isDefault: Boolean!
    createdAt: String!
    updatedAt: String!
  }

  input CreateInstructionInput {
    instruction: String!
    questions: [String!]!
    isDefault: Boolean!
  }

  input UpdateInstructionInput {
    instruction: String
    questions: [String!]
    isDefault: Boolean
  }

  input InstructionWhereInput {
    id: Int!
  }

  # Query and Mutation
  type Query {
    # On Boarding Steps
    listDataSourceTables: [CompactTable!]!
    autoGenerateRelation: [RecommendRelations!]!
    onboardingStatus: OnboardingStatusResponse!

    # Modeling Page
    listModels: [ModelInfo!]!
    model(where: ModelWhereInput!): DetailedModel!
    modelSync: ModelSyncResponse!
    diagram: Diagram!
    schemaChange: SchemaChange!

    # View
    listViews: [ViewInfo!]!
    view(where: ViewWhereUniqueInput!): ViewInfo!

    # Ask
    askingTask(taskId: String!): AskingTask
    suggestedQuestions: SuggestedQuestionResponse!
    threads: [Thread!]!
    thread(threadId: Int!): DetailedThread!
    threadResponse(responseId: Int!): ThreadResponse!
    nativeSql(responseId: Int!): String!

    # Adjustment
    adjustmentTask(taskId: String!): AdjustmentTask

    # Settings
    settings: Settings!

    # System
    getMDL(hash: String!): GetMDLResult!

    # Learning
    learningRecord: LearningRecord!

    # Recommendation questions
    getThreadRecommendationQuestions(threadId: Int!): RecommendedQuestionsTask!
    getProjectRecommendationQuestions: RecommendedQuestionsTask!
    instantRecommendedQuestions(taskId: String!): RecommendedQuestionsTask!

    # Dashboard
    dashboardItems: [DashboardItem!]!
    dashboard: DetailedDashboard!

    # SQL Pairs
    sqlPairs: [SqlPair]!
    # Instructions
    instructions: [Instruction]!

    # Api History
    apiHistory(
      filter: ApiHistoryFilterInput
      pagination: ApiHistoryPaginationInput!
    ): ApiHistoryPaginatedResponse!
  }

  type Mutation {
    # On Boarding Steps
    saveDataSource(data: DataSourceInput!): DataSource!
    startSampleDataset(data: SampleDatasetInput!): JSON!
    saveTables(data: SaveTablesInput!): JSON!
    saveRelations(data: SaveRelationInput!): JSON!
    deploy(force: Boolean): JSON!

    # Modeling Page
    createModel(data: CreateModelInput!): JSON!
    updateModel(where: ModelWhereInput!, data: UpdateModelInput!): JSON!
    deleteModel(where: ModelWhereInput!): Boolean!
    previewModelData(where: WhereIdInput!): JSON!
    triggerDataSourceDetection: Boolean!
    resolveSchemaChange(where: ResolveSchemaChangeWhereInput!): Boolean!

    # Metadata
    updateModelMetadata(
      where: ModelWhereInput!
      data: UpdateModelMetadataInput!
    ): Boolean!
    updateViewMetadata(
      where: ViewWhereUniqueInput!
      data: UpdateViewMetadataInput!
    ): Boolean!

    # Relation
    createRelation(data: RelationInput!): JSON!
    updateRelation(data: UpdateRelationInput!, where: WhereIdInput!): JSON!
    deleteRelation(where: WhereIdInput!): Boolean!

    # Calculated field
    createCalculatedField(data: CreateCalculatedFieldInput!): JSON!
    updateCalculatedField(
      where: UpdateCalculatedFieldWhere!
      data: UpdateCalculatedFieldInput!
    ): JSON!
    deleteCalculatedField(where: UpdateCalculatedFieldWhere): Boolean!
    validateCalculatedField(
      data: ValidateCalculatedFieldInput!
    ): CalculatedFieldValidationResponse!

    # View
    createView(data: CreateViewInput!): ViewInfo!
    deleteView(where: ViewWhereUniqueInput!): Boolean!
    previewViewData(where: PreviewViewDataInput!): JSON!
    validateView(data: ValidateViewInput!): ViewValidationResponse!

    # Ask
    createAskingTask(data: AskingTaskInput!): Task!
    cancelAskingTask(taskId: String!): Boolean!
    rerunAskingTask(responseId: Int!): Task!

    # Thread
    createThread(data: CreateThreadInput!): Thread!
    updateThread(
      where: ThreadUniqueWhereInput!
      data: UpdateThreadInput!
    ): Thread!
    deleteThread(where: ThreadUniqueWhereInput!): Boolean!

    # Thread Response
    createThreadResponse(
      threadId: Int!
      data: CreateThreadResponseInput!
    ): ThreadResponse!
    updateThreadResponse(
      where: ThreadResponseUniqueWhereInput!
      data: UpdateThreadResponseInput!
    ): ThreadResponse!
    previewData(where: PreviewDataInput!): JSON!
    previewBreakdownData(where: PreviewDataInput!): JSON!

    # Generate Thread Response Breakdown
    generateThreadResponseBreakdown(responseId: Int!): ThreadResponse!

    # Generate Thread Response Answer
    generateThreadResponseAnswer(responseId: Int!): ThreadResponse!

    # Generate Thread Response Chart
    generateThreadResponseChart(responseId: Int!): ThreadResponse!

    # Adjust Thread Response Chart
    adjustThreadResponseChart(
      responseId: Int!
      data: AdjustThreadResponseChartInput!
    ): ThreadResponse!

    # Adjustment
    adjustThreadResponse(
      responseId: Int!
      data: AdjustThreadResponseInput!
    ): ThreadResponse!
    cancelAdjustmentTask(taskId: String!): Boolean!
    rerunAdjustmentTask(responseId: Int!): Boolean!

    # Settings
    resetCurrentProject: Boolean!
    updateCurrentProject(data: UpdateCurrentProjectInput!): Boolean!
    updateDataSource(data: UpdateDataSourceInput!): DataSource!

    # preview
    previewSql(data: PreviewSQLDataInput): JSON!

    # Learning
    saveLearningRecord(data: SaveLearningRecordInput!): LearningRecord!

    # Recommendation questions
    generateThreadRecommendationQuestions(threadId: Int!): Boolean!
    generateProjectRecommendationQuestions: Boolean!
    createInstantRecommendedQuestions(
      data: InstantRecommendedQuestionsInput!
    ): Task!

    # Dashboard
    updateDashboardItemLayouts(
      data: UpdateDashboardItemLayoutsInput!
    ): [DashboardItem!]!
    createDashboardItem(data: CreateDashboardItemInput!): DashboardItem!
    updateDashboardItem(
      where: DashboardItemWhereInput!
      data: UpdateDashboardItemInput!
    ): DashboardItem!
    deleteDashboardItem(where: DashboardItemWhereInput!): Boolean!
    previewItemSQL(data: PreviewItemSQLInput!): PreviewItemResponse!
    setDashboardSchedule(data: SetDashboardScheduleInput!): Dashboard!

    # SQL Pairs
    createSqlPair(data: CreateSqlPairInput!): SqlPair!
    updateSqlPair(
      where: SqlPairWhereUniqueInput!
      data: UpdateSqlPairInput!
    ): SqlPair!
    deleteSqlPair(where: SqlPairWhereUniqueInput!): Boolean!
    generateQuestion(data: GenerateQuestionInput!): String!
    modelSubstitute(data: ModelSubstituteInput!): String!
    # Instructions
    createInstruction(data: CreateInstructionInput!): Instruction!
    updateInstruction(
      where: InstructionWhereInput!
      data: UpdateInstructionInput!
    ): Instruction!
    deleteInstruction(where: InstructionWhereInput!): Boolean!
  }
`;
</file>

<file path="src/apollo/server/services/askingService.ts">
import { IWrenAIAdaptor } from '@server/adaptors/wrenAIAdaptor';
import {
  AskResultStatus,
  RecommendationQuestionsResult,
  RecommendationQuestionsInput,
  RecommendationQuestion,
  WrenAIError,
  RecommendationQuestionStatus,
  ChartStatus,
  ChartAdjustmentOption,
  WrenAILanguage,
} from '@server/models/adaptor';
import { IDeployService } from './deployService';
import { IProjectService } from './projectService';
import { IThreadRepository, Thread } from '../repositories/threadRepository';
import {
  IThreadResponseRepository,
  ThreadResponse,
  ThreadResponseAdjustmentType,
} from '../repositories/threadResponseRepository';
import { getLogger } from '@server/utils';
import { isEmpty, isNil } from 'lodash';
import { format } from 'sql-formatter';
import {
  PostHogTelemetry,
  TelemetryEvent,
  WrenService,
} from '../telemetry/telemetry';
import {
  IAskingTaskRepository,
  IViewRepository,
  Project,
} from '../repositories';
import { IQueryService, PreviewDataResponse } from './queryService';
import { IMDLService } from './mdlService';
import {
  ThreadRecommendQuestionBackgroundTracker,
  ChartBackgroundTracker,
  ChartAdjustmentBackgroundTracker,
  AdjustmentBackgroundTaskTracker,
  TrackedAdjustmentResult,
} from '../backgrounds';
import { getConfig } from '@server/config';
import { TextBasedAnswerBackgroundTracker } from '../backgrounds/textBasedAnswerBackgroundTracker';
import { IAskingTaskTracker, TrackedAskingResult } from './askingTaskTracker';

const config = getConfig();

const logger = getLogger('AskingService');
logger.level = 'debug';

// const QUERY_ID_PLACEHOLDER = '0';

export interface Task {
  id: string;
}

export interface AskingPayload {
  threadId?: number;
  language: string;
}

export interface AskingTaskInput {
  question: string;
}

export interface AskingDetailTaskInput {
  question?: string;
  sql?: string;
  trackedAskingResult?: TrackedAskingResult;
}

export interface AskingDetailTaskUpdateInput {
  summary?: string;
}

export enum RecommendQuestionResultStatus {
  NOT_STARTED = 'NOT_STARTED',
  GENERATING = 'GENERATING',
  FINISHED = 'FINISHED',
  FAILED = 'FAILED',
}

export interface ThreadRecommendQuestionResult {
  status: RecommendQuestionResultStatus;
  questions: RecommendationQuestion[];
  error?: WrenAIError;
}

export interface InstantRecommendedQuestionsInput {
  previousQuestions?: string[];
}

export enum ThreadResponseAnswerStatus {
  NOT_STARTED = 'NOT_STARTED',
  FETCHING_DATA = 'FETCHING_DATA',
  PREPROCESSING = 'PREPROCESSING',
  STREAMING = 'STREAMING',
  FINISHED = 'FINISHED',
  FAILED = 'FAILED',
  INTERRUPTED = 'INTERRUPTED',
}

// adjustment input
export interface AdjustmentReasoningInput {
  tables: string[];
  sqlGenerationReasoning: string;
  projectId: number;
}

export interface AdjustmentSqlInput {
  sql: string;
}

export interface IAskingService {
  /**
   * Asking task.
   */
  createAskingTask(
    input: AskingTaskInput,
    payload: AskingPayload,
    // if the asking task is rerun from a cancelled thread response
    rerunFromCancelled?: boolean,
    // if the asking task is rerun from a cancelled thread response,
    // the previous task id is the task id of the cancelled thread response
    previousTaskId?: number,
    // if the asking task is rerun from a thread response
    // the thread response id is the id of the cancelled thread response
    threadResponseId?: number,
  ): Promise<Task>;
  rerunAskingTask(
    threadResponseId: number,
    payload: AskingPayload,
  ): Promise<Task>;
  cancelAskingTask(taskId: string): Promise<void>;
  getAskingTask(taskId: string): Promise<TrackedAskingResult>;
  getAskingTaskById(id: number): Promise<TrackedAskingResult>;

  /**
   * Asking detail task.
   */
  createThread(input: AskingDetailTaskInput): Promise<Thread>;
  updateThread(
    threadId: number,
    input: Partial<AskingDetailTaskUpdateInput>,
  ): Promise<Thread>;
  deleteThread(threadId: number): Promise<void>;
  listThreads(): Promise<Thread[]>;
  createThreadResponse(
    input: AskingDetailTaskInput,
    threadId: number,
  ): Promise<ThreadResponse>;
  updateThreadResponse(
    responseId: number,
    data: { sql: string },
  ): Promise<ThreadResponse>;
  getResponsesWithThread(threadId: number): Promise<ThreadResponse[]>;
  getResponse(responseId: number): Promise<ThreadResponse>;
  generateThreadResponseBreakdown(
    threadResponseId: number,
    configurations: { language: string },
  ): Promise<ThreadResponse>;
  generateThreadResponseAnswer(
    threadResponseId: number,
    configurations: { language: string },
  ): Promise<ThreadResponse>;
  generateThreadResponseChart(
    threadResponseId: number,
    configurations: { language: string },
  ): Promise<ThreadResponse>;
  adjustThreadResponseChart(
    threadResponseId: number,
    input: ChartAdjustmentOption,
    configurations: { language: string },
  ): Promise<ThreadResponse>;
  adjustThreadResponseWithSQL(
    threadResponseId: number,
    input: AdjustmentSqlInput,
  ): Promise<ThreadResponse>;
  adjustThreadResponseAnswer(
    threadResponseId: number,
    input: AdjustmentReasoningInput,
    configurations: { language: string },
  ): Promise<ThreadResponse>;
  cancelAdjustThreadResponseAnswer(taskId: string): Promise<void>;
  rerunAdjustThreadResponseAnswer(
    threadResponseId: number,
    projectId: number,
    configurations: { language: string },
  ): Promise<{ queryId: string }>;
  getAdjustmentTask(taskId: string): Promise<TrackedAdjustmentResult>;
  getAdjustmentTaskById(id: number): Promise<TrackedAdjustmentResult>;
  changeThreadResponseAnswerDetailStatus(
    responseId: number,
    status: ThreadResponseAnswerStatus,
    content?: string,
  ): Promise<ThreadResponse>;
  previewData(responseId: number, limit?: number): Promise<PreviewDataResponse>;
  previewBreakdownData(
    responseId: number,
    stepIndex?: number,
    limit?: number,
  ): Promise<PreviewDataResponse>;

  /**
   * Recommendation questions
   */
  createInstantRecommendedQuestions(
    input: InstantRecommendedQuestionsInput,
  ): Promise<Task>;
  getInstantRecommendedQuestions(
    queryId: string,
  ): Promise<RecommendationQuestionsResult>;
  generateThreadRecommendationQuestions(threadId: number): Promise<void>;
  getThreadRecommendationQuestions(
    threadId: number,
  ): Promise<ThreadRecommendQuestionResult>;

  deleteAllByProjectId(projectId: number): Promise<void>;
}

/**
 * utility function to check if the status is finalized
 */
const isFinalized = (status: AskResultStatus) => {
  return (
    status === AskResultStatus.FAILED ||
    status === AskResultStatus.FINISHED ||
    status === AskResultStatus.STOPPED
  );
};

/**
 * Given a list of steps, construct the SQL statement with CTEs
 * If stepIndex is provided, only construct the SQL from top to that step
 * @param steps
 * @param stepIndex
 * @returns string
 */
export const constructCteSql = (
  steps: Array<{ cteName: string; summary: string; sql: string }>,
  stepIndex?: number,
): string => {
  // validate stepIndex
  if (!isNil(stepIndex) && (stepIndex < 0 || stepIndex >= steps.length)) {
    throw new Error(`Invalid stepIndex: ${stepIndex}`);
  }

  const slicedSteps = isNil(stepIndex) ? steps : steps.slice(0, stepIndex + 1);

  // if there's only one step, return the sql directly
  if (slicedSteps.length === 1) {
    return `-- ${slicedSteps[0].summary}\n${slicedSteps[0].sql}`;
  }

  let sql = 'WITH ';
  slicedSteps.forEach((step, index) => {
    if (index === slicedSteps.length - 1) {
      // if it's the last step, remove the trailing comma.
      // no need to wrap with WITH
      sql += `\n-- ${step.summary}\n`;
      sql += `${step.sql}`;
    } else if (index === slicedSteps.length - 2) {
      // if it's the last two steps, remove the trailing comma.
      // wrap with CTE
      sql += `${step.cteName} AS`;
      sql += `\n-- ${step.summary}\n`;
      sql += `(${step.sql})`;
    } else {
      // if it's not the last step, wrap with CTE
      sql += `${step.cteName} AS`;
      sql += `\n-- ${step.summary}\n`;
      sql += `(${step.sql}),`;
    }
  });

  return sql;
};

/**
 * Background tracker to track the status of the asking breakdown task
 */
class BreakdownBackgroundTracker {
  // tasks is a kv pair of task id and thread response
  private tasks: Record<number, ThreadResponse> = {};
  private intervalTime: number;
  private wrenAIAdaptor: IWrenAIAdaptor;
  private threadResponseRepository: IThreadResponseRepository;
  private runningJobs = new Set();
  private telemetry: PostHogTelemetry;

  constructor({
    telemetry,
    wrenAIAdaptor,
    threadResponseRepository,
  }: {
    telemetry: PostHogTelemetry;
    wrenAIAdaptor: IWrenAIAdaptor;
    threadResponseRepository: IThreadResponseRepository;
  }) {
    this.telemetry = telemetry;
    this.wrenAIAdaptor = wrenAIAdaptor;
    this.threadResponseRepository = threadResponseRepository;
    this.intervalTime = 1000;
    this.start();
  }

  public start() {
    logger.info('Background tracker started');
    setInterval(() => {
      const jobs = Object.values(this.tasks).map(
        (threadResponse) => async () => {
          // check if same job is running
          if (this.runningJobs.has(threadResponse.id)) {
            return;
          }

          // mark the job as running
          this.runningJobs.add(threadResponse.id);

          // get the answer detail
          const breakdownDetail = threadResponse.breakdownDetail;

          // get the latest result from AI service
          const result = await this.wrenAIAdaptor.getAskDetailResult(
            breakdownDetail.queryId,
          );

          // check if status change
          if (breakdownDetail.status === result.status) {
            // mark the job as finished
            logger.debug(
              `Job ${threadResponse.id} status not changed, finished`,
            );
            this.runningJobs.delete(threadResponse.id);
            return;
          }

          // update database
          const updatedBreakdownDetail = {
            queryId: breakdownDetail.queryId,
            status: result?.status,
            error: result?.error,
            description: result?.response?.description,
            steps: result?.response?.steps,
          };
          logger.debug(`Job ${threadResponse.id} status changed, updating`);
          await this.threadResponseRepository.updateOne(threadResponse.id, {
            breakdownDetail: updatedBreakdownDetail,
          });

          // remove the task from tracker if it is finalized
          if (isFinalized(result.status)) {
            const eventProperties = {
              question: threadResponse.question,
              error: result.error,
            };
            if (result.status === AskResultStatus.FINISHED) {
              this.telemetry.sendEvent(
                TelemetryEvent.HOME_ANSWER_BREAKDOWN,
                eventProperties,
              );
            } else {
              this.telemetry.sendEvent(
                TelemetryEvent.HOME_ANSWER_BREAKDOWN,
                eventProperties,
                WrenService.AI,
                false,
              );
            }
            logger.debug(`Job ${threadResponse.id} is finalized, removing`);
            delete this.tasks[threadResponse.id];
          }

          // mark the job as finished
          this.runningJobs.delete(threadResponse.id);
        },
      );

      // run the jobs
      Promise.allSettled(jobs.map((job) => job())).then((results) => {
        // show reason of rejection
        results.forEach((result, index) => {
          if (result.status === 'rejected') {
            logger.error(`Job ${index} failed: ${result.reason}`);
          }
        });
      });
    }, this.intervalTime);
  }

  public addTask(threadResponse: ThreadResponse) {
    this.tasks[threadResponse.id] = threadResponse;
  }

  public getTasks() {
    return this.tasks;
  }
}

export class AskingService implements IAskingService {
  private wrenAIAdaptor: IWrenAIAdaptor;
  private deployService: IDeployService;
  private projectService: IProjectService;
  private viewRepository: IViewRepository;
  private threadRepository: IThreadRepository;
  private threadResponseRepository: IThreadResponseRepository;
  private breakdownBackgroundTracker: BreakdownBackgroundTracker;
  private textBasedAnswerBackgroundTracker: TextBasedAnswerBackgroundTracker;
  private chartBackgroundTracker: ChartBackgroundTracker;
  private chartAdjustmentBackgroundTracker: ChartAdjustmentBackgroundTracker;
  private threadRecommendQuestionBackgroundTracker: ThreadRecommendQuestionBackgroundTracker;
  private queryService: IQueryService;
  private telemetry: PostHogTelemetry;
  private mdlService: IMDLService;
  private askingTaskTracker: IAskingTaskTracker;
  private askingTaskRepository: IAskingTaskRepository;
  private adjustmentBackgroundTracker: AdjustmentBackgroundTaskTracker;

  constructor({
    telemetry,
    wrenAIAdaptor,
    deployService,
    projectService,
    viewRepository,
    threadRepository,
    threadResponseRepository,
    askingTaskRepository,
    queryService,
    mdlService,
    askingTaskTracker,
  }: {
    telemetry: PostHogTelemetry;
    wrenAIAdaptor: IWrenAIAdaptor;
    deployService: IDeployService;
    projectService: IProjectService;
    viewRepository: IViewRepository;
    threadRepository: IThreadRepository;
    threadResponseRepository: IThreadResponseRepository;
    askingTaskRepository: IAskingTaskRepository;
    queryService: IQueryService;
    mdlService: IMDLService;
    askingTaskTracker: IAskingTaskTracker;
  }) {
    this.wrenAIAdaptor = wrenAIAdaptor;
    this.deployService = deployService;
    this.projectService = projectService;
    this.viewRepository = viewRepository;
    this.threadRepository = threadRepository;
    this.threadResponseRepository = threadResponseRepository;
    this.telemetry = telemetry;
    this.queryService = queryService;
    this.breakdownBackgroundTracker = new BreakdownBackgroundTracker({
      telemetry,
      wrenAIAdaptor,
      threadResponseRepository,
    });
    this.textBasedAnswerBackgroundTracker =
      new TextBasedAnswerBackgroundTracker({
        wrenAIAdaptor,
        threadResponseRepository,
        projectService,
        deployService,
        queryService,
      });
    this.chartBackgroundTracker = new ChartBackgroundTracker({
      telemetry,
      wrenAIAdaptor,
      threadResponseRepository,
    });
    this.chartAdjustmentBackgroundTracker =
      new ChartAdjustmentBackgroundTracker({
        telemetry,
        wrenAIAdaptor,
        threadResponseRepository,
      });
    this.threadRecommendQuestionBackgroundTracker =
      new ThreadRecommendQuestionBackgroundTracker({
        telemetry,
        wrenAIAdaptor,
        threadRepository,
      });
    this.adjustmentBackgroundTracker = new AdjustmentBackgroundTaskTracker({
      telemetry,
      wrenAIAdaptor,
      askingTaskRepository,
      threadResponseRepository,
    });

    this.askingTaskRepository = askingTaskRepository;
    this.mdlService = mdlService;
    this.askingTaskTracker = askingTaskTracker;
  }

  public async getThreadRecommendationQuestions(
    threadId: number,
  ): Promise<ThreadRecommendQuestionResult> {
    const thread = await this.threadRepository.findOneBy({ id: threadId });
    if (!thread) {
      throw new Error(`Thread ${threadId} not found`);
    }

    // handle not started
    const res: ThreadRecommendQuestionResult = {
      status: RecommendQuestionResultStatus.NOT_STARTED,
      questions: [],
      error: null,
    };
    if (thread.queryId && thread.questionsStatus) {
      res.status = RecommendQuestionResultStatus[thread.questionsStatus]
        ? RecommendQuestionResultStatus[thread.questionsStatus]
        : res.status;
      res.questions = thread.questions || [];
      res.error = thread.questionsError as WrenAIError;
    }
    return res;
  }

  public async generateThreadRecommendationQuestions(
    threadId: number,
  ): Promise<void> {
    const thread = await this.threadRepository.findOneBy({ id: threadId });
    if (!thread) {
      throw new Error(`Thread ${threadId} not found`);
    }

    if (this.threadRecommendQuestionBackgroundTracker.isExist(thread)) {
      logger.debug(
        `thread "${threadId}" recommended questions are generating, skip the current request`,
      );
      return;
    }

    const project = await this.projectService.getCurrentProject();
    const { manifest } = await this.mdlService.makeCurrentModelMDL();

    const threadResponses = await this.threadResponseRepository.findAllBy({
      threadId,
    });
    // descending order and get the latest 5
    const slicedThreadResponses = threadResponses
      .sort((a, b) => b.id - a.id)
      .slice(0, 5);
    const questions = slicedThreadResponses.map(({ question }) => question);
    const recommendQuestionData: RecommendationQuestionsInput = {
      manifest,
      previousQuestions: questions,
      ...this.getThreadRecommendationQuestionsConfig(project),
    };

    const result = await this.wrenAIAdaptor.generateRecommendationQuestions(
      recommendQuestionData,
    );
    // reset thread recommended questions
    const updatedThread = await this.threadRepository.updateOne(threadId, {
      queryId: result.queryId,
      questionsStatus: RecommendationQuestionStatus.GENERATING,
      questions: [],
      questionsError: null,
    });
    this.threadRecommendQuestionBackgroundTracker.addTask(updatedThread);
    return;
  }

  public async initialize() {
    // list thread responses from database
    // filter status not finalized and put them into background tracker
    const threadResponses = await this.threadResponseRepository.findAll();
    const unfininshedBreakdownThreadResponses = threadResponses.filter(
      (threadResponse) =>
        threadResponse?.breakdownDetail?.status &&
        !isFinalized(
          threadResponse?.breakdownDetail?.status as AskResultStatus,
        ),
    );
    logger.info(
      `Initialization: adding unfininshed breakdown thread responses (total: ${unfininshedBreakdownThreadResponses.length}) to background tracker`,
    );
    for (const threadResponse of unfininshedBreakdownThreadResponses) {
      this.breakdownBackgroundTracker.addTask(threadResponse);
    }
  }

  /**
   * Asking task.
   */
  public async createAskingTask(
    input: AskingTaskInput,
    payload: AskingPayload,
    rerunFromCancelled?: boolean,
    previousTaskId?: number,
    threadResponseId?: number,
  ): Promise<Task> {
    const { threadId, language } = payload;
    const deployId = await this.getDeployId();

    // if it's a follow-up question, then the input will have a threadId
    // then use the threadId to get the sql and get the steps of last thread response
    // construct it into AskHistory and pass to ask
    const histories = threadId
      ? await this.getAskingHistory(threadId, threadResponseId)
      : null;
    const response = await this.askingTaskTracker.createAskingTask({
      query: input.question,
      histories,
      deployId,
      configurations: { language },
      rerunFromCancelled,
      previousTaskId,
      threadResponseId,
    });
    return {
      id: response.queryId,
    };
  }

  public async rerunAskingTask(
    threadResponseId: number,
    payload: AskingPayload,
  ): Promise<Task> {
    const threadResponse = await this.threadResponseRepository.findOneBy({
      id: threadResponseId,
    });

    if (!threadResponse) {
      throw new Error(`Thread response ${threadResponseId} not found`);
    }

    // get the original question and ask again
    const question = threadResponse.question;
    const input = {
      question,
    };
    const askingPayload = {
      ...payload,
      // it's possible that the threadId is not provided in the payload
      // so we'll just use the threadId from the thread response
      threadId: threadResponse.threadId,
    };
    const task = await this.createAskingTask(
      input,
      askingPayload,
      true,
      threadResponse.askingTaskId,
      threadResponseId,
    );
    return task;
  }

  public async cancelAskingTask(taskId: string): Promise<void> {
    const eventName = TelemetryEvent.HOME_CANCEL_ASK;
    try {
      await this.askingTaskTracker.cancelAskingTask(taskId);
      this.telemetry.sendEvent(eventName, {});
    } catch (err: any) {
      this.telemetry.sendEvent(eventName, {}, err.extensions?.service, false);
      throw err;
    }
  }

  public async getAskingTask(
    taskId: string,
  ): Promise<TrackedAskingResult | null> {
    return this.askingTaskTracker.getAskingResult(taskId);
  }

  public async getAskingTaskById(
    id: number,
  ): Promise<TrackedAskingResult | null> {
    return this.askingTaskTracker.getAskingResultById(id);
  }

  /**
   * Asking detail task.
   * The process of creating a thread is as follows:
   * 1. create a thread and the first thread response
   * 2. create a task on AI service to generate the detail
   * 3. update the thread response with the task id
   */
  public async createThread(input: AskingDetailTaskInput): Promise<Thread> {
    // 1. create a thread and the first thread response
    const { id } = await this.projectService.getCurrentProject();
    const thread = await this.threadRepository.createOne({
      projectId: id,
      summary: input.question,
    });

    const threadResponse = await this.threadResponseRepository.createOne({
      threadId: thread.id,
      question: input.question,
      sql: input.sql,
      askingTaskId: input.trackedAskingResult?.taskId,
    });

    // if queryId is provided, update asking task
    if (input.trackedAskingResult?.taskId) {
      await this.askingTaskTracker.bindThreadResponse(
        input.trackedAskingResult.taskId,
        input.trackedAskingResult.queryId,
        thread.id,
        threadResponse.id,
      );
    }

    // return the task id
    return thread;
  }

  public async listThreads(): Promise<Thread[]> {
    const { id } = await this.projectService.getCurrentProject();
    return await this.threadRepository.listAllTimeDescOrder(id);
  }

  public async updateThread(
    threadId: number,
    input: Partial<AskingDetailTaskUpdateInput>,
  ): Promise<Thread> {
    // if input is empty, throw error
    if (isEmpty(input)) {
      throw new Error('Update thread input is empty');
    }

    return this.threadRepository.updateOne(threadId, {
      summary: input.summary,
    });
  }

  public async deleteThread(threadId: number): Promise<void> {
    await this.threadRepository.deleteOne(threadId);
  }

  public async createThreadResponse(
    input: AskingDetailTaskInput,
    threadId: number,
  ): Promise<ThreadResponse> {
    const thread = await this.threadRepository.findOneBy({
      id: threadId,
    });

    if (!thread) {
      throw new Error(`Thread ${threadId} not found`);
    }

    const threadResponse = await this.threadResponseRepository.createOne({
      threadId: thread.id,
      question: input.question,
      sql: input.sql,
      askingTaskId: input.trackedAskingResult?.taskId,
    });

    // if queryId is provided, update asking task
    if (input.trackedAskingResult?.taskId) {
      await this.askingTaskTracker.bindThreadResponse(
        input.trackedAskingResult.taskId,
        input.trackedAskingResult.queryId,
        thread.id,
        threadResponse.id,
      );
    }

    return threadResponse;
  }

  public async updateThreadResponse(
    responseId: number,
    data: { sql: string },
  ): Promise<ThreadResponse> {
    const threadResponse = await this.threadResponseRepository.findOneBy({
      id: responseId,
    });
    if (!threadResponse) {
      throw new Error(`Thread response ${responseId} not found`);
    }

    return await this.threadResponseRepository.updateOne(responseId, {
      sql: data.sql,
    });
  }

  public async generateThreadResponseBreakdown(
    threadResponseId: number,
    configurations: { language: string },
  ): Promise<ThreadResponse> {
    const { language } = configurations;
    const threadResponse = await this.threadResponseRepository.findOneBy({
      id: threadResponseId,
    });

    if (!threadResponse) {
      throw new Error(`Thread response ${threadResponseId} not found`);
    }

    // 1. create a task on AI service to generate the detail
    const response = await this.wrenAIAdaptor.generateAskDetail({
      query: threadResponse.question,
      sql: threadResponse.sql,
      configurations: { language },
    });

    // 2. update the thread response with breakdown detail
    const updatedThreadResponse = await this.threadResponseRepository.updateOne(
      threadResponse.id,
      {
        breakdownDetail: {
          queryId: response.queryId,
          status: AskResultStatus.UNDERSTANDING,
        },
      },
    );

    // 3. put the task into background tracker
    this.breakdownBackgroundTracker.addTask(updatedThreadResponse);

    // return the task id
    return updatedThreadResponse;
  }

  public async generateThreadResponseAnswer(
    threadResponseId: number,
  ): Promise<ThreadResponse> {
    const threadResponse = await this.threadResponseRepository.findOneBy({
      id: threadResponseId,
    });

    if (!threadResponse) {
      throw new Error(`Thread response ${threadResponseId} not found`);
    }

    // update with initial status
    const updatedThreadResponse = await this.threadResponseRepository.updateOne(
      threadResponse.id,
      {
        answerDetail: {
          status: ThreadResponseAnswerStatus.NOT_STARTED,
        },
      },
    );

    // put the task into background tracker
    this.textBasedAnswerBackgroundTracker.addTask(updatedThreadResponse);

    return updatedThreadResponse;
  }

  public async generateThreadResponseChart(
    threadResponseId: number,
    configurations: { language: string },
  ): Promise<ThreadResponse> {
    const threadResponse = await this.threadResponseRepository.findOneBy({
      id: threadResponseId,
    });

    if (!threadResponse) {
      throw new Error(`Thread response ${threadResponseId} not found`);
    }

    // 1. create a task on AI service to generate the chart
    const response = await this.wrenAIAdaptor.generateChart({
      query: threadResponse.question,
      sql: threadResponse.sql,
      configurations,
    });

    // 2. update the thread response with chart detail
    const updatedThreadResponse = await this.threadResponseRepository.updateOne(
      threadResponse.id,
      {
        chartDetail: {
          queryId: response.queryId,
          status: ChartStatus.FETCHING,
        },
      },
    );

    // 3. put the task into background tracker
    this.chartBackgroundTracker.addTask(updatedThreadResponse);

    return updatedThreadResponse;
  }

  public async adjustThreadResponseChart(
    threadResponseId: number,
    input: ChartAdjustmentOption,
    configurations: { language: string },
  ): Promise<ThreadResponse> {
    const threadResponse = await this.threadResponseRepository.findOneBy({
      id: threadResponseId,
    });

    if (!threadResponse) {
      throw new Error(`Thread response ${threadResponseId} not found`);
    }

    // 1. create a task on AI service to adjust the chart
    const response = await this.wrenAIAdaptor.adjustChart({
      query: threadResponse.question,
      sql: threadResponse.sql,
      adjustmentOption: input,
      chartSchema: threadResponse.chartDetail?.chartSchema,
      configurations,
    });

    // 2. update the thread response with chart detail
    const updatedThreadResponse = await this.threadResponseRepository.updateOne(
      threadResponse.id,
      {
        chartDetail: {
          queryId: response.queryId,
          status: ChartStatus.FETCHING,
          adjustment: true,
        },
      },
    );

    // 3. put the task into background tracker
    this.chartAdjustmentBackgroundTracker.addTask(updatedThreadResponse);

    return updatedThreadResponse;
  }

  public async getResponsesWithThread(threadId: number) {
    return this.threadResponseRepository.getResponsesWithThread(threadId);
  }

  public async getResponse(responseId: number) {
    return this.threadResponseRepository.findOneBy({ id: responseId });
  }

  public async previewData(responseId: number, limit?: number) {
    const response = await this.getResponse(responseId);
    if (!response) {
      throw new Error(`Thread response ${responseId} not found`);
    }
    const project = await this.projectService.getCurrentProject();
    const deployment = await this.deployService.getLastDeployment(project.id);
    const mdl = deployment.manifest;
    const eventName = TelemetryEvent.HOME_PREVIEW_ANSWER;
    try {
      const data = (await this.queryService.preview(response.sql, {
        project,
        manifest: mdl,
        limit,
      })) as PreviewDataResponse;
      this.telemetry.sendEvent(eventName, { sql: response.sql });
      return data;
    } catch (err: any) {
      this.telemetry.sendEvent(
        eventName,
        { sql: response.sql, error: err.message },
        err.extensions?.service,
        false,
      );
      throw err;
    }
  }

  /**
   * this function is used to preview the data of a thread response
   * get the target thread response and get the steps
   * construct the CTEs and get the data
   * @param responseId: the id of the thread response
   * @param stepIndex: the step in the response detail
   * @returns Promise<QueryResponse>
   */
  public async previewBreakdownData(
    responseId: number,
    stepIndex?: number,
    limit?: number,
  ): Promise<PreviewDataResponse> {
    const response = await this.getResponse(responseId);
    if (!response) {
      throw new Error(`Thread response ${responseId} not found`);
    }
    const project = await this.projectService.getCurrentProject();
    const deployment = await this.deployService.getLastDeployment(project.id);
    const mdl = deployment.manifest;
    const steps = response?.breakdownDetail?.steps;
    const sql = format(constructCteSql(steps, stepIndex));
    const eventName = TelemetryEvent.HOME_PREVIEW_ANSWER;
    try {
      const data = (await this.queryService.preview(sql, {
        project,
        manifest: mdl,
        limit,
      })) as PreviewDataResponse;
      this.telemetry.sendEvent(eventName, { sql });
      return data;
    } catch (err: any) {
      this.telemetry.sendEvent(
        eventName,
        { sql, error: err.message },
        err.extensions?.service,
        false,
      );
      throw err;
    }
  }

  public async createInstantRecommendedQuestions(
    input: InstantRecommendedQuestionsInput,
  ): Promise<Task> {
    const project = await this.projectService.getCurrentProject();
    const { manifest } = await this.deployService.getLastDeployment(project.id);

    const response = await this.wrenAIAdaptor.generateRecommendationQuestions({
      manifest,
      previousQuestions: input.previousQuestions,
      ...this.getThreadRecommendationQuestionsConfig(project),
    });
    return { id: response.queryId };
  }

  public async getInstantRecommendedQuestions(
    queryId: string,
  ): Promise<RecommendationQuestionsResult> {
    const response =
      await this.wrenAIAdaptor.getRecommendationQuestionsResult(queryId);
    return response;
  }

  public async deleteAllByProjectId(projectId: number): Promise<void> {
    // delete all threads
    await this.threadRepository.deleteAllBy({ projectId });
  }

  public async changeThreadResponseAnswerDetailStatus(
    responseId: number,
    status: ThreadResponseAnswerStatus,
    content?: string,
  ): Promise<ThreadResponse> {
    const response = await this.threadResponseRepository.findOneBy({
      id: responseId,
    });
    if (!response) {
      throw new Error(`Thread response ${responseId} not found`);
    }

    if (response.answerDetail?.status === status) {
      return;
    }

    const updatedResponse = await this.threadResponseRepository.updateOne(
      responseId,
      {
        answerDetail: {
          ...response.answerDetail,
          status,
          content,
        },
      },
    );

    return updatedResponse;
  }

  private async getDeployId() {
    const { id } = await this.projectService.getCurrentProject();
    const lastDeploy = await this.deployService.getLastDeployment(id);
    return lastDeploy.hash;
  }

  public async adjustThreadResponseWithSQL(
    threadResponseId: number,
    input: AdjustmentSqlInput,
  ): Promise<ThreadResponse> {
    const response = await this.threadResponseRepository.findOneBy({
      id: threadResponseId,
    });
    if (!response) {
      throw new Error(`Thread response ${threadResponseId} not found`);
    }

    return await this.threadResponseRepository.createOne({
      sql: input.sql,
      threadId: response.threadId,
      question: response.question,
      adjustment: {
        type: ThreadResponseAdjustmentType.APPLY_SQL,
        payload: {
          originalThreadResponseId: response.id,
          sql: input.sql,
        },
      },
    });
  }

  public async adjustThreadResponseAnswer(
    threadResponseId: number,
    input: AdjustmentReasoningInput,
    configurations: { language: string },
  ): Promise<ThreadResponse> {
    const originalThreadResponse =
      await this.threadResponseRepository.findOneBy({
        id: threadResponseId,
      });
    if (!originalThreadResponse) {
      throw new Error(`Thread response ${threadResponseId} not found`);
    }

    const { createdThreadResponse } =
      await this.adjustmentBackgroundTracker.createAdjustmentTask({
        threadId: originalThreadResponse.threadId,
        tables: input.tables,
        sqlGenerationReasoning: input.sqlGenerationReasoning,
        sql: originalThreadResponse.sql,
        projectId: input.projectId,
        configurations,
        question: originalThreadResponse.question,
        originalThreadResponseId: originalThreadResponse.id,
      });
    return createdThreadResponse;
  }

  public async cancelAdjustThreadResponseAnswer(taskId: string): Promise<void> {
    // call cancelAskFeedback on AI service
    await this.adjustmentBackgroundTracker.cancelAdjustmentTask(taskId);
  }

  public async rerunAdjustThreadResponseAnswer(
    threadResponseId: number,
    projectId: number,
    configurations: { language: string },
  ): Promise<{ queryId: string }> {
    const threadResponse = await this.threadResponseRepository.findOneBy({
      id: threadResponseId,
    });
    if (!threadResponse) {
      throw new Error(`Thread response ${threadResponseId} not found`);
    }

    const { queryId } =
      await this.adjustmentBackgroundTracker.rerunAdjustmentTask({
        threadId: threadResponse.threadId,
        threadResponseId,
        projectId,
        configurations,
      });
    return { queryId };
  }

  public async getAdjustmentTask(
    taskId: string,
  ): Promise<TrackedAdjustmentResult | null> {
    return this.adjustmentBackgroundTracker.getAdjustmentResult(taskId);
  }

  public async getAdjustmentTaskById(
    id: number,
  ): Promise<TrackedAdjustmentResult | null> {
    return this.adjustmentBackgroundTracker.getAdjustmentResultById(id);
  }

  /**
   * Get the thread response of a thread for asking
   * @param threadId
   * @returns Promise<ThreadResponse[]>
   */
  private async getAskingHistory(
    threadId: number,
    excludeThreadResponseId?: number,
  ): Promise<ThreadResponse[]> {
    if (!threadId) {
      return [];
    }
    let responses = await this.threadResponseRepository.getResponsesWithThread(
      threadId,
      10,
    );

    // exclude the thread response if the excludeThreadResponseId is provided
    // it's used when rerun the asking task, we don't want include the cancelled thread response
    if (excludeThreadResponseId) {
      responses = responses.filter(
        (response) => response.id !== excludeThreadResponseId,
      );
    }

    // filter out the thread response with empty sql
    return responses.filter((response) => response.sql);
  }

  private getThreadRecommendationQuestionsConfig(project: Project) {
    return {
      maxCategories: config.threadRecommendationQuestionMaxCategories,
      maxQuestions: config.threadRecommendationQuestionsMaxQuestions,
      configuration: {
        language: WrenAILanguage[project.language] || WrenAILanguage.EN,
      },
    };
  }
}
</file>

<file path="src/apollo/server/services/askingTaskTracker.ts">
import { getLogger } from '@server/utils';
import {
  AskResult,
  AskResultType,
  AskResultStatus,
  AskInput,
} from '@server/models/adaptor';
import {
  AskingTask,
  IAskingTaskRepository,
  IThreadResponseRepository,
  IViewRepository,
} from '@server/repositories';
import { IWrenAIAdaptor } from '../adaptors';
import * as Errors from '@server/utils/error';

const logger = getLogger('AskingTaskTracker');
logger.level = 'debug';

interface TrackedTask {
  queryId: string;
  taskId?: number;
  lastPolled: number;
  question?: string;
  result?: AskResult;
  isFinalized: boolean;
  threadResponseId?: number;
  rerunFromCancelled?: boolean;
}

export type TrackedAskingResult = AskResult & {
  taskId?: number;
  queryId: string;
  question: string;
};

export type CreateAskingTaskInput = AskInput & {
  rerunFromCancelled?: boolean;
  previousTaskId?: number;
  threadResponseId?: number;
};

export interface IAskingTaskTracker {
  createAskingTask(input: CreateAskingTaskInput): Promise<{ queryId: string }>;
  getAskingResult(queryId: string): Promise<TrackedAskingResult | null>;
  getAskingResultById(id: number): Promise<TrackedAskingResult | null>;
  cancelAskingTask(queryId: string): Promise<void>;
  bindThreadResponse(
    id: number,
    queryId: string,
    threadId: number,
    threadResponseId: number,
  ): Promise<void>;
}

export class AskingTaskTracker implements IAskingTaskTracker {
  private wrenAIAdaptor: IWrenAIAdaptor;
  private askingTaskRepository: IAskingTaskRepository;
  private trackedTasks: Map<string, TrackedTask> = new Map();
  private trackedTasksById: Map<number, TrackedTask> = new Map();
  private pollingInterval: number;
  private memoryRetentionTime: number;
  private pollingIntervalId: NodeJS.Timeout;
  private runningJobs = new Set<string>();
  private threadResponseRepository: IThreadResponseRepository;
  private viewRepository: IViewRepository;

  constructor({
    wrenAIAdaptor,
    askingTaskRepository,
    threadResponseRepository,
    viewRepository,
    pollingInterval = 1000, // 1 second
    memoryRetentionTime = 5 * 60 * 1000, // 5 minutes
  }: {
    wrenAIAdaptor: IWrenAIAdaptor;
    askingTaskRepository: IAskingTaskRepository;
    threadResponseRepository: IThreadResponseRepository;
    viewRepository: IViewRepository;
    pollingInterval?: number;
    memoryRetentionTime?: number;
  }) {
    this.wrenAIAdaptor = wrenAIAdaptor;
    this.askingTaskRepository = askingTaskRepository;
    this.threadResponseRepository = threadResponseRepository;
    this.viewRepository = viewRepository;
    this.pollingInterval = pollingInterval;
    this.memoryRetentionTime = memoryRetentionTime;
    this.startPolling();
  }

  public async createAskingTask(
    input: CreateAskingTaskInput,
  ): Promise<{ queryId: string }> {
    try {
      // Call the AI service to create a task
      const response = await this.wrenAIAdaptor.ask(input);
      const queryId = response.queryId;

      // validate the input
      if (
        input.rerunFromCancelled &&
        (!input.previousTaskId || !input.threadResponseId)
      ) {
        throw new Error(
          'Previous task id and thread response id are required if rerun from cancelled',
        );
      }

      // Start tracking this task
      const task = {
        queryId,
        lastPolled: Date.now(),
        question: input.query,
        isFinalized: false,
        rerunFromCancelled: input.rerunFromCancelled,
      } as TrackedTask;
      this.trackedTasks.set(queryId, task);

      // if rerun from cancelled, we update the query id to the previous task
      if (
        input.rerunFromCancelled &&
        input.previousTaskId &&
        input.threadResponseId
      ) {
        // set the thread response id in memory to bind the task to the thread response
        // we don't have to update to database here because the thread response id is already set in database
        task.threadResponseId = input.threadResponseId;

        // update the task id in memory
        this.trackedTasksById.set(input.previousTaskId, task);

        // get the latest result from the AI service
        // we get the latest result first to make it more responsive to client-side
        const result = await this.wrenAIAdaptor.getAskResult(queryId);

        // update the result in memory
        task.result = result;

        // update the query id in database
        await this.askingTaskRepository.updateOne(input.previousTaskId, {
          queryId,
        });
      }

      logger.info(`Created asking task with queryId: ${queryId}`);
      return { queryId };
    } catch (err) {
      logger.error(`Failed to create asking task: ${err}`);
      throw err;
    }
  }

  public async getAskingResult(
    queryId: string,
  ): Promise<TrackedAskingResult | null> {
    // Check if we're tracking this task in memory
    const trackedTask = this.trackedTasks.get(queryId);

    if (trackedTask && trackedTask.result) {
      return {
        ...trackedTask.result,
        queryId,
        question: trackedTask.question,
        taskId: trackedTask.taskId,
      };
    }

    // If not in memory or no result yet, check the database
    return this.getAskingResultFromDB({ queryId });
  }

  public async getAskingResultById(
    id: number,
  ): Promise<TrackedAskingResult | null> {
    const task = this.trackedTasksById.get(id);
    if (task) {
      return this.getAskingResult(task.queryId);
    }

    return this.getAskingResultFromDB({ taskId: id });
  }

  public async cancelAskingTask(queryId: string): Promise<void> {
    await this.wrenAIAdaptor.cancelAsk(queryId);
  }

  public stopPolling(): void {
    if (this.pollingIntervalId) {
      clearInterval(this.pollingIntervalId);
    }
  }

  public async bindThreadResponse(
    id: number,
    queryId: string,
    threadId: number,
    threadResponseId: number,
  ): Promise<void> {
    const task = this.trackedTasks.get(queryId);
    if (!task) {
      throw new Error(`Task ${queryId} not found`);
    }

    task.threadResponseId = threadResponseId;
    this.trackedTasksById.set(id, task);
    await this.askingTaskRepository.updateOne(id, {
      threadId,
      threadResponseId,
    });

    // check if the task is finalized and has a sql
    if (task.isFinalized) {
      await this.updateThreadResponseWhenTaskFinalized(task);
    }
  }

  private startPolling(): void {
    this.pollingIntervalId = setInterval(() => {
      this.pollTasks();
    }, this.pollingInterval);
  }

  private async pollTasks(): Promise<void> {
    const now = Date.now();
    const tasksToRemove: string[] = [];

    // Create an array of job functions
    const jobs = Array.from(this.trackedTasks.entries()).map(
      ([queryId, task]) =>
        async () => {
          try {
            // Skip if the job is already running
            if (this.runningJobs.has(queryId)) {
              return;
            }

            // Skip finalized tasks that have been in memory too long
            if (
              task.isFinalized &&
              now - task.lastPolled > this.memoryRetentionTime
            ) {
              tasksToRemove.push(queryId);
              return;
            }

            // Skip finalized tasks
            if (task.isFinalized) {
              return;
            }

            // Mark the job as running
            this.runningJobs.add(queryId);

            // Poll for updates
            logger.info(`Polling for updates for task ${queryId}`);
            const result = await this.wrenAIAdaptor.getAskResult(queryId);
            task.lastPolled = now;

            // if result is not changed, we don't need to update the database
            if (!this.isResultChanged(task.result, result)) {
              this.runningJobs.delete(queryId);
              return;
            }

            // update task in memory if any change
            task.result = result;

            // if result is still understanding, we don't need to update the database
            if (result.status === AskResultStatus.UNDERSTANDING) {
              this.runningJobs.delete(queryId);
              return;
            }

            // if it's identified as GENERAL or MISLEADING_QUER
            // we don't need to update the database and finalize the task
            if (
              result.type === AskResultType.GENERAL ||
              result.type === AskResultType.MISLEADING_QUERY
            ) {
              task.isFinalized = true;
              // if it's rerun from cancelled, we need to update the task result to failed in db
              if (task.rerunFromCancelled) {
                const errorCode =
                  result.type === AskResultType.GENERAL
                    ? Errors.GeneralErrorCodes.IDENTIED_AS_GENERAL
                    : Errors.GeneralErrorCodes.IDENTIED_AS_MISLEADING_QUERY;
                const error = {
                  code: errorCode,
                  message: Errors.errorMessages[errorCode],
                  shortMessage: Errors.shortMessages[errorCode],
                };
                await this.updateTaskInDatabase(
                  { queryId },
                  {
                    ...task,
                    // update the status to failed
                    // and the error message should be "IDENTIED_AS_GENERAL" or "IDENTIED_AS_MISLEADING_QUERY"
                    result: {
                      ...task.result,
                      status: AskResultStatus.FAILED,
                      error,
                    },
                  },
                );
              }
              this.runningJobs.delete(queryId);
              return;
            }

            // update the database
            // note: type could be null if it's still being understood or it's stopped
            // we already filtered out the understanding status above
            // so we update to database if it's stopped as well here.
            logger.info(`Updating task ${queryId} in database`);
            await this.updateTaskInDatabase({ queryId }, task);

            // Check if task is now finalized
            if (this.isTaskFinalized(result.status)) {
              task.isFinalized = true;
              // update thread response if threadResponseId is provided
              if (task.threadResponseId) {
                await this.updateThreadResponseWhenTaskFinalized(task);
              }

              logger.info(
                `Task ${queryId} is finalized with status: ${result.status}`,
              );
            }

            // Mark the job as finished
            this.runningJobs.delete(queryId);
          } catch (err) {
            this.runningJobs.delete(queryId);
            logger.error(err.stack);
            throw err;
          }
        },
    );

    // Run all jobs in parallel
    Promise.allSettled(jobs.map((job) => job())).then((results) => {
      // Log any rejected promises
      results.forEach((result, index) => {
        if (result.status === 'rejected') {
          logger.error(`Job ${index} failed: ${result.reason}`);
        }
      });

      // Clean up tasks that have been in memory too long
      if (tasksToRemove.length > 0) {
        logger.info(
          `Cleaning up tasks that have been in memory too long. Tasks: ${tasksToRemove.join(
            ', ',
          )}`,
        );
      }
      for (const queryId of tasksToRemove) {
        this.trackedTasks.delete(queryId);
      }
    });
  }

  private async updateThreadResponseWhenTaskFinalized(
    task: TrackedTask,
  ): Promise<void> {
    const response = task?.result?.response?.[0];
    if (!response) {
      return;
    }
    // if the generated response of asking task is not null, update the thread response
    if (response.viewId) {
      // get sql from the view
      const view = await this.viewRepository.findOneBy({
        id: response.viewId,
      });
      await this.threadResponseRepository.updateOne(task.threadResponseId, {
        sql: view.statement,
        viewId: response.viewId,
      });
    } else {
      await this.threadResponseRepository.updateOne(task.threadResponseId, {
        sql: response?.sql,
      });
    }
  }

  private async getAskingResultFromDB({
    queryId,
    taskId,
  }: {
    queryId?: string;
    taskId?: number;
  }): Promise<TrackedAskingResult | null> {
    let taskRecord: AskingTask | null = null;
    if (queryId) {
      taskRecord = await this.askingTaskRepository.findByQueryId(queryId);
    } else if (taskId) {
      taskRecord = await this.askingTaskRepository.findOneBy({ id: taskId });
    }

    if (!taskRecord) {
      return null;
    }

    return {
      ...(taskRecord?.detail as AskResult),
      queryId: queryId || taskRecord?.queryId,
      question: taskRecord?.question,
      taskId: taskRecord?.id,
    };
  }

  private async updateTaskInDatabase(
    filter: { queryId?: string; taskId?: number },
    trackedTask: TrackedTask,
  ): Promise<void> {
    const { queryId, taskId } = filter;
    let taskRecord: AskingTask | null = null;
    if (queryId) {
      taskRecord = await this.askingTaskRepository.findByQueryId(queryId);
    } else if (taskId) {
      taskRecord = await this.askingTaskRepository.findOneBy({ id: taskId });
    }

    if (!taskRecord) {
      // if record not found, create one
      const task = await this.askingTaskRepository.createOne({
        queryId,
        question: trackedTask.question,
        detail: trackedTask.result,
      });
      // update the task id in memory
      let existingTask: TrackedTask;
      if (queryId) {
        existingTask = this.trackedTasks.get(queryId);
      } else if (taskId) {
        existingTask = this.trackedTasksById.get(taskId);
      }
      if (existingTask) {
        existingTask.taskId = task.id;
      }
      return;
    }

    // update the task
    await this.askingTaskRepository.updateOne(taskRecord.id, {
      detail: trackedTask.result,
    });
  }

  private isTaskFinalized(status: AskResultStatus): boolean {
    return [
      AskResultStatus.FINISHED,
      AskResultStatus.FAILED,
      AskResultStatus.STOPPED,
    ].includes(status);
  }

  private isResultChanged(
    previousResult: AskResult,
    newResult: AskResult,
  ): boolean {
    // check status change
    if (previousResult?.status !== newResult.status) {
      return true;
    }

    return false;
  }
}
</file>

<file path="src/apollo/server/services/dashboardService.ts">
import {
  IDashboardRepository,
  IDashboardItemRepository,
  Dashboard,
  DashboardItem,
  DashboardItemType,
  DashboardItemDetail,
  DashboardItemLayout,
} from '@server/repositories';
import { getLogger } from '@server/utils';
import { getUTCOffsetMinutes } from '@server/utils/timezone';
import { IProjectService } from './projectService';
import {
  SetDashboardCacheData,
  ScheduleFrequencyEnum,
  CacheScheduleDayEnum,
  DashboardSchedule,
  DAYS,
} from '@server/models/dashboard';
import { CronExpressionParser } from 'cron-parser';
const logger = getLogger('DashboardService');
logger.level = 'debug';

export interface CreateDashboardItemInput {
  dashboardId: number;
  type: DashboardItemType;
  sql: string;
  chartSchema: DashboardItemDetail['chartSchema'];
}

export interface UpdateDashboardItemInput {
  displayName: string;
}

export type UpdateDashboardItemLayouts = (DashboardItemLayout & {
  itemId: number;
})[];

export interface IDashboardService {
  initDashboard(): Promise<Dashboard>;
  getCurrentDashboard(): Promise<Dashboard>;
  getDashboardItem(dashboardItemId: number): Promise<DashboardItem>;
  getDashboardItems(dashboardId: number): Promise<DashboardItem[]>;
  createDashboardItem(input: CreateDashboardItemInput): Promise<DashboardItem>;
  updateDashboardItem(
    dashboardItemId: number,
    input: UpdateDashboardItemInput,
  ): Promise<DashboardItem>;
  deleteDashboardItem(dashboardItemId: number): Promise<boolean>;
  updateDashboardItemLayouts(
    layouts: UpdateDashboardItemLayouts,
  ): Promise<DashboardItem[]>;
  setDashboardSchedule(
    dashboardId: number,
    data: SetDashboardCacheData,
  ): Promise<Dashboard>;
  parseCronExpression(dashboard: Dashboard): DashboardSchedule;
}

export class DashboardService implements IDashboardService {
  private projectService: IProjectService;
  private dashboardItemRepository: IDashboardItemRepository;
  private dashboardRepository: IDashboardRepository;

  constructor({
    projectService,
    dashboardItemRepository,
    dashboardRepository,
  }: {
    projectService: IProjectService;
    dashboardItemRepository: IDashboardItemRepository;
    dashboardRepository: IDashboardRepository;
  }) {
    this.projectService = projectService;
    this.dashboardItemRepository = dashboardItemRepository;
    this.dashboardRepository = dashboardRepository;
  }

  public async setDashboardSchedule(
    dashboardId: number,
    data: SetDashboardCacheData,
  ): Promise<Dashboard> {
    try {
      const { cacheEnabled, schedule } = data;
      // Validate input
      this.validateScheduleInput(data);

      // Check if dashboard exists
      const dashboard = await this.dashboardRepository.findOneBy({
        id: dashboardId,
      });
      if (!dashboard) {
        throw new Error(`Dashboard with id ${dashboardId} not found`);
      }
      if (!cacheEnabled) {
        return await this.dashboardRepository.updateOne(dashboardId, {
          cacheEnabled: false,
          scheduleFrequency: null,
          scheduleTimezone: null,
          scheduleCron: null,
          nextScheduledAt: null,
        });
      }
      // Initialize schedule-related variables
      let cronExpression: string | null = null;
      let nextScheduledAt: Date | null = null;

      // Process schedule if caching is enabled
      if (cacheEnabled && schedule.frequency !== ScheduleFrequencyEnum.NEVER) {
        cronExpression = this.generateCronExpression(schedule);
        nextScheduledAt = this.calculateNextRunTime(cronExpression);
      }

      // Update dashboard with new schedule
      return await this.dashboardRepository.updateOne(dashboardId, {
        cacheEnabled,
        scheduleFrequency: schedule.frequency,
        scheduleTimezone: schedule.timezone,
        scheduleCron: cronExpression,
        nextScheduledAt,
      });
    } catch (error) {
      logger.error(`Failed to set dashboard schedule: ${error.message}`);
      throw error;
    }
  }

  public async initDashboard(): Promise<Dashboard> {
    const project = await this.projectService.getCurrentProject();
    const existingDashboard = await this.dashboardRepository.findOneBy({
      projectId: project.id,
    });
    if (existingDashboard) return existingDashboard;
    // only support one dashboard for oss
    return await this.dashboardRepository.createOne({
      name: 'Dashboard',
      projectId: project.id,
    });
  }

  public async getCurrentDashboard(): Promise<Dashboard> {
    const project = await this.projectService.getCurrentProject();
    const dashboard = await this.dashboardRepository.findOneBy({
      projectId: project.id,
    });
    return { ...dashboard };
  }

  public async getDashboardItem(
    dashboardItemId: number,
  ): Promise<DashboardItem> {
    const item = await this.dashboardItemRepository.findOneBy({
      id: dashboardItemId,
    });
    if (!item) {
      throw new Error('Dashboard item not found.');
    }
    return item;
  }

  public async getDashboardItems(
    dashboardId: number,
  ): Promise<DashboardItem[]> {
    return await this.dashboardItemRepository.findAllBy({
      dashboardId,
    });
  }

  public async createDashboardItem(
    input: CreateDashboardItemInput,
  ): Promise<DashboardItem> {
    const layout = await this.calculateNewLayout(input.dashboardId);
    return await this.dashboardItemRepository.createOne({
      dashboardId: input.dashboardId,
      type: input.type,
      detail: {
        sql: input.sql,
        chartSchema: input.chartSchema,
      },
      layout,
    });
  }

  public async updateDashboardItem(
    dashboardItemId: number,
    input: UpdateDashboardItemInput,
  ): Promise<DashboardItem> {
    return await this.dashboardItemRepository.updateOne(dashboardItemId, {
      displayName: input.displayName,
    });
  }

  public async updateDashboardItemLayouts(
    layouts: UpdateDashboardItemLayouts,
  ): Promise<DashboardItem[]> {
    const updatedItems: DashboardItem[] = [];
    const isValidLayouts = layouts.every(
      (layout) =>
        layout.itemId &&
        layout.x >= 0 &&
        layout.y >= 0 &&
        layout.w > 0 &&
        layout.h > 0,
    );
    if (!isValidLayouts) {
      throw new Error('Invalid layouts boundaries.');
    }
    await Promise.all(
      layouts.map(async (layout) => {
        const updatedItem = await this.dashboardItemRepository.updateOne(
          layout.itemId,
          {
            layout: {
              x: layout.x,
              y: layout.y,
              w: layout.w,
              h: layout.h,
            },
          },
        );
        updatedItems.push(updatedItem);
      }),
    );
    return updatedItems;
  }

  public async deleteDashboardItem(dashboardItemId: number): Promise<boolean> {
    await this.dashboardItemRepository.deleteOne(dashboardItemId);
    return true;
  }

  private async calculateNewLayout(
    dashboardId: number,
  ): Promise<DashboardItemLayout> {
    const dashboardItems = await this.dashboardItemRepository.findAllBy({
      dashboardId,
    });
    const allLayouts = dashboardItems.map((item) => item.layout);
    if (allLayouts.length === 0) return { x: 0, y: 0, w: 3, h: 2 };

    const columnCount = 6;
    const halfLayoutX = columnCount / 2;
    // the current max y is the current row
    const maxY = Math.max(...allLayouts.map((layout) => layout.y));

    const latestLayout = allLayouts.filter((layout) => layout.y === maxY);
    const isNextRow =
      latestLayout.reduce((acc, layout) => acc + layout.x + layout.w, 0) >
      halfLayoutX;

    const x = isNextRow ? 0 : halfLayoutX;
    const y = isNextRow ? maxY + 2 : maxY;
    return { x, y, w: 3, h: 2 };
  }

  protected toUTC(schedule: DashboardSchedule): DashboardSchedule {
    // If no timezone is specified or it's a custom schedule, return as is
    if (
      !schedule.timezone ||
      schedule.frequency === ScheduleFrequencyEnum.CUSTOM
    ) {
      return schedule;
    }

    // Get timezone offset in minutes
    const offsetMinutes = getUTCOffsetMinutes(schedule.timezone);

    // Convert to UTC by subtracting the offset (if timezone is ahead of UTC)
    // or adding the offset (if timezone is behind UTC)
    let utcMinute = schedule.minute - offsetMinutes;
    let carryOver = 0;

    // Handle minute carry-over
    if (utcMinute < 0) {
      carryOver = Math.ceil(Math.abs(utcMinute) / 60);
      utcMinute = (utcMinute + carryOver * 60) % 60;
      carryOver = -carryOver;
    } else if (utcMinute >= 60) {
      carryOver = Math.floor(utcMinute / 60);
      utcMinute = utcMinute % 60;
    }

    let utcHour = schedule.hour + carryOver;
    let dayAdjustment = 0;

    // Handle hour carry-over
    if (utcHour < 0) {
      dayAdjustment = Math.ceil(Math.abs(utcHour) / 24);
      utcHour = (utcHour + dayAdjustment * 24) % 24;
      dayAdjustment = -dayAdjustment;
    } else if (utcHour >= 24) {
      dayAdjustment = Math.floor(utcHour / 24);
      utcHour = utcHour % 24;
    }

    // For weekly schedules, adjust the day if needed
    if (
      schedule.frequency === ScheduleFrequencyEnum.WEEKLY &&
      dayAdjustment !== 0
    ) {
      const currentDayIndex = DAYS.indexOf(schedule.day);
      const adjustedDayIndex = (currentDayIndex + dayAdjustment + 7) % 7;
      return {
        ...schedule,
        hour: utcHour,
        minute: utcMinute,
        day: DAYS[adjustedDayIndex],
      };
    }

    // Return a new schedule object with UTC hours and minutes
    return {
      ...schedule,
      hour: utcHour,
      minute: utcMinute,
    };
  }

  protected toTimezone(schedule: DashboardSchedule): DashboardSchedule {
    const { timezone } = schedule;
    // If it's a custom schedule or no timezone is specified, return as is
    if (
      [ScheduleFrequencyEnum.CUSTOM, ScheduleFrequencyEnum.NEVER].includes(
        schedule.frequency,
      ) ||
      !timezone
    ) {
      return schedule;
    }

    // Get timezone offset in minutes
    const offsetMinutes = getUTCOffsetMinutes(timezone);

    // Convert from UTC to timezone by adding the offset (if timezone is ahead of UTC)
    // or subtracting the offset (if timezone is behind UTC)
    let localMinute = schedule.minute + offsetMinutes;
    let carryOver = 0;

    // Handle minute carry-over
    if (localMinute < 0) {
      carryOver = Math.ceil(Math.abs(localMinute) / 60);
      localMinute = (localMinute + carryOver * 60) % 60;
      carryOver = -carryOver;
    } else if (localMinute >= 60) {
      carryOver = Math.floor(localMinute / 60);
      localMinute = localMinute % 60;
    }

    let localHour = schedule.hour + carryOver;
    let dayAdjustment = 0;

    // Handle hour carry-over
    if (localHour < 0) {
      dayAdjustment = Math.ceil(Math.abs(localHour) / 24);
      localHour = (localHour + dayAdjustment * 24) % 24;
      dayAdjustment = -dayAdjustment;
    } else if (localHour >= 24) {
      dayAdjustment = Math.floor(localHour / 24);
      localHour = localHour % 24;
    }

    // For weekly schedules, adjust the day if needed
    if (
      schedule.frequency === ScheduleFrequencyEnum.WEEKLY &&
      dayAdjustment !== 0
    ) {
      const currentDayIndex = DAYS.indexOf(schedule.day);
      const adjustedDayIndex = (currentDayIndex + dayAdjustment + 7) % 7;
      return {
        ...schedule,
        hour: localHour,
        minute: localMinute,
        day: DAYS[adjustedDayIndex],
        timezone,
      };
    }

    // Return a new schedule object with local hours and minutes
    return {
      ...schedule,
      hour: localHour,
      minute: localMinute,
      timezone,
    };
  }

  protected generateCronExpression(schedule: DashboardSchedule): string | null {
    const { frequency, day, hour, minute } = this.toUTC(schedule);

    switch (frequency) {
      case ScheduleFrequencyEnum.DAILY:
        return `${minute} ${hour} * * *`;
      case ScheduleFrequencyEnum.WEEKLY:
        // e.g. 0 10 * * MON
        return `${minute} ${hour} * * ${day}`;
      case ScheduleFrequencyEnum.CUSTOM:
        return schedule.cron;
      case ScheduleFrequencyEnum.NEVER:
        return null;
      default:
        logger.warn(`Unsupported schedule frequency: ${frequency}`);
        return null;
    }
  }

  protected calculateNextRunTime(cronExpression: string): Date | null {
    try {
      const interval = CronExpressionParser.parse(cronExpression, {
        currentDate: new Date(),
      });
      return interval.next().toDate();
    } catch (error) {
      logger.error(`Failed to parse cron expression: ${error.message}`);
      return null;
    }
  }

  protected validateScheduleInput(data: SetDashboardCacheData): void {
    const { schedule } = data;
    if (!schedule) {
      return;
    }
    if (schedule.frequency === ScheduleFrequencyEnum.WEEKLY && !schedule.day) {
      throw new Error('Day of week is required for weekly schedule');
    }

    if (schedule.frequency === ScheduleFrequencyEnum.CUSTOM && !schedule.cron) {
      throw new Error('Cron expression is required for custom schedule');
    }

    if (schedule.hour < 0 || schedule.hour > 23) {
      throw new Error('Hour must be between 0 and 23');
    }

    if (schedule.minute < 0 || schedule.minute > 59) {
      throw new Error('Minute must be between 0 and 59');
    }

    if (schedule.timezone) {
      try {
        new Date().toLocaleString('en-US', { timeZone: schedule.timezone });
      } catch (_) {
        throw new Error(`Invalid timezone: ${schedule.timezone}`);
      }
    }

    if (schedule.frequency === ScheduleFrequencyEnum.CUSTOM) {
      // can not less than 10 minutes, skip if is local
      if (process.env.NODE_ENV === 'development') return;
      const baseInterval = CronExpressionParser.parse(schedule.cron, {
        currentDate: new Date(),
      });
      const baseDate = baseInterval.next().toDate();

      const nextInterval = CronExpressionParser.parse(schedule.cron, {
        currentDate: baseDate,
      });
      const nextDate = nextInterval.next().toDate();
      const diff = nextDate.getTime() - baseDate.getTime();
      if (diff < 10 * 60 * 1000) {
        throw new Error(
          'Custom cron expression must be at least 10 minutes apart',
        );
      }
    }
  }

  public parseCronExpression(dashboard: Dashboard): DashboardSchedule {
    if (!dashboard.scheduleCron) {
      return {
        frequency: dashboard.scheduleFrequency,
        hour: 0,
        minute: 0,
        day: null,
        timezone: dashboard.scheduleTimezone || '',
        cron: '',
      } as DashboardSchedule;
    }
    switch (dashboard.scheduleFrequency) {
      case ScheduleFrequencyEnum.CUSTOM:
        return {
          frequency: ScheduleFrequencyEnum.CUSTOM,
          hour: 0,
          minute: 0,
          day: null,
          timezone: dashboard.scheduleTimezone || '',
          cron: dashboard.scheduleCron,
        };
      case ScheduleFrequencyEnum.DAILY:
      case ScheduleFrequencyEnum.WEEKLY: {
        const parts = dashboard.scheduleCron.split(' ');
        if (parts.length !== 5) {
          throw new Error('Invalid cron expression format');
        }
        const [minute, hour, , , dayOfWeek] = parts;
        return this.toTimezone({
          frequency: dashboard.scheduleFrequency,
          hour: parseInt(hour, 10),
          minute: parseInt(minute, 10),
          day:
            dashboard.scheduleFrequency === ScheduleFrequencyEnum.WEEKLY
              ? (dayOfWeek as CacheScheduleDayEnum)
              : null,
          timezone: dashboard.scheduleTimezone || '',
          cron: null,
        } as DashboardSchedule);
      }
      case ScheduleFrequencyEnum.NEVER: {
        return {
          frequency: ScheduleFrequencyEnum.NEVER,
          hour: null,
          minute: null,
          day: null,
          timezone: dashboard.scheduleTimezone || '',
          cron: null,
        } as DashboardSchedule;
      }
      default: {
        throw new Error('Invalid schedule frequency');
      }
    }
  }
}
</file>

<file path="src/apollo/server/services/deployService.ts">
import { WrenAIDeployStatusEnum } from '@server/models/adaptor';
import { IWrenAIAdaptor } from '../adaptors/wrenAIAdaptor';
import {
  Deploy,
  DeployStatusEnum,
  IDeployLogRepository,
} from '../repositories/deployLogRepository';
import { Manifest } from '../mdl/type';
import { createHash } from 'node:crypto';
import { getLogger } from '@server/utils';
import {
  PostHogTelemetry,
  TelemetryEvent,
  WrenService,
} from '../telemetry/telemetry';

const logger = getLogger('DeployService');
logger.level = 'debug';

export interface DeployResponse {
  status: DeployStatusEnum;
  error?: string;
}

export interface MDLSyncResponse {
  isSyncronized: boolean;
}

export interface IDeployService {
  deploy(
    manifest: Manifest,
    projectId: number,
    force?: boolean,
  ): Promise<DeployResponse>;
  getLastDeployment(projectId: number): Promise<Deploy>;
  getInProgressDeployment(projectId: number): Promise<Deploy>;
  createMDLHash(manifest: Manifest, projectId: number): string;
  getMDLByHash(hash: string): Promise<string>;
  deleteAllByProjectId(projectId: number): Promise<void>;
}

export class DeployService implements IDeployService {
  private wrenAIAdaptor: IWrenAIAdaptor;
  private deployLogRepository: IDeployLogRepository;
  private telemetry: PostHogTelemetry;

  constructor({
    wrenAIAdaptor,
    deployLogRepository,
    telemetry,
  }: {
    wrenAIAdaptor: IWrenAIAdaptor;
    deployLogRepository: IDeployLogRepository;
    telemetry: PostHogTelemetry;
  }) {
    this.wrenAIAdaptor = wrenAIAdaptor;
    this.deployLogRepository = deployLogRepository;
    this.telemetry = telemetry;
  }

  public async getLastDeployment(projectId) {
    const lastDeploy =
      await this.deployLogRepository.findLastProjectDeployLog(projectId);
    if (!lastDeploy) {
      return null;
    }
    return lastDeploy;
  }

  public async getInProgressDeployment(projectId) {
    return await this.deployLogRepository.findInProgressProjectDeployLog(
      projectId,
    );
  }

  public async deploy(manifest, projectId, force = false) {
    const eventName = TelemetryEvent.MODELING_DEPLOY_MDL;
    try {
      // generate hash of manifest
      const hash = this.createMDLHash(manifest, projectId);
      logger.debug(`Deploying model, hash: ${hash}`);

      if (!force) {
        // check if the model current deployment
        const lastDeploy =
          await this.deployLogRepository.findLastProjectDeployLog(projectId);
        if (lastDeploy && lastDeploy.hash === hash) {
          logger.log(`Model has been deployed, hash: ${hash}`);
          return { status: DeployStatusEnum.SUCCESS };
        }
      }
      const deployData = {
        manifest,
        hash,
        projectId,
        status: DeployStatusEnum.IN_PROGRESS,
      } as Deploy;
      const deploy = await this.deployLogRepository.createOne(deployData);

      // deploy to AI-service
      const { status: aiStatus, error: aiError } =
        await this.wrenAIAdaptor.deploy({
          manifest,
          hash,
        });

      // update deploy status
      const status =
        aiStatus === WrenAIDeployStatusEnum.SUCCESS
          ? DeployStatusEnum.SUCCESS
          : DeployStatusEnum.FAILED;
      await this.deployLogRepository.updateOne(deploy.id, {
        status,
        error: aiError,
      });

      // telemetry
      if (status === DeployStatusEnum.SUCCESS) {
        this.telemetry.sendEvent(eventName);
      } else {
        this.telemetry.sendEvent(
          eventName,
          { mdl: manifest, error: aiError },
          WrenService.AI,
          false,
        );
      }
      return { status, error: aiError };
    } catch (err: any) {
      logger.error(`Error deploying model: ${err.message}`);
      this.telemetry.sendEvent(
        eventName,
        { mdl: manifest, error: err.message },
        err.extensions?.service,
        false,
      );
      return { status: DeployStatusEnum.FAILED, error: err.message };
    }
  }

  public createMDLHash(manifest: Manifest, projectId: number) {
    const manifestStr = JSON.stringify(manifest);
    const content = `${projectId} ${manifestStr}`;
    const hash = createHash('sha1').update(content).digest('hex');
    return hash;
  }

  public async getMDLByHash(hash: string) {
    const deploy = await this.deployLogRepository.findOneBy({ hash });
    if (!deploy) {
      return null;
    }
    // return base64 encoded manifest
    return Buffer.from(JSON.stringify(deploy.manifest)).toString('base64');
  }

  public async deleteAllByProjectId(projectId: number): Promise<void> {
    // delete all deploy logs
    await this.deployLogRepository.deleteAllBy({ projectId });
  }
}
</file>

<file path="src/apollo/server/services/index.ts">
export * from './askingService';
export * from './deployService';
export * from './mdlService';
export * from './modelService';
export * from './projectService';
export * from './queryService';
export * from './metadataService';
export * from './dashboardService';
export * from './askingTaskTracker';
export * from './instructionService';
</file>

<file path="src/apollo/server/services/instructionService.ts">
import { pick } from 'lodash';
import { IWrenAIAdaptor } from '@server/adaptors';
import { InstructionInput, UpdateInstructionInput } from '@server/models';
import {
  InstructionResult,
  InstructionStatus,
  GenerateInstructionInput,
} from '@server/models/adaptor';
import { IInstructionRepository, Instruction } from '@server/repositories';
import * as Errors from '@server/utils/error';
import { GeneralErrorCodes } from '@server/utils/error';
export interface IInstructionService {
  getInstructions(projectId: number): Promise<Instruction[]>;
  createInstruction(instruction: InstructionInput): Promise<Instruction>;
  createInstructions(instructions: InstructionInput[]): Promise<Instruction[]>;
  updateInstruction(instruction: UpdateInstructionInput): Promise<Instruction>;
  deleteInstruction(id: number, projectId: number): Promise<void>;
}

export class InstructionService implements IInstructionService {
  private readonly instructionRepository: IInstructionRepository;
  private readonly wrenAIAdaptor: IWrenAIAdaptor;
  constructor({
    instructionRepository,
    wrenAIAdaptor,
  }: {
    instructionRepository: IInstructionRepository;
    wrenAIAdaptor: IWrenAIAdaptor;
  }) {
    this.instructionRepository = instructionRepository;
    this.wrenAIAdaptor = wrenAIAdaptor;
  }
  public async getInstructions(projectId: number): Promise<Instruction[]> {
    return this.instructionRepository.findAllBy({ projectId });
  }

  public async createInstruction(
    input: InstructionInput,
  ): Promise<Instruction> {
    const tx = await this.instructionRepository.transaction();
    try {
      this.validateInstructionInput(input);
      const newInstruction = await this.instructionRepository.createOne(
        {
          ...input,
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString(),
        },
        {
          tx,
        },
      );
      const { queryId } = await this.wrenAIAdaptor.generateInstruction([
        this.pickGenerateInstructionInput(newInstruction),
      ]);
      const res = await this.waitDeployInstruction(queryId);
      if (res.error) {
        await tx.rollback();
        throw Errors.create(res.error.code, {
          customMessage: res.error.message,
        });
      }
      await tx.commit();
      return newInstruction;
    } catch (e: any) {
      await tx.rollback();
      throw new Error(`Failed to create instruction: ${e}`);
    }
  }

  public async createInstructions(
    inputs: InstructionInput[],
  ): Promise<Instruction[]> {
    const tx = await this.instructionRepository.transaction();
    try {
      inputs.forEach((input) => this.validateInstructionInput(input));
      const newInstructions = await this.instructionRepository.createMany(
        inputs.map((input) => ({
          ...input,
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString(),
        })),
        {
          tx,
        },
      );
      const { queryId } = await this.wrenAIAdaptor.generateInstruction(
        newInstructions.map(this.pickGenerateInstructionInput),
      );
      const res = await this.waitDeployInstruction(queryId);
      if (res.error) {
        await tx.rollback();
        throw Errors.create(res.error.code, {
          customMessage: res.error.message,
        });
      }
      await tx.commit();
      return newInstructions;
    } catch (e: any) {
      await tx.rollback();
      throw new Error(`Failed to create instruction: ${e}`);
    }
  }

  public async updateInstruction(
    input: UpdateInstructionInput,
  ): Promise<Instruction> {
    const tx = await this.instructionRepository.transaction();
    try {
      this.validateInstructionInput(input);
      const instruction = await this.instructionRepository.findOneBy(
        { id: input.id, projectId: input.projectId },
        {
          tx,
        },
      );
      if (!instruction) {
        throw new Error('Instruction not found');
      }
      const instructionData = {
        ...instruction,
        ...input,
        updatedAt: new Date().toISOString(),
      };
      const updatedInstruction = await this.instructionRepository.updateOne(
        input.id,
        instructionData,
        { tx },
      );
      const { queryId } = await this.wrenAIAdaptor.generateInstruction([
        this.pickGenerateInstructionInput(updatedInstruction),
      ]);
      const res = await this.waitDeployInstruction(queryId);
      if (res.error) {
        await tx.rollback();
        throw Errors.create(res.error.code, {
          customMessage: res.error.message,
        });
      }
      await tx.commit();
      return updatedInstruction;
    } catch (e: any) {
      await tx.rollback();
      throw new Error(`Failed to update instruction: ${e}`);
    }
  }
  async deleteInstruction(id: number, projectId: number): Promise<void> {
    const tx = await this.instructionRepository.transaction();
    try {
      const instruction = await this.instructionRepository.findOneBy(
        { id, projectId },
        { tx },
      );
      if (!instruction) {
        throw new Error('Instruction not found');
      }
      await this.instructionRepository.deleteOne(id, { tx });
      await this.wrenAIAdaptor.deleteInstructions([id], instruction.projectId);
      await tx.commit();
    } catch (e: any) {
      await tx.rollback();
      throw new Error(`Failed to delete instruction: ${e}`);
    }
  }

  private async waitDeployInstruction(
    queryId: string,
    maxRetries = 30, // Default 30 retries (30 seconds)
  ): Promise<InstructionResult> {
    const isFinalStatus = (status: InstructionStatus) =>
      status === InstructionStatus.FINISHED ||
      status === InstructionStatus.FAILED;

    let res = await this.wrenAIAdaptor.getInstructionResult(queryId);
    let retryCount = 0;

    while (!isFinalStatus(res.status) && retryCount < maxRetries) {
      await new Promise((resolve) => setTimeout(resolve, 1000));
      res = await this.wrenAIAdaptor.getInstructionResult(queryId);
      retryCount++;
    }

    if (!isFinalStatus(res.status)) {
      throw Errors.create(GeneralErrorCodes.DEPLOY_TIMEOUT_ERROR, {
        customMessage: `Instruction deployment timed out after ${maxRetries} seconds`,
      });
    }

    return res;
  }

  private pickGenerateInstructionInput(
    instruction: Instruction,
  ): GenerateInstructionInput {
    return pick(instruction, [
      'id',
      'projectId',
      'instruction',
      'questions',
      'isDefault',
    ]);
  }

  private validateInstructionInput(input: InstructionInput): void {
    if (!input.instruction) {
      throw new Error('Instruction is required');
    }
    if (input.instruction.length > 1000) {
      throw new Error('Instruction is too long');
    }
  }
}
</file>

<file path="src/apollo/server/services/mdlService.ts">
import { MDLBuilder } from '../mdl/mdlBuilder';
import {
  IModelNestedColumnRepository,
  IModelColumnRepository,
  IModelRepository,
  IProjectRepository,
  IRelationRepository,
  IViewRepository,
} from '../repositories';
import { Manifest } from '../mdl/type';

export interface MakeCurrentModelMDLResult {
  manifest: Manifest;
  mdlBuilder: MDLBuilder;
}
export interface IMDLService {
  makeCurrentModelMDL(): Promise<MakeCurrentModelMDLResult>;
}

export class MDLService implements IMDLService {
  private projectRepository: IProjectRepository;
  private modelRepository: IModelRepository;
  private modelColumnRepository: IModelColumnRepository;
  private modelNestedColumnRepository: IModelNestedColumnRepository;
  private relationRepository: IRelationRepository;
  private viewRepository: IViewRepository;

  constructor({
    projectRepository,
    modelRepository,
    modelColumnRepository,
    modelNestedColumnRepository,
    relationRepository,
    viewRepository,
  }: {
    projectRepository: IProjectRepository;
    modelRepository: IModelRepository;
    modelColumnRepository: IModelColumnRepository;
    modelNestedColumnRepository: IModelNestedColumnRepository;
    relationRepository: IRelationRepository;
    viewRepository: IViewRepository;
  }) {
    this.projectRepository = projectRepository;
    this.modelRepository = modelRepository;
    this.modelColumnRepository = modelColumnRepository;
    this.modelNestedColumnRepository = modelNestedColumnRepository;
    this.relationRepository = relationRepository;
    this.viewRepository = viewRepository;
  }

  public async makeCurrentModelMDL() {
    const project = await this.projectRepository.getCurrentProject();
    const projectId = project.id;
    const models = await this.modelRepository.findAllBy({ projectId });
    const modelIds = models.map((m) => m.id);
    const columns =
      await this.modelColumnRepository.findColumnsByModelIds(modelIds);
    const modelNestedColumns =
      await this.modelNestedColumnRepository.findNestedColumnsByModelIds(
        modelIds,
      );
    const relations = await this.relationRepository.findRelationInfoBy({
      projectId,
    });
    const views = await this.viewRepository.findAllBy({ projectId });
    const relatedModels = models;
    const relatedColumns = columns;
    const relatedRelations = relations;
    const mdlBuilder = new MDLBuilder({
      project,
      models,
      columns,
      nestedColumns: modelNestedColumns,
      relations,
      views,
      relatedModels,
      relatedColumns,
      relatedRelations,
    });
    return { manifest: mdlBuilder.build(), mdlBuilder };
  }
}
</file>

<file path="src/apollo/server/services/metadataService.ts">
/** 
    This class is responsible for handling the retrieval of metadata from the data source.
    For DuckDB, we control the access logic and directly query the WrenEngine.
    For PostgreSQL and BigQuery, we will use the Ibis server API.
 */

import { IIbisAdaptor } from '../adaptors/ibisAdaptor';
import { IWrenEngineAdaptor } from '../adaptors/wrenEngineAdaptor';
import { Project } from '../repositories';
import { DataSourceName } from '../types';
import { getLogger } from '@server/utils';

const logger = getLogger('MetadataService');
logger.level = 'debug';

export interface CompactColumn {
  name: string;
  type: string;
  notNull: boolean;
  description?: string;
  properties?: Record<string, any>;
  nestedColumns?: CompactColumn[];
}

export enum ConstraintType {
  PRIMARY_KEY = 'PRIMARY KEY',
  FOREIGN_KEY = 'FOREIGN KEY',
  UNIQUE = 'UNIQUE',
}

export interface CompactTable {
  name: string;
  columns: CompactColumn[];
  description?: string;
  properties?: Record<string, any>;
  primaryKey?: string;
}

export interface RecommendConstraint {
  constraintName: string;
  constraintType: ConstraintType;
  constraintTable: string;
  constraintColumn: string;
  constraintedTable: string;
  constraintedColumn: string;
}

export interface IDataSourceMetadataService {
  listTables(project: Project): Promise<CompactTable[]>;
  listConstraints(project: Project): Promise<RecommendConstraint[]>;
  getVersion(project: Project): Promise<string>;
}

export class DataSourceMetadataService implements IDataSourceMetadataService {
  private readonly ibisAdaptor: IIbisAdaptor;
  private readonly wrenEngineAdaptor: IWrenEngineAdaptor;

  constructor({
    ibisAdaptor,
    wrenEngineAdaptor,
  }: {
    ibisAdaptor: IIbisAdaptor;
    wrenEngineAdaptor: IWrenEngineAdaptor;
  }) {
    this.ibisAdaptor = ibisAdaptor;
    this.wrenEngineAdaptor = wrenEngineAdaptor;
  }

  public async listTables(project): Promise<CompactTable[]> {
    const { type: dataSource, connectionInfo } = project;
    if (dataSource === DataSourceName.DUCKDB) {
      const tables = await this.wrenEngineAdaptor.listTables();
      return tables;
    }
    return await this.ibisAdaptor.getTables(dataSource, connectionInfo);
  }

  public async listConstraints(
    project: Project,
  ): Promise<RecommendConstraint[]> {
    const { type: dataSource, connectionInfo } = project;
    if (dataSource === DataSourceName.DUCKDB) {
      return [];
    }
    return await this.ibisAdaptor.getConstraints(dataSource, connectionInfo);
  }

  public async getVersion(project: Project): Promise<string> {
    const { type: dataSource, connectionInfo } = project;
    return await this.ibisAdaptor.getVersion(dataSource, connectionInfo);
  }
}
</file>

<file path="src/apollo/server/services/modelService.ts">
import { SampleDatasetTable } from '@server/data';
import {
  IModelColumnRepository,
  IModelRepository,
  IRelationRepository,
  IViewRepository,
  Model,
  ModelColumn,
  Relation,
} from '@server/repositories';
import {
  getLogger,
  safeParseJson,
  replaceAllowableSyntax,
  validateDisplayName,
} from '@server/utils';
import { RelationData, UpdateRelationData } from '@server/types';
import { IProjectService } from './projectService';
import {
  CreateCalculatedFieldData,
  ExpressionName,
  UpdateCalculatedFieldData,
  CheckCalculatedFieldCanQueryData,
} from '@server/models';
import { IMDLService } from './mdlService';
import { IWrenEngineAdaptor } from '../adaptors/wrenEngineAdaptor';
import { ValidationRules } from '@server/adaptors/ibisAdaptor';
import { isEmpty, capitalize } from 'lodash';
import {} from '@server/utils/regex';
import * as Errors from '@server/utils/error';
import { DataSourceName } from '@server/types';
import { IQueryService } from './queryService';

const logger = getLogger('ModelService');
logger.level = 'debug';

export interface ValidateCalculatedFieldResponse {
  valid: boolean;
  message?: string;
}

export interface IModelService {
  updatePrimaryKeys(tables: SampleDatasetTable[]): Promise<void>;
  batchUpdateModelProperties(tables: SampleDatasetTable[]): Promise<void>;
  batchUpdateColumnProperties(tables: SampleDatasetTable[]): Promise<void>;
  // saveRelations was used in the onboarding process, we assume there is not existing relation in the project
  saveRelations(relations: RelationData[]): Promise<Relation[]>;
  createRelation(relation: RelationData): Promise<Relation>;
  updateRelation(relation: UpdateRelationData, id: number): Promise<Relation>;
  deleteRelation(id: number): Promise<void>;
  createCalculatedField(data: CreateCalculatedFieldData): Promise<ModelColumn>;
  updateCalculatedField(
    data: UpdateCalculatedFieldData,
    id: number,
  ): Promise<ModelColumn>;
  generateReferenceName(data: any): string;
  validateCalculatedFieldNaming(
    name: string,
    modelId: number,
    columnId?: number,
  ): Promise<ValidateCalculatedFieldResponse>;
  deleteAllViewsByProjectId(projectId: number): Promise<void>;
  deleteAllModelsByProjectId(projectId: number): Promise<void>;
}

export interface GenerateReferenceNameData {
  displayName: string;
  sourceTableName: string;
  existedReferenceNames: string[];
}

export class ModelService implements IModelService {
  private projectService: IProjectService;
  private modelRepository: IModelRepository;
  private modelColumnRepository: IModelColumnRepository;
  private relationRepository: IRelationRepository;
  private viewRepository: IViewRepository;
  private mdlService: IMDLService;
  private wrenEngineAdaptor: IWrenEngineAdaptor;
  private queryService: IQueryService;

  constructor({
    projectService,
    modelRepository,
    modelColumnRepository,
    relationRepository,
    viewRepository,
    mdlService,
    wrenEngineAdaptor,
    queryService,
  }: {
    projectService: IProjectService;
    modelRepository: IModelRepository;
    modelColumnRepository: IModelColumnRepository;
    relationRepository: IRelationRepository;
    viewRepository: IViewRepository;
    mdlService: IMDLService;
    wrenEngineAdaptor: IWrenEngineAdaptor;
    queryService: IQueryService;
  }) {
    this.projectService = projectService;
    this.modelRepository = modelRepository;
    this.modelColumnRepository = modelColumnRepository;
    this.relationRepository = relationRepository;
    this.viewRepository = viewRepository;
    this.mdlService = mdlService;
    this.wrenEngineAdaptor = wrenEngineAdaptor;
    this.queryService = queryService;
  }

  public async createCalculatedField(
    data: CreateCalculatedFieldData,
  ): Promise<ModelColumn> {
    const { modelId, name: displayName, expression, lineage } = data;
    const logTitle = `Create Calculated Field ${displayName}`;
    const model = await this.modelRepository.findOneBy({
      id: modelId,
    });
    if (!model) {
      throw new Error('Model not found');
    }
    const { valid, message } = await this.validateCalculatedFieldNaming(
      displayName,
      modelId,
    );
    logger.debug(
      `${logTitle} : validateCalculatedFieldNaming: ${valid}, ${message}`,
    );
    if (!valid) {
      throw new Error(message);
    }

    // generate referenceName
    const referenceName =
      this.generateReferenceNameFromDisplayName(displayName);
    logger.debug(`${logTitle} : generated referenceName: "${referenceName}"`);

    // check this calculated field is valid for engine to query
    const { valid: canQuery, message: errorMessage } =
      await this.checkCalculatedFieldCanQuery(modelId, model.referenceName, {
        referenceName,
        expression,
        lineage,
      } as CheckCalculatedFieldCanQueryData);
    logger.debug(`${logTitle} : checkCalculatedFieldCanQuery: ${canQuery}`);
    if (!canQuery) {
      const parsedErrorMessage = safeParseJson(errorMessage);
      throw Errors.create(Errors.GeneralErrorCodes.INVALID_CALCULATED_FIELD, {
        customMessage: parsedErrorMessage?.message || errorMessage,
        originalError: parsedErrorMessage || null,
      });
    }
    const inputFieldId = lineage[lineage.length - 1];
    const dataType = await this.inferCalculatedFieldDataType(
      expression,
      inputFieldId,
    );
    logger.debug(`${logTitle} : inferCalculatedFieldDataType: ${dataType}`);

    // create calculated field
    const column = await this.modelColumnRepository.createOne({
      modelId,
      displayName: displayName,
      sourceColumnName: referenceName,
      referenceName,
      type: dataType,
      isCalculated: true,
      isPk: false,
      notNull: false,
      aggregation: expression,
      lineage: JSON.stringify(lineage),
      properties: JSON.stringify({ description: '' }),
    });
    return column;
  }

  public async updateCalculatedField(
    data: UpdateCalculatedFieldData,
    id: number,
  ): Promise<ModelColumn> {
    const { name: displayName, expression, lineage } = data;
    const logTitle = `Update Calculated Field ${id}`;
    const column = await this.modelColumnRepository.findOneBy({ id });
    if (!column) {
      throw new Error('Column not found');
    }
    const model = await this.modelRepository.findOneBy({
      id: column.modelId,
    });
    const { valid, message } = await this.validateCalculatedFieldNaming(
      displayName,
      column.modelId,
      id,
    );
    logger.debug(
      `${logTitle}: validateCalculatedFieldNaming: ${valid}, ${message}`,
    );
    if (!valid) {
      throw new Error(message);
    }
    const referenceName =
      this.generateReferenceNameFromDisplayName(displayName);
    logger.debug(`${logTitle}: generated referenceName: "${referenceName}"`);

    // check this calculated field is valid for engine to query
    const { valid: canQuery, message: errorMessage } =
      await this.checkCalculatedFieldCanQuery(model.id, model.referenceName, {
        referenceName,
        expression,
        lineage,
      } as CheckCalculatedFieldCanQueryData);
    logger.debug(`${logTitle}: checkCalculatedFieldCanQuery: ${canQuery}`);
    if (!canQuery) {
      const error = JSON.parse(errorMessage);
      throw Errors.create(Errors.GeneralErrorCodes.INVALID_CALCULATED_FIELD, {
        customMessage: error?.message,
        originalError: error,
      });
    }
    const inputFieldId = lineage[lineage.length - 1];
    const dataType = await this.inferCalculatedFieldDataType(
      expression,
      inputFieldId,
    );
    logger.debug(`${logTitle}: inferCalculatedFieldDataType: ${dataType}`);
    const updatedColumn = await this.modelColumnRepository.updateOne(id, {
      displayName: displayName,
      sourceColumnName: referenceName,
      referenceName,
      type: dataType,
      aggregation: expression,
      lineage: JSON.stringify(lineage),
    });
    return updatedColumn;
  }

  public async updatePrimaryKeys(tables: SampleDatasetTable[]) {
    logger.debug('start update primary keys');
    const { id } = await this.projectService.getCurrentProject();
    const models = await this.modelRepository.findAllBy({
      projectId: id,
    });
    const tableToUpdate = tables.filter((t) => t.primaryKey);
    for (const table of tableToUpdate) {
      const model = models.find((m) => m.sourceTableName === table.tableName);
      if (!model) {
        logger.debug(`Model not found, table name: ${table.tableName}`);
      }
      await this.modelColumnRepository.setModelPrimaryKey(
        model.id,
        table.primaryKey,
      );
    }
  }

  public async batchUpdateModelProperties(tables: SampleDatasetTable[]) {
    logger.debug('start batch update model description');
    const { id } = await this.projectService.getCurrentProject();
    const models = await this.modelRepository.findAllBy({
      projectId: id,
    });

    await Promise.all([
      tables.map(async (table) => {
        const model = models.find((m) => m.sourceTableName === table.tableName);
        if (!model) {
          logger.debug(`Model not found, table name: ${table.tableName}`);
          return;
        }
        const properties = model.properties
          ? { ...JSON.parse(model.properties), ...table.properties }
          : { ...table.properties };
        await this.modelRepository.updateOne(model.id, {
          displayName: table.properties?.displayName || model.displayName,
          properties: JSON.stringify(properties),
        });
      }),
    ]);
  }

  public async batchUpdateColumnProperties(tables: SampleDatasetTable[]) {
    logger.debug('start batch update column description');
    const { id } = await this.projectService.getCurrentProject();
    const models = await this.modelRepository.findAllBy({
      projectId: id,
    });
    const sourceColumns =
      (await this.modelColumnRepository.findColumnsByModelIds(
        models.map((m) => m.id),
      )) as ModelColumn[];
    const transformedColumns = tables.reduce((acc, table) => {
      const columns = table.columns?.map((column) => {
        return { ...column, tableName: table.tableName };
      });
      if (columns) {
        acc.push(...columns);
      }
      return acc;
    }, []);

    await Promise.all([
      transformedColumns.map(async (column) => {
        if (!column.properties) {
          return;
        }
        const model = models.find(
          (m) => m.sourceTableName === column.tableName,
        );
        const sourceColumn = sourceColumns.find(
          (sourceColumn) =>
            sourceColumn.modelId === model.id &&
            sourceColumn.sourceColumnName === column.name,
        );
        if (!sourceColumn) {
          logger.debug(
            `Column not found, table name: ${column.tableName}, column name: ${column.name}`,
          );
          return;
        }
        const properties = sourceColumn.properties
          ? {
              ...JSON.parse(sourceColumn.properties),
              ...column.properties,
            }
          : { description: column.description };
        await this.modelColumnRepository.updateOne(sourceColumn.id, {
          properties: JSON.stringify(properties),
        });
      }),
    ]);
  }

  public generateReferenceName(data: GenerateReferenceNameData): string {
    const { sourceTableName, existedReferenceNames } = data;
    if (!existedReferenceNames.includes(sourceTableName)) {
      return sourceTableName;
    }
    return `${sourceTableName}_${existedReferenceNames.length + 1}`;
  }

  public async saveRelations(relations: RelationData[]) {
    if (isEmpty(relations)) {
      return [];
    }
    const { id } = await this.projectService.getCurrentProject();

    const models = await this.modelRepository.findAllBy({
      projectId: id,
    });

    const columnIds = relations
      .map(({ fromColumnId, toColumnId }) => [fromColumnId, toColumnId])
      .flat();
    const columns =
      await this.modelColumnRepository.findColumnsByIds(columnIds);
    const relationValues = relations.map((relation) => {
      const fromColumn = columns.find(
        (column) => column.id === relation.fromColumnId,
      );
      if (!fromColumn) {
        throw new Error(`Column not found, column Id ${relation.fromColumnId}`);
      }
      const toColumn = columns.find(
        (column) => column.id === relation.toColumnId,
      );
      if (!toColumn) {
        throw new Error(`Column not found, column Id  ${relation.toColumnId}`);
      }
      const relationName = this.generateRelationName(relation, models, columns);
      return {
        projectId: id,
        name: relationName,
        fromColumnId: relation.fromColumnId,
        toColumnId: relation.toColumnId,
        joinType: relation.type,
        properties: relation.description
          ? JSON.stringify({ description: relation.description })
          : null,
      } as Partial<Relation>;
    });

    const savedRelations =
      await this.relationRepository.createMany(relationValues);

    return savedRelations;
  }

  public async createRelation(relation: RelationData): Promise<Relation> {
    const { id } = await this.projectService.getCurrentProject();
    const modelIds = [relation.fromModelId, relation.toModelId];
    const models = await this.modelRepository.findAllByIds(modelIds);
    const columnIds = [relation.fromColumnId, relation.toColumnId];
    const columns =
      await this.modelColumnRepository.findColumnsByIds(columnIds);

    const { valid, message } = await this.validateCreateRelation(
      models,
      columns,
      relation,
    );
    if (!valid) {
      throw new Error(message);
    }
    const relationName = this.generateRelationName(relation, models, columns);
    const savedRelation = await this.relationRepository.createOne({
      projectId: id,
      name: relationName,
      fromColumnId: relation.fromColumnId,
      toColumnId: relation.toColumnId,
      joinType: relation.type,
    });
    return savedRelation;
  }

  public async updateRelation(
    relation: UpdateRelationData,
    id: number,
  ): Promise<Relation> {
    const updatedRelation = await this.relationRepository.updateOne(id, {
      joinType: relation.type,
    });
    return updatedRelation;
  }

  public async deleteRelation(id: number): Promise<void> {
    const relation = await this.relationRepository.findOneBy({ id });
    if (!relation) {
      throw new Error('Relation not found');
    }
    const calculatedFields = await this.getCalculatedFieldByRelation(id);
    if (calculatedFields.length > 0) {
      // delete related calculated fields
      await this.modelColumnRepository.deleteMany(
        calculatedFields.map((f) => f.id),
      );
    }
    await this.relationRepository.deleteOne(id);
  }

  public async getCalculatedFieldByRelation(
    relationId: number,
  ): Promise<ModelColumn[]> {
    const calculatedFields = await this.modelColumnRepository.findAllBy({
      isCalculated: true,
    });
    const relatedCalculatedFields = calculatedFields.reduce((acc, field) => {
      const lineage = JSON.parse(field.lineage);
      const relationIds = lineage.slice(0, lineage.length - 1);
      if (relationIds.includes(relationId)) {
        acc.push(field);
      }
      return acc;
    }, []);
    return relatedCalculatedFields;
  }

  public async validateCalculatedFieldNaming(
    displayName: string,
    modelId: number,
    columnId?: number,
  ): Promise<ValidateCalculatedFieldResponse> {
    // only allow uppercase/lowercase english, numbers, syntaxes in the first raw of keyboard, {}, [], ', ", ,, .
    const validationRes = validateDisplayName(displayName);
    if (!validationRes.valid) {
      return {
        valid: false,
        message: validationRes.message || 'Invalid Calculated field name',
      };
    }

    // can not duplicated with existed column
    const referenceName =
      this.generateReferenceNameFromDisplayName(displayName);
    let existedColumns = await this.modelColumnRepository.findColumnsByModelIds(
      [modelId],
    );
    if (columnId) {
      existedColumns = existedColumns.filter(
        (column) => column.id !== columnId,
      );
    }
    if (
      existedColumns.find((column) => column.referenceName === referenceName)
    ) {
      return {
        valid: false,
        message: `The generated calculated field name "${referenceName}" is duplicated with existed column, please change the name and try again`,
      };
    }
    return { valid: true };
  }

  public async deleteAllViewsByProjectId(projectId: number): Promise<void> {
    // delete all views
    await this.viewRepository.deleteAllBy({ projectId });
  }

  public async deleteAllModelsByProjectId(projectId: number): Promise<void> {
    // delete all relations
    await this.relationRepository.deleteAllBy({ projectId });

    // delete all models
    await this.modelRepository.deleteAllBy({ projectId });
  }

  private generateReferenceNameFromDisplayName(displayName: string) {
    // replace all syntaxes that [in the first raw of keyboard, {}, [], ', ", ,, . ] with _
    return replaceAllowableSyntax(displayName);
  }

  private generateRelationName(
    relation: RelationData,
    models: Model[],
    columns: ModelColumn[],
  ) {
    const fromModel = models.find((m) => m.id === relation.fromModelId);
    const toModel = models.find((m) => m.id === relation.toModelId);
    if (!fromModel || !toModel) {
      throw new Error('Model not found');
    }

    const fromColumn = columns.find(
      (column) => column.id === relation.fromColumnId,
    );
    const toColumn = columns.find(
      (column) => column.id === relation.toColumnId,
    );

    return (
      capitalize(fromModel.sourceTableName) +
      capitalize(fromColumn.referenceName) +
      capitalize(toModel.sourceTableName) +
      capitalize(toColumn.referenceName)
    );
  }

  /** We currently support expression below, right side is the return type of the calculated field.
  Aggregations
    - **avg(***x***)** → double
    - **count(***x***)** → bigint
    - **max(***x***)** → [same as input]
    - **min(***x***)** → [same as input]
    - **sum(***x***)** → [same as input]
  Math functions
    - **abs(***x***)** → [same as input]
    - **cbrt(***x***)** → double
    - **ceil(***x***)** → [same as input]
    - **exp(***x***)** → double
    - **floor(***x***)** → [same as input]
    - **ln(***x***)** → double
    - **log10(***x***)** → double
    - **round(***x***)** → [same as input]
    - **sign(***x***)** → [same as input]

  String functions
    - **length(***string***)** → bigint
    - **reverse(**string**)** → varbinary
  */
  private async inferCalculatedFieldDataType(
    expression: ExpressionName,
    inputFieldId: number,
  ) {
    let type = null;
    switch (expression) {
      case ExpressionName.CEIL:
      case ExpressionName.FLOOR:
      case ExpressionName.ROUND:
      case ExpressionName.SIGN:
      case ExpressionName.SUM:
      case ExpressionName.MAX:
      case ExpressionName.MIN:
      case ExpressionName.ABS:
        type = await this.getFieldDataType(inputFieldId);
        break;
      case ExpressionName.CBRT:
      case ExpressionName.EXP:
      case ExpressionName.AVG:
      case ExpressionName.LN:
      case ExpressionName.LOG10:
        type = 'DOUBLE';
        break;
      case ExpressionName.COUNT:
      case ExpressionName.LENGTH:
        type = 'BIGINT';
        break;
      case ExpressionName.REVERSE:
        type = 'VARBINARY';
        break;
      default:
        throw new Error('Unsupported expression');
    }
    return type;
  }

  private async getFieldDataType(fieldId: number): Promise<string> {
    const field = await this.modelColumnRepository.findOneBy({ id: fieldId });
    if (!field) {
      throw new Error('Field not found');
    }
    return field.type;
  }

  private async checkCalculatedFieldCanQuery(
    modelId: number,
    modelName: string,
    data: CheckCalculatedFieldCanQueryData,
  ) {
    const project = await this.projectService.getCurrentProject();
    const { mdlBuilder } = await this.mdlService.makeCurrentModelMDL();
    const { referenceName, expression, lineage } = data;
    const inputFieldId = lineage[lineage.length - 1];
    const dataType = await this.inferCalculatedFieldDataType(
      expression,
      inputFieldId,
    );

    // add temporary calculated field
    const modelColumn = {
      id: 99999999,
      modelId,
      displayName: referenceName,
      sourceColumnName: referenceName,
      referenceName: referenceName,
      type: dataType,
      isCalculated: true,
      isPk: false,
      notNull: false,
      aggregation: expression,
      lineage: JSON.stringify(lineage),
      properties: JSON.stringify({ description: '' }),
    } as ModelColumn;
    mdlBuilder.insertCalculatedField(modelName, modelColumn);
    const manifest = mdlBuilder.getManifest();

    // find the calculated field in manifest
    const calculatedField = manifest.models
      .find((m) => m.name === modelName)
      ?.columns.find((c) => c.name === referenceName);

    logger.debug(`Calculated field MDL: ${JSON.stringify(calculatedField)}`);

    // validate calculated field can query
    const dataSource = project.type;
    if (dataSource === DataSourceName.DUCKDB) {
      return await this.wrenEngineAdaptor.validateColumnIsValid(
        manifest,
        modelName,
        referenceName,
      );
    } else {
      const parameters = { modelName, columnName: referenceName };
      return await this.queryService.validate(
        project,
        ValidationRules.COLUMN_IS_VALID,
        manifest,
        parameters,
      );
    }
  }

  private async validateCreateRelation(
    models: Model[],
    columns: ModelColumn[],
    relation: RelationData,
  ) {
    const { fromModelId, fromColumnId, toModelId, toColumnId } = relation;
    const fromModel = models.find((m) => m.id === fromModelId);
    const toModel = models.find((m) => m.id === toModelId);
    // model should exist
    if (!fromModel) {
      return {
        valid: false,
        message: `Model not found: fromModelId ${fromModelId}`,
      };
    }
    if (!toModel) {
      return {
        valid: false,
        message: `Model not found: toModelId ${toModelId}`,
      };
    }
    // column should exist
    const fromColumn = columns.find((column) => column.id === fromColumnId);
    const toColumn = columns.find((column) => column.id === toColumnId);
    if (!fromColumn) {
      return {
        valid: false,
        message: `Column not found, column Id ${fromColumnId}`,
      };
    }
    if (!toColumn) {
      return {
        valid: false,
        message: `Column not found, column Id ${toColumnId}`,
      };
    }

    // column should belong to the model
    if (toColumn.modelId != toModelId) {
      return {
        valid: false,
        message: `Column not belong to the model, column Id ${toColumnId}`,
      };
    }
    if (fromColumn.modelId != fromModelId) {
      return {
        valid: false,
        message: `Column not belong to the model, column Id ${fromColumnId}`,
      };
    }

    const existedRelations =
      await this.relationRepository.findExistedRelationBetweenModels(relation);

    if (existedRelations.length > 0) {
      return {
        valid: false,
        message: 'This relationship already exists.',
      };
    }

    return { valid: true };
  }
}
</file>

<file path="src/apollo/server/services/projectService.ts">
import crypto from 'crypto';
import * as fs from 'fs';
import path from 'path';
import { getLogger } from '@server/utils';
import { IProjectRepository, WREN_AI_CONNECTION_INFO } from '../repositories';
import { Project } from '../repositories';
import {
  CompactTable,
  IDataSourceMetadataService,
  RecommendConstraint,
} from './metadataService';
import { DataSourceName } from '../types';
import {
  RecommendationQuestion,
  RecommendationQuestionStatus,
  WrenAIError,
  WrenAILanguage,
} from '@server/models/adaptor';
import { encryptConnectionInfo } from '../dataSource';
import { IWrenAIAdaptor } from '../adaptors';
import { RecommendQuestionResultStatus } from './askingService';
import { IMDLService } from './mdlService';
import { ProjectRecommendQuestionBackgroundTracker } from '../backgrounds';
import { ITelemetry } from '../telemetry/telemetry';
import { getConfig } from '../config';

const config = getConfig();

const logger = getLogger('ProjectService');
logger.level = 'debug';

const SENSITIVE_PROPERTY_NAME = new Set([
  'credentials',
  'password',
  'awsSecretKey',
]);
export interface ProjectData {
  displayName: string;
  type: DataSourceName;
  connectionInfo: WREN_AI_CONNECTION_INFO;
}

export interface ProjectRecommendationQuestionsResult {
  status: RecommendQuestionResultStatus;
  questions: RecommendationQuestion[];
  error: WrenAIError;
}
export interface IProjectService {
  createProject: (projectData: ProjectData) => Promise<Project>;
  updateProject: (
    projectId: number,
    projectData: Partial<Project>,
  ) => Promise<Project>;
  getGeneralConnectionInfo: (project: Project) => Record<string, any>;
  getProjectDataSourceTables: (
    project?: Project,
    projectId?: number,
  ) => Promise<CompactTable[]>;
  getProjectDataSourceVersion: (
    project?: Project,
    projectId?: number,
  ) => Promise<string>;
  getProjectSuggestedConstraint: (
    project?: Project,
    projectId?: number,
  ) => Promise<RecommendConstraint[]>;

  getCurrentProject: () => Promise<Project>;
  getProjectById: (projectId: number) => Promise<Project>;
  writeCredentialFile: (
    credentials: JSON,
    persistCredentialDir: string,
  ) => string;
  deleteProject: (projectId: number) => Promise<void>;
  getProjectRecommendationQuestions: () => Promise<ProjectRecommendationQuestionsResult>;

  // recommend questions
  generateProjectRecommendationQuestions: () => Promise<void>;
}

export class ProjectService implements IProjectService {
  private projectRepository: IProjectRepository;
  private metadataService: IDataSourceMetadataService;
  private mdlService: IMDLService;
  private wrenAIAdaptor: IWrenAIAdaptor;
  private projectRecommendQuestionBackgroundTracker: ProjectRecommendQuestionBackgroundTracker;
  constructor({
    projectRepository,
    metadataService,
    mdlService,
    wrenAIAdaptor,
    telemetry,
  }: {
    projectRepository: IProjectRepository;
    metadataService: IDataSourceMetadataService;
    mdlService: IMDLService;
    wrenAIAdaptor: IWrenAIAdaptor;
    telemetry: ITelemetry;
  }) {
    this.projectRepository = projectRepository;
    this.metadataService = metadataService;
    this.mdlService = mdlService;
    this.wrenAIAdaptor = wrenAIAdaptor;
    this.projectRecommendQuestionBackgroundTracker =
      new ProjectRecommendQuestionBackgroundTracker({
        projectRepository,
        telemetry,
        wrenAIAdaptor,
      });
  }
  public async updateProject(
    projectId: number,
    projectData: Partial<Project>,
  ): Promise<Project> {
    return await this.projectRepository.updateOne(projectId, projectData);
  }

  public async getProjectDataSourceVersion(
    project?: Project,
    projectId?: number,
  ): Promise<string> {
    const usedProject = project
      ? project
      : projectId
        ? await this.getProjectById(projectId)
        : await this.getCurrentProject();
    return await this.metadataService.getVersion(usedProject);
  }

  public async generateProjectRecommendationQuestions(): Promise<void> {
    const project = await this.getCurrentProject();
    if (!project) {
      throw new Error(`Project not found`);
    }
    const { manifest } = await this.mdlService.makeCurrentModelMDL();
    const recommendQuestionResult =
      await this.wrenAIAdaptor.generateRecommendationQuestions({
        manifest,
        ...this.getProjectRecommendationQuestionsConfig(project),
      });

    const updatedProject = await this.projectRepository.updateOne(project.id, {
      queryId: recommendQuestionResult.queryId,
      questionsStatus: RecommendationQuestionStatus.GENERATING,
      questions: [],
      questionsError: null,
    });

    if (
      !this.projectRecommendQuestionBackgroundTracker.isExist(updatedProject)
    ) {
      this.projectRecommendQuestionBackgroundTracker.addTask(updatedProject);
    } else {
      logger.debug(
        `Generate Project Recommendation Questions Task ${updatedProject.id} already exists, skip adding`,
      );
    }
  }

  public async getProjectRecommendationQuestions() {
    const project = await this.projectRepository.getCurrentProject();
    if (!project) {
      throw new Error(`Project not found`);
    }
    const result: ProjectRecommendationQuestionsResult = {
      status: RecommendQuestionResultStatus.NOT_STARTED,
      questions: [],
      error: null,
    };
    if (project.queryId) {
      result.status = project.questionsStatus
        ? RecommendQuestionResultStatus[project.questionsStatus]
        : result.status;
      result.questions = project.questions || [];
      result.error = project.questionsError as WrenAIError;
    }
    return result;
  }

  public async getCurrentProject() {
    return await this.projectRepository.getCurrentProject();
  }

  public async getProjectById(projectId: number) {
    return await this.projectRepository.findOneBy({ id: projectId });
  }

  public async getProjectDataSourceTables(
    project?: Project,
    projectId?: number,
  ) {
    const usedProject = project
      ? project
      : projectId
        ? await this.getProjectById(projectId)
        : await this.getCurrentProject();
    return await this.metadataService.listTables(usedProject);
  }

  public async getProjectSuggestedConstraint(
    project?: Project,
    projectId?: number,
  ) {
    const usedProject = project
      ? project
      : projectId
        ? await this.getProjectById(projectId)
        : await this.getCurrentProject();
    return await this.metadataService.listConstraints(usedProject);
  }

  public async createProject(projectData: ProjectData) {
    const projectValue = {
      displayName: projectData.displayName,
      type: projectData.type,
      catalog: 'wrenai',
      schema: 'public',
      connectionInfo: encryptConnectionInfo(
        projectData.type,
        projectData.connectionInfo,
      ),
    };
    logger.debug('Creating project...');
    const project = await this.projectRepository.createOne(projectValue);
    return project;
  }

  public writeCredentialFile(credentials: JSON, persistCredentialDir: string) {
    // create persist_credential_dir if not exists
    if (!fs.existsSync(persistCredentialDir)) {
      fs.mkdirSync(persistCredentialDir, { recursive: true });
    }
    // file name will be the hash of the credentials, file path is current working directory
    // convert credentials from base64 to string and replace all the matched "\n" with "\\n",  there are many \n in the "private_key" property
    const credentialString = JSON.stringify(credentials);
    const fileName = crypto
      .createHash('md5')
      .update(credentialString)
      .digest('hex');

    const filePath = path.join(persistCredentialDir, `${fileName}.json`);
    // check if file exists
    if (fs.existsSync(filePath)) {
      logger.debug(`File ${filePath} already exists`);
      return filePath;
    }
    fs.writeFileSync(filePath, credentialString);
    logger.debug(`Wrote credentials to file`);
    return filePath;
  }

  public async deleteProject(projectId: number): Promise<void> {
    await this.projectRepository.deleteOne(projectId);
  }

  public getGeneralConnectionInfo(project) {
    return Object.entries(project.connectionInfo).reduce(
      (acc, [key, value]) => {
        if (!SENSITIVE_PROPERTY_NAME.has(key)) {
          acc[key] = value;
        }
        return acc;
      },
      {},
    );
  }

  private getProjectRecommendationQuestionsConfig(project: Project) {
    return {
      maxCategories: config.projectRecommendationQuestionMaxCategories,
      maxQuestions: config.projectRecommendationQuestionsMaxQuestions,
      regenerate: true,
      configuration: {
        language: WrenAILanguage[project.language] || WrenAILanguage.EN,
      },
    };
  }
}
</file>

<file path="src/apollo/server/services/queryService.ts">
import { DataSourceName } from '@server/types';
import { Manifest } from '@server/mdl/type';
import { IWrenEngineAdaptor } from '../adaptors/wrenEngineAdaptor';
import {
  SupportedDataSource,
  IIbisAdaptor,
  IbisQueryResponse,
  ValidationRules,
  IbisResponse,
} from '../adaptors/ibisAdaptor';
import { getLogger } from '@server/utils';
import { Project } from '../repositories';
import { PostHogTelemetry, TelemetryEvent } from '../telemetry/telemetry';

const logger = getLogger('QueryService');
logger.level = 'debug';

export const DEFAULT_PREVIEW_LIMIT = 500;

export interface ColumnMetadata {
  name: string;
  type: string;
}

export interface PreviewDataResponse extends IbisResponse {
  columns: ColumnMetadata[];
  data: any[][];
  cacheHit?: boolean;
  cacheCreatedAt?: string;
  cacheOverrodeAt?: string;
  override?: boolean;
}

export interface DescribeStatementResponse {
  columns: ColumnMetadata[];
}

export interface PreviewOptions {
  project: Project;
  modelingOnly?: boolean;
  // if not given, will use the deployed manifest
  manifest: Manifest;
  limit?: number;
  dryRun?: boolean;
  refresh?: boolean;
  cacheEnabled?: boolean;
}

export interface SqlValidateOptions {
  project: Project;
  mdl: Manifest;
  modelingOnly?: boolean;
}

export interface ValidateResponse {
  valid: boolean;
  message?: string;
}

export interface IQueryService {
  preview(
    sql: string,
    options: PreviewOptions,
  ): Promise<IbisResponse | PreviewDataResponse | boolean>;

  describeStatement(
    sql: string,
    options: PreviewOptions,
  ): Promise<DescribeStatementResponse>;

  validate(
    project: Project,
    rule: ValidationRules,
    manifest: Manifest,
    parameters: Record<string, any>,
  ): Promise<ValidateResponse>;
}

export class QueryService implements IQueryService {
  private readonly ibisAdaptor: IIbisAdaptor;
  private readonly wrenEngineAdaptor: IWrenEngineAdaptor;
  private readonly telemetry: PostHogTelemetry;

  constructor({
    ibisAdaptor,
    wrenEngineAdaptor,
    telemetry,
  }: {
    ibisAdaptor: IIbisAdaptor;
    wrenEngineAdaptor: IWrenEngineAdaptor;
    telemetry: PostHogTelemetry;
  }) {
    this.ibisAdaptor = ibisAdaptor;
    this.wrenEngineAdaptor = wrenEngineAdaptor;
    this.telemetry = telemetry;
  }

  public async preview(
    sql: string,
    options: PreviewOptions,
  ): Promise<IbisResponse | PreviewDataResponse | boolean> {
    const {
      project,
      manifest: mdl,
      limit,
      dryRun,
      refresh,
      cacheEnabled,
    } = options;
    const { type: dataSource, connectionInfo } = project;
    if (this.useEngine(dataSource)) {
      if (dryRun) {
        logger.debug('Using wren engine to dry run');
        await this.wrenEngineAdaptor.dryRun(sql, {
          manifest: mdl,
          limit,
        });
        return true;
      } else {
        logger.debug('Using wren engine to preview');
        const data = await this.wrenEngineAdaptor.previewData(sql, mdl, limit);
        return data as PreviewDataResponse;
      }
    } else {
      this.checkDataSourceIsSupported(dataSource);
      logger.debug('Use ibis adaptor to preview');
      if (dryRun) {
        return await this.ibisDryRun(sql, dataSource, connectionInfo, mdl);
      } else {
        return await this.ibisQuery(
          sql,
          dataSource,
          connectionInfo,
          mdl,
          limit,
          refresh,
          cacheEnabled,
        );
      }
    }
  }

  public async describeStatement(
    sql: string,
    options: PreviewOptions,
  ): Promise<DescribeStatementResponse> {
    try {
      // preview data with limit 1 to get column metadata
      options.limit = 1;
      const res = (await this.preview(sql, options)) as PreviewDataResponse;
      return { columns: res.columns };
    } catch (err: any) {
      logger.debug(`Got error when describing statement: ${err.message}`);
      throw err;
    }
  }

  public async validate(
    project,
    rule: ValidationRules,
    manifest: Manifest,
    parameters: Record<string, any>,
  ): Promise<ValidateResponse> {
    const { type: dataSource, connectionInfo } = project;
    const res = await this.ibisAdaptor.validate(
      dataSource,
      rule,
      connectionInfo,
      manifest,
      parameters,
    );
    return res;
  }

  private useEngine(dataSource: DataSourceName): boolean {
    if (dataSource === DataSourceName.DUCKDB) {
      return true;
    } else {
      return false;
    }
  }

  private checkDataSourceIsSupported(dataSource: DataSourceName) {
    if (
      !Object.prototype.hasOwnProperty.call(SupportedDataSource, dataSource)
    ) {
      throw new Error(`Unsupported datasource for ibis: "${dataSource}"`);
    }
  }

  private async ibisDryRun(
    sql: string,
    dataSource: DataSourceName,
    connectionInfo: any,
    mdl: Manifest,
  ): Promise<IbisResponse> {
    const event = TelemetryEvent.IBIS_DRY_RUN;
    try {
      const res = await this.ibisAdaptor.dryRun(sql, {
        dataSource,
        connectionInfo,
        mdl,
      });
      this.sendIbisEvent(event, res, { dataSource, sql });
      return {
        correlationId: res.correlationId,
      };
    } catch (err: any) {
      this.sendIbisFailedEvent(event, err, { dataSource, sql });
      throw err;
    }
  }

  private async ibisQuery(
    sql: string,
    dataSource: DataSourceName,
    connectionInfo: any,
    mdl: Manifest,
    limit: number,
    refresh?: boolean,
    cacheEnabled?: boolean,
  ): Promise<PreviewDataResponse> {
    const event = TelemetryEvent.IBIS_QUERY;
    try {
      const res = await this.ibisAdaptor.query(sql, {
        dataSource,
        connectionInfo,
        mdl,
        limit,
        refresh,
        cacheEnabled,
      });
      this.sendIbisEvent(event, res, { dataSource, sql });
      const data = this.transformDataType(res);
      return {
        correlationId: res.correlationId,
        cacheHit: res.cacheHit,
        cacheCreatedAt: res.cacheCreatedAt,
        cacheOverrodeAt: res.cacheOverrodeAt,
        override: res.override,
        ...data,
      };
    } catch (err: any) {
      this.sendIbisFailedEvent(event, err, { dataSource, sql });
      throw err;
    }
  }

  private transformDataType(data: IbisQueryResponse): PreviewDataResponse {
    const columns = data.columns;
    const dtypes = data.dtypes;
    const transformedColumns = columns.map((column) => {
      let type = 'unknown';
      if (dtypes && dtypes[column]) {
        type = dtypes[column] === 'object' ? 'string' : dtypes[column];
      }
      if (type === 'unknown') {
        logger.debug(`Did not find type mapping for "${column}"`);
        logger.debug(
          `dtypes mapping: ${dtypes ? JSON.stringify(dtypes, null, 2) : 'undefined'} `,
        );
      }
      return {
        name: column,
        type,
      } as ColumnMetadata;
    });
    return {
      columns: transformedColumns,
      data: data.data,
    } as PreviewDataResponse;
  }

  private sendIbisEvent(
    event: TelemetryEvent,
    res: IbisResponse,
    others: Record<string, any>,
  ) {
    this.telemetry.sendEvent(event, {
      correlationId: res.correlationId,
      processTime: res.processTime,
      ...others,
    });
  }

  private sendIbisFailedEvent(
    event: TelemetryEvent,
    err: any,
    others: Record<string, any>,
  ) {
    this.telemetry.sendEvent(
      event,
      {
        correlationId: err.extensions?.other?.correlationId,
        processTime: err.extensions?.other?.processTime,
        error: err.message,
        ...others,
      },
      err.extensions?.service,
      false,
    );
  }
}
</file>

<file path="src/apollo/server/services/sqlPairService.ts">
import { SqlPair } from '@server/repositories';
import { IWrenAIAdaptor } from '@server/adaptors/wrenAIAdaptor';
import { ISqlPairRepository } from '@server/repositories/sqlPairRepository';
import { getLogger } from '@server/utils';
import { chunk } from 'lodash';
import * as Errors from '@server/utils/error';
import { Project } from '../repositories';
import { IIbisAdaptor } from '../adaptors/ibisAdaptor';
import {
  DialectSQL,
  WrenSQL,
  WrenAILanguage,
  SqlPairResult,
  SqlPairStatus,
  QuestionsResult,
  QuestionsStatus,
} from '../models/adaptor';
import { Manifest } from '@server/mdl/type';
import { DataSourceName } from '@server/types';

const logger = getLogger('SqlPairService');

export interface CreateSqlPair {
  sql: string;
  question: string;
}

export interface EditSqlPair {
  sql?: string;
  question?: string;
}

export interface ModelSubstituteOptions {
  project: Project;
  // if not given, will use the deployed manifest
  manifest: Manifest;
}

export interface ISqlPairService {
  getProjectSqlPairs(projectId: number): Promise<SqlPair[]>;
  createSqlPair(projectId: number, sqlPair: CreateSqlPair): Promise<SqlPair>;
  createSqlPairs(
    projectId: number,
    sqlPairs: CreateSqlPair[],
  ): Promise<SqlPair[]>;
  editSqlPair(
    projectId: number,
    sqlPairId: number,
    sqlPair: EditSqlPair,
  ): Promise<SqlPair>;
  deleteSqlPair(projectId: number, sqlPairId: number): Promise<boolean>;
  generateQuestions(project: Project, sqls: string[]): Promise<string[]>;
  modelSubstitute(
    sql: DialectSQL,
    options: ModelSubstituteOptions,
  ): Promise<WrenSQL>;
}

export class SqlPairService implements ISqlPairService {
  private sqlPairRepository: ISqlPairRepository;
  private wrenAIAdaptor: IWrenAIAdaptor;
  private ibisAdaptor: IIbisAdaptor;

  constructor({
    sqlPairRepository,
    wrenAIAdaptor,
    ibisAdaptor,
  }: {
    sqlPairRepository: ISqlPairRepository;
    wrenAIAdaptor: IWrenAIAdaptor;
    ibisAdaptor: IIbisAdaptor;
  }) {
    this.sqlPairRepository = sqlPairRepository;
    this.wrenAIAdaptor = wrenAIAdaptor;
    this.ibisAdaptor = ibisAdaptor;
  }

  public async modelSubstitute(
    sql: DialectSQL,
    options: ModelSubstituteOptions,
  ): Promise<WrenSQL> {
    const { manifest: mdl, project } = options;
    const { type: dataSource, connectionInfo } = project;
    if (dataSource === DataSourceName.DUCKDB) {
      // engine does not implement model substitute.
      throw Errors.create(Errors.GeneralErrorCodes.IBIS_SERVER_ERROR, {
        customMessage: 'DuckDB data source does not support model substitute.',
      });
    }
    // use the first model's table reference as default catalog and schema
    const firstModel = mdl.models?.[0];
    const catalog = firstModel?.tableReference?.catalog;
    const schema = firstModel?.tableReference?.schema;
    return await this.ibisAdaptor.modelSubstitute(sql, {
      dataSource,
      connectionInfo,
      mdl,
      catalog,
      schema,
    });
  }

  public async generateQuestions(
    project: Project,
    sqls: string[],
  ): Promise<string[]> {
    try {
      const configurations = {
        language: WrenAILanguage[project.language] || WrenAILanguage.EN,
      };

      const { queryId } = await this.wrenAIAdaptor.generateQuestions({
        projectId: project.id,
        configurations,
        sqls,
      });
      const result = await this.waitQuestionGenerateResult(queryId);
      if (result.error) {
        throw Errors.create(Errors.GeneralErrorCodes.GENERATE_QUESTIONS_ERROR, {
          customMessage: result.error.message,
        });
      }
      return result.questions;
    } catch (err) {
      throw Errors.create(Errors.GeneralErrorCodes.GENERATE_QUESTIONS_ERROR, {
        customMessage: err.message,
      });
    }
  }

  public async getProjectSqlPairs(projectId: number): Promise<SqlPair[]> {
    return this.sqlPairRepository.findAllBy({ projectId });
  }

  public async createSqlPair(
    projectId: number,
    sqlPair: CreateSqlPair,
  ): Promise<SqlPair> {
    const tx = await this.sqlPairRepository.transaction();
    try {
      const newPair = await this.sqlPairRepository.createOne(
        {
          ...sqlPair,
          projectId,
        },
        { tx },
      );
      const { queryId } = await this.wrenAIAdaptor.deploySqlPair(
        projectId,
        newPair,
      );
      const deployResult = await this.waitUntilSqlPairResult(queryId);
      if (deployResult.error) {
        throw Errors.create(deployResult.error.code, {
          customMessage: deployResult.error.message,
        });
      }
      await tx.commit();
      return newPair;
    } catch (error) {
      await tx.rollback();
      throw error;
    }
  }

  public async createSqlPairs(
    projectId: number,
    sqlPairs: CreateSqlPair[],
  ): Promise<SqlPair[]> {
    const tx = await this.sqlPairRepository.transaction();
    const newPairs = await this.sqlPairRepository.createMany(
      sqlPairs.map((pair) => ({
        ...pair,
        projectId,
      })),
      { tx },
    );
    // batch parall process with size of 10
    const successPairs = [];
    const errorPairs = [];
    const chunks = chunk(newPairs, 10);
    for (const pairs of chunks) {
      await Promise.allSettled(
        pairs.map(async (pair) => {
          const { queryId } = await this.wrenAIAdaptor.deploySqlPair(
            projectId,
            pair,
          );
          const deployResult = await this.waitUntilSqlPairResult(queryId);
          if (deployResult.error) {
            errorPairs.push(deployResult.error);
          }
          successPairs.push(deployResult);
        }),
      ).then(async (_result) => {
        if (errorPairs.length > 0) {
          logger.debug(
            `deploy sql pair failed. ${errorPairs.map((pair) => pair.question).join(', ')}`,
          );
          await tx.rollback();
          await this.wrenAIAdaptor.deleteSqlPairs(
            projectId,
            successPairs.map((pair) => pair.id),
          );
          throw Errors.create(Errors.GeneralErrorCodes.DEPLOY_SQL_PAIR_ERROR, {
            customMessage: errorPairs.map((pair) => pair.message).join(', '),
          });
        }
      });
    }
    await tx.commit();
    return newPairs;
  }

  async editSqlPair(
    projectId: number,
    sqlPairId: number,
    sqlPair: EditSqlPair,
  ): Promise<SqlPair> {
    // First verify the SQL pair exists and belongs to the project
    const existingPair = await this.sqlPairRepository.findOneBy({
      id: sqlPairId,
      projectId,
    });
    if (!existingPair) {
      throw new Error(
        `SQL pair with ID ${sqlPairId} not found in project ${projectId}`,
      );
    }

    // Update only the provided fields
    const updatedData: Partial<SqlPair> = {
      sql: existingPair.sql,
      question: existingPair.question,
      updatedAt: new Date().toISOString(),
    };

    if (sqlPair.sql !== undefined) {
      updatedData.sql = sqlPair.sql;
    }

    if (sqlPair.question !== undefined) {
      updatedData.question = sqlPair.question;
    }
    const tx = await this.sqlPairRepository.transaction();
    try {
      const updatedSqlPair = await this.sqlPairRepository.updateOne(
        sqlPairId,
        updatedData,
        { tx },
      );
      const { queryId } = await this.wrenAIAdaptor.deploySqlPair(
        projectId,
        updatedSqlPair,
      );
      const deployResult = await this.waitUntilSqlPairResult(queryId);
      if (deployResult.error) {
        throw Errors.create(Errors.GeneralErrorCodes.DEPLOY_SQL_PAIR_ERROR, {
          customMessage: deployResult.error.message,
        });
      }
      await tx.commit();
      return updatedSqlPair;
    } catch (error) {
      logger.error(`edit sql pair failed. ${error}`);
      await tx.rollback();
      throw Errors.create(Errors.GeneralErrorCodes.DEPLOY_SQL_PAIR_ERROR, {
        customMessage: error.message,
      });
    }
  }

  async deleteSqlPair(projectId: number, sqlPairId: number): Promise<boolean> {
    // First verify the SQL pair exists and belongs to the project
    const existingPair = await this.sqlPairRepository.findOneBy({
      id: sqlPairId,
      projectId,
    });

    if (!existingPair) {
      throw new Error(
        `SQL pair with ID ${sqlPairId} not found in project ${projectId}`,
      );
    }
    const tx = await this.sqlPairRepository.transaction();
    try {
      await this.sqlPairRepository.deleteOne(sqlPairId, { tx });
      await this.wrenAIAdaptor.deleteSqlPairs(projectId, [sqlPairId]);
      await tx.commit();
      return true;
    } catch (error) {
      logger.error(`delete sql pair failed. ${error}`);
      await tx.rollback();
      throw Errors.create(Errors.GeneralErrorCodes.DEPLOY_SQL_PAIR_ERROR, {
        customMessage: error.message,
      });
    }
  }

  private async waitUntilSqlPairResult(
    queryId: string,
  ): Promise<SqlPairResult> {
    let result = await this.wrenAIAdaptor.getSqlPairResult(queryId);
    while (!this.isFinishedState(result.status)) {
      await new Promise((resolve) => setTimeout(resolve, 500));
      result = await this.wrenAIAdaptor.getSqlPairResult(queryId);
    }
    return result;
  }

  private async waitQuestionGenerateResult(
    queryId: string,
  ): Promise<Partial<QuestionsResult>> {
    let result = await this.wrenAIAdaptor.getQuestionsResult(queryId);
    while (
      ![QuestionsStatus.SUCCEEDED, QuestionsStatus.FAILED].includes(
        result.status,
      )
    ) {
      await new Promise((resolve) => setTimeout(resolve, 500));
      result = await this.wrenAIAdaptor.getQuestionsResult(queryId);
    }
    return result;
  }

  private isFinishedState(status: SqlPairStatus) {
    return [SqlPairStatus.FINISHED, SqlPairStatus.FAILED].includes(status);
  }
}
</file>

<file path="src/apollo/server/services/tests/askingService.test.ts">
import { constructCteSql } from '../askingService';

describe('AskingService', () => {
  describe('utility: constructCteSql', () => {
    test('oneline sql', () => {
      const sql = 'SELECT * FROM test';
      const steps = [{ sql, summary: 'test', cteName: '' }];
      const result = constructCteSql(steps);
      expect(result).toBe(`-- test\nSELECT * FROM test`);
    });

    test('2 steps of sql', () => {
      const steps = [
        {
          sql: 'SELECT * FROM test',
          summary: 'test1 summary',
          cteName: 'test1',
        },
        { sql: 'SELECT * FROM test2', summary: 'test2', cteName: '' },
      ];
      const result = constructCteSql(steps);
      expect(result).toBe(
        `WITH test1 AS\n-- test1 summary\n(SELECT * FROM test)\n-- test2\nSELECT * FROM test2`,
      );
    });

    test('3 steps of sql', () => {
      const steps = [
        {
          sql: 'SELECT * FROM test',
          summary: 'test1 summary',
          cteName: 'test1',
        },
        {
          sql: 'SELECT * FROM test2',
          summary: 'test2 summary',
          cteName: 'test2',
        },
        { sql: 'SELECT * FROM test3', summary: 'test3', cteName: '' },
      ];
      const result = constructCteSql(steps);
      expect(result).toBe(
        `WITH test1 AS\n-- test1 summary\n(SELECT * FROM test),` +
          `test2 AS\n-- test2 summary\n(SELECT * FROM test2)\n-- test3\nSELECT * FROM test3`,
      );
    });

    test('2 steps of sql with stepIndex=0', () => {
      const steps = [
        {
          sql: 'SELECT * FROM test',
          summary: 'test1 summary',
          cteName: 'test1',
        },
        { sql: 'SELECT * FROM test2', summary: 'test2', cteName: '' },
      ];
      const result = constructCteSql(steps, 0);
      expect(result).toBe(`-- test1 summary\nSELECT * FROM test`);
    });

    test('2 steps of sql with stepIndex=1', () => {
      const steps = [
        {
          sql: 'SELECT * FROM test',
          summary: 'test1 summary',
          cteName: 'test1',
        },
        { sql: 'SELECT * FROM test2', summary: 'test2', cteName: '' },
      ];
      const result = constructCteSql(steps, 1);
      expect(result).toBe(
        `WITH test1 AS\n-- test1 summary\n(SELECT * FROM test)\n-- test2\nSELECT * FROM test2`,
      );
    });

    test('3 steps of sql with stepIndex=1', () => {
      const steps = [
        {
          sql: 'SELECT * FROM test',
          summary: 'test1 summary',
          cteName: 'test1',
        },
        {
          sql: 'SELECT * FROM test2',
          summary: 'test2 summary',
          cteName: 'test2',
        },
        { sql: 'SELECT * FROM test3', summary: 'test3', cteName: '' },
      ];
      const result = constructCteSql(steps, 1);
      expect(result).toBe(
        `WITH test1 AS\n-- test1 summary\n(SELECT * FROM test)` +
          `\n-- test2 summary\nSELECT * FROM test2`,
      );
    });
  });
});
</file>

<file path="src/apollo/server/services/tests/dashboardService.test.ts">
import { DashboardService } from '../dashboardService';
import { ScheduleFrequencyEnum } from '@server/models/dashboard';
import { CacheScheduleDayEnum } from '@server/models/dashboard';
import {
  SetDashboardCacheData,
  DashboardSchedule,
} from '@server/models/dashboard';

// Create a test class that extends DashboardService to access protected methods
class TestDashboardService extends DashboardService {
  public testGenerateCronExpression(
    schedule: DashboardSchedule,
  ): string | null {
    return this.generateCronExpression(schedule);
  }

  public testCalculateNextRunTime(cronExpression: string): Date | null {
    return this.calculateNextRunTime(cronExpression);
  }

  public testToUTC(schedule: DashboardSchedule): DashboardSchedule {
    return this.toUTC(schedule);
  }

  public testToTimezone(schedule: DashboardSchedule): DashboardSchedule {
    return this.toTimezone(schedule);
  }

  public testValidateScheduleInput(data: SetDashboardCacheData): void {
    return this.validateScheduleInput(data);
  }
}

describe('DashboardService', () => {
  let dashboardService: TestDashboardService;
  let mockProjectService;
  let mockDashboardItemRepository;
  let mockDashboardRepository;

  const createScheduleData = (
    frequency: ScheduleFrequencyEnum,
    options: {
      hour?: number;
      minute?: number;
      day?: CacheScheduleDayEnum;
      timezone?: string;
      cron?: string;
      cacheEnabled?: boolean;
    } = {},
  ): SetDashboardCacheData => {
    return {
      cacheEnabled: options.cacheEnabled ?? true,
      schedule: {
        frequency,
        hour: options.hour ?? 0,
        minute: options.minute ?? 0,
        day: options.day ?? CacheScheduleDayEnum.MON,
        timezone: options.timezone ?? '',
        cron: options.cron ?? '',
      },
    };
  };

  beforeEach(() => {
    mockProjectService = {
      getCurrentProject: jest.fn(),
    };
    mockDashboardItemRepository = {
      findOneBy: jest.fn(),
      findAllBy: jest.fn(),
      createOne: jest.fn(),
      updateOne: jest.fn(),
      deleteOne: jest.fn(),
    };
    mockDashboardRepository = {
      findOneBy: jest.fn(),
      createOne: jest.fn(),
      updateOne: jest.fn(),
    };

    dashboardService = new TestDashboardService({
      projectService: mockProjectService,
      dashboardItemRepository: mockDashboardItemRepository,
      dashboardRepository: mockDashboardRepository,
    });
  });

  describe('generateCronExpression', () => {
    it('should generate correct cron expression for daily schedule', () => {
      const schedule = {
        frequency: ScheduleFrequencyEnum.DAILY,
        hour: 14,
        minute: 30,
        timezone: '',
        day: null,
        cron: null,
      };

      const result = dashboardService.testGenerateCronExpression(schedule);
      expect(result).toBe('30 14 * * *');
    });

    it('should generate correct cron expression for weekly schedule', () => {
      const schedule = {
        frequency: ScheduleFrequencyEnum.WEEKLY,
        day: CacheScheduleDayEnum.MON,
        hour: 9,
        minute: 0,
        timezone: '',
        cron: null,
      };

      const result = dashboardService.testGenerateCronExpression(schedule);
      expect(result).toBe('0 9 * * MON');
    });

    it('should return custom cron expression for custom schedule', () => {
      const schedule = {
        frequency: ScheduleFrequencyEnum.CUSTOM,
        cron: '0 0 * * *',
        timezone: '',
        day: null,
        hour: 0,
        minute: 0,
      };

      const result = dashboardService.testGenerateCronExpression(schedule);
      expect(result).toBe('0 0 * * *');
    });

    it('should return null for never schedule', () => {
      const schedule = {
        frequency: ScheduleFrequencyEnum.NEVER,
        timezone: '',
        day: null,
        hour: 0,
        minute: 0,
        cron: null,
      };

      const result = dashboardService.testGenerateCronExpression(schedule);
      expect(result).toBeNull();
    });
  });

  describe('calculateNextRunTime', () => {
    it('should return null for invalid cron expression', () => {
      const result = dashboardService.testCalculateNextRunTime('invalid-cron');
      expect(result).toBeNull();
    });

    it('should calculate next run time for daily schedule', () => {
      const cronExpression = '0 12 * * *'; // Every day at 12:00 PM
      const result = dashboardService.testCalculateNextRunTime(cronExpression);

      const now = Date.now();
      expect(result).toBeInstanceOf(Date);
      expect(result!.getTime()).toBeGreaterThan(now);

      // Verify the time is correct (within 1 minute of expected time)
      const expectedTime = new Date();
      expectedTime.setHours(12, 0, 0, 0);
      if (expectedTime < new Date()) {
        expectedTime.setDate(expectedTime.getDate() + 1);
      }
      expect(
        Math.abs((result?.getTime() ?? 0) - expectedTime.getTime()),
      ).toBeLessThan(60000);
    });

    it('should calculate next run time for weekly schedule', () => {
      const cronExpression = '0 12 * * 1'; // Every Monday at 12:00 PM
      const result = dashboardService.testCalculateNextRunTime(cronExpression);

      expect(result).toBeInstanceOf(Date);
      const now = Date.now();
      expect(result!.getTime()).toBeGreaterThan(now);

      // Verify it's a Monday
      expect(result?.getDay()).toBe(1); // 1 represents Monday
    });

    it('should calculate next run time for custom schedule', () => {
      const cronExpression = '0 */2 * * *'; // Every 2 hours
      const result = dashboardService.testCalculateNextRunTime(cronExpression);

      expect(result).toBeInstanceOf(Date);
      const now = Date.now();
      expect(result!.getTime()).toBeGreaterThan(now);

      // Verify the time is in 2-hour intervals
      const hours = result?.getHours() ?? 0;
      expect(hours % 2).toBe(0);
    });

    it('should handle timezone conversion correctly', () => {
      // Test with a schedule that would be affected by timezone conversion
      const schedule = {
        frequency: ScheduleFrequencyEnum.DAILY,
        timezone: 'America/New_York',
        hour: 12,
        minute: 0,
        day: CacheScheduleDayEnum.MON,
        cron: '',
      };

      const cronExpression =
        dashboardService.testGenerateCronExpression(schedule);
      const result = dashboardService.testCalculateNextRunTime(
        cronExpression ?? '',
      );

      expect(result).toBeInstanceOf(Date);
      const now = Date.now();
      expect(result!.getTime()).toBeGreaterThan(now);
    });
  });

  describe('toUTC', () => {
    beforeEach(() => {
      // Mock the current date to a fixed value for consistent testing
      jest.useFakeTimers().setSystemTime(new Date('2024-04-22T10:00:00Z'));
    });

    afterEach(() => {
      jest.useRealTimers();
    });

    it('should return original schedule if no timezone is specified', () => {
      const schedule = {
        frequency: ScheduleFrequencyEnum.DAILY,
        hour: 14,
        minute: 30,
        timezone: '',
        day: null,
        cron: null,
      };

      const result = dashboardService.testToUTC(schedule);
      expect(result).toEqual(schedule);
    });

    it('should convert daily schedule from local time to UTC', () => {
      const schedule = {
        frequency: ScheduleFrequencyEnum.DAILY,
        hour: 14,
        minute: 30,
        timezone: 'America/New_York', // UTC-4
        day: null,
        cron: null,
      };
      const result = dashboardService.testToUTC(schedule);
      expect(result).toEqual({
        ...schedule,
        hour: 18, // 14 + 4 = 18 UTC
        minute: 30,
      });
    });

    it('should convert weekly schedule from local time to UTC without day change', () => {
      const schedule = {
        frequency: ScheduleFrequencyEnum.WEEKLY,
        day: CacheScheduleDayEnum.MON,
        hour: 14,
        minute: 30,
        timezone: 'America/New_York', // UTC-4
        cron: null,
      };

      const result = dashboardService.testToUTC(schedule);
      expect(result).toEqual({
        ...schedule,
        hour: 18, // 14 + 4 = 18 UTC
        minute: 30,
        day: CacheScheduleDayEnum.MON, // Same day because 18:30 UTC is still Monday
      });
    });

    it('should adjust day forward for weekly schedule when UTC time crosses midnight', () => {
      const schedule = {
        frequency: ScheduleFrequencyEnum.WEEKLY,
        day: CacheScheduleDayEnum.MON,
        hour: 23,
        minute: 30,
        timezone: 'America/New_York', // UTC-4
        cron: null,
      };

      const result = dashboardService.testToUTC(schedule);
      expect(result).toEqual({
        ...schedule,
        hour: 3, // 23 + 4 = 3 UTC (next day)
        minute: 30,
        day: CacheScheduleDayEnum.TUE, // Day changes to Tuesday
      });
    });

    it('should adjust day forward from Saturday to Sunday when UTC time crosses midnight', () => {
      const schedule = {
        frequency: ScheduleFrequencyEnum.WEEKLY,
        day: CacheScheduleDayEnum.SAT,
        hour: 23,
        minute: 30,
        timezone: 'America/New_York', // UTC-4
        cron: null,
      };

      const result = dashboardService.testToUTC(schedule);
      expect(result).toEqual({
        ...schedule,
        hour: 3, // 23 + 4 = 3 UTC (next day)
        minute: 30,
        day: CacheScheduleDayEnum.SUN, // Day wraps around from Saturday to Sunday
      });
    });

    it('should adjust day backward for weekly schedule when UTC time is on previous day', () => {
      const schedule = {
        frequency: ScheduleFrequencyEnum.WEEKLY,
        day: CacheScheduleDayEnum.MON,
        hour: 1,
        minute: 30,
        timezone: 'Asia/Tokyo', // UTC+9
        cron: null,
      };

      const result = dashboardService.testToUTC(schedule);
      expect(result).toEqual({
        ...schedule,
        hour: 16, // 1 - 9 = 16 UTC (previous day)
        minute: 30,
        day: CacheScheduleDayEnum.SUN, // Day changes to Sunday
      });
    });

    it('should adjust day backward from Sunday to Saturday when UTC time crosses midnight', () => {
      const schedule = {
        frequency: ScheduleFrequencyEnum.WEEKLY,
        day: CacheScheduleDayEnum.SUN,
        hour: 1,
        minute: 30,
        timezone: 'Asia/Tokyo', // UTC+9
        cron: null,
      };

      const result = dashboardService.testToUTC(schedule);
      expect(result).toEqual({
        ...schedule,
        hour: 16, // 1 - 9 = 16 UTC (previous day)
        minute: 30,
        day: CacheScheduleDayEnum.SAT, // Day wraps around from Sunday to Saturday
      });
    });

    it('should handle custom schedule without timezone conversion', () => {
      const schedule = {
        frequency: ScheduleFrequencyEnum.CUSTOM,
        cron: '0 0 * * *',
        timezone: 'America/New_York',
        day: null,
        hour: 0,
        minute: 0,
      };

      const result = dashboardService.testToUTC(schedule);
      expect(result).toEqual(schedule);
    });

    it('should handle timezone with non-hour offset (UTC+2:15)', () => {
      const schedule = {
        frequency: ScheduleFrequencyEnum.DAILY,
        hour: 14,
        minute: 30,
        timezone: 'Asia/Kolkata', // UTC+5:30
        day: null,
        cron: null,
      };

      const result = dashboardService.testToUTC(schedule);
      expect(result).toEqual({
        ...schedule,
        hour: 9, // 14 - 5 = 9 UTC
        minute: 0, // 30 - 30 = 0 UTC
      });
    });

    it('should handle timezone with non-hour offset crossing midnight', () => {
      const schedule = {
        frequency: ScheduleFrequencyEnum.WEEKLY,
        day: CacheScheduleDayEnum.MON,
        hour: 23,
        minute: 45,
        timezone: 'Asia/Kolkata', // UTC+5:30
        cron: null,
      };

      const result = dashboardService.testToUTC(schedule);
      expect(result).toEqual({
        ...schedule,
        hour: 18, // 23 - 5 = 18 UTC
        minute: 15, // 45 - 30 = 15 UTC
        day: CacheScheduleDayEnum.MON, // Same day because 18:15 UTC is still Monday
      });
    });
  });

  describe('toTimezone', () => {
    beforeEach(() => {
      // Mock the current date to a fixed value for consistent testing
      jest.useFakeTimers().setSystemTime(new Date('2024-04-22T10:00:00Z'));
    });

    afterEach(() => {
      jest.useRealTimers();
    });

    it('should return original schedule if no timezone is specified', () => {
      const schedule = {
        frequency: ScheduleFrequencyEnum.DAILY,
        hour: 14,
        minute: 30,
        day: null,
        timezone: '',
        cron: null,
      };

      const result = dashboardService.testToTimezone(schedule);
      expect(result).toEqual(schedule);
    });

    it('should convert daily schedule from UTC to local time', () => {
      const schedule = {
        frequency: ScheduleFrequencyEnum.DAILY,
        hour: 18,
        minute: 30,
        day: null,
        timezone: 'America/New_York', // UTC-4
        cron: null,
      };
      const result = dashboardService.testToTimezone(schedule);
      expect(result).toEqual({
        ...schedule,
        hour: 14, // 18 - 4 = 14 local time
        minute: 30,
      });
    });

    it('should convert weekly schedule from UTC to local time without day change', () => {
      const schedule = {
        frequency: ScheduleFrequencyEnum.WEEKLY,
        day: CacheScheduleDayEnum.MON,
        hour: 18,
        minute: 30,
        timezone: 'America/New_York', // UTC-4
        cron: null,
      };

      const result = dashboardService.testToTimezone(schedule);
      expect(result).toEqual({
        ...schedule,
        hour: 14, // 18 - 4 = 14 local time
        minute: 30,
        day: CacheScheduleDayEnum.MON, // Same day because 14:30 local is still Monday
      });
    });

    it('should adjust day forward for weekly schedule when local time crosses midnight', () => {
      const schedule = {
        frequency: ScheduleFrequencyEnum.WEEKLY,
        day: CacheScheduleDayEnum.MON,
        hour: 3,
        minute: 30,
        timezone: 'America/New_York', // UTC-4
        cron: null,
      };

      const result = dashboardService.testToTimezone(schedule);
      expect(result).toEqual({
        ...schedule,
        hour: 23, // 3 + 4 = 23 local time (previous day)
        minute: 30,
        day: CacheScheduleDayEnum.SUN, // Day changes to Sunday
      });
    });

    it('should adjust day forward from Saturday to Sunday when local time crosses midnight', () => {
      const schedule = {
        frequency: ScheduleFrequencyEnum.WEEKLY,
        day: CacheScheduleDayEnum.SAT,
        hour: 3,
        minute: 30,
        timezone: 'America/New_York', // UTC-4
        cron: null,
      };

      const result = dashboardService.testToTimezone(schedule);
      expect(result).toEqual({
        ...schedule,
        hour: 23, // 3 + 4 = 23 local time (previous day)
        minute: 30,
        day: CacheScheduleDayEnum.FRI, // Day wraps around from Saturday to Friday
      });
    });

    it('should adjust day backward for weekly schedule when local time is on next day', () => {
      const schedule = {
        frequency: ScheduleFrequencyEnum.WEEKLY,
        day: CacheScheduleDayEnum.MON,
        hour: 16,
        minute: 30,
        timezone: 'Asia/Tokyo', // UTC+9
        cron: null,
      };

      const result = dashboardService.testToTimezone(schedule);
      expect(result).toEqual({
        ...schedule,
        hour: 1, // 16 - 9 = 1 local time (next day)
        minute: 30,
        day: CacheScheduleDayEnum.TUE, // Day changes to Tuesday
      });
    });

    it('should adjust day backward from Sunday to Monday when local time crosses midnight', () => {
      const schedule = {
        frequency: ScheduleFrequencyEnum.WEEKLY,
        day: CacheScheduleDayEnum.SUN,
        hour: 16,
        minute: 30,
        timezone: 'Asia/Tokyo', // UTC+9
        cron: null,
      };

      const result = dashboardService.testToTimezone(schedule);
      expect(result).toEqual({
        ...schedule,
        hour: 1, // 16 - 9 = 1 local time (next day)
        minute: 30,
        day: CacheScheduleDayEnum.MON, // Day wraps around from Sunday to Monday
      });
    });

    it('should handle custom schedule without timezone conversion', () => {
      const schedule = {
        frequency: ScheduleFrequencyEnum.CUSTOM,
        minute: null,
        hour: null,
        day: null,
        cron: '0 0 * * *',
        timezone: 'America/New_York',
      };

      const result = dashboardService.testToTimezone(schedule);
      expect(result).toEqual(schedule);
    });

    it('should handle timezone with non-hour offset (UTC+2:15)', () => {
      const schedule = {
        frequency: ScheduleFrequencyEnum.DAILY,
        hour: 9,
        minute: 0,
        day: null,
        timezone: 'Asia/Kolkata', // UTC+5:30
        cron: null,
      };

      const result = dashboardService.testToTimezone(schedule);
      expect(result).toEqual({
        ...schedule,
        hour: 14, // 9 + 5 = 14 local time
        minute: 30, // 0 + 30 = 30 local time
      });
    });

    it('should handle timezone with non-hour offset crossing midnight', () => {
      const schedule = {
        frequency: ScheduleFrequencyEnum.WEEKLY,
        day: CacheScheduleDayEnum.MON,
        hour: 18,
        minute: 15,
        timezone: 'Asia/Kolkata', // UTC+5:30
        cron: null,
      };

      const result = dashboardService.testToTimezone(schedule);
      expect(result).toEqual({
        ...schedule,
        hour: 23, // 18 + 5 = 23 local time
        minute: 45, // 15 + 30 = 45 local time
        day: CacheScheduleDayEnum.MON, // Same day because 23:45 local is still Monday
      });
    });
  });

  describe('validateScheduleInput', () => {
    it('should throw error for weekly schedule without day', () => {
      const data = {
        cacheEnabled: true,
        schedule: {
          frequency: ScheduleFrequencyEnum.WEEKLY,
          hour: 12,
          minute: 0,
          timezone: '',
          day: null,
          cron: null,
        },
      };

      expect(() => {
        dashboardService.testValidateScheduleInput(data);
      }).toThrow('Day of week is required for weekly schedule');
    });

    it('should throw error for custom schedule without cron expression', () => {
      const data = {
        cacheEnabled: true,
        schedule: {
          frequency: ScheduleFrequencyEnum.CUSTOM,
          hour: 12,
          minute: 0,
          timezone: '',
          day: null,
          cron: null,
        },
      };

      expect(() => {
        dashboardService.testValidateScheduleInput(data);
      }).toThrow('Cron expression is required for custom schedule');
    });

    it('should throw error for invalid hour', () => {
      const data = {
        cacheEnabled: true,
        schedule: {
          frequency: ScheduleFrequencyEnum.DAILY,
          hour: 24,
          minute: 0,
          timezone: '',
          day: null,
          cron: null,
        },
      };

      expect(() => {
        dashboardService.testValidateScheduleInput(data);
      }).toThrow('Hour must be between 0 and 23');
    });

    it('should throw error for invalid minute', () => {
      const data = {
        cacheEnabled: true,
        schedule: {
          frequency: ScheduleFrequencyEnum.DAILY,
          hour: 12,
          minute: 60,
          timezone: '',
          day: null,
          cron: null,
        },
      };

      expect(() => {
        dashboardService.testValidateScheduleInput(data);
      }).toThrow('Minute must be between 0 and 59');
    });

    it('should throw error for invalid timezone', () => {
      const data = {
        cacheEnabled: true,
        schedule: {
          frequency: ScheduleFrequencyEnum.DAILY,
          hour: 12,
          minute: 0,
          timezone: 'Invalid/Timezone',
          day: null,
          cron: null,
        },
      };

      expect(() => {
        dashboardService.testValidateScheduleInput(data);
      }).toThrow('Invalid timezone: Invalid/Timezone');
    });

    it('should throw error for custom schedule with interval less than 10 minutes', () => {
      const data = {
        cacheEnabled: true,
        schedule: {
          frequency: ScheduleFrequencyEnum.CUSTOM,
          cron: '*/5 * * * *', // Every 5 minutes
          timezone: '',
          day: null,
          hour: 0,
          minute: 0,
        },
      };

      expect(() => {
        dashboardService.testValidateScheduleInput(data);
      }).toThrow('Custom cron expression must be at least 10 minutes apart');
    });

    it('should not throw error for valid daily schedule', () => {
      const data = {
        cacheEnabled: true,
        schedule: {
          frequency: ScheduleFrequencyEnum.DAILY,
          hour: 12,
          minute: 0,
          timezone: '',
          day: CacheScheduleDayEnum.MON,
          cron: '',
        },
      };

      expect(() => {
        dashboardService.testValidateScheduleInput(data);
      }).not.toThrow();
    });

    it('should not throw error for valid weekly schedule', () => {
      const data = {
        cacheEnabled: true,
        schedule: {
          frequency: ScheduleFrequencyEnum.WEEKLY,
          day: CacheScheduleDayEnum.MON,
          hour: 12,
          minute: 0,
          timezone: '',
          cron: null,
        },
      };

      expect(() => {
        dashboardService.testValidateScheduleInput(data);
      }).not.toThrow();
    });

    it('should not throw error for valid custom schedule', () => {
      const data = {
        cacheEnabled: true,
        schedule: {
          frequency: ScheduleFrequencyEnum.CUSTOM,
          cron: '0 */15 * * *', // Every 15 minutes
          timezone: '',
          day: null,
          hour: 0,
          minute: 0,
        },
      };

      expect(() => {
        dashboardService.testValidateScheduleInput(data);
      }).not.toThrow();
    });

    it('should not throw error for valid schedule with timezone', () => {
      const data = {
        cacheEnabled: true,
        schedule: {
          frequency: ScheduleFrequencyEnum.DAILY,
          hour: 12,
          minute: 0,
          timezone: 'America/New_York',
          day: null,
          cron: null,
        },
      };

      expect(() => {
        dashboardService.testValidateScheduleInput(data);
      }).not.toThrow();
    });
  });

  describe('setDashboardSchedule', () => {
    beforeEach(() => {
      mockDashboardRepository.findOneBy.mockReset();
      mockDashboardRepository.updateOne.mockReset();
    });

    it('should throw error if dashboard not found', async () => {
      mockDashboardRepository.findOneBy.mockResolvedValue(null);

      const data = createScheduleData(ScheduleFrequencyEnum.DAILY, {
        hour: 12,
        minute: 0,
      });

      await expect(
        dashboardService.setDashboardSchedule(1, data),
      ).rejects.toThrow('Dashboard with id 1 not found');
    });

    it('should update dashboard with daily schedule', async () => {
      const mockDashboard = {
        id: 1,
        projectId: 1,
        name: 'Test Dashboard',
      };
      mockDashboardRepository.findOneBy.mockResolvedValue(mockDashboard);
      mockDashboardRepository.updateOne.mockResolvedValue({
        ...mockDashboard,
        cacheEnabled: true,
        scheduleFrequency: ScheduleFrequencyEnum.DAILY,
        scheduleCron: '0 12 * * *',
        nextScheduledAt: expect.any(Date),
        scheduleTimezone: '',
      });

      const data = createScheduleData(ScheduleFrequencyEnum.DAILY, {
        hour: 12,
        minute: 0,
      });

      await dashboardService.setDashboardSchedule(1, data);

      expect(mockDashboardRepository.updateOne).toHaveBeenCalledWith(1, {
        cacheEnabled: true,
        scheduleFrequency: ScheduleFrequencyEnum.DAILY,
        scheduleCron: '0 12 * * *',
        nextScheduledAt: expect.any(Date),
        scheduleTimezone: '',
      });
    });

    it('should update dashboard with weekly schedule', async () => {
      const mockDashboard = {
        id: 1,
        projectId: 1,
        name: 'Test Dashboard',
      };
      mockDashboardRepository.findOneBy.mockResolvedValue(mockDashboard);
      mockDashboardRepository.updateOne.mockResolvedValue({
        ...mockDashboard,
        cacheEnabled: true,
        scheduleFrequency: ScheduleFrequencyEnum.WEEKLY,
        scheduleCron: '0 12 * * MON',
        nextScheduledAt: expect.any(Date),
        scheduleTimezone: '',
      });

      const data = createScheduleData(ScheduleFrequencyEnum.WEEKLY, {
        day: CacheScheduleDayEnum.MON,
        hour: 12,
        minute: 0,
      });

      await dashboardService.setDashboardSchedule(1, data);

      expect(mockDashboardRepository.updateOne).toHaveBeenCalledWith(1, {
        cacheEnabled: true,
        scheduleFrequency: ScheduleFrequencyEnum.WEEKLY,
        scheduleCron: '0 12 * * MON',
        nextScheduledAt: expect.any(Date),
        scheduleTimezone: '',
      });
    });

    it('should update dashboard with custom schedule', async () => {
      const mockDashboard = {
        id: 1,
        projectId: 1,
        name: 'Test Dashboard',
      };
      mockDashboardRepository.findOneBy.mockResolvedValue(mockDashboard);
      mockDashboardRepository.updateOne.mockResolvedValue({
        ...mockDashboard,
        cacheEnabled: true,
        scheduleFrequency: ScheduleFrequencyEnum.CUSTOM,
        scheduleCron: '0 */15 * * *',
        nextScheduledAt: expect.any(Date),
        scheduleTimezone: '',
      });

      const data = createScheduleData(ScheduleFrequencyEnum.CUSTOM, {
        cron: '0 */15 * * *',
      });

      await dashboardService.setDashboardSchedule(1, data);

      expect(mockDashboardRepository.updateOne).toHaveBeenCalledWith(1, {
        cacheEnabled: true,
        scheduleFrequency: ScheduleFrequencyEnum.CUSTOM,
        scheduleCron: '0 */15 * * *',
        nextScheduledAt: expect.any(Date),
        scheduleTimezone: '',
      });
    });

    it('should update dashboard with disabled cache', async () => {
      const mockDashboard = {
        id: 1,
        projectId: 1,
        name: 'Test Dashboard',
      };
      mockDashboardRepository.findOneBy.mockResolvedValue(mockDashboard);
      mockDashboardRepository.updateOne.mockResolvedValue({
        ...mockDashboard,
        cacheEnabled: false,
        scheduleFrequency: null,
        scheduleCron: null,
        nextScheduledAt: null,
        scheduleTimezone: null,
      });

      const data = createScheduleData(ScheduleFrequencyEnum.NEVER, {
        cacheEnabled: false,
      });

      await dashboardService.setDashboardSchedule(1, data);

      expect(mockDashboardRepository.updateOne).toHaveBeenCalledWith(1, {
        cacheEnabled: false,
        scheduleFrequency: null,
        scheduleCron: null,
        nextScheduledAt: null,
        scheduleTimezone: null,
      });
    });

    it('should handle timezone conversion in schedule', async () => {
      const mockDashboard = {
        id: 1,
        projectId: 1,
        name: 'Test Dashboard',
      };
      mockDashboardRepository.findOneBy.mockResolvedValue(mockDashboard);
      mockDashboardRepository.updateOne.mockResolvedValue({
        ...mockDashboard,
        cacheEnabled: true,
        scheduleFrequency: ScheduleFrequencyEnum.DAILY,
        scheduleCron: '0 16 * * *', // 12:00 PM EST = 16:00 UTC
        nextScheduledAt: expect.any(Date),
        scheduleTimezone: 'America/New_York',
      });

      const data = createScheduleData(ScheduleFrequencyEnum.DAILY, {
        hour: 12,
        minute: 0,
        timezone: 'America/New_York',
      });

      await dashboardService.setDashboardSchedule(1, data);

      expect(mockDashboardRepository.updateOne).toHaveBeenCalledWith(1, {
        cacheEnabled: true,
        scheduleFrequency: ScheduleFrequencyEnum.DAILY,
        scheduleCron: '0 16 * * *',
        nextScheduledAt: expect.any(Date),
        scheduleTimezone: 'America/New_York',
      });
    });

    it('should handle error during update', async () => {
      const mockDashboard = {
        id: 1,
        projectId: 1,
        name: 'Test Dashboard',
      };
      mockDashboardRepository.findOneBy.mockResolvedValue(mockDashboard);
      mockDashboardRepository.updateOne.mockRejectedValue(
        new Error('Update failed'),
      );

      const data = createScheduleData(ScheduleFrequencyEnum.DAILY, {
        hour: 12,
        minute: 0,
      });

      await expect(
        dashboardService.setDashboardSchedule(1, data),
      ).rejects.toThrow('Update failed');
    });
  });
});
</file>

<file path="src/apollo/server/services/tests/deployService.test.ts">
import { DeployService } from '../deployService';
import { DeployStatusEnum } from '@server/repositories/deployLogRepository';

describe('DeployService', () => {
  let mockWrenAIAdaptor;

  let mockDeployLogRepository;
  let deployService;
  let mockTelemetry;

  beforeEach(() => {
    mockTelemetry = { sendEvent: jest.fn() };
    mockWrenAIAdaptor = { deploy: jest.fn() };
    mockDeployLogRepository = {
      findLastProjectDeployLog: jest.fn(),
      createOne: jest.fn(),
      updateOne: jest.fn(),
    };

    deployService = new DeployService({
      telemetry: mockTelemetry,
      wrenAIAdaptor: mockWrenAIAdaptor,
      deployLogRepository: mockDeployLogRepository,
    });
  });

  it('should successfully deploy when there is no existing deployment with the same hash', async () => {
    const manifest = { key: 'value' };
    const projectId = 1;

    mockDeployLogRepository.findLastProjectDeployLog.mockResolvedValue(null);
    mockWrenAIAdaptor.deploy.mockResolvedValue({ status: 'SUCCESS' });
    mockDeployLogRepository.createOne.mockResolvedValue({ id: 123 });

    const response = await deployService.deploy(manifest, projectId);

    expect(response.status).toEqual(DeployStatusEnum.SUCCESS);
    expect(mockDeployLogRepository.updateOne).toHaveBeenCalledWith(123, {
      status: DeployStatusEnum.SUCCESS,
      error: undefined,
    });
  });

  it('should return failed status if ai-service deployment fails', async () => {
    const manifest = { key: 'value' };
    const projectId = 1;

    mockDeployLogRepository.findLastProjectDeployLog.mockResolvedValue(null);
    mockWrenAIAdaptor.deploy.mockResolvedValue({
      status: 'FAILED',
      error: 'AI error',
    });
    mockDeployLogRepository.createOne.mockResolvedValue({ id: 123 });

    const response = await deployService.deploy(manifest, projectId);

    expect(response.status).toEqual(DeployStatusEnum.FAILED);
    expect(response.error).toEqual('AI error');
  });

  it('should skip deployment if an existing deployment with the same hash exists', async () => {
    const manifest = { key: 'value' };
    const projectId = 1;

    mockDeployLogRepository.findLastProjectDeployLog.mockResolvedValue({
      hash: deployService.createMDLHash(manifest, 1),
    });

    const response = await deployService.deploy(manifest, projectId);

    expect(response.status).toEqual(DeployStatusEnum.SUCCESS);
    expect(mockWrenAIAdaptor.deploy).not.toHaveBeenCalled();
  });

  // Add more tests here to cover other scenarios and error handling
});
</file>

<file path="src/apollo/server/services/tests/queryService.test.ts">
import { TelemetryEvent } from '../../telemetry/telemetry';
import { DataSourceName } from '../../types';
import { QueryService } from '../queryService';

describe('QueryService', () => {
  let mockIbisAdaptor;
  let mockWrenEngineAdaptor;
  let mockTelemetry;
  let queryService;

  beforeEach(() => {
    mockIbisAdaptor = {
      query: jest.fn(),
      dryRun: jest.fn(),
    };
    mockWrenEngineAdaptor = {};
    mockTelemetry = new MockTelemetry();

    queryService = new QueryService({
      ibisAdaptor: mockIbisAdaptor,
      wrenEngineAdaptor: mockWrenEngineAdaptor,
      telemetry: mockTelemetry,
    });
  });

  afterEach(() => {
    mockTelemetry.records = [];
    jest.clearAllMocks();
  });

  it('should return true and send event when previewing via ibis dry run succeeds', async () => {
    mockIbisAdaptor.dryRun.mockResolvedValue({
      correlationId: '123',
      processTime: '1s',
    });

    const res = await queryService.preview('SELECT * FROM test', {
      project: { type: DataSourceName.POSTGRES, connectionInfo: {} },
      manifest: {},
      dryRun: true,
    });

    expect(res).toEqual({ correlationId: '123' });
    expect(mockTelemetry.records).toHaveLength(1);
    expect(mockTelemetry.records[0]).toEqual({
      event: TelemetryEvent.IBIS_DRY_RUN,
      properties: {
        correlationId: '123',
        processTime: '1s',
        sql: 'SELECT * FROM test',
        dataSource: DataSourceName.POSTGRES,
      },
      actionSuccess: true,
    });
  });

  it('should send event when previewing via ibis dry run fails', async () => {
    mockIbisAdaptor.dryRun.mockRejectedValue({
      message: 'Error message',
      extensions: {
        other: {
          correlationId: '123',
          processTime: '1s',
        },
      },
    });

    try {
      await queryService.preview('SELECT * FROM test', {
        project: { type: DataSourceName.POSTGRES, connectionInfo: {} },
        manifest: {},
        dryRun: true,
      });
    } catch (e) {
      expect(e.message).toEqual('Error message');
      expect(e.extensions.other.correlationId).toEqual('123');
      expect(e.extensions.other.processTime).toEqual('1s');
    }

    expect(mockTelemetry.records).toHaveLength(1);
    expect(mockTelemetry.records[0]).toEqual({
      event: TelemetryEvent.IBIS_DRY_RUN,
      properties: {
        correlationId: '123',
        processTime: '1s',
        sql: 'SELECT * FROM test',
        dataSource: DataSourceName.POSTGRES,
        error: 'Error message',
      },
      actionSuccess: false,
      service: undefined,
    });
  });

  it('should return data and send event when previewing via ibis query succeeds', async () => {
    mockIbisAdaptor.query.mockResolvedValue({
      data: [],
      columns: [],
      dtypes: [],
      correlationId: '123',
      processTime: '1s',
    });

    const res = await queryService.preview('SELECT * FROM test', {
      project: { type: DataSourceName.POSTGRES, connectionInfo: {} },
      manifest: {},
      limit: 10,
    });

    expect(res.data).toEqual([]);
    expect(mockTelemetry.records).toHaveLength(1);
    expect(mockTelemetry.records[0]).toEqual({
      event: TelemetryEvent.IBIS_QUERY,
      properties: {
        correlationId: '123',
        processTime: '1s',
        sql: 'SELECT * FROM test',
        dataSource: DataSourceName.POSTGRES,
      },
      actionSuccess: true,
    });
  });

  it('should send event when previewing via ibis query fails', async () => {
    mockIbisAdaptor.query.mockRejectedValue({
      message: 'Error message',
      extensions: {
        other: {
          correlationId: '123',
          processTime: '1s',
        },
      },
    });

    await expect(
      queryService.preview('SELECT * FROM test', {
        project: { type: DataSourceName.POSTGRES, connectionInfo: {} },
        manifest: {},
      }),
    ).rejects.toMatchObject({
      message: 'Error message',
      extensions: {
        other: {
          correlationId: '123',
          processTime: '1s',
        },
      },
    });

    expect(mockTelemetry.records).toHaveLength(1);
    expect(mockTelemetry.records[0]).toEqual({
      event: TelemetryEvent.IBIS_QUERY,
      properties: {
        correlationId: '123',
        processTime: '1s',
        sql: 'SELECT * FROM test',
        dataSource: DataSourceName.POSTGRES,
        error: 'Error message',
      },
      actionSuccess: false,
      service: undefined,
    });
  });
});

class MockTelemetry {
  records: any[] = [];
  sendEvent(
    event: TelemetryEvent,
    properties: Record<string, any> = {},
    service: any,
    actionSuccess: boolean = true,
  ) {
    this.records.push({ event, properties, service, actionSuccess });
  }
}
</file>

<file path="src/apollo/server/telemetry/telemetry.ts">
import { getConfig } from '../config';
import { PostHog } from 'posthog-node';
import { v4 as uuidv4 } from 'uuid';
import { getLogger } from '@server/utils';
import { IContext } from '../types';

const logger = getLogger('TELEMETRY');
logger.level = 'debug';

const config = getConfig();

const {
  userUUID,
  telemetryEnabled,
  wrenAIVersion,
  generationModel,
  wrenEngineVersion,
  wrenUIVersion,
  posthogApiKey,
  posthogHost,
} = config;

export enum TelemetryEvent {
  // onboarding
  CONNECTION_START_SAMPLE_DATASET = 'connection_start_sample_dataset',
  CONNECTION_SAVE_DATA_SOURCE = 'connection_save_data_source',
  CONNECTION_SAVE_TABLES = 'connection_save_tables',
  CONNECTION_SAVE_RELATION = 'connection_save_relation',

  // modeling page
  MODELING_DEPLOY_MDL = 'modeling_deploy_mdl',
  MODELING_CREATE_MODEL = 'modeling_create_model',
  MODELING_UPDATE_MODEL = 'modeling_update_model',
  MODELING_CREATE_CF = 'modeling_create_cf',
  MODELING_UPDATE_CF = 'modeling_update_cf',
  MODELING_UPDATE_MODEL_METADATA = 'modeling_update_model_metadata',
  MODELING_UPDATE_VIEW_METADATA = 'modeling_update_view_metadata',
  MODELING_CREATE_RELATION = 'modeling_create_relation',
  MODELING_UPDATE_RELATION = 'modeling_update_relation',
  // schema change
  MODELING_DETECT_SCHEMA_CHANGE = 'modeling_detect_schema_change',
  MODELING_RESOLVE_SCHEMA_CHANGE = 'modeling_resolve_schema_change',

  HOME_UPDATE_THREAD_SUMMARY = 'update_thread_summary',
  // ask question
  HOME_ASK_CANDIDATE = 'home_ask_candidate',
  HOME_CREATE_THREAD = 'home_create_thread',
  HOME_ANSWER_QUESTION = 'home_answer_question',
  HOME_ANSWER_QUESTION_INTERRUPTED = 'home_answer_question_interrupted',
  HOME_ANSWER_BREAKDOWN = 'home_answer_breakdown',
  HOME_ANSWER_CHART = 'home_answer_chart',
  HOME_ANSWER_ADJUST_CHART = 'home_answer_adjust_chart',
  HOME_ASK_FOLLOWUP_QUESTION = 'home_ask_followup_question',
  HOME_CANCEL_ASK = 'home_cancel_ask',
  HOME_RERUN_ASKING_TASK = 'home_rerun_asking_task',
  HOME_GENERATE_PROJECT_RECOMMENDATION_QUESTIONS = 'home_generate_project_recommendation_questions',
  HOME_GENERATE_THREAD_RECOMMENDATION_QUESTIONS = 'home_generate_thread_recommendation_questions',

  // adjustment
  HOME_ADJUST_THREAD_RESPONSE = 'home_adjust_thread_response',
  HOME_ADJUST_THREAD_RESPONSE_CANCEL = 'home_adjust_thread_response_cancel',
  HOME_ADJUST_THREAD_RESPONSE_RERUN = 'home_adjust_thread_response_rerun',
  HOME_ADJUST_THREAD_RESPONSE_WITH_SQL = 'home_adjust_thread_response_with_sql',

  // event after ask
  HOME_CREATE_VIEW = 'home_create_view',
  HOME_PREVIEW_ANSWER = 'home_preview_answer',

  // settings event
  SETTING_RESET_PROJECT = 'setting_reset_project',

  // ibis event
  IBIS_DRY_RUN = 'ibis_dry_run',
  IBIS_QUERY = 'ibis_query',

  // Default error
  GRAPHQL_ERROR = 'graphql_error',

  // Knowledge
  KNOWLEDGE_CREATE_INSTRUCTION = 'knowledge_create_instruction',
  KNOWLEDGE_UPDATE_INSTRUCTION = 'knowledge_update_instruction',
  KNOWLEDGE_DELETE_INSTRUCTION = 'knowledge_delete_instruction',
  KNOWLEDGE_CREATE_SQL_PAIR = 'knowledge_create_sql_pair',
  KNOWLEDGE_UPDATE_SQL_PAIR = 'knowledge_update_sql_pair',
  KNOWLEDGE_DELETE_SQL_PAIR = 'knowledge_delete_sql_pair',
}

export enum WrenService {
  BE = 'BE',
  AI = 'AI',
  ENGINE = 'ENGINE',
  UNKNOWN = 'UNKNOWN',
}

export interface ITelemetry {
  sendEvent: (
    event: TelemetryEvent,
    properties: Record<string, any>,
    service?: WrenService | any,
    actionSuccess?: boolean,
  ) => void;
}

export class PostHogTelemetry {
  private readonly posthog: any;
  private readonly userId: string;

  constructor() {
    if (telemetryEnabled) {
      if (!posthogApiKey) {
        logger.debug('Telemetry enabled but posthogApiKey not provided.');
        return;
      }
      const client = new PostHog(posthogApiKey, {
        host: posthogHost || 'https://us.posthog.com',
      });
      this.posthog = client;
      this.userId = userUUID || uuidv4();
      logger.info(`Telemetry initialized: ${this.userId}`);
      return;
    }
    logger.info('Telemetry not enabled.');
  }

  public async sendEvent(
    event: TelemetryEvent,
    properties: Record<string, any> = {},
    service: WrenService | any = WrenService.UNKNOWN,
    actionSuccess: boolean = true,
  ) {
    if (!this.posthog) {
      return;
    }
    const eventName = actionSuccess ? `${event}_success` : `${event}_failed`;
    try {
      console.log('sendEvent', eventName, properties, service, actionSuccess);
      const systemInfo = this.collectSystemInfo();
      this.posthog.capture({
        distinctId: this.userId,
        event: eventName,
        properties: {
          ...systemInfo,
          ...properties,
          wren_service: service,
        },
      });
    } catch (e) {
      logger.error(e);
    }
  }

  private collectSystemInfo(): Record<string, any> {
    return {
      // collect services version
      'wren-ui-version': wrenUIVersion || null,
      'wren-engine-version': wrenEngineVersion || null,
      'wren-ai-service-version': wrenAIVersion || null,

      // collect AI model info
      'generation-model': generationModel || null,

      // collect some system info from process module
      node_version: process.version,
      node_platform: process.platform,
      node_arch: process.arch,
      memory_usage: process.memoryUsage(),
      cpu_usage: process.cpuUsage(),
    };
  }

  public stop() {
    if (this.posthog) {
      this.posthog.shutdown();
    }
  }
}

export const withTelemetry = async <T>(
  eventName: TelemetryEvent,
  data: any,
  operation: () => Promise<T>,
  ctx: IContext,
): Promise<T> => {
  try {
    const result = await operation();
    ctx.telemetry.sendEvent(eventName, { data });
    return result;
  } catch (err: any) {
    ctx.telemetry.sendEvent(
      eventName,
      { data, error: err.message },
      err.extensions?.service,
      false,
    );
    throw err;
  }
};

export function TrackTelemetry(eventName: TelemetryEvent) {
  return function (
    _target: any,
    _propertyKey: string,
    descriptor: PropertyDescriptor,
  ) {
    const originalMethod = descriptor.value;

    descriptor.value = async function (...args: [any, any, IContext]) {
      // The last argument is typically the context in GraphQL resolvers
      const [, , ctx] = args;
      // Extract data using the provided extractor or use a default approach
      const data = args[1]?.data || args[1];

      try {
        const result = await originalMethod.apply(this, args);
        ctx.telemetry.sendEvent(eventName, { data });
        return result;
      } catch (err: any) {
        ctx.telemetry.sendEvent(
          eventName,
          { data, error: err.message },
          err.extensions?.service,
          false,
        );
        throw err;
      }
    };

    return descriptor;
  };
}
</file>

<file path="src/apollo/server/types/context.ts">
import { IConfig } from '@server/config';
import {
  IIbisAdaptor,
  IWrenAIAdaptor,
  IWrenEngineAdaptor,
} from '@server/adaptors';
import {
  IModelColumnRepository,
  IModelNestedColumnRepository,
  IModelRepository,
  IProjectRepository,
  IRelationRepository,
  IViewRepository,
  ILearningRepository,
  ISchemaChangeRepository,
  IDeployLogRepository,
  IDashboardRepository,
  IDashboardItemRepository,
  ISqlPairRepository,
  IInstructionRepository,
  IApiHistoryRepository,
  IDashboardItemRefreshJobRepository,
} from '@server/repositories';
import {
  IQueryService,
  IAskingService,
  IDeployService,
  IModelService,
  IMDLService,
  IProjectService,
  IDashboardService,
  IInstructionService,
} from '@server/services';
import { ITelemetry } from '@server/telemetry/telemetry';
import {
  ProjectRecommendQuestionBackgroundTracker,
  ThreadRecommendQuestionBackgroundTracker,
  DashboardCacheBackgroundTracker,
} from '@server/backgrounds';
import { ISqlPairService } from '../services/sqlPairService';

export interface IContext {
  config: IConfig;
  // telemetry
  telemetry: ITelemetry;

  // adaptor
  wrenEngineAdaptor: IWrenEngineAdaptor;
  ibisServerAdaptor: IIbisAdaptor;
  wrenAIAdaptor: IWrenAIAdaptor;

  // services
  projectService: IProjectService;
  modelService: IModelService;
  mdlService: IMDLService;
  deployService: IDeployService;
  askingService: IAskingService;
  queryService: IQueryService;
  dashboardService: IDashboardService;
  sqlPairService: ISqlPairService;
  instructionService: IInstructionService;

  // repository
  projectRepository: IProjectRepository;
  modelRepository: IModelRepository;
  modelColumnRepository: IModelColumnRepository;
  modelNestedColumnRepository: IModelNestedColumnRepository;
  relationRepository: IRelationRepository;
  viewRepository: IViewRepository;
  deployRepository: IDeployLogRepository;
  schemaChangeRepository: ISchemaChangeRepository;
  learningRepository: ILearningRepository;
  dashboardRepository: IDashboardRepository;
  dashboardItemRepository: IDashboardItemRepository;
  sqlPairRepository: ISqlPairRepository;
  instructionRepository: IInstructionRepository;
  apiHistoryRepository: IApiHistoryRepository;
  dashboardItemRefreshJobRepository: IDashboardItemRefreshJobRepository;

  // background trackers
  projectRecommendQuestionBackgroundTracker: ProjectRecommendQuestionBackgroundTracker;
  threadRecommendQuestionBackgroundTracker: ThreadRecommendQuestionBackgroundTracker;
  dashboardCacheBackgroundTracker: DashboardCacheBackgroundTracker;
}
</file>

<file path="src/apollo/server/types/dataSource.ts">
export enum DataSourceName {
  BIG_QUERY = 'BIG_QUERY',
  DUCKDB = 'DUCKDB',
  POSTGRES = 'POSTGRES',
  MYSQL = 'MYSQL',
  ORACLE = 'ORACLE',
  MSSQL = 'MSSQL',
  CLICK_HOUSE = 'CLICK_HOUSE',
  TRINO = 'TRINO',
  SNOWFLAKE = 'SNOWFLAKE',
  ATHENA = 'ATHENA',
  REDSHIFT = 'REDSHIFT',
}

export interface DataSource {
  type: DataSourceName;
  properties: DataSourceProperties;
  sampleDataset?: string;
}

export interface SampleDatasetData {
  name: string;
}

export type DataSourceProperties = { displayName: string } & Partial<
  BigQueryDataSourceProperties &
    DuckDBDataSourceProperties &
    PGDataSourceProperties
>;

export interface BigQueryDataSourceProperties {
  displayName: string;
  projectId: string;
  datasetId: string;
  credentials: JSON;
}

export interface DuckDBDataSourceProperties {
  displayName: string;
  initSql: string;
  extensions: string[];
  configurations: Record<string, any>;
}

export interface PGDataSourceProperties {
  displayName: string;
  host: string;
  port: number;
  database: string;
  user: string;
  password: string;
  ssl?: boolean;
}
</file>

<file path="src/apollo/server/types/diagram.ts">
import { RelationType } from '@server/types';

export enum NodeType {
  MODEL = 'MODEL',
  VIEW = 'VIEW',
  RELATION = 'RELATION',
  FIELD = 'FIELD',
  CALCULATED_FIELD = 'CALCULATED_FIELD',
}

export interface Diagram {
  models: DiagramModel[];
  views: DiagramView[];
}

export interface DiagramView {
  id: string;
  viewId: number;
  nodeType: NodeType;
  statement: string;
  displayName: string;
  referenceName: string;
  fields: DiagramViewField[];
  description: string;
}

export interface DiagramViewField {
  id: string;
  displayName: string;
  referenceName: string;
  type: string;
  nodeType: NodeType;
  description: string;
}

export interface DiagramModel {
  id: string;
  modelId: number;
  nodeType: NodeType;
  displayName: string;
  referenceName: string;
  sourceTableName: string;
  refSql?: string;
  cached: boolean;
  refreshTime: string;
  description: string;
  fields: DiagramModelField[];
  calculatedFields: DiagramModelField[];
  relationFields: DiagramModelRelationField[];
}

export interface DiagramModelNestedField {
  id: string;
  nestedColumnId: number;
  type: string;
  displayName: string;
  referenceName: string;
  description: string;
}

export interface DiagramModelField {
  id: string;
  columnId: number;
  type: string;
  nodeType: NodeType;
  displayName: string;
  referenceName: string;
  description: string;
  isPrimaryKey?: boolean;
  expression?: string;
  lineage?: string;
  aggregation?: string;
  nestedFields?: DiagramModelNestedField[];
}

export interface DiagramModelRelationField {
  id: string;
  relationId: number;
  type: RelationType;
  nodeType: NodeType;
  displayName: string;
  referenceName: string;
  fromModelId: number;
  fromModelName: string;
  fromModelDisplayName: string;
  fromColumnId: number;
  fromColumnName: string;
  fromColumnDisplayName: string;
  toModelId: number;
  toModelName: string;
  toModelDisplayName: string;
  toColumnId: number;
  toColumnName: string;
  toColumnDisplayName: string;
  description: string;
}
</file>

<file path="src/apollo/server/types/index.ts">
export * from './dataSource';
export * from './relationship';
export * from './manifest';
export * from './diagram';
export * from './metric';
export * from './context';
</file>

<file path="src/apollo/server/types/manifest.ts">
export interface Manifest {
  catalog: string;
  schema: string;
  models: Model[];
  relationships: Relationship[];
  enumDefinitions: EnumDefinition[];
  metrics: Metric[];
  cumulativeMetrics: CumulativeMetric[];
  views: EnumDefinition[];
  macros: Macro[];
  dateSpine: DateSpine;
}

export interface CumulativeMetric {
  name: string;
  baseObject: string;
  measure: Measure;
  window: Window;
  cached: boolean;
  description?: string;
  properties: CumulativeMetricProperties;
}

export interface Measure {
  name: string;
  type: string;
  operator: string;
  refColumn: string;
  properties?: CumulativeMetricProperties;
}

export interface CumulativeMetricProperties {
  description?: string;
}

export interface Window {
  name: string;
  refColumn: string;
  timeUnit: string;
  start: Date;
  end: Date;
  properties: CumulativeMetricProperties;
}

export interface DateSpine {
  unit: string;
  start: Date;
  end: Date;
  properties: CumulativeMetricProperties;
}

export interface EnumDefinition {
  name: string;
  values?: Value[];
  description: string;
  properties: CumulativeMetricProperties;
  statement?: string;
}

export interface Value {
  name: string;
  value: string;
  properties: CumulativeMetricProperties;
}

export interface Macro {
  name: string;
  definition: string;
  properties: CumulativeMetricProperties;
}

export interface Metric {
  name: string;
  baseObject: string;
  dimension: Dimension[];
  measure: Dimension[];
  timeGrain: TimeGrain[];
  cached: boolean;
  refreshTime: string;
  description: string;
  properties: CumulativeMetricProperties;
}

export interface Dimension {
  name: string;
  type: string;
  isCalculated: boolean;
  notNull: boolean;
  properties: DimensionProperties;
}

export interface DimensionProperties {}

export interface TimeGrain {
  name: string;
  refColumn: string;
  dateParts: string[];
}

export interface Model {
  name: string;
  refSql: string;
  columns: Column[];
  primaryKey?: string;
  cached: boolean;
  refreshTime: string;
  description?: string;
  properties: CumulativeMetricProperties;
}

export interface createColumnInput {
  name: string;
}

export interface Column {
  name: string;
  type: string;
  isCalculated: boolean;
  notNull: boolean;
  description?: string;
  properties: CumulativeMetricProperties;
  relationship?: string;
  expression?: string;
}

export interface Relationship {
  name: string;
  models: string[];
  joinType: string;
  condition: string;
  manySideSortKeys: ManySideSortKey[];
  description: string;
  properties: CumulativeMetricProperties;
}

export interface ManySideSortKey {
  name: string;
  descending: boolean;
}
</file>

<file path="src/apollo/server/types/metric.ts">
enum ModelType {
  TABLE = 'TABLE',
  METRIC = 'METRIC',
}

export type CreateSimpleMetricPayload = BaseMetricPaylod & {
  measure: SimpleMeasure[];
  dimension: Dimension[];
  timeGrain: TimeGrain[];
};

export type CreateCumulativeMetricPayload = BaseMetricPaylod & {
  measure: CumulativeMeasure[];
  window: Window;
};

interface BaseMetricPaylod {
  name: string;
  displayName: string;
  description: string;
  cached: boolean;
  refreshTime?: string;
  model: string;
  modelType: ModelType;
  properties: Properties;
}

interface SimpleMeasure {
  name: string;
  type: string;
  isCalculated: boolean;
  notNull: boolean;
  properties: Properties;
}

interface CumulativeMeasure {
  name: string;
  type: string;
  operator: string;
  refColumn: string;
  properties: Properties;
}

interface Dimension {
  name: string;
  type: string;
  isCalculated: boolean;
  notNull: boolean;
  properties: Properties;
}

interface TimeGrain {
  name: string;
  refColumn: string;
  dateParts: string[];
}

interface Window {
  name: string;
  refColumn: string;
  timeUnit: string;
  start: string;
  end: string;
  properties: Properties;
}

export interface Properties {}
</file>

<file path="src/apollo/server/types/relationship.ts">
export interface RelationData {
  fromModelId: number;
  fromColumnId: number;
  toModelId: number;
  toColumnId: number;
  type: RelationType;
  description?: string;
}

export interface UpdateRelationData {
  type: RelationType;
}

export interface AnalysisRelationInfo {
  name: string;
  fromModelId: number;
  fromModelReferenceName: string;
  fromColumnId: number;
  fromColumnReferenceName: string;
  toModelId: number;
  toModelReferenceName: string;
  toColumnId: number;
  toColumnReferenceName: string;
  type: RelationType;
}

export enum RelationType {
  ONE_TO_ONE = 'ONE_TO_ONE',
  ONE_TO_MANY = 'ONE_TO_MANY',
  MANY_TO_ONE = 'MANY_TO_ONE',
}
</file>

<file path="src/apollo/server/utils/apiUtils.ts">
import { NextApiResponse } from 'next';
import { v4 as uuidv4 } from 'uuid';
import { ApiType } from '@server/repositories/apiHistoryRepository';
import * as Errors from '@server/utils/error';
import { components } from '@/common';

const { apiHistoryRepository } = components;

/**
 * Common error class for API endpoints
 */
export class ApiError extends Error {
  statusCode: number;
  code?: Errors.GeneralErrorCodes;
  additionalData?: Record<string, any>;

  constructor(
    message: string,
    statusCode: number,
    code?: Errors.GeneralErrorCodes,
    additionalData?: Record<string, any>,
  ) {
    super(message);
    this.statusCode = statusCode;
    this.code = code;
    this.additionalData = additionalData;
  }
}

/**
 * Common response handler for API endpoints that also logs to API history
 */
export const respondWith = async ({
  res,
  statusCode,
  responsePayload,
  projectId,
  apiType,
  threadId,
  headers,
  requestPayload,
  startTime,
}: {
  res: NextApiResponse;
  statusCode: number;
  responsePayload: any;
  projectId: number;
  apiType: ApiType;
  startTime: number;
  requestPayload?: Record<string, any>;
  threadId?: string;
  headers?: Record<string, string>;
}) => {
  const durationMs = startTime ? Date.now() - startTime : undefined;
  const responseId = uuidv4();
  await apiHistoryRepository.createOne({
    id: responseId,
    projectId,
    apiType,
    threadId,
    headers,
    requestPayload,
    responsePayload,
    statusCode,
    durationMs,
  });

  return res.status(statusCode).json({
    id: responseId,
    ...responsePayload,
  });
};

/**
 * Common error handler for API endpoints
 */
export const handleApiError = async ({
  error,
  res,
  projectId,
  apiType,
  requestPayload,
  threadId,
  headers,
  startTime,
  logger,
}: {
  error: any;
  res: NextApiResponse;
  projectId?: number;
  apiType: ApiType;
  requestPayload?: Record<string, any>;
  threadId?: string;
  headers?: Record<string, string>;
  startTime: number;
  logger?: any;
}) => {
  if (logger) {
    logger.error(`Error in ${apiType} API:`, error);
  }

  const statusCode = error instanceof ApiError ? error.statusCode : 500;
  let responsePayload: Record<string, any>;

  if (error instanceof ApiError && error.code) {
    responsePayload = {
      code: error.code,
      error: error.message,
    };

    // Include any additional data associated with the error
    if (error.additionalData) {
      Object.assign(responsePayload, error.additionalData);
    }
  } else {
    responsePayload = { error: error.message };
  }

  await respondWith({
    res,
    statusCode,
    responsePayload,
    projectId: projectId || 0,
    apiType,
    startTime,
    requestPayload,
    threadId,
    headers,
  });
};
</file>

<file path="src/apollo/server/utils/dataUtils.ts">
import { ColumnMetadata } from '@server/services/queryService';

/**
 * Transform raw data (columns + rows) into an array of objects
 * @param columns Column metadata (name, type)
 * @param rows Raw data rows
 * @returns Array of objects with column names as keys
 */
export const transformToObjects = (
  columns: ColumnMetadata[],
  rows: any[][],
): Record<string, any>[] => {
  if (!rows || !columns || rows.length === 0 || columns.length === 0) {
    return [];
  }

  // throw an error if the number of columns in the rows does not match the number of columns in the columns array
  if (rows[0].length !== columns.length) {
    throw new Error(
      'Number of columns in the rows does not match the number of columns in the columns array',
    );
  }

  return rows.map((row) => {
    const obj: Record<string, any> = {};
    columns.forEach((col, index) => {
      obj[col.name] = row[index];
    });
    return obj;
  });
};
</file>

<file path="src/apollo/server/utils/docker.ts">
export const toDockerHost = (host: string) => {
  // if host is localhost or 127.0.0.1, rewrite it to docker.for.{platform}.localhost
  if (host === 'localhost' || host === '127.0.0.1') {
    const platform = process.platform;
    switch (platform) {
      case 'darwin':
        return 'docker.for.mac.localhost';
      case 'linux':
        return 'docker.for.linux.localhost';
      default:
        // windows and others...
        return 'host.docker.internal';
    }
  }
  return host;
};
</file>

<file path="src/apollo/server/utils/encode.ts">
export function toBase64(str: string): string {
  return Buffer.from(str).toString('base64');
}
</file>

<file path="src/apollo/server/utils/encryptor.ts">
import crypto from 'crypto';

export interface encryptOptions {
  password: string;
  salt: string;
  iteration?: number;
  keyLength?: number;
  algorithm?: string;
  separator?: string;
}

export class Encryptor {
  private readonly ENCRYPTION_PASSWORD: string;
  private readonly ENCRYPTION_SALT: string;
  private ENCRYPTION_ITERATION = 1000;
  private ENCRYPTION_KEY_LENGTH = 256 / 8; // in bytes
  private ENCRYPTION_ALGORITHM = 'aes-256-cbc';
  private ENCRYPTION_SEPARATOR = ':';

  constructor({
    encryptionPassword,
    encryptionSalt,
  }: {
    encryptionPassword: string;
    encryptionSalt: string;
  }) {
    this.ENCRYPTION_PASSWORD = encryptionPassword;
    this.ENCRYPTION_SALT = encryptionSalt;
  }

  public encrypt(credentials: JSON) {
    const credentialsString = JSON.stringify(credentials);
    const key = this.createSecretKey();
    const iv = crypto.randomBytes(16); // AES block size
    const cipher = crypto.createCipheriv(this.ENCRYPTION_ALGORITHM, key, iv);
    const encrypted = Buffer.concat([
      cipher.update(credentialsString, 'utf8'),
      cipher.final(),
    ]);
    return (
      iv.toString('base64') +
      this.ENCRYPTION_SEPARATOR +
      encrypted.toString('base64')
    );
  }

  public decrypt(encryptedText: string) {
    const [ivBase64, encryptedBase64] = encryptedText.split(
      this.ENCRYPTION_SEPARATOR,
    );
    const iv = Buffer.from(ivBase64, 'base64');
    const encrypted = Buffer.from(encryptedBase64, 'base64');
    const key = this.createSecretKey();
    const decipher = crypto.createDecipheriv(
      this.ENCRYPTION_ALGORITHM,
      key,
      iv,
    );
    const decrypted = Buffer.concat([
      decipher.update(encrypted),
      decipher.final(),
    ]);
    return decrypted.toString('utf8');
  }

  private createSecretKey() {
    return crypto.pbkdf2Sync(
      this.ENCRYPTION_PASSWORD,
      this.ENCRYPTION_SALT,
      this.ENCRYPTION_ITERATION,
      this.ENCRYPTION_KEY_LENGTH,
      'sha512',
    );
  }
}
</file>

<file path="src/apollo/server/utils/error.ts">
import { GraphQLError } from 'graphql';
import { WrenService } from '../telemetry/telemetry';

export enum GeneralErrorCodes {
  INTERNAL_SERVER_ERROR = 'INTERNAL_SERVER_ERROR',
  // AI service errors
  NO_RELEVANT_DATA = 'NO_RELEVANT_DATA',
  NO_RELEVANT_SQL = 'NO_RELEVANT_SQL',
  RESOURCE_NOT_FOUND = 'RESOURCE_NOT_FOUND',
  MDL_PARSE_ERROR = 'MDL_PARSE_ERROR',
  NO_CHART = 'NO_CHART',

  // Exception error for AI service (e.g., network connection error)
  AI_SERVICE_UNDEFINED_ERROR = 'OTHERS',

  // IBIS Error
  IBIS_SERVER_ERROR = 'IBIS_SERVER_ERROR',

  // Connector errors
  CONNECTION_ERROR = 'CONNECTION_ERROR',
  // duckdb
  INIT_SQL_ERROR = 'INIT_SQL_ERROR',
  SESSION_PROPS_ERROR = 'SESSION_PROPS_ERROR',
  // postgres
  CONNECTION_REFUSED = 'CONNECTION_REFUSED',

  // calculated field validation
  DUPLICATED_FIELD_NAME = 'DUPLICATED_FIELD_NAME',
  INVALID_EXPRESSION = 'INVALID_EXPRESSION',
  INVALID_CALCULATED_FIELD = 'INVALID_CALCULATED_FIELD',

  // when createing views
  INVALID_VIEW_CREATION = 'INVALID_VIEW_CREATION',

  // dry run error
  DRY_RUN_ERROR = 'DRY_RUN_ERROR',
  DRY_PLAN_ERROR = 'DRY_PLAN_ERROR',

  // deploy sql pair error
  DEPLOY_SQL_PAIR_ERROR = 'DEPLOY_SQL_PAIR_ERROR',
  GENERATE_QUESTIONS_ERROR = 'GENERATE_QUESTIONS_ERROR',
  INVALID_SQL_ERROR = 'INVALID_SQL_ERROR',

  // wren engine error
  WREN_ENGINE_ERROR = 'WREN_ENGINE_ERROR',

  // asking task error
  // when rerun from cancelled, the task is identified as general or misleading query
  IDENTIED_AS_GENERAL = 'IDENTIED_AS_GENERAL',
  IDENTIED_AS_MISLEADING_QUERY = 'IDENTIED_AS_MISLEADING_QUERY',
  DEPLOY_TIMEOUT_ERROR = 'DEPLOY_TIMEOUT_ERROR',

  // api error
  NON_SQL_QUERY = 'NON_SQL_QUERY',
  NO_DEPLOYMENT_FOUND = 'NO_DEPLOYMENT_FOUND',

  // vega schema error
  FAILED_TO_GENERATE_VEGA_SCHEMA = 'FAILED_TO_GENERATE_VEGA_SCHEMA',
  POLLING_TIMEOUT = 'POLLING_TIMEOUT',
}

export const errorMessages = {
  [GeneralErrorCodes.INTERNAL_SERVER_ERROR]: 'Internal server error',

  // AI service errors
  [GeneralErrorCodes.NO_RELEVANT_DATA]:
    "I can't find the exact data you're looking for, but feel free to ask about other available topics.",
  [GeneralErrorCodes.NO_RELEVANT_SQL]:
    "Could you please provide more details or specify the information you're seeking?",
  [GeneralErrorCodes.NO_CHART]:
    "The chart couldn't be generated this time. Please try regenerating the chart or rephrasing your question for better results.",

  // Connector errors
  [GeneralErrorCodes.CONNECTION_ERROR]: 'Can not connect to data source',
  // duckdb
  [GeneralErrorCodes.INIT_SQL_ERROR]:
    'The initializing SQL seems to be invalid, Please check your SQL and try again.',
  [GeneralErrorCodes.SESSION_PROPS_ERROR]:
    'The session properties seem to be invalid, Please check your session properties and try again.',
  // postgres
  [GeneralErrorCodes.CONNECTION_REFUSED]:
    'Connection refused by the server, Please check your connection settings and try again.',

  // ibis service errors
  [GeneralErrorCodes.IBIS_SERVER_ERROR]:
    'Error occurred while querying ibis server, please try again later.',

  // calculated field validation
  [GeneralErrorCodes.DUPLICATED_FIELD_NAME]: 'This field name already exists',
  [GeneralErrorCodes.INVALID_EXPRESSION]:
    'Invalid expression, please check your expression and try again.',
  [GeneralErrorCodes.INVALID_CALCULATED_FIELD]:
    'Can not execute a query when using this calculated field',

  // when createing views
  [GeneralErrorCodes.INVALID_VIEW_CREATION]: 'Invalid view creation',

  // dry run error
  [GeneralErrorCodes.DRY_RUN_ERROR]: 'Dry run sql statement error',
  [GeneralErrorCodes.DRY_PLAN_ERROR]: 'Dry plan error',

  // deploy sql pair error
  [GeneralErrorCodes.DEPLOY_SQL_PAIR_ERROR]: 'Deploy sql pair error',
  [GeneralErrorCodes.GENERATE_QUESTIONS_ERROR]: 'Generate questions error',
  [GeneralErrorCodes.INVALID_SQL_ERROR]:
    'Invalid SQL, please check your SQL syntax',

  // asking task error
  [GeneralErrorCodes.IDENTIED_AS_GENERAL]:
    'The question is identified as a general question, please follow-up ask with more specific questions.',
  [GeneralErrorCodes.IDENTIED_AS_MISLEADING_QUERY]:
    'The question is identified as a misleading query, please follow-up ask with more specific questions.',
  [GeneralErrorCodes.DEPLOY_TIMEOUT_ERROR]:
    'LLM deployment timed out after 30 seconds',

  // api error
  [GeneralErrorCodes.NON_SQL_QUERY]: 'Cannot generate SQL from this question.',
  [GeneralErrorCodes.NO_DEPLOYMENT_FOUND]:
    'No deployment found, please deploy your project first',

  // vega schema error
  [GeneralErrorCodes.FAILED_TO_GENERATE_VEGA_SCHEMA]:
    'Failed to generate Vega spec',
  [GeneralErrorCodes.POLLING_TIMEOUT]: 'Polling timeout',
};

export const shortMessages = {
  [GeneralErrorCodes.INTERNAL_SERVER_ERROR]: 'Internal server error',
  [GeneralErrorCodes.NO_RELEVANT_DATA]: 'Try a different query',
  [GeneralErrorCodes.NO_RELEVANT_SQL]: 'Clarification needed',
  [GeneralErrorCodes.NO_CHART]: 'Chart not available',
  [GeneralErrorCodes.CONNECTION_ERROR]: 'Failed to connect',
  [GeneralErrorCodes.IBIS_SERVER_ERROR]: 'Data connection error',
  [GeneralErrorCodes.INIT_SQL_ERROR]: 'Invalid initializing SQL',
  [GeneralErrorCodes.SESSION_PROPS_ERROR]: 'Invalid session properties',
  [GeneralErrorCodes.CONNECTION_REFUSED]: 'Connection refused',
  [GeneralErrorCodes.DUPLICATED_FIELD_NAME]: 'Duplicated field name',
  [GeneralErrorCodes.INVALID_EXPRESSION]: 'Invalid expression',
  [GeneralErrorCodes.INVALID_CALCULATED_FIELD]: 'Invalid calculated field',
  [GeneralErrorCodes.INVALID_VIEW_CREATION]: 'Invalid view creation',
  [GeneralErrorCodes.DRY_RUN_ERROR]: 'Dry run sql statement error',
  [GeneralErrorCodes.DRY_PLAN_ERROR]: 'Dry plan error',
  [GeneralErrorCodes.DEPLOY_SQL_PAIR_ERROR]: 'Deploy sql pair error',
  [GeneralErrorCodes.GENERATE_QUESTIONS_ERROR]: 'Generate questions error',
  [GeneralErrorCodes.INVALID_SQL_ERROR]:
    'Invalid SQL, please check your SQL syntax',
  [GeneralErrorCodes.IDENTIED_AS_GENERAL]: 'Identified as general question',
  [GeneralErrorCodes.IDENTIED_AS_MISLEADING_QUERY]:
    'Identified as misleading query',
  [GeneralErrorCodes.DEPLOY_TIMEOUT_ERROR]: 'LLM deployment timed out',
  [GeneralErrorCodes.NON_SQL_QUERY]: 'Cannot generate SQL from this question.',
  [GeneralErrorCodes.NO_DEPLOYMENT_FOUND]:
    'No deployment found, please deploy your project first',
  [GeneralErrorCodes.FAILED_TO_GENERATE_VEGA_SCHEMA]:
    'Failed to generate Vega spec',
  [GeneralErrorCodes.POLLING_TIMEOUT]: 'Polling timeout',
};

export const create = (
  code?: GeneralErrorCodes,
  options?: {
    customMessage?: string;
    originalError?: Error;
    service?: WrenService;
    other?: any;
  },
): GraphQLError => {
  const { customMessage, originalError, service } = options || {};
  // Default to INTERNAL_SERVER_ERROR if no code is provided
  code = code || GeneralErrorCodes.INTERNAL_SERVER_ERROR;

  // Get the error message based on the code
  const message =
    customMessage ||
    originalError?.message ||
    errorMessages[code] ||
    errorMessages[GeneralErrorCodes.INTERNAL_SERVER_ERROR];

  // Return the GraphQLError
  const err = new GraphQLError(message, {
    extensions: {
      originalError,
      code,
      message,
      service,
      shortMessage:
        shortMessages[code] ||
        shortMessages[GeneralErrorCodes.INTERNAL_SERVER_ERROR],
      other: options?.other,
    },
  });

  return err;
};

/**
 * Default error handler for Apollo Server
 * For error like this:
 * [GraphQLError: connect ECONNREFUSED 127.0.0.1:8080] {
 *   locations: [ { line: 2, column: 3 } ],
 *   path: [ 'previewData' ],
 *   extensions: {
 *     code: 'INTERNAL_SERVER_ERROR',
 *     exception: {
 *       port: 8080,
 *       address: '127.0.0.1',
 *       syscall: 'connect',
 *       code: 'ECONNREFUSED',
 *       errno: -61,
 *       message: 'connect ECONNREFUSED 127.0.0.1:8080',
 *       stack: 'Error: connect ECONNREFUSED 127.0.0.1:8080\n' +
 *         '    at TCPConnectWrap.afterConnect [as oncomplete] (node:net:1278:16)',
 *       name: 'Error',
 *       config: [Object],
 *       request: [Writable],
 *       stacktrace: [Array]
 *     }
 *   }
 * }
 * it will easily cause `Converting circular structure to JSON` error.
 * Thus, we only pick required fields to reformat the error.
 */
export const defaultApolloErrorHandler = (error: GraphQLError) => {
  if (error instanceof GraphQLError) {
    const code = (error.extensions?.code ||
      GeneralErrorCodes.INTERNAL_SERVER_ERROR) as GeneralErrorCodes;
    return {
      locations: error.locations,
      path: error.path,
      message: error.message,
      extensions: {
        code,
        message: error.message,
        shortMessage: shortMessages[code],
        stacktrace: error.extensions?.exception?.stacktrace,
      },
    };
  }

  // Return the original error if it's not a GraphQLError
  return error;
};
</file>

<file path="src/apollo/server/utils/helper.ts">
/**
 * @function
 * @description Retrieve json without error
 */
export const safeParseJson = (data) => {
  try {
    return JSON.parse(data);
  } catch (_e) {
    return false;
  }
};

export const safeStringify = (data) => {
  if (typeof data === 'string') {
    return data;
  }
  try {
    return JSON.stringify(data);
  } catch (_e) {
    return data;
  }
};

export const convertColumnType = (parent: { type: string }) => {
  return parent.type.includes('STRUCT') ? 'RECORD' : parent.type;
};
</file>

<file path="src/apollo/server/utils/index.ts">
export * from './logger';
export * from './encryptor';
export * from './encode';
export * from './string';
export * from './docker';
export * from './model';
export * from './helper';
export * from './regex';
</file>

<file path="src/apollo/server/utils/knex.ts">
interface KnexOptions {
  dbType: string;
  pgUrl?: string;
  debug?: boolean;
  sqliteFile?: string;
}

export const bootstrapKnex = (options: KnexOptions) => {
  if (options.dbType === 'pg') {
    const { pgUrl, debug } = options;
    console.log('using pg');
    /* eslint-disable @typescript-eslint/no-var-requires */
    return require('knex')({
      client: 'pg',
      connection: pgUrl,
      debug,
      pool: { min: 2, max: 10 },
    });
  } else {
    console.log('using sqlite');
    /* eslint-disable @typescript-eslint/no-var-requires */
    return require('knex')({
      client: 'better-sqlite3',
      connection: {
        filename: options.sqliteFile,
      },
      useNullAsDefault: true,
    });
  }
};
</file>

<file path="src/apollo/server/utils/logger.ts">
export { getLogger } from 'log4js';
</file>

<file path="src/apollo/server/utils/model.ts">
import {
  IModelColumnRepository,
  ModelColumn,
  ModelNestedColumn,
} from '@server/repositories';
import { replaceAllowableSyntax } from './regex';
import { CompactColumn } from '@server/services/metadataService';

export function getPreviewColumnsStr(modelColumns: ModelColumn[]) {
  if (modelColumns.length === 0) return '*';
  const columns = modelColumns.map((column) => `"${column.referenceName}"`);
  return columns.join(',');
}

export function transformInvalidColumnName(columnName: string) {
  let referenceName = replaceAllowableSyntax(columnName);
  // If the reference name does not start with a letter, add a prefix
  const startWithLetterRegex = /^[A-Za-z]/;
  if (!startWithLetterRegex.test(referenceName)) {
    referenceName = `col_${referenceName}`;
  }
  return referenceName;
}

export function replaceInvalidReferenceName(referenceName: string) {
  // replace dot with underscore
  return referenceName.replace(/\./g, '_');
}

export function findColumnsToUpdate(
  columns: string[],
  existingColumns: ModelColumn[],
  sourceTableColumns: CompactColumn[],
): {
  toDeleteColumnIds: number[];
  toCreateColumns: string[];
  toUpdateColumns: Array<{
    id: number;
    sourceColumnName: string;
    type: string;
  }>;
} {
  const toDeleteColumnIds = existingColumns
    .map(({ id, sourceColumnName }) => {
      const shouldKeep = columns.includes(sourceColumnName);
      return shouldKeep ? undefined : id;
    })
    .filter((id) => id);
  const existColumnNames = existingColumns.map(
    ({ sourceColumnName }) => sourceColumnName,
  );
  const toCreateColumns = columns.filter(
    (columnName) => !existColumnNames.includes(columnName),
  );

  const toUpdateColumns = sourceTableColumns.reduce((acc, sourceColumn) => {
    const existingColumn = existingColumns.find(
      (col) => col.sourceColumnName === sourceColumn.name,
    );
    if (!existingColumn) return acc;

    const columnName = columns.find((col) => col === sourceColumn.name);
    if (!columnName) return acc;

    if (sourceColumn.type === existingColumn.type) return acc;

    return [
      ...acc,
      {
        id: existingColumn.id,
        sourceColumnName: sourceColumn.name,
        type: sourceColumn.type || 'string',
      },
    ];
  }, []);

  return {
    toDeleteColumnIds,
    toCreateColumns,
    toUpdateColumns,
  };
}

export async function updateModelPrimaryKey(
  repository: IModelColumnRepository,
  modelId: number,
  primaryKey: string,
) {
  await repository.resetModelPrimaryKey(modelId);
  if (primaryKey) {
    await repository.setModelPrimaryKey(modelId, primaryKey);
  }
}

export function handleNestedColumns(
  column: CompactColumn,
  parent: {
    modelId: number;
    columnId: number;
    sourceColumnName: string;
    columnPath?: string[];
  },
): Partial<ModelNestedColumn>[] {
  if (!column.nestedColumns) return [];

  const nestedColumnValues = [];
  for (const nestedColumn of column.nestedColumns) {
    const parentColumnPath = (parent as Partial<ModelNestedColumn>)
      .columnPath || [parent.sourceColumnName];
    const name = nestedColumn.name.split(`${parent.sourceColumnName}.`)[1];
    const columnPath = [...parentColumnPath, name];
    const nestedColumnValue = {
      modelId: parent.modelId,
      columnId: parent.columnId,
      columnPath,
      displayName: nestedColumn.name,
      sourceColumnName: nestedColumn.name,
      referenceName: columnPath.map(transformInvalidColumnName).join('.'),
      type: nestedColumn.type || 'string',
      properties: nestedColumn.properties,
    } as Partial<ModelNestedColumn>;
    nestedColumnValues.push(nestedColumnValue);
    nestedColumnValues.push(
      ...handleNestedColumns(nestedColumn, {
        modelId: parent.modelId,
        columnId: parent.columnId,
        sourceColumnName: nestedColumn.name,
        columnPath,
      }),
    );
  }
  return nestedColumnValues;
}
</file>

<file path="src/apollo/server/utils/regex.ts">
export interface ValidationResult {
  valid: boolean;
  message: string | null;
}

export function validateDisplayName(displayName: string): ValidationResult {
  let message = null;
  let valid = true;

  const allowableSyntaxRegex = /^[A-Za-z0-9 !@#$%^&*()_+{}[\],.'"-]*$/;
  const syntaxValid = allowableSyntaxRegex.test(displayName);
  if (!syntaxValid) {
    valid = false;
    message =
      'Only space & [  a-z, A-Z, 0-9, _, -, !@#$%^&*()-+{}[]\'".,  ] are allowed.';
  }
  const startWithLetterRegex = /^[A-Za-z]/;
  const startWithLetterValid = startWithLetterRegex.test(displayName);
  if (!startWithLetterValid) {
    valid = false;
    message = 'Must start with a letter.';
  }

  return {
    valid,
    message,
  };
}

export function replaceAllowableSyntax(str: string) {
  const replacedStr = str.replace(/[!@#$%^&*()+{}[\]'",. -]/g, '_');
  return replacedStr;
}
</file>

<file path="src/apollo/server/utils/string.ts">
export const trim = (str: string) => str.replace(/^\s+|\s+$/g, '');
</file>

<file path="src/apollo/server/utils/tests/dataSource.test.ts">
import { encryptConnectionInfo } from '../../dataSource';
import { DataSourceName } from '../../types';
import {
  BIG_QUERY_CONNECTION_INFO,
  DUCKDB_CONNECTION_INFO,
  MYSQL_CONNECTION_INFO,
  POSTGRES_CONNECTION_INFO,
} from '../../repositories';
import { Encryptor } from '@server/utils/encryptor';

jest.mock('@server/utils/encryptor');

const mockedEncryptor = Encryptor as jest.MockedClass<typeof Encryptor>;

describe('Encryptor', () => {
  beforeEach(() => {
    mockedEncryptor.prototype.decrypt.mockReturnValue('decrypted string');
    mockedEncryptor.prototype.encrypt.mockReturnValue('encrypted string');
  });

  it('should encrypt sensitive connection info for BigQuery connection info', async () => {
    const connectionInfo = {
      credentials: 'some-credentials',
      datasetId: 'my-bq-dataset-id',
      projectId: 'my-bq-project-id',
    } as BIG_QUERY_CONNECTION_INFO;

    const encryptedConnectionInfo = await encryptConnectionInfo(
      DataSourceName.BIG_QUERY,
      connectionInfo,
    );

    expect(encryptedConnectionInfo).toEqual({
      credentials: 'encrypted string',
      datasetId: 'my-bq-dataset-id',
      projectId: 'my-bq-project-id',
    });
  });

  it('should encrypt sensitive connection info for Postgres connection info', async () => {
    const connectionInfo = {
      host: 'localhost',
      port: 5432,
      database: 'my-database',
      user: 'my-user',
      password: 'my-password',
      ssl: false,
    } as POSTGRES_CONNECTION_INFO;

    const encryptedConnectionInfo = await encryptConnectionInfo(
      DataSourceName.POSTGRES,
      connectionInfo,
    );

    expect(encryptedConnectionInfo).toEqual({
      host: 'localhost',
      port: 5432,
      database: 'my-database',
      user: 'my-user',
      password: 'encrypted string',
      ssl: false,
    });
  });

  it('should encrypt sensitive connection info for MySQL connection info', async () => {
    const connectionInfo = {
      host: 'localhost',
      port: 5432,
      database: 'my-database',
      user: 'my-user',
      password: 'my-password',
    } as MYSQL_CONNECTION_INFO;

    const encryptedConnectionInfo = await encryptConnectionInfo(
      DataSourceName.MYSQL,
      connectionInfo,
    );

    expect(encryptedConnectionInfo).toEqual({
      host: 'localhost',
      port: 5432,
      database: 'my-database',
      user: 'my-user',
      password: 'encrypted string',
    });
  });

  it('should encrypt sensitive connection info for DuckDB connection info', async () => {
    const connectionInfo = {
      initSql: 'some-sql',
      extensions: ['extension1', 'extension2'],
      configurations: { key: 'value' },
    } as DUCKDB_CONNECTION_INFO;

    const encryptedConnectionInfo = await encryptConnectionInfo(
      DataSourceName.DUCKDB,
      connectionInfo,
    );

    expect(encryptedConnectionInfo).toEqual({
      initSql: 'some-sql',
      extensions: ['extension1', 'extension2'],
      configurations: { key: 'value' },
    });
  });
});
</file>

<file path="src/apollo/server/utils/tests/encryptor.test.ts">
import { Encryptor } from '../encryptor';
import crypto from 'crypto';

jest.mock('crypto', () => ({
  randomBytes: jest.fn(),
  createCipheriv: jest.fn(),
  createDecipheriv: jest.fn(),
  pbkdf2Sync: jest.fn(),
}));

const credentials = { username: 'user', password: 'pass' };

describe('Encryptor', () => {
  const mockConfig = {
    encryptionPassword: 'testPassword',
    encryptionSalt: 'testSalt',
  };

  let encryptor: Encryptor;
  beforeEach(() => {
    encryptor = new Encryptor(mockConfig);
  });

  it('should encrypt data correctly', async () => {
    // Arrange
    const testData = JSON.parse(JSON.stringify(credentials));
    const mockIV = Buffer.from('mockIV');
    (crypto.randomBytes as jest.Mock).mockReturnValue(mockIV);
    const mockCipher = {
      update: jest.fn().mockReturnValue(Buffer.from('ciphered')),
      final: jest.fn().mockReturnValue(Buffer.from('finalCiphered')),
    };
    (crypto.createCipheriv as jest.Mock).mockReturnValue(mockCipher);

    // Act
    const encryptedData = await encryptor.encrypt(testData);

    // Assert
    expect(encryptedData).toContain(Buffer.from('mockIV').toString('base64')); // Basic check, more sophisticated assertions can be made
    expect(encryptedData).toContain(':'); // contain seperator
    expect(encryptedData).toContain(
      Buffer.concat([
        Buffer.from('ciphered'),
        Buffer.from('finalCiphered'),
      ]).toString('base64'),
    ); // contain ciphered data
    expect(crypto.createCipheriv).toHaveBeenCalled();
  });

  it('should decrypt data correctly', async () => {
    // Setup
    const encryptedData = 'mockIV:encryptedData';
    const mockDecrypted = Buffer.from(JSON.stringify(credentials));
    const mockDecipher = {
      update: jest.fn().mockReturnValue(mockDecrypted),
      final: jest.fn().mockReturnValue(Buffer.from('')),
    };
    (crypto.createDecipheriv as jest.Mock).mockReturnValue(mockDecipher);

    // Act
    const decryptedData = await encryptor.decrypt(encryptedData);

    // Assert
    expect(decryptedData).toEqual(JSON.stringify(credentials));
    expect(crypto.createDecipheriv).toHaveBeenCalled();
  });

  it('should return original data after encrypt and decrypt', async () => {
    // Setup
    const testData = JSON.parse('{"username":"user","password":"pass"}');
    const mockIV = Buffer.from('mockIV');
    (crypto.randomBytes as jest.Mock).mockReturnValue(mockIV);
    const mockCipher = {
      update: jest.fn().mockReturnValue(Buffer.from('ciphered')),
      final: jest.fn().mockReturnValue(Buffer.from('finalCiphered')),
    };
    (crypto.createCipheriv as jest.Mock).mockReturnValue(mockCipher);

    const mockDecipher = {
      update: jest.fn().mockReturnValue(Buffer.from(JSON.stringify(testData))),
      final: jest.fn().mockReturnValue(Buffer.from('')),
    };
    (crypto.createDecipheriv as jest.Mock).mockReturnValue(mockDecipher);

    // Act
    const encryptedData = await encryptor.encrypt(testData);
    const decryptedData = await encryptor.decrypt(encryptedData);

    // Assert
    expect(JSON.parse(decryptedData)).toEqual(testData);
  });
});
</file>

<file path="src/apollo/server/utils/tests/regex.test.ts">
import { validateDisplayName, replaceAllowableSyntax } from '../regex';

describe('validateDisplayName', () => {
  it('should return valid when displayName contains only allowable syntax and start with a letter', () => {
    // Arrange
    const displayName = 'Valid Display Name !@#$%^&*()_+{}[].,"\'';

    // Act
    const result = validateDisplayName(displayName);

    // Assert
    expect(result.valid).toBe(true);
    expect(result.message).toBeNull();
  });

  it.each([['~'], ['<'], ['\\'], ['>'], ['?']])(
    'should return invalid when displayName contains invalid syntax: %s',
    ([invalidSyntax]) => {
      // Arrange
      const displayName = `Invalid Display Name ${invalidSyntax}`;

      // Act
      const result = validateDisplayName(displayName);

      // Assert
      expect(result.valid).toBe(false);
      expect(result.message).toBe(
        'Only space & [  a-z, A-Z, 0-9, _, -, !@#$%^&*()-+{}[]\'".,  ] are allowed.',
      );
    },
  );
  it.each([['@'], ['1'], [' ']])(
    'should return invalid when displayName does not start with a letter',
    ([invalidSyntax]) => {
      // Arrange
      const displayName = `${invalidSyntax}Display Name`;

      // Act
      const result = validateDisplayName(displayName);

      // Assert
      expect(result.valid).toBe(false);
      expect(result.message).toBe('Must start with a letter.');
    },
  );
});

describe('replaceAllowableSyntax', () => {
  it('should replace allowable syntax characters with underscores', () => {
    // Arrange
    const str = 'Replace   !@#$%^&*() -+{}[],\'".';

    // Act
    const result = replaceAllowableSyntax(str);

    // Assert
    expect(result).toBe('Replace________________________');
    expect(result.length).toBe(str.length);
  });
});
</file>

<file path="src/apollo/server/utils/timezone.ts">
export function getUTCOffsetMinutes(timeZone: string) {
  const date = new Date();
  const utcDate = new Date(
    date.toLocaleString('en-US', { timeZone: 'UTC' }),
  ) as any;
  const tzDate = new Date(date.toLocaleString('en-US', { timeZone })) as any;

  return (tzDate - utcDate) / 60000; // Convert to minutes
}

export function formatUTCOffset(offsetMinutes: number) {
  const sign = offsetMinutes >= 0 ? '+' : '-';
  const absOffset = Math.abs(offsetMinutes);
  const hours = Math.floor(absOffset / 60)
    .toString()
    .padStart(2, '0');
  const minutes = (absOffset % 60).toString().padStart(2, '0');
  return `UTC${sign}${hours}:${minutes}`;
}
</file>

<file path="src/common.ts">
import { getConfig } from '@server/config';
import { bootstrapKnex } from './apollo/server/utils/knex';
import {
  ProjectRepository,
  ViewRepository,
  DeployLogRepository,
  ThreadRepository,
  ThreadResponseRepository,
  ModelRepository,
  ModelColumnRepository,
  RelationRepository,
  SchemaChangeRepository,
  ModelNestedColumnRepository,
  LearningRepository,
  DashboardItemRepository,
  DashboardRepository,
  SqlPairRepository,
  AskingTaskRepository,
  InstructionRepository,
  ApiHistoryRepository,
  DashboardItemRefreshJobRepository,
} from '@server/repositories';
import {
  WrenEngineAdaptor,
  WrenAIAdaptor,
  IbisAdaptor,
} from '@server/adaptors';
import {
  DataSourceMetadataService,
  QueryService,
  ProjectService,
  DeployService,
  AskingService,
  MDLService,
  DashboardService,
  AskingTaskTracker,
  InstructionService,
} from '@server/services';
import { PostHogTelemetry } from './apollo/server/telemetry/telemetry';
import {
  ProjectRecommendQuestionBackgroundTracker,
  ThreadRecommendQuestionBackgroundTracker,
  DashboardCacheBackgroundTracker,
} from './apollo/server/backgrounds';
import { SqlPairService } from './apollo/server/services/sqlPairService';

export const serverConfig = getConfig();

export const initComponents = () => {
  const telemetry = new PostHogTelemetry();
  const knex = bootstrapKnex({
    dbType: serverConfig.dbType,
    pgUrl: serverConfig.pgUrl,
    debug: serverConfig.debug,
    sqliteFile: serverConfig.sqliteFile,
  });

  // repositories
  const projectRepository = new ProjectRepository(knex);
  const deployLogRepository = new DeployLogRepository(knex);
  const threadRepository = new ThreadRepository(knex);
  const threadResponseRepository = new ThreadResponseRepository(knex);
  const viewRepository = new ViewRepository(knex);
  const modelRepository = new ModelRepository(knex);
  const modelColumnRepository = new ModelColumnRepository(knex);
  const modelNestedColumnRepository = new ModelNestedColumnRepository(knex);
  const relationRepository = new RelationRepository(knex);
  const schemaChangeRepository = new SchemaChangeRepository(knex);
  const learningRepository = new LearningRepository(knex);
  const dashboardRepository = new DashboardRepository(knex);
  const dashboardItemRepository = new DashboardItemRepository(knex);
  const sqlPairRepository = new SqlPairRepository(knex);
  const askingTaskRepository = new AskingTaskRepository(knex);
  const instructionRepository = new InstructionRepository(knex);
  const apiHistoryRepository = new ApiHistoryRepository(knex);
  const dashboardItemRefreshJobRepository =
    new DashboardItemRefreshJobRepository(knex);

  // adaptors
  const wrenEngineAdaptor = new WrenEngineAdaptor({
    wrenEngineEndpoint: serverConfig.wrenEngineEndpoint,
  });
  const wrenAIAdaptor = new WrenAIAdaptor({
    wrenAIBaseEndpoint: serverConfig.wrenAIEndpoint,
  });
  const ibisAdaptor = new IbisAdaptor({
    ibisServerEndpoint: serverConfig.ibisServerEndpoint,
  });

  // services
  const metadataService = new DataSourceMetadataService({
    ibisAdaptor,
    wrenEngineAdaptor,
  });
  const queryService = new QueryService({
    ibisAdaptor,
    wrenEngineAdaptor,
    telemetry,
  });
  const deployService = new DeployService({
    wrenAIAdaptor,
    deployLogRepository,
    telemetry,
  });
  const mdlService = new MDLService({
    projectRepository,
    modelRepository,
    modelColumnRepository,
    modelNestedColumnRepository,
    relationRepository,
    viewRepository,
  });
  const projectService = new ProjectService({
    projectRepository,
    metadataService,
    mdlService,
    wrenAIAdaptor,
    telemetry,
  });
  const askingTaskTracker = new AskingTaskTracker({
    wrenAIAdaptor,
    askingTaskRepository,
    threadResponseRepository,
    viewRepository,
  });
  const askingService = new AskingService({
    telemetry,
    wrenAIAdaptor,
    deployService,
    projectService,
    viewRepository,
    threadRepository,
    threadResponseRepository,
    queryService,
    mdlService,
    askingTaskTracker,
    askingTaskRepository,
  });
  const dashboardService = new DashboardService({
    projectService,
    dashboardItemRepository,
    dashboardRepository,
  });
  const sqlPairService = new SqlPairService({
    sqlPairRepository,
    wrenAIAdaptor,
    ibisAdaptor,
  });
  const instructionService = new InstructionService({
    instructionRepository,
    wrenAIAdaptor,
  });

  // background trackers
  const projectRecommendQuestionBackgroundTracker =
    new ProjectRecommendQuestionBackgroundTracker({
      telemetry,
      wrenAIAdaptor,
      projectRepository,
    });
  const threadRecommendQuestionBackgroundTracker =
    new ThreadRecommendQuestionBackgroundTracker({
      telemetry,
      wrenAIAdaptor,
      threadRepository,
    });
  const dashboardCacheBackgroundTracker = new DashboardCacheBackgroundTracker({
    dashboardRepository,
    dashboardItemRepository,
    dashboardItemRefreshJobRepository,
    projectService,
    deployService,
    queryService,
  });

  return {
    knex,
    telemetry,

    // repositories
    projectRepository,
    deployLogRepository,
    threadRepository,
    threadResponseRepository,
    viewRepository,
    modelRepository,
    modelColumnRepository,
    relationRepository,
    schemaChangeRepository,
    learningRepository,
    modelNestedColumnRepository,
    dashboardRepository,
    dashboardItemRepository,
    sqlPairRepository,
    askingTaskRepository,
    apiHistoryRepository,
    instructionRepository,
    dashboardItemRefreshJobRepository,

    // adaptors
    wrenEngineAdaptor,
    wrenAIAdaptor,
    ibisAdaptor,

    // services
    metadataService,
    projectService,
    queryService,
    deployService,
    askingService,
    mdlService,
    dashboardService,
    sqlPairService,
    instructionService,
    askingTaskTracker,

    // background trackers
    projectRecommendQuestionBackgroundTracker,
    threadRecommendQuestionBackgroundTracker,
    dashboardCacheBackgroundTracker,
  };
};

// singleton components
export const components = initComponents();
</file>

<file path="src/components/ActionButton.tsx">
import { Button } from 'antd';
import PlusSquareOutlined from '@ant-design/icons/PlusSquareOutlined';
import { MoreIcon } from '@/utils/icons';

interface Props {
  onClick?: (event: React.MouseEvent) => void;
  onMouseEnter?: (event: React.MouseEvent) => void;
  onMouseLeave?: (event: React.MouseEvent) => void;
  className?: string;
  marginLeft?: number;
  marginRight?: number;
}

const makeActionButton = (icon: React.ReactNode) => (props: Props) => {
  const {
    onClick,
    onMouseEnter,
    onMouseLeave,
    className,
    marginLeft,
    marginRight,
    ...restProps
  } = props;
  const click = (event) => {
    onClick && onClick(event);
    event.stopPropagation();
  };
  const mouseEnter = (event) => {
    onMouseEnter && onMouseEnter(event);
    event.stopPropagation();
  };
  const mouseLeave = (event) => {
    onMouseLeave && onMouseLeave(event);
    event.stopPropagation();
  };
  return (
    <Button
      className={className}
      style={{ marginLeft, marginRight }}
      icon={icon}
      onClick={click}
      onMouseEnter={mouseEnter}
      onMouseLeave={mouseLeave}
      type="text"
      size="small"
      {...restProps}
    />
  );
};

export const AddButton = makeActionButton(<PlusSquareOutlined />);
export const MoreButton = makeActionButton(<MoreIcon />);
</file>

<file path="src/components/chart/handler.ts">
import {
  ChartType,
  ThreadResponseChartDetail,
} from '@/apollo/client/graphql/__types__';
import { isNil, cloneDeep, uniq, sortBy, omit, isNumber } from 'lodash';
import { Config, TopLevelSpec } from 'vega-lite';

enum MarkType {
  ARC = 'arc',
  AREA = 'area',
  BAR = 'bar',
  BOXPLOT = 'boxplot',
  CIRCLE = 'circle',
  ERRORBAND = 'errorband',
  ERRORBAR = 'errorbar',
  IMAGE = 'image',
  LINE = 'line',
  POINT = 'point',
  RECT = 'rect',
  RULE = 'rule',
  SQUARE = 'square',
  TEXT = 'text',
  TICK = 'tick',
  TRAIL = 'trail',
}

const COLOR = {
  GRAY_10: '#262626',
  GRAY_9: '#434343',
  GRAY_8: '#65676c',
  GRAY_5: '#d9d9d9',
};

// Default color scheme
const colorScheme = [
  '#7763CF',
  '#444CE7',
  '#1570EF',
  '#0086C9',
  '#3E4784',
  '#E31B54',
  '#EC4A0A',
  '#EF8D0C',
  '#EBC405',
  '#5381AD',
];

// high contrast color scheme
const pickedColorScheme = [
  colorScheme[4],
  colorScheme[5],
  colorScheme[8],
  colorScheme[3],
  colorScheme[0],
];

const DEFAULT_COLOR = colorScheme[2];

// type EncodingFieldType = 'quantitative' | 'nominal' | 'temporal';
type DataSpec = { values: Record<string, any>[] };
type EncodingSpec = Extract<TopLevelSpec, { encoding?: any }>['encoding'] & {
  x: { type: string; field: string };
  y: { type: string; field: string };
};
type MarkSpec = Extract<TopLevelSpec, { mark?: any }>['mark'] extends
  | string
  | infer M
  ? M
  : never;
type AutosizeSpec = Extract<TopLevelSpec, { autosize?: any }>['autosize'];
type ParamsSpec = {
  name: string;
  select: {
    type: string;
    fields?: string[];
    on: string;
    clear: string;
  };
  value?: any;
}[];
type TransformSpec = Extract<TopLevelSpec, { transform?: any }>['transform'];

type ChartOptions = {
  width?: number | string;
  height?: number | string;
  stack?: 'zero' | 'normalize';
  point?: boolean;
  donutInner?: number | false;
  categoriesLimit?: number;
  isShowTopCategories?: boolean;
  isHideLegend?: boolean;
  isHideTitle?: boolean;
};

const config: Config = {
  mark: { tooltip: true },
  font: 'Roboto, Arial, Noto Sans, sans-serif',
  padding: {
    top: 30,
    bottom: 20,
    left: 0,
    right: 0,
  },
  title: {
    color: COLOR.GRAY_10,
    fontSize: 14,
  },
  axis: {
    labelPadding: 0,
    labelOffset: 0,
    labelFontSize: 10,
    gridColor: COLOR.GRAY_5,
    titleColor: COLOR.GRAY_9,
    labelColor: COLOR.GRAY_8,
    labelFont: ' Roboto, Arial, Noto Sans, sans-serif',
  },
  axisX: { labelAngle: -45 },
  line: {
    color: DEFAULT_COLOR,
  },
  bar: {
    color: DEFAULT_COLOR,
  },
  legend: {
    symbolLimit: 15,
    columns: 1,
    labelFontSize: 10,
    labelColor: COLOR.GRAY_8,
    titleColor: COLOR.GRAY_9,
    titleFontSize: 14,
  },
  range: {
    category: colorScheme,
    ordinal: colorScheme,
    diverging: colorScheme,
    symbol: colorScheme,
    heatmap: colorScheme,
    ramp: colorScheme,
  },
  point: { size: 60, color: DEFAULT_COLOR },
};

export default class ChartSpecHandler {
  public config: Config;
  public options: ChartOptions;
  public $schema: string;
  public title: string;
  public data: DataSpec;
  public encoding: EncodingSpec;
  public mark: MarkSpec;
  public autosize: AutosizeSpec;
  public params: ParamsSpec;
  public transform: TransformSpec;

  constructor(spec: TopLevelSpec, options?: ChartOptions) {
    this.config = config;
    this.data = spec.data as DataSpec;
    this.autosize = { type: 'fit', contains: 'padding' };
    this.params = [
      {
        name: 'hover',
        select: {
          type: 'point',
          on: 'mouseover',
          clear: 'mouseout',
        },
      },
    ];
    // default options
    this.options = {
      width: isNil(options?.width) ? 'container' : options.width,
      height: isNil(options?.height) ? 'container' : options.height,
      stack: isNil(options?.stack) ? 'zero' : options.stack,
      point: isNil(options?.point) ? true : options.point,
      donutInner: isNil(options?.donutInner) ? 60 : options.donutInner,
      categoriesLimit: isNil(options?.categoriesLimit)
        ? 25
        : options.categoriesLimit,
      isShowTopCategories: isNil(options?.isShowTopCategories)
        ? false
        : options?.isShowTopCategories,
      isHideLegend: isNil(options?.isHideLegend) ? false : options.isHideLegend,
      isHideTitle: isNil(options?.isHideTitle) ? false : options.isHideTitle,
    };

    // avoid mutating the original spec
    const clonedSpec = cloneDeep(spec);
    this.parseSpec(clonedSpec);
  }

  public getChartSpec() {
    const categories = this.getAllCategories(this.encoding);
    // chart not support if categories more than the categories limit
    if (categories.length > this.options.categoriesLimit) {
      return null;
    }

    // if categories less or equal 5, use the picked color
    if (categories.length <= 5) {
      // Set the contrast color range on the color encoding instead of x/xOffset
      this.encoding.color = {
        ...this.encoding.color,
        scale: {
          range: pickedColorScheme,
        },
      } as any;
    }

    if (this.options.isHideLegend) {
      this.encoding.color = {
        ...this.encoding.color,
        legend: null,
      } as any;
    }

    if (this.options.isHideTitle) {
      this.title = null;
    }

    // transform values
    this.data = this.transformDataValues(this.data, this.encoding);

    return {
      $schema: this.$schema,
      title: this.title,
      data: this.data,
      mark: this.mark,
      width: this.options.width,
      height: this.options.height,
      autosize: this.autosize,
      encoding: this.encoding,
      params: this.params,
      transform: this.transform,
    } as TopLevelSpec;
  }

  private parseSpec(spec: TopLevelSpec) {
    this.$schema = spec.$schema;
    this.title = spec.title as string;
    this.transform = spec.transform;

    if ('mark' in spec) {
      const mark =
        typeof spec.mark === 'string' ? { type: spec.mark } : spec.mark;
      this.addMark(mark);
    }

    if ('encoding' in spec) {
      // filter top categories before encoding scale calculation
      if (this.options?.isShowTopCategories) {
        const filteredData = this.filterTopCategories(
          spec.encoding as EncodingSpec,
        );
        if (filteredData) this.data = filteredData;
      }

      this.addEncoding(spec.encoding as EncodingSpec);
    }
  }

  private addMark(mark: MarkSpec) {
    let additionalProps = {};

    if (mark.type === MarkType.LINE) {
      additionalProps = { point: this.options.point, tooltip: true };
    } else if (mark.type === MarkType.ARC) {
      additionalProps = { innerRadius: this.options.donutInner };
    }
    this.mark = { type: mark.type, ...additionalProps };
  }

  private addEncoding(encoding: EncodingSpec) {
    this.encoding = encoding;

    // fill color by x field if AI not provide color(category) field
    if (isNil(this.encoding.color)) {
      // find the nominal axis
      const nominalAxis = ['x', 'y'].find(
        (axis) => encoding[axis]?.type === 'nominal',
      );
      if (nominalAxis) {
        const category = encoding[nominalAxis] as any;
        this.encoding.color = {
          field: category.field,
          type: category.type,
        };
      }
    }

    // handle scale on bar chart
    if (this.mark.type === MarkType.BAR) {
      if ('stack' in this.encoding.y) {
        this.encoding.y.stack = this.options.stack;
      }

      if ('xOffset' in this.encoding) {
        const xOffset = this.encoding.xOffset as any;
        let title = xOffset?.title;
        // find xOffset title if not provided
        if (!title) {
          title = this.findFieldTitleInEncoding(this.encoding, xOffset?.field);
        }
        this.encoding.xOffset = { ...xOffset, title };
      }
    }

    this.addHoverHighlight(this.encoding);
  }

  private addHoverHighlight(encoding: EncodingSpec) {
    const category = (
      encoding.color?.condition ? encoding.color.condition : encoding.color
    ) as { type: any; field: string; title?: string };
    if (!category?.field || !category?.type) return;

    // Define the hover parameter correctly
    if (this.params && category?.field) {
      this.params[0].select.fields = [category.field];
    }

    this.encoding.opacity = {
      condition: {
        param: 'hover',
        value: 1,
      },
      value: 0.3,
    };

    let title = category?.title;
    // find color title if not provided
    if (!title) {
      title = this.findFieldTitleInEncoding(this.encoding, category?.field);
    }

    // basic color properties
    const colorProperties = {
      title,
      field: category?.field,
      type: category?.type,
      scale: {
        range: colorScheme,
      },
    } as any;

    this.encoding.color = {
      ...colorProperties,
      condition: {
        param: 'hover',
        ...omit(colorProperties, 'scale'),
      } as any,
    };
  }

  private filterTopCategories(encoding: EncodingSpec) {
    const nominalKeys = ['xOffset', 'color', 'x', 'y'].filter(
      (axis) => encoding[axis]?.type === 'nominal',
    );
    const quantitativeKeys = ['theta', 'x', 'y'].filter(
      (axis) => encoding[axis]?.type === 'quantitative',
    );
    if (!nominalKeys.length || !quantitativeKeys.length) return;

    const clonedValues = cloneDeep((this.data as any).values);

    const quantitativeAxis = quantitativeKeys[0];
    const quanAxis = encoding[quantitativeAxis] as any;
    const sortedValues = sortBy(clonedValues, (val) => {
      const value = val[quanAxis.field];
      return isNumber(value) ? -value : 0;
    });

    // nominal values probably have different length, so we need to filter them
    const filteredNominals = [];
    for (const nominalKey of nominalKeys) {
      const nomiAxis = encoding[nominalKey] as any;
      if (filteredNominals.some((val) => val.field === nomiAxis.field)) {
        continue;
      }
      const nominalValues = sortedValues.map((val) => val[nomiAxis.field]);
      const uniqueNominalValues = uniq(nominalValues);
      const topNominalValues = uniqueNominalValues.slice(
        0,
        this.options.categoriesLimit,
      );
      filteredNominals.push({
        field: nomiAxis.field,
        values: topNominalValues,
      });
    }
    const values = clonedValues.filter((val) =>
      filteredNominals.every((nominal) =>
        nominal.values.includes(val[nominal.field]),
      ),
    );
    return { values };
  }

  private getAllCategories(encoding: EncodingSpec) {
    const nominalAxis = ['xOffset', 'color', 'x', 'y'].find(
      (axis) => encoding[axis]?.type === 'nominal',
    );
    if (!nominalAxis) return [];
    const axisKey = encoding[nominalAxis] as any;
    const values = (this.data as any).values;
    const categoryValues = values.map((val) => val[axisKey.field]);
    const uniqueCategoryValues = uniq(categoryValues);

    return uniqueCategoryValues;
  }

  private findFieldTitleInEncoding(encoding: EncodingSpec, field: string) {
    const axis = ['x', 'y', 'xOffset', 'color'].find(
      (axis) => encoding[axis]?.field === field && encoding[axis]?.title,
    ) as any;
    return encoding[axis]?.title || undefined;
  }

  private transformDataValues(
    data: DataSpec,
    encoding: {
      x?: { type?: string; field?: string };
      y?: { type?: string; field?: string };
    },
  ) {
    // If axis x is temporal
    if (encoding?.x?.type === 'temporal') {
      const transformedValues = data.values.map((val) => ({
        ...val,
        [encoding.x.field]: this.transformTemporalValue(val[encoding.x.field]),
      }));
      return { ...data, values: transformedValues };
    }
    // If axis y is temporal
    if (encoding?.y?.type === 'temporal') {
      const transformedValues = data.values.map((val) => ({
        ...val,
        [encoding.y.field]: this.transformTemporalValue(val[encoding.y.field]),
      }));
      return { ...data, values: transformedValues };
    }
    return data;
  }

  private transformTemporalValue(value: string | any) {
    if (value === null || value === undefined) {
      return value;
    }
    const strValue = typeof value === 'string' ? value : String(value);
    // Safari not support if containing "YYYY-MM-DD HH:mm:ss.SSS UTC+00:00"
    // so we remove the UTC+00:00 for compatibility
    if (strValue.includes('UTC')) {
      return strValue.replace(/\s+UTC([+-][0-9]+)?(:[0-9]+)?/, '');
    }
    return strValue;
  }
}

export const convertToChartType = (
  markType: string,
  encoding: EncodingSpec,
) => {
  if (markType === MarkType.BAR) {
    if (encoding?.xOffset) {
      return ChartType.GROUPED_BAR;
    } else if (
      !isNil((encoding?.y as any)?.stack) ||
      !isNil((encoding?.x as any)?.stack)
    ) {
      return ChartType.STACKED_BAR;
    }
  } else if (markType === MarkType.ARC) {
    return ChartType.PIE;
  }
  return markType ? (markType.toUpperCase() as ChartType) : null;
};

export const getChartSpecOptionValues = (
  chartDetail: ThreadResponseChartDetail,
) => {
  const spec = chartDetail?.chartSchema;
  let chartType: string | null = chartDetail?.chartType || null;
  let xAxis: string | null = null;
  let yAxis: string | null = null;
  let color: string | null = null;
  let xOffset: string | null = null;
  let theta: string | null = null;

  if (spec && 'encoding' in spec) {
    const encoding = spec.encoding as EncodingSpec;
    xAxis = (encoding?.x as any)?.field || null;
    yAxis = (encoding?.y as any)?.field || null;
    color = (encoding?.color as any)?.field || null;
    xOffset = (encoding?.xOffset as any)?.field || null;
    theta = (encoding?.theta as any)?.field || null;
    if (chartType === null) {
      chartType = convertToChartType(
        typeof spec.mark === 'string' ? spec.mark : spec.mark.type,
        encoding,
      );
    }
  }
  return {
    chartType,
    xAxis,
    yAxis,
    color,
    xOffset,
    theta,
  };
};

export const getChartSpecFieldTitleMap = (encoding: EncodingSpec) => {
  if (!encoding) return {};
  const allFields = ['x', 'y', 'xOffset', 'color'].reduce((result, key) => {
    const axis = encoding[key] as any;
    if (axis?.field && axis?.title) {
      result[axis?.field] = axis?.title;
    }
    return result;
  }, {});
  return allFields;
};
</file>

<file path="src/components/chart/index.tsx">
import { useEffect, useMemo, useRef, useState } from 'react';
import clsx from 'clsx';
import { isEmpty } from 'lodash';
import { Alert, Button, Tooltip } from 'antd';
import { TopLevelSpec, compile } from 'vega-lite';
import embed, { EmbedOptions, Result } from 'vega-embed';
import ChartSpecHandler from './handler';
import ReloadOutlined from '@ant-design/icons/ReloadOutlined';
import EditOutlined from '@ant-design/icons/EditOutlined';
import EyeOutlined from '@ant-design/icons/EyeOutlined';
import PushPinOutlined from '@ant-design/icons/PushpinOutlined';

const embedOptions: EmbedOptions = {
  mode: 'vega-lite',
  renderer: 'svg',
  tooltip: { theme: 'custom' },
  actions: {
    export: true,
    editor: false,
  },
};

interface VegaLiteProps {
  className?: string;
  width?: number | string;
  height?: number | string;
  spec?: TopLevelSpec;
  values?: Record<string, any>[];
  autoFilter?: boolean;
  hideActions?: boolean;
  hideTitle?: boolean;
  hideLegend?: boolean;
  forceUpdate?: number;
  onReload?: () => void;
  onEdit?: () => void;
  onPin?: () => void;
}

export default function Chart(props: VegaLiteProps) {
  const {
    className,
    spec,
    values,
    width = 600,
    height = 320,
    autoFilter,
    hideActions,
    hideTitle,
    hideLegend,
    forceUpdate,
    onReload,
    onEdit,
    onPin,
  } = props;

  const [donutInner, setDonutInner] = useState(null);
  const [isShowTopCategories, setIsShowTopCategories] = useState(false);
  const $view = useRef<Result>(null);
  const $container = useRef<HTMLDivElement>(null);
  const vegaSpec = useMemo(() => {
    if (!spec || !values) return;
    const specHandler = new ChartSpecHandler(
      {
        ...spec,
        data: { values },
      },
      {
        donutInner,
        isShowTopCategories: autoFilter || isShowTopCategories,
        isHideLegend: hideLegend,
        isHideTitle: hideTitle,
      },
    );
    const chartSpec = specHandler.getChartSpec();
    const isDataEmpty = isEmpty((chartSpec?.data as any)?.values);
    if (isDataEmpty) return null;
    return compile(chartSpec, {
      config: specHandler.config,
    }).spec;
  }, [spec, values, isShowTopCategories, donutInner, forceUpdate]);

  // initial vega view
  useEffect(() => {
    if ($container.current && vegaSpec) {
      embed($container.current, vegaSpec, embedOptions).then((view) => {
        $view.current = view;
      });
    }
    return () => {
      if ($view.current) $view.current.finalize();
    };
  }, [vegaSpec, forceUpdate]);

  useEffect(() => {
    if ($container.current) {
      setDonutInner($container.current.clientHeight * 0.15);
    }
  }, [forceUpdate]);

  const onShowTopCategories = () => {
    setIsShowTopCategories(!isShowTopCategories);
  };

  if (vegaSpec === null) {
    if (values.length === 0) return <div>No available data</div>;
    return (
      <Alert
        className="mt-6 mb-4 mx-4"
        message={
          <div className="d-flex align-center justify-space-between">
            <div>
              There are too many categories to display effectively. Click 'Show
              top 25' to view the top results, or ask a follow-up question to
              focus on a specific group or filter results.
            </div>
            <Button
              size="small"
              icon={<EyeOutlined />}
              onClick={onShowTopCategories}
            >
              Show top 25
            </Button>
          </div>
        }
        type="warning"
      />
    );
  }

  const isAdditionalShow = !!onReload || !!onEdit || !!onPin;

  return (
    <div
      className={clsx(
        'adm-chart',
        { 'adm-chart--no-actions': hideActions },
        className,
      )}
      style={{ width }}
    >
      {isAdditionalShow && (
        <div className="adm-chart-additional d-flex justify-content-between align-center">
          {!!onReload && (
            <Tooltip title="Regenerate chart">
              <button onClick={onReload}>
                <ReloadOutlined />
              </button>
            </Tooltip>
          )}
          {!!onEdit && (
            <Tooltip title="Edit chart">
              <button onClick={onEdit}>
                <EditOutlined />
              </button>
            </Tooltip>
          )}
          {!!onPin && (
            <Tooltip title="Pin chart to dashboard">
              <button onClick={onPin}>
                <PushPinOutlined />
              </button>
            </Tooltip>
          )}
        </div>
      )}
      <div style={{ width, height }} ref={$container} />
    </div>
  );
}
</file>

<file path="src/components/chart/properties/BasicProperties.tsx">
import { capitalize } from 'lodash';
import { Form, Row, Col, Select } from 'antd';
import { ChartType } from '@/apollo/client/graphql/__types__';

export const getChartTypeOptions = () => {
  return Object.entries(ChartType).map(([key, value]) => ({
    label: capitalize(value.replace('_', ' ')),
    value: key,
  }));
};

export const getColumnOptions = (
  columns: { name: string; type: string }[],
  titleMap?: Record<string, string>,
) => {
  return (columns || []).map((column) => ({
    label: titleMap?.[column.name] || column.name,
    value: column.name,
  }));
};

export function ChartTypeProperty(props: {
  options: { label: string; value: string }[];
}) {
  const { options } = props;
  return (
    <Form.Item className="mb-0" label="Chart type" name="chartType">
      <Select size="small" options={options} placeholder="Select chart type" />
    </Form.Item>
  );
}

export function AxisProperty(props: {
  options: { label: string; value: string }[];
}) {
  const { options } = props;
  return (
    <Row gutter={16}>
      <Col span={12}>
        <Form.Item className="mb-0" label="X-axis" name="xAxis">
          <Select size="small" options={options} placeholder="Select x-axis" />
        </Form.Item>
      </Col>
      <Col span={12}>
        <Form.Item className="mb-0" label="Y-axis" name="yAxis">
          <Select size="small" options={options} placeholder="Select y-axis" />
        </Form.Item>
      </Col>
    </Row>
  );
}

export interface PropertiesProps {
  columns: { name: string; type: string }[];
  titleMap: Record<string, string>;
  onChartTypeChange: (chartType: ChartType) => void;
}

export default function BasicProperties(props: PropertiesProps) {
  const { columns, titleMap } = props;
  const chartTypeOptions = getChartTypeOptions();
  const columnOptions = getColumnOptions(columns, titleMap);
  return (
    <>
      <Row className="mb-2" gutter={16}>
        <Col span={12}>
          <ChartTypeProperty options={chartTypeOptions} />
        </Col>
        <Col span={12}></Col>
      </Row>
      <AxisProperty options={columnOptions} />
    </>
  );
}
</file>

<file path="src/components/chart/properties/DonutProperties.tsx">
import { Form, Row, Col, Select } from 'antd';
import {
  PropertiesProps,
  getColumnOptions,
  getChartTypeOptions,
  ChartTypeProperty,
} from './BasicProperties';

export default function DonutProperties(props: PropertiesProps) {
  const { columns, titleMap } = props;
  const chartTypeOptions = getChartTypeOptions();
  const columnOptions = getColumnOptions(columns, titleMap);
  return (
    <>
      <Row gutter={16} className="mb-2">
        <Col span={12}>
          <ChartTypeProperty options={chartTypeOptions} />
        </Col>
        <Col span={12}>
          <Form.Item className="mb-0" label="Category" name="color">
            <Select
              size="small"
              options={columnOptions}
              placeholder="Select category"
            />
          </Form.Item>
        </Col>
      </Row>
      <Row gutter={16}>
        <Col span={12}>
          <Form.Item className="mb-0" label="Value" name="theta">
            <Select
              size="small"
              options={columnOptions}
              placeholder="Select value"
            />
          </Form.Item>
        </Col>
        <Col span={12}></Col>
      </Row>
    </>
  );
}
</file>

<file path="src/components/chart/properties/GroupedBarProperties.tsx">
import { Form, Row, Col, Select } from 'antd';
import {
  PropertiesProps,
  getChartTypeOptions,
  getColumnOptions,
  ChartTypeProperty,
  AxisProperty,
} from './BasicProperties';

export default function GroupedBarProperties(props: PropertiesProps) {
  const { columns, titleMap } = props;
  const chartTypeOptions = getChartTypeOptions();
  const columnOptions = getColumnOptions(columns, titleMap);
  return (
    <>
      <Row className="mb-2" gutter={16}>
        <Col span={12}>
          <ChartTypeProperty options={chartTypeOptions} />
        </Col>
        <Col span={12}>
          <Form.Item className="mb-0" label="Sub-category" name="xOffset">
            <Select
              size="small"
              options={columnOptions}
              placeholder="Select sub-category"
            />
          </Form.Item>
        </Col>
      </Row>
      <AxisProperty options={columnOptions} />
    </>
  );
}
</file>

<file path="src/components/chart/properties/LineProperties.tsx">
import { Form, Row, Col, Select } from 'antd';
import {
  PropertiesProps,
  getChartTypeOptions,
  getColumnOptions,
  ChartTypeProperty,
  AxisProperty,
} from './BasicProperties';

export default function LineProperties(props: PropertiesProps) {
  const { columns, titleMap } = props;
  const chartTypeOptions = getChartTypeOptions();
  const columnOptions = getColumnOptions(columns, titleMap);
  return (
    <>
      <Row className="mb-2" gutter={16}>
        <Col span={12}>
          <ChartTypeProperty options={chartTypeOptions} />
        </Col>
        <Col span={12}>
          <Form.Item className="mb-0" label="Line groups" name="color">
            <Select
              size="small"
              options={columnOptions}
              placeholder="Select line groups"
            />
          </Form.Item>
        </Col>
      </Row>
      <AxisProperty options={columnOptions} />
    </>
  );
}
</file>

<file path="src/components/chart/properties/StackedBarProperties.tsx">
import { Form, Row, Col, Select } from 'antd';
import {
  PropertiesProps,
  getChartTypeOptions,
  getColumnOptions,
  ChartTypeProperty,
  AxisProperty,
} from './BasicProperties';

export default function StackedBarProperties(props: PropertiesProps) {
  const { columns, titleMap } = props;
  const chartTypeOptions = getChartTypeOptions();
  const columnOptions = getColumnOptions(columns, titleMap);
  return (
    <>
      <Row className="mb-2" gutter={16}>
        <Col span={12}>
          <ChartTypeProperty options={chartTypeOptions} />
        </Col>
        <Col span={12}>
          <Form.Item className="mb-0" label="Stack groups" name="color">
            <Select
              size="small"
              options={columnOptions}
              placeholder="Select stack groups"
            />
          </Form.Item>
        </Col>
      </Row>
      <AxisProperty options={columnOptions} />
    </>
  );
}
</file>

<file path="src/components/code/BaseCodeBlock.tsx">
import { useEffect, useRef, useState } from 'react';
import styled from 'styled-components';
import { Button, Typography } from 'antd';
import CheckOutlined from '@ant-design/icons/CheckOutlined';
import CopyOutlined from '@ant-design/icons/CopyOutlined';
import { Loading } from '@/components/PageLoading';
import '@/components/editor/AceEditor';

export interface BaseProps {
  code: string;
  copyable?: boolean;
  inline?: boolean;
  loading?: boolean;
  maxHeight?: string;
  showLineNumbers?: boolean;
  backgroundColor?: string;
  onCopy?: () => void;
}

const getBlockStyles = (props: {
  inline?: boolean;
  backgroundColor?: string;
}) => {
  if (props.inline) {
    return `
      display: inline;
      border: none;
      background: transparent !important;
      padding: 0;
      * { display: inline !important; }
    `;
  }
  return `
    background: ${props.backgroundColor || 'var(--gray-1)'} !important;
    padding: 8px;
  `;
};

export const Block = styled.div<{
  maxHeight?: string;
  inline?: boolean;
  backgroundColor?: string;
}>`
  position: relative;
  white-space: pre;
  font-size: 13px;
  border: 1px var(--gray-4) solid;
  border-radius: 4px;
  font-family: 'Source Code Pro', monospace;
  user-select: text;
  cursor: text;
  &:focus {
    outline: none;
  }
  ${getBlockStyles}

  .adm-code-wrap {
    ${(props) => (props.inline ? '' : 'overflow: auto;')}
    ${(props) => (props.maxHeight ? `max-height: ${props.maxHeight}px;` : ``)}
    user-select: text;
  }

  .adm-code-line {
    display: block;
    user-select: text;
    &-number {
      user-select: none;
      display: inline-block;
      min-width: 14px;
      text-align: right;
      margin-right: 1em;
      color: var(--gray-6);
      font-weight: 700;
      font-size: 12px;
    }
  }
`;

export const CopyText = styled(Typography.Text)<{ $hasVScrollbar: boolean }>`
  position: absolute;
  top: 0;
  right: ${(props) => (props.$hasVScrollbar ? '20px' : '0')};
  font-size: 0;
  button {
    background: var(--gray-1) !important;
  }

  .ant-typography-copy {
    font-size: 12px;
  }

  .ant-btn:not(:hover) {
    color: var(--gray-8);
  }
`;

export const addThemeStyleManually = (cssText: string) => {
  const id = 'ace-tomorrow';
  const themeElement = document.getElementById(id);
  if (!themeElement) {
    const styleElement = document.createElement('style');
    styleElement.id = id;
    document.head.appendChild(styleElement);
    styleElement.appendChild(document.createTextNode(cssText));
  }
};

export const createCodeBlock = (HighlightRules: any) => {
  return function CodeBlock(props: BaseProps) {
    const {
      code,
      copyable,
      maxHeight,
      inline,
      loading,
      showLineNumbers,
      backgroundColor,
      onCopy,
    } = props;
    const { ace } = window as any;
    const { Tokenizer } = ace.require('ace/tokenizer');
    const rules = new HighlightRules();
    const tokenizer = new Tokenizer(rules.getRules());

    const codeWrapRef = useRef<HTMLDivElement>(null);
    const [hasVerticalScrollbar, setHasVerticalScrollbar] =
      useState<boolean>(false);

    useEffect(() => {
      const { cssText } = ace.require('ace/theme/tomorrow');
      addThemeStyleManually(cssText);
    }, []);

    useEffect(() => {
      const el = codeWrapRef.current;
      if (!el) return;

      const hasScroll = el.scrollHeight > el.clientHeight;
      setHasVerticalScrollbar(hasScroll);
    }, [code]);

    const lines = (code || '').split('\n').map((line, index) => {
      const tokens = tokenizer.getLineTokens(line).tokens;
      const children = tokens.map((token, index) => {
        const classNames = token.type.split('.').map((name) => `ace_${name}`);
        return (
          <span key={index} className={classNames.join(' ')}>
            {token.value}
          </span>
        );
      });

      return (
        <span className="adm-code-line ace_line" key={`${line}-${index}`}>
          {showLineNumbers && (
            <span className="adm-code-line-number">{index + 1}</span>
          )}
          {children}
        </span>
      );
    });

    const handleKeyDown = (e: React.KeyboardEvent) => {
      if ((e.metaKey || e.ctrlKey) && e.key === 'a') {
        e.preventDefault();
        const selection = window.getSelection();
        const range = document.createRange();
        range.selectNodeContents(
          e.currentTarget.querySelector('.adm-code-wrap') || e.currentTarget,
        );
        selection?.removeAllRanges();
        selection?.addRange(range);
      }
    };

    return (
      <Block
        className="ace_editor ace-tomorrow adm_code-block"
        maxHeight={maxHeight}
        inline={inline}
        backgroundColor={backgroundColor}
        tabIndex={0}
        onKeyDown={handleKeyDown}
      >
        <Loading spinning={loading}>
          <div className="adm-code-wrap" ref={codeWrapRef}>
            {lines}
            {copyable && (
              <CopyText
                $hasVScrollbar={hasVerticalScrollbar}
                copyable={{
                  onCopy,
                  icon: [
                    <Button
                      key="copy-icon"
                      icon={<CopyOutlined />}
                      size="small"
                      style={{ backgroundColor: 'transparent' }}
                    />,
                    <Button
                      key="copied-icon"
                      icon={<CheckOutlined className="green-6" />}
                      size="small"
                    />,
                  ],
                  text: code,
                }}
              >
                {code}
              </CopyText>
            )}
          </div>
        </Loading>
      </Block>
    );
  };
};
</file>

<file path="src/components/code/JsonCodeBlock.tsx">
import { createCodeBlock, BaseProps } from './BaseCodeBlock';

const JsonCodeBlock = (props: BaseProps) => {
  const { code, ...rest } = props;
  const { ace } = window as any;
  let formattedJson;
  try {
    formattedJson =
      typeof code === 'string' ? code : JSON.stringify(code, null, 2);
  } catch {
    console.warn('Failed to format JSON', code);
    formattedJson = code;
  }

  const { JsonHighlightRules } = ace.require('ace/mode/json_highlight_rules');
  const BaseCodeBlock = createCodeBlock(JsonHighlightRules);
  return <BaseCodeBlock code={formattedJson} {...rest} />;
};

export default JsonCodeBlock;
</file>

<file path="src/components/code/SQLCodeBlock.tsx">
import { createCodeBlock, BaseProps } from './BaseCodeBlock';

const SQLCodeBlock = (props: BaseProps) => {
  const { ace } = window as any;
  const { SqlHighlightRules } = ace.require('ace/mode/sql_highlight_rules');
  const BaseCodeBlock = createCodeBlock(SqlHighlightRules);
  return <BaseCodeBlock {...props} />;
};

export default SQLCodeBlock;
</file>

<file path="src/components/dataPreview/PreviewData.tsx">
import { memo, useMemo } from 'react';
import { Alert, Typography, Button } from 'antd';
import { ApolloError } from '@apollo/client';
import styled from 'styled-components';
import { getColumnTypeIcon } from '@/utils/columnType';
import PreviewDataContent from '@/components/dataPreview/PreviewDataContent';
import { parseGraphQLError } from '@/utils/errorHandler';

const { Text } = Typography;

const StyledCell = styled.div`
  position: relative;

  .copy-icon {
    position: absolute;
    top: 50%;
    right: 0;
    transform: translateY(-50%);
    opacity: 0;
    transition: opacity 0.3s;
  }

  .ant-typography-copy {
    margin: -4px;
  }

  &:hover .copy-icon {
    opacity: 1;
  }
`;

const ColumnTitle = memo((props: { name: string; type: any }) => {
  const { name, type } = props;
  const columnTypeIcon = getColumnTypeIcon({ type }, { title: type });

  return (
    <>
      {columnTypeIcon}
      <Text title={name} className="ml-1">
        {name}
      </Text>
    </>
  );
});

const ColumnContext = memo((props: { text: string; copyable: boolean }) => {
  const { text, copyable } = props;
  return (
    <StyledCell className="text-truncate">
      <span title={text} className="text text-container">
        {text}
      </span>
      {copyable && (
        <Button size="small" className="copy-icon">
          <Text copyable={{ text, tooltips: false }} className="gray-8" />
        </Button>
      )}
    </StyledCell>
  );
});

const getPreviewColumns = (cols, { copyable }) =>
  cols.map(({ name, type }: Record<string, any>) => {
    return {
      dataIndex: name,
      titleText: name,
      key: name,
      ellipsis: true,
      title: <ColumnTitle name={name} type={type} />,
      render: (text) => <ColumnContext text={text} copyable={copyable} />,
      onCell: () => ({ style: { lineHeight: '24px' } }),
    };
  });

interface Props {
  previewData?: {
    data: Array<Array<any>>;
    columns: Array<{
      name: string;
      type: string;
    }>;
  };
  loading: boolean;
  error?: ApolloError;
  locale?: { emptyText: React.ReactNode };
  copyable?: boolean;
}

export default function PreviewData(props: Props) {
  const { previewData, loading, error, locale, copyable = true } = props;

  const columns = useMemo(
    () =>
      previewData?.columns &&
      getPreviewColumns(previewData.columns, { copyable }),
    [previewData?.columns, copyable],
  );

  const hasErrorMessage = error && error.message;
  if (!loading && hasErrorMessage) {
    const { message, shortMessage } = parseGraphQLError(error);

    return (
      <Alert
        message={shortMessage}
        description={message}
        type="error"
        showIcon
      />
    );
  }

  return (
    <PreviewDataContent
      columns={columns}
      data={previewData?.data || []}
      loading={loading}
      locale={locale}
    />
  );
}
</file>

<file path="src/components/dataPreview/PreviewDataContent.tsx">
import { useMemo } from 'react';
import { Table, TableColumnProps } from 'antd';
import { isString } from 'lodash';

const FONT_SIZE = 16;
const BASIC_COLUMN_WIDTH = 100;

type TableColumn = TableColumnProps<any> & { titleText?: string };

interface Props {
  columns: TableColumn[];
  data: Array<any[]>;
  loading: boolean;
  locale?: { emptyText: React.ReactNode };
}

const getValueByValueType = (value: any) =>
  ['boolean', 'object'].includes(typeof value) ? JSON.stringify(value) : value;

const convertResultData = (data: Array<any>, columns) => {
  return data.map((datum: Array<any>, index: number) => {
    const obj = {};
    // should have a unique "key" prop.
    obj['key'] = index;

    datum.forEach((value, index) => {
      const columnName = columns[index].dataIndex;
      obj[columnName] = getValueByValueType(value);
    });

    return obj;
  });
};

export default function PreviewDataContent(props: Props) {
  const { columns = [], data = [], loading, locale } = props;
  const hasColumns = !!columns.length;

  const dynamicWidth = useMemo(() => {
    return columns.reduce((result, column) => {
      const width = isString(column.titleText || column.title)
        ? (column.titleText || (column.title as string)).length * FONT_SIZE
        : BASIC_COLUMN_WIDTH;
      return result + width;
    }, 0);
  }, [columns]);

  const tableColumns = useMemo(() => {
    return columns.map((column) => ({
      ...column,
      ellipsis: true,
    }));
  }, [columns]);

  const dataSource = useMemo(() => convertResultData(data, columns), [data]);

  // https://posthog.com/docs/session-replay/privacy#other-elements
  return (
    <Table
      className={`ph-no-capture ${hasColumns ? 'ant-table-has-header' : ''}`}
      showHeader={hasColumns}
      dataSource={dataSource}
      columns={tableColumns}
      pagination={false}
      size="small"
      scroll={{ y: 280, x: dynamicWidth }}
      loading={loading}
      locale={locale}
    />
  );
}
</file>

<file path="src/components/deploy/Context.ts">
import { createContext, useContext } from 'react';
import { DeployStatusQueryHookResult } from '@/apollo/client/graphql/deploy.generated';

type ContextProps = DeployStatusQueryHookResult;

export const DeployStatusContext = createContext<ContextProps>(
  {} as ContextProps,
);

export function useDeployStatusContext() {
  return useContext(DeployStatusContext);
}
</file>

<file path="src/components/deploy/Deploy.tsx">
import { useEffect } from 'react';
import { Button, Space, Typography, message } from 'antd';
import CheckCircleOutlined from '@ant-design/icons/CheckCircleOutlined';
import LoadingOutlined from '@ant-design/icons/LoadingOutlined';
import WarningOutlined from '@ant-design/icons/WarningOutlined';
import { SyncStatus } from '@/apollo/client/graphql/__types__';
import { useDeployMutation } from '@/apollo/client/graphql/deploy.generated';
import { useDeployStatusContext } from '@/components/deploy/Context';

const { Text } = Typography;

const getDeployStatus = (deploying: boolean, status: SyncStatus) => {
  const syncStatus = deploying ? SyncStatus.IN_PROGRESS : status;

  return (
    {
      [SyncStatus.IN_PROGRESS]: (
        <Space size={[4, 0]}>
          <LoadingOutlined className="mr-1 gray-1" />
          <Text className="gray-1">Deploying...</Text>
        </Space>
      ),
      [SyncStatus.SYNCRONIZED]: (
        <Space size={[4, 0]}>
          <CheckCircleOutlined className="mr-1 green-7" />
          <Text className="gray-1">Synced</Text>
        </Space>
      ),
      [SyncStatus.UNSYNCRONIZED]: (
        <Space size={[4, 0]}>
          <WarningOutlined className="mr-1 gold-6" />
          <Text className="gray-1">Undeployed changes</Text>
        </Space>
      ),
    }[syncStatus] || ''
  );
};

export default function Deploy() {
  const deployContext = useDeployStatusContext();
  const { data, loading, startPolling, stopPolling } = deployContext;

  const [deployMutation, { data: deployResult, loading: deploying }] =
    useDeployMutation({
      onCompleted: (data) => {
        if (data.deploy?.status === 'FAILED') {
          console.error('Failed to deploy - ', data.deploy?.error);
          message.error(
            'Failed to deploy. Please check the log for more details.',
          );
        }
      },
    });

  useEffect(() => {
    // Stop polling deploy status if deploy failed
    if (
      deployResult?.deploy?.status === 'FAILED' &&
      data?.modelSync.status === SyncStatus.UNSYNCRONIZED
    ) {
      stopPolling();
    }
  }, [deployResult, data]);

  const syncStatus = data?.modelSync.status;

  const onDeploy = () => {
    deployMutation();
    startPolling(1000);
  };

  useEffect(() => {
    if (syncStatus === SyncStatus.SYNCRONIZED) stopPolling();
  }, [syncStatus]);

  const disabled =
    deploying ||
    loading ||
    [SyncStatus.SYNCRONIZED, SyncStatus.IN_PROGRESS].includes(syncStatus);

  return (
    <Space size={[8, 0]}>
      {getDeployStatus(deploying, syncStatus)}
      <Button
        className={`adm-modeling-header-btn ${disabled ? '' : 'gray-10'}`}
        disabled={disabled}
        onClick={() => onDeploy()}
        size="small"
        data-guideid="deploy-model"
      >
        Deploy
      </Button>
    </Space>
  );
}
</file>

<file path="src/components/diagram/Context.ts">
import { createContext } from 'react';
import { ComposeDiagram } from '@/utils/data';

export interface ClickPayload {
  [key: string]: any;
  data: ComposeDiagram;
}

type ContextProps = {
  onMoreClick: (data: ClickPayload) => void;
  onNodeClick: (data: ClickPayload) => void;
  onAddClick: (data: ClickPayload) => void;
} | null;

export const DiagramContext = createContext<ContextProps>({
  onMoreClick: () => {},
  onNodeClick: () => {},
  onAddClick: () => {},
});
</file>

<file path="src/components/diagram/CustomDropdown.tsx">
import React from 'react';
import styled from 'styled-components';
import { Dropdown, Menu } from 'antd';
import { ItemType } from 'antd/lib/menu/hooks/useItems';
import { MORE_ACTION, NODE_TYPE } from '@/utils/enum';
import EditOutlined from '@ant-design/icons/EditOutlined';
import ReloadOutlined from '@ant-design/icons/ReloadOutlined';
import EyeInvisibleOutlined from '@ant-design/icons/EyeInvisibleOutlined';
import EyeOutlined from '@ant-design/icons/EyeOutlined';
import CodeFilled from '@ant-design/icons/CodeFilled';
import DatabaseOutlined from '@ant-design/icons/DatabaseOutlined';
import { EditSVG } from '@/utils/svgs';
import {
  DeleteCalculatedFieldModal,
  DeleteRelationshipModal,
  DeleteModelModal,
  DeleteViewModal,
  DeleteDashboardItemModal,
  DeleteQuestionSQLPairModal,
  DeleteInstructionModal,
} from '@/components/modals/DeleteModal';

const StyledMenu = styled(Menu)`
  .ant-dropdown-menu-item:not(.ant-dropdown-menu-item-disabled) {
    color: var(--gray-8);
  }
`;

interface Props {
  [key: string]: any;
  onMoreClick: (type: MORE_ACTION | { type: MORE_ACTION; data: any }) => void;
  onMenuEnter?: (event: React.MouseEvent) => void;
  children: React.ReactNode;
  onDropdownVisibleChange?: (visible: boolean) => void;
}

const makeDropdown =
  (getItems: (props: Props) => ItemType[]) => (props: Props) => {
    const { children, onMenuEnter, onDropdownVisibleChange } = props;

    const items = getItems(props);

    return (
      <Dropdown
        trigger={['click']}
        overlayStyle={{ minWidth: 100, userSelect: 'none' }}
        overlay={
          <StyledMenu
            onClick={(e) => e.domEvent.stopPropagation()}
            items={items}
            onMouseEnter={onMenuEnter}
          />
        }
        onVisibleChange={onDropdownVisibleChange}
      >
        {children}
      </Dropdown>
    );
  };

export const ModelDropdown = makeDropdown((props: Props) => {
  const { onMoreClick } = props;

  const items: ItemType[] = [
    {
      label: (
        <>
          <EditOutlined className="mr-2" />
          Update Columns
        </>
      ),
      key: MORE_ACTION.UPDATE_COLUMNS,
      onClick: () => onMoreClick(MORE_ACTION.UPDATE_COLUMNS),
    },
    {
      label: (
        <DeleteModelModal onConfirm={() => onMoreClick(MORE_ACTION.DELETE)} />
      ),
      className: 'red-5',
      key: MORE_ACTION.DELETE,
      onClick: ({ domEvent }) => domEvent.stopPropagation(),
    },
  ];

  return items;
});

export const ViewDropdown = makeDropdown((props: Props) => {
  const { onMoreClick } = props;
  const items: ItemType[] = [
    {
      label: (
        <DeleteViewModal onConfirm={() => onMoreClick(MORE_ACTION.DELETE)} />
      ),
      className: 'red-5',
      key: MORE_ACTION.DELETE,
      onClick: ({ domEvent }) => domEvent.stopPropagation(),
    },
  ];
  return items;
});

export const ColumnDropdown = makeDropdown((props: Props) => {
  const { onMoreClick, data } = props;
  const { nodeType } = data;

  const DeleteColumnModal =
    {
      [NODE_TYPE.CALCULATED_FIELD]: DeleteCalculatedFieldModal,
      [NODE_TYPE.RELATION]: DeleteRelationshipModal,
    }[nodeType] || DeleteCalculatedFieldModal;

  const items: ItemType[] = [
    {
      label: (
        <>
          <EditOutlined className="mr-2" />
          Edit
        </>
      ),
      key: MORE_ACTION.EDIT,
      onClick: () => onMoreClick(MORE_ACTION.EDIT),
    },
    {
      label: (
        <DeleteColumnModal onConfirm={() => onMoreClick(MORE_ACTION.DELETE)} />
      ),
      className: 'red-5',
      key: MORE_ACTION.DELETE,
      onClick: ({ domEvent }) => domEvent.stopPropagation(),
    },
  ];

  return items;
});

export const DashboardDropdown = makeDropdown((props: Props) => {
  const { onMoreClick, isSupportCached } = props;
  const items: ItemType[] = [
    isSupportCached && {
      label: (
        <>
          <DatabaseOutlined className="mr-2" />
          Cache settings
        </>
      ),
      key: MORE_ACTION.CACHE_SETTINGS,
      onClick: () => onMoreClick(MORE_ACTION.CACHE_SETTINGS),
    },
    {
      label: (
        <>
          <ReloadOutlined className="mr-2" />
          {isSupportCached ? 'Refresh all caches' : 'Refresh all'}
        </>
      ),
      key: MORE_ACTION.REFRESH,
      onClick: () => onMoreClick(MORE_ACTION.REFRESH),
    },
  ].filter(Boolean);
  return items;
});

export const DashboardItemDropdown = makeDropdown((props: Props) => {
  const { onMoreClick, isHideLegend, isSupportCached } = props;
  const items: ItemType[] = [
    {
      label: isHideLegend ? (
        <>
          <EyeOutlined className="mr-2" />
          Show categories
        </>
      ) : (
        <>
          {<EyeInvisibleOutlined className="mr-2" />}
          Hide categories
        </>
      ),
      key: MORE_ACTION.HIDE_CATEGORY,
      onClick: () => onMoreClick(MORE_ACTION.HIDE_CATEGORY),
    },
    {
      label: (
        <>
          <ReloadOutlined className="mr-2" />
          {isSupportCached ? 'Refresh cache' : 'Refresh'}
        </>
      ),
      key: MORE_ACTION.REFRESH,
      onClick: () => onMoreClick(MORE_ACTION.REFRESH),
    },
    {
      label: (
        <DeleteDashboardItemModal
          onConfirm={() => onMoreClick(MORE_ACTION.DELETE)}
        />
      ),
      className: 'red-5',
      key: MORE_ACTION.DELETE,
      onClick: ({ domEvent }) => domEvent.stopPropagation(),
    },
  ];
  return items;
});

export const SQLPairDropdown = makeDropdown(
  (
    props: Props & {
      onMoreClick: (payload: { type: MORE_ACTION; data: any }) => void;
    },
  ) => {
    const { onMoreClick, data } = props;
    const items: ItemType[] = [
      {
        label: (
          <>
            <EyeOutlined className="mr-2" />
            View
          </>
        ),
        key: MORE_ACTION.VIEW_SQL_PAIR,
        onClick: () =>
          onMoreClick({
            type: MORE_ACTION.VIEW_SQL_PAIR,
            data,
          }),
      },
      {
        label: (
          <>
            <EditOutlined className="mr-2" />
            Edit
          </>
        ),
        key: MORE_ACTION.EDIT,
        onClick: () =>
          onMoreClick({
            type: MORE_ACTION.EDIT,
            data,
          }),
      },
      {
        label: (
          <DeleteQuestionSQLPairModal
            onConfirm={() =>
              onMoreClick({
                type: MORE_ACTION.DELETE,
                data,
              })
            }
            modalProps={{
              cancelButtonProps: { autoFocus: true },
            }}
          />
        ),
        className: 'red-5',
        key: MORE_ACTION.DELETE,
        onClick: ({ domEvent }) => domEvent.stopPropagation(),
      },
    ];
    return items;
  },
);

export const InstructionDropdown = makeDropdown(
  (
    props: Props & {
      onMoreClick: (payload: { type: MORE_ACTION; data: any }) => void;
    },
  ) => {
    const { onMoreClick, data } = props;
    const items: ItemType[] = [
      {
        label: (
          <>
            <EyeOutlined className="mr-2" />
            View
          </>
        ),
        key: MORE_ACTION.VIEW_INSTRUCTION,
        onClick: () =>
          onMoreClick({
            type: MORE_ACTION.VIEW_INSTRUCTION,
            data,
          }),
      },
      {
        label: (
          <>
            <EditOutlined className="mr-2" />
            Edit
          </>
        ),
        key: MORE_ACTION.EDIT,
        onClick: () =>
          onMoreClick({
            type: MORE_ACTION.EDIT,
            data,
          }),
      },
      {
        label: (
          <DeleteInstructionModal
            onConfirm={() =>
              onMoreClick({
                type: MORE_ACTION.DELETE,
                data,
              })
            }
            modalProps={{
              cancelButtonProps: { autoFocus: true },
            }}
          />
        ),
        className: 'red-5',
        key: MORE_ACTION.DELETE,
        onClick: ({ domEvent }) => domEvent.stopPropagation(),
      },
    ];
    return items;
  },
);

export const AdjustAnswerDropdown = makeDropdown(
  (
    props: Props & {
      onMoreClick: (payload: { type: MORE_ACTION; data: any }) => void;
    },
  ) => {
    const { onMoreClick, data } = props;
    const items: ItemType[] = [
      {
        label: 'Adjust steps',
        icon: <EditSVG />,
        disabled: !data.sqlGenerationReasoning,
        key: 'adjust-steps',
        onClick: () =>
          onMoreClick({
            type: MORE_ACTION.ADJUST_STEPS,
            data,
          }),
      },
      {
        label: 'Adjust SQL',
        icon: <CodeFilled className="text-base" />,
        disabled: !data.sql,
        key: 'adjust-sql',
        onClick: () =>
          onMoreClick({
            type: MORE_ACTION.ADJUST_SQL,
            data,
          }),
      },
    ];
    return items;
  },
);
</file>

<file path="src/components/diagram/customEdge/index.ts">
export { default as ModelEdge } from './ModelEdge';
</file>

<file path="src/components/diagram/customEdge/ModelEdge.tsx">
import { memo, useMemo } from 'react';
import {
  BaseEdge,
  EdgeLabelRenderer,
  EdgeProps,
  getSmoothStepPath,
} from 'reactflow';
import styled from 'styled-components';
import CustomPopover from '../CustomPopover';
import { getJoinTypeText } from '@/utils/data';

const Joint = styled.div`
  position: absolute;
  width: 30px;
  height: 30px;
  opacity: 0;
`;

const ModelEdge = ({
  sourceX,
  sourceY,
  targetX,
  targetY,
  sourcePosition,
  targetPosition,
  markerStart,
  markerEnd,
  data,
}: EdgeProps) => {
  const [edgePath, labelX, labelY] = getSmoothStepPath({
    sourceX,
    sourceY,
    sourcePosition,
    targetX,
    targetY,
    targetPosition,
  });

  const isPopoverShow = data.highlight;
  const style = isPopoverShow
    ? {
        stroke: 'var(--geekblue-6)',
        strokeWidth: 1.5,
      }
    : { stroke: 'var(--gray-5)' };

  const relation = useMemo(() => {
    const fromField = `${data.relation.fromModelName}.${data.relation.fromColumnName}`;
    const toField = `${data.relation.toModelName}.${data.relation.toColumnName}`;
    return {
      name: data.relation.name,
      joinType: getJoinTypeText(data.relation.type),
      description: data.relation?.description || '-',
      fromField,
      toField,
    };
  }, [data.relation]);

  return (
    <>
      <BaseEdge
        path={edgePath}
        markerStart={markerStart}
        markerEnd={markerEnd}
        style={style}
      />
      <EdgeLabelRenderer>
        <CustomPopover
          visible={isPopoverShow}
          title="Relationship"
          content={
            <CustomPopover.Row gutter={16}>
              <CustomPopover.Col title="From" span={12}>
                {relation.fromField}
              </CustomPopover.Col>
              <CustomPopover.Col title="To" span={12}>
                {relation.toField}
              </CustomPopover.Col>
              <CustomPopover.Col title="Type" span={12}>
                {relation.joinType}
              </CustomPopover.Col>
              <CustomPopover.Col title="Description">
                {relation.description}
              </CustomPopover.Col>
            </CustomPopover.Row>
          }
        >
          <Joint
            style={{
              transform: `translate(-50%, -50%) translate(${labelX}px,${labelY}px)`,
            }}
          />
        </CustomPopover>
      </EdgeLabelRenderer>
    </>
  );
};

export default memo(ModelEdge);
</file>

<file path="src/components/diagram/customNode/Column.tsx">
import React from 'react';
import styled from 'styled-components';
import MarkerHandle from '@/components/diagram/customNode/MarkerHandle';

const NodeColumn = styled.div`
  position: relative;
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 4px 8px;
  color: var(--gray-9);
  line-height: 24px;

  &:hover {
    background-color: var(--gray-3);
  }

  svg {
    flex-shrink: 0;
  }

  .adm-column-title {
    display: flex;
    align-items: center;
    min-width: 1px;
    svg {
      margin-right: 6px;
    }
    > span {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
  }
`;

const Title = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  color: var(--gray-8);
  padding: 4px 12px;
  cursor: default;
`;

type ColumnProps = {
  id: number | string;
  type: string;
  displayName: string;
  style?: React.CSSProperties;
  icon: React.ReactNode;
  extra?: React.ReactNode;
  onMouseEnter?: (event: React.MouseEvent) => void;
  onMouseLeave?: (event: React.MouseEvent) => void;
};

type ColumnTitleProps = {
  show: boolean;
  extra?: React.ReactNode;
  children: React.ReactNode;
};

export default function Column(props: ColumnProps) {
  const {
    id,
    type,
    onMouseEnter,
    onMouseLeave,
    displayName,
    style = {},
    icon,
    extra,
  } = props;

  const nodeColumn = (
    <NodeColumn
      style={style}
      onMouseEnter={onMouseEnter}
      onMouseLeave={onMouseLeave}
    >
      <div className="adm-column-title">
        <span className="d-inline-flex flex-shrink-0" title={type}>
          {icon}
        </span>
        <span title={displayName}>{displayName}</span>
      </div>
      {extra}
      <MarkerHandle id={id.toString()} />
    </NodeColumn>
  );

  return nodeColumn;
}

const MoreColumnTip = (props: { count: number }) => {
  return <div className="text-sm gray-7 px-3 py-1">and {props.count} more</div>;
};

const ColumnTitle = (props: ColumnTitleProps) => {
  const { show, extra, children } = props;
  if (!show) return null;

  return (
    <Title>
      {children}
      <span>{extra}</span>
    </Title>
  );
};

Column.Title = ColumnTitle;
Column.MoreTip = MoreColumnTip;
</file>

<file path="src/components/diagram/customNode/index.ts">
export { default as ModelNode } from './ModelNode';
export { default as ViewNode } from './ViewNode';
</file>

<file path="src/components/diagram/customNode/MarkerHandle.tsx">
import { Handle, Position } from 'reactflow';

// parent should be position relative
export default function MarkerHandle({ id }: { id: string }) {
  return (
    <>
      {/* all handlers */}
      <Handle
        type="source"
        position={Position.Left}
        id={`${id}_${Position.Left}`}
      />
      <Handle
        type="source"
        position={Position.Right}
        id={`${id}_${Position.Right}`}
      />
      <Handle
        type="target"
        position={Position.Left}
        id={`${id}_${Position.Left}`}
      />
      <Handle
        type="target"
        position={Position.Right}
        id={`${id}_${Position.Right}`}
      />
    </>
  );
}
</file>

<file path="src/components/diagram/customNode/ModelNode.tsx">
import { memo, useCallback, useContext } from 'react';
import { Typography } from 'antd';
import { useReactFlow } from 'reactflow';
import {
  highlightEdges,
  highlightNodes,
  trimId,
} from '@/components/diagram/utils';
import {
  CachedIcon,
  CustomNodeProps,
  NodeBody,
  NodeHeader,
  StyledNode,
} from '@/components/diagram/customNode/utils';
import MarkerHandle from '@/components/diagram/customNode/MarkerHandle';
import { DiagramContext } from '@/components/diagram/Context';
import Column from '@/components/diagram/customNode/Column';
import { PrimaryKeyIcon, ModelIcon } from '@/utils/icons';
import {
  ComposeDiagram,
  ComposeDiagramField,
  DiagramModel,
} from '@/utils/data';
import { getColumnTypeIcon } from '@/utils/columnType';
import { makeIterable } from '@/utils/iteration';
import { Config } from '@/utils/diagram';
import { MORE_ACTION, NODE_TYPE } from '@/utils/enum';
import {
  ModelDropdown,
  ColumnDropdown,
} from '@/components/diagram/CustomDropdown';
import { AddButton, MoreButton } from '@/components/ActionButton';

const { Text } = Typography;

export const ModelNode = ({ data }: CustomNodeProps<DiagramModel>) => {
  const context = useContext(DiagramContext);
  const onMoreClick = (type: MORE_ACTION) => {
    context?.onMoreClick({
      type,
      data: data.originalData,
    });
  };
  const onNodeClick = () => {
    context?.onNodeClick({
      data: data.originalData,
    });
  };
  const onAddClick = (targetNodeType: NODE_TYPE) => {
    context?.onAddClick({
      targetNodeType,
      data: data.originalData,
    });
  };

  const renderColumns = useCallback(
    (columns: ComposeDiagramField[]) =>
      getColumns(columns, data, { limit: Config.columnsLimit }),
    [data.highlight],
  );

  return (
    <StyledNode
      onClick={onNodeClick}
      data-testid={`diagram__model-node__${data.originalData.displayName}`}
      data-guideid={`model-${data.index}`}
    >
      <NodeHeader className="dragHandle">
        <span className="adm-model-header">
          <ModelIcon />
          <Text ellipsis title={data.originalData.displayName}>
            {data.originalData.displayName}
          </Text>
        </span>
        <span>
          <CachedIcon originalData={data.originalData} />
          <ModelDropdown data={data.originalData} onMoreClick={onMoreClick}>
            <MoreButton
              className="gray-1"
              marginRight={-4}
              data-guideid={`edit-model-${data.index}`}
            />
          </ModelDropdown>
        </span>

        <MarkerHandle id={data.originalData.id.toString()} />
      </NodeHeader>
      <NodeBody draggable={false}>
        <Column.Title show={true}>Columns</Column.Title>
        {renderColumns(data.originalData.fields)}
        <Column.Title
          show={true}
          extra={
            <AddButton
              className="gray-8"
              marginRight={-8}
              onClick={() => onAddClick(NODE_TYPE.CALCULATED_FIELD)}
            />
          }
        >
          Calculated Fields
        </Column.Title>
        {renderColumns(data.originalData.calculatedFields)}
        <Column.Title
          show={true}
          extra={
            <AddButton
              className="gray-8"
              marginRight={-8}
              onClick={() => onAddClick(NODE_TYPE.RELATION)}
            />
          }
        >
          Relationships
        </Column.Title>
        {renderColumns(data.originalData.relationFields)}
      </NodeBody>
    </StyledNode>
  );
};

export default memo(ModelNode);

const ColumnTemplate = (props) => {
  const { nodeType, id, type, isPrimaryKey, highlight } = props;
  const isRelationship = nodeType === NODE_TYPE.RELATION;
  const isCalculatedField = nodeType === NODE_TYPE.CALCULATED_FIELD;
  const isMoreButtonShow = isCalculatedField || isRelationship;
  const reactflowInstance = useReactFlow();

  const context = useContext(DiagramContext);
  const onMoreClick = (type: MORE_ACTION) => {
    context?.onMoreClick({
      type,
      data: props,
    });
  };

  const onMouseEnter = useCallback(
    (_event: React.MouseEvent) => {
      if (!isRelationship) return;
      const { getEdges, setEdges, setNodes } = reactflowInstance;
      const edges = getEdges();
      const relatedEdge = edges.find(
        (edge: any) =>
          trimId(edge.sourceHandle) === id || trimId(edge.targetHandle) === id,
      );

      // skip to highlight & open relationship popup if no related edge
      if (!relatedEdge) return;

      setEdges(highlightEdges([relatedEdge?.id], true));
      setNodes(
        highlightNodes(
          [relatedEdge.source, relatedEdge.target],
          [trimId(relatedEdge.sourceHandle), trimId(relatedEdge.targetHandle)],
        ),
      );
    },
    [reactflowInstance],
  );
  const onMouseLeave = useCallback(
    (_event: React.MouseEvent) => {
      if (!isRelationship) return;
      const { setEdges, setNodes } = reactflowInstance;
      setEdges(highlightEdges([], false));
      setNodes(highlightNodes([], []));
    },
    [reactflowInstance],
  );

  const onMoreMouseEnter = useCallback(
    (event: React.MouseEvent) => {
      onMouseLeave(event);
    },
    [reactflowInstance],
  );

  const onMoreMouseLeave = useCallback(
    (event: React.MouseEvent) => {
      onMouseEnter(event);
    },
    [reactflowInstance],
  );

  const onMenuEnter = useCallback(
    (event: React.MouseEvent) => {
      onMouseLeave(event);
    },
    [reactflowInstance],
  );

  return (
    <Column
      {...props}
      key={id}
      className={highlight.includes(id) ? 'bg-gray-3' : undefined}
      icon={isRelationship ? <ModelIcon /> : getColumnTypeIcon({ type })}
      extra={
        <>
          {isPrimaryKey && <PrimaryKeyIcon />}{' '}
          {isMoreButtonShow && (
            <ColumnDropdown
              data={props}
              onMoreClick={onMoreClick}
              onMenuEnter={onMenuEnter}
            >
              <MoreButton
                className="gray-8"
                marginRight={-4}
                onMouseEnter={onMoreMouseEnter}
                onMouseLeave={onMoreMouseLeave}
              />
            </ColumnDropdown>
          )}
        </>
      }
      onMouseLeave={onMouseLeave}
      onMouseEnter={onMouseEnter}
    />
  );
};

const ColumnIterator = makeIterable(ColumnTemplate);

const getColumns = (
  columns: ComposeDiagramField[],
  data: CustomNodeProps<ComposeDiagram>['data'],
  pagination?: { limit: number },
) => {
  const moreCount = pagination ? columns.length - pagination.limit : 0;
  const slicedColumns = pagination
    ? columns.slice(0, pagination.limit)
    : columns;
  return (
    <>
      <ColumnIterator
        data={slicedColumns}
        highlight={data.highlight}
        modelId={data.originalData.modelId}
      />
      {moreCount > 0 && <Column.MoreTip count={moreCount} />}
    </>
  );
};
</file>

<file path="src/components/diagram/customNode/utils.tsx">
import { CachedProps } from '@/utils/data';
import { LightningIcon } from '@/utils/icons';
import { Tooltip } from 'antd';
import { NodeProps } from 'reactflow';
import styled from 'styled-components';

export type CustomNodeProps<T> = NodeProps<{
  originalData: T;
  index: number;
  highlight: string[];
}>;

export const StyledNode = styled.div`
  position: relative;
  width: 200px;
  border-radius: 4px;
  overflow: hidden;
  box-shadow:
    0px 3px 6px -4px rgba(0, 0, 0, 0.12),
    0px 6px 16px rgba(0, 0, 0, 0.08),
    0px 9px 28px 8px rgba(0, 0, 0, 0.05);
  cursor: pointer;

  &:before {
    content: '';
    pointer-events: none;
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    z-index: 1;
    border: 2px solid transparent;
    transition: border-color 0.15s ease-in-out;
  }

  &:hover,
  &:focus {
    &:before {
      border-color: var(--geekblue-6);
    }
  }

  .react-flow__handle {
    border: none;
    opacity: 0;

    &-left {
      left: 0;
    }

    &-right {
      right: 0;
    }
  }
`;

export const NodeHeader = styled.div`
  position: relative;
  background-color: ${(props) => props.color || 'var(--geekblue-6)'};
  font-size: 14px;
  color: white;
  padding: 6px 8px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  height: 36px;

  &.dragHandle {
    cursor: move;
  }

  .adm-model-header {
    display: flex;
    align-items: center;

    svg {
      margin-right: 6px;
    }
    + svg {
      cursor: pointer;
    }

    .ant-typography {
      width: 140px;
      color: white;
    }
  }
`;

export const NodeBody = styled.div`
  background-color: white;
  padding-bottom: 4px;
`;

export const CachedIcon = ({ originalData }: { originalData: CachedProps }) => {
  return originalData.cached ? (
    <Tooltip
      title={
        <>
          Cached
          {originalData.refreshTime
            ? `: refresh every ${originalData.refreshTime}`
            : null}
        </>
      }
      placement="top"
    >
      <LightningIcon className="cursor-pointer" />
    </Tooltip>
  ) : null;
};
</file>

<file path="src/components/diagram/customNode/ViewNode.tsx">
import { memo, useCallback, useContext } from 'react';
import { Button, Typography } from 'antd';
import { MoreIcon, ViewIcon } from '@/utils/icons';
import { MORE_ACTION } from '@/utils/enum';
import { ComposeDiagram, ComposeDiagramField, DiagramView } from '@/utils/data';
import { getColumnTypeIcon } from '@/utils/columnType';
import { Config } from '@/utils/diagram';
import { makeIterable } from '@/utils/iteration';
import { DiagramContext } from '@/components/diagram/Context';
import {
  CustomNodeProps,
  NodeBody,
  NodeHeader,
  StyledNode,
} from '@/components/diagram/customNode/utils';
import MarkerHandle from '@/components/diagram/customNode/MarkerHandle';
import Column from '@/components/diagram/customNode/Column';
import { ViewDropdown } from '@/components/diagram/CustomDropdown';

const { Text } = Typography;

export const ViewNode = ({ data }: CustomNodeProps<DiagramView>) => {
  const context = useContext(DiagramContext);
  const onMoreClick = (type: MORE_ACTION) => {
    context?.onMoreClick({
      type,
      data: data.originalData,
    });
  };
  const onNodeClick = () => {
    context?.onNodeClick({
      data: data.originalData,
    });
  };

  const renderColumns = useCallback(
    (columns: ComposeDiagramField[]) =>
      getColumns(columns, data, { limit: Config.columnsLimit }),
    [data.highlight],
  );

  return (
    <StyledNode
      onClick={onNodeClick}
      data-testid={`diagram__view-node__${data.originalData.displayName}`}
    >
      <NodeHeader className="dragHandle" color="var(--green-6)">
        <span className="adm-model-header">
          <ViewIcon />
          <Text ellipsis title={data.originalData.displayName}>
            {data.originalData.displayName}
          </Text>
        </span>
        <span>
          <ViewDropdown onMoreClick={onMoreClick}>
            <Button
              className="gray-1"
              icon={<MoreIcon />}
              onClick={(event) => event.stopPropagation()}
              type="text"
              size="small"
            />
          </ViewDropdown>
        </span>

        <MarkerHandle id={data.originalData.id} />
      </NodeHeader>
      <NodeBody draggable={false}>
        {renderColumns(data.originalData.fields)}
      </NodeBody>
    </StyledNode>
  );
};

export default memo(ViewNode);

const ColumnTemplate = (props) => {
  const { id, type } = props;
  return <Column {...props} key={id} icon={getColumnTypeIcon({ type })} />;
};

const ColumnIterator = makeIterable(ColumnTemplate);

function getColumns(
  columns: ComposeDiagramField[],
  data: CustomNodeProps<ComposeDiagram>['data'],
  pagination?: { limit: number },
) {
  const moreCount = pagination ? columns.length - pagination.limit : 0;
  const slicedColumns = pagination
    ? columns.slice(0, pagination.limit)
    : columns;
  return (
    <>
      <ColumnIterator data={slicedColumns} highlight={data.highlight} />
      {moreCount > 0 && <Column.MoreTip count={moreCount} />}
    </>
  );
}
</file>

<file path="src/components/diagram/CustomPopover.tsx">
import { Popover, PopoverProps, Row, Col, Typography } from 'antd';

type Props = PopoverProps;

export default function CustomPopover(props: Props) {
  const { children } = props;

  return (
    <Popover {...props} mouseLeaveDelay={0} overlayStyle={{ maxWidth: 520 }}>
      {children}
    </Popover>
  );
}

const CustomPopoverCol = (props: {
  title: string;
  children: React.ReactNode;
  code?: boolean;
  span?: number;
  marginBottom?: number;
}) => {
  const { title, children, code, span = 24, marginBottom = 8 } = props;
  return (
    <Col span={span}>
      <div className="gray-7 mb-0">{title}</div>
      <div style={{ marginBottom }}>
        <Typography.Text code={code}>{children}</Typography.Text>
      </div>
    </Col>
  );
};

CustomPopover.Row = Row;
CustomPopover.Col = CustomPopoverCol;
</file>

<file path="src/components/diagram/index.tsx">
import {
  ForwardedRef,
  forwardRef,
  useCallback,
  useEffect,
  useImperativeHandle,
  useMemo,
  useState,
} from 'react';
import ReactFlow, {
  MiniMap,
  Background,
  Controls,
  ControlButton,
  useNodesState,
  useEdgesState,
  Edge,
  useReactFlow,
  ReactFlowProvider,
} from 'reactflow';
import { ModelNode, ViewNode } from './customNode';
import { ModelEdge } from './customEdge';
import Marker from './Marker';
import { DiagramContext, ClickPayload } from './Context';
import { trimId, highlightNodes, highlightEdges } from './utils';
import { Diagram as DiagramData } from '@/utils/data';
import { RefreshIcon } from '@/utils/icons';
import { EDGE_TYPE, NODE_TYPE } from '@/utils/enum';
import { DiagramCreator } from '@/utils/diagram';
import { nextTick } from '@/utils/time';

import 'reactflow/dist/style.css';

const nodeTypes = {
  [NODE_TYPE.MODEL]: ModelNode,
  [NODE_TYPE.VIEW]: ViewNode,
};
const edgeTypes = {
  [EDGE_TYPE.MODEL]: ModelEdge,
};
const minimapStyle = {
  height: 120,
};

interface Props {
  forwardRef?: ForwardedRef<unknown>;
  data: DiagramData;
  onMoreClick: (data: ClickPayload) => void;
  onNodeClick: (data: ClickPayload) => void;
  onAddClick: (data: ClickPayload) => void;
}

const ReactFlowDiagram = forwardRef(function ReactFlowDiagram(
  props: Props,
  ref,
) {
  const { data, onMoreClick, onNodeClick, onAddClick } = props;
  const [forceRender, setForceRender] = useState(false);
  const reactFlowInstance = useReactFlow();
  useImperativeHandle(ref, () => reactFlowInstance, [reactFlowInstance]);

  const diagram = useMemo(() => {
    return new DiagramCreator(data).toJsonObject();
  }, [data]);

  useEffect(() => {
    setNodes(diagram.nodes);
    setEdges(diagram.edges);

    nextTick(50).then(() => reactFlowInstance.fitView());
  }, [diagram]);

  const [nodes, setNodes, onNodesChange] = useNodesState(diagram.nodes);
  const [edges, setEdges, onEdgesChange] = useEdgesState(diagram.edges);

  const onEdgeMouseEnter = useCallback(
    (_event: React.MouseEvent, edge: Edge) => {
      setEdges(highlightEdges([edge.id], true));
      setNodes(
        highlightNodes(
          [edge.source, edge.target],
          [
            trimId(edge.sourceHandle as string),
            trimId(edge.targetHandle as string),
          ],
        ),
      );
    },
    [],
  );

  const onEdgeMouseLeave = useCallback(
    (_event: React.MouseEvent, _edge: Edge) => {
      setEdges(highlightEdges([], false));
      setNodes(highlightNodes([], []));
    },
    [],
  );

  const onRestore = async () => {
    setNodes(diagram.nodes);
    setEdges(diagram.edges);
  };

  const onInit = async () => {
    await nextTick();
    reactFlowInstance.fitView();
    await nextTick(100);
    setForceRender(!forceRender);
  };

  const triggerMouseDown = (event: React.MouseEvent | MouseEvent) => {
    const mouseDownEvent = new MouseEvent('mousedown', {
      bubbles: true,
      cancelable: true,
      clientX: event.clientX,
      clientY: event.clientY,
      button: 0,
    });
    document.dispatchEvent(mouseDownEvent);
  };

  const isTargetInDropdown = (target: EventTarget | null) => {
    const dropdowns = document.querySelectorAll('.ant-dropdown');
    return Array.from(dropdowns).some((dropdown) =>
      dropdown.contains(target as Node),
    );
  };

  const dispatchMouseEvent = (event: React.MouseEvent | MouseEvent) => {
    if (!event.isTrusted || isTargetInDropdown(event.target)) return;
    triggerMouseDown(event);
  };

  return (
    <>
      <DiagramContext.Provider value={{ onMoreClick, onNodeClick, onAddClick }}>
        <ReactFlow
          nodes={nodes}
          edges={edges}
          onNodesChange={onNodesChange}
          onEdgesChange={onEdgesChange}
          onEdgeMouseEnter={onEdgeMouseEnter}
          onEdgeMouseLeave={onEdgeMouseLeave}
          onInit={onInit}
          nodeTypes={nodeTypes}
          edgeTypes={edgeTypes}
          maxZoom={1}
          onPointerDown={(event) => dispatchMouseEvent(event)}
          proOptions={{ hideAttribution: true }}
        >
          <MiniMap style={minimapStyle} zoomable pannable />
          <Controls showInteractive={false}>
            <ControlButton onClick={onRestore}>
              <RefreshIcon style={{ maxWidth: 24, maxHeight: 24 }} />
            </ControlButton>
          </Controls>
          <Background gap={16} />
        </ReactFlow>
      </DiagramContext.Provider>

      <Marker />
    </>
  );
});

const Diagram = (props: Props) => {
  return (
    <ReactFlowProvider>
      <ReactFlowDiagram ref={props.forwardRef} {...props} />
    </ReactFlowProvider>
  );
};

export default Diagram;
</file>

<file path="src/components/diagram/Marker.tsx">
export default function Marker() {
  // This is only used to embed definitions which can reused inside an svg image.
  return (
    <svg
      style={{
        position: 'absolute',
        top: 0,
        left: 0,
        width: 0,
        height: 0,
        zIndex: -1,
      }}
    >
      <defs>
        <marker
          id="many_right"
          viewBox="0 0 14 22"
          markerHeight={14}
          markerWidth={14}
          refX={0}
          refY={11}
        >
          <path
            fillRule="evenodd"
            clipRule="evenodd"
            d="M9.28866 10L6.49577e-06 2.33206L1.4329e-05 -1.18499e-06L13.5547 11L2.869e-06 22L3.07287e-06 19.668L9.28864 12L5.65057e-06 12L5.82542e-06 10L9.28866 10Z"
            fill="#b1b1b7"
          />
        </marker>
        <marker
          id="many_left"
          viewBox="0 0 14 22"
          markerHeight={14}
          markerWidth={14}
          refX={14}
          refY={11}
        >
          <path
            fillRule="evenodd"
            clipRule="evenodd"
            d="M4.26603 12L13.5547 19.6679L13.5547 22L0 11L13.5547 0V2.33204L4.26605 10L13.5547 10V12L4.26603 12Z"
            fill="#b1b1b7"
          />
        </marker>
        <marker
          id="one_right"
          viewBox="0 0 14 22"
          markerHeight={14}
          markerWidth={14}
          refX={-4}
          refY={11}
        >
          <rect
            width="1400"
            height="993"
            transform="translate(-407 -263)"
            fill="none"
          />
          <rect x="6" width="2" height="22" fill="#b1b1b7" />
        </marker>
        <marker
          id="one_left"
          viewBox="0 0 14 22"
          markerHeight={14}
          markerWidth={14}
          refX={18}
          refY={11}
        >
          <rect
            width="1400"
            height="993"
            transform="translate(-407 -263)"
            fill="none"
          />
          <rect x="6" width="2" height="22" fill="#b1b1b7" />
        </marker>

        {/* seleceted */}
        <marker
          id="many_right_selected"
          viewBox="0 0 18 32"
          markerHeight={18}
          markerWidth={18}
          refX={0}
          refY={16}
        >
          <path
            fillRule="evenodd"
            clipRule="evenodd"
            d="M13.4161 4.94444L13.2993 8H14.7007L14.5839 4.94444L17.2993 6.58333L18 5.41667L15.1387 4L18 2.58333L17.2993 1.41667L14.5839 3.05556L14.7007 0H13.2993L13.4161 3.05556L10.7007 1.41667L10 2.58333L12.8613 4L10 5.41667L10.7007 6.58333L13.4161 4.94444ZM3.63475e-06 7.33206L9.28865 15L2.9644e-06 15L2.78955e-06 17L9.28863 17L0 24.668V27L13.5547 16L1.1468e-05 5L3.63475e-06 7.33206Z"
            fill="#2F54EB"
          />
        </marker>
        <marker
          id="many_left_selected"
          viewBox="0 0 18 32"
          markerHeight={18}
          markerWidth={18}
          refX={18}
          refY={16}
        >
          <path
            fillRule="evenodd"
            clipRule="evenodd"
            d="M3.41606 4.94444L3.29927 8H4.70073L4.58394 4.94444L7.29927 6.58333L8 5.41667L5.13869 4L8 2.58333L7.29927 1.41667L4.58394 3.05556L4.70073 0H3.29927L3.41606 3.05556L0.70073 1.41667L0 2.58333L2.86131 4L0 5.41667L0.70073 6.58333L3.41606 4.94444ZM17.8899 24.6679L8.60127 17H17.8899V15H8.60129L17.8899 7.33204V5L4.33524 16L17.8899 27L17.8899 24.6679Z"
            fill="#2F54EB"
          />
        </marker>
        <marker
          id="one_right_selected"
          viewBox="0 0 16 32"
          markerHeight={16}
          markerWidth={16}
          refX={0}
          refY={16}
        >
          <path
            fillRule="evenodd"
            clipRule="evenodd"
            d="M16 8V0H15.0211L13 1.32812V2.3125L14.9737 1.01563H15.0211V8H16ZM8.63351 5H6.63351V27H8.63351V5Z"
            fill="#2F54EB"
          />
        </marker>
        <marker
          id="one_left_selected"
          viewBox="0 0 16 32"
          markerHeight={16}
          markerWidth={16}
          refX={18}
          refY={16}
        >
          <path
            fillRule="evenodd"
            clipRule="evenodd"
            d="M3 8V0H2.02105L0 1.32812V2.3125L1.97368 1.01563H2.02105V8H3ZM9 5H7V27H9V5Z"
            fill="#2F54EB"
          />
        </marker>
      </defs>
    </svg>
  );
}
</file>

<file path="src/components/diagram/utils.ts">
export const trimId = (id: string) => id.split('_')[0];

export const highlightEdges = (edgeIds: string[], highlight: boolean) => {
  return (edges: any) =>
    edges.map((edge: any) => {
      const selected = '_selected';
      const markerStart = edge.markerStart.replace(selected, '');
      const markerEnd = edge.markerEnd.replace(selected, '');
      return edgeIds.includes(edge.id)
        ? {
            ...edge,
            data: { ...edge.data, highlight },
            markerStart: markerStart + selected,
            markerEnd: markerEnd + selected,
          }
        : {
            ...edge,
            data: { ...edge.data, highlight: false },
            markerStart,
            markerEnd,
          };
    });
};

export const highlightNodes = (nodeIds: string[], highlight: string[]) => {
  return (nodes: any) =>
    nodes.map((node: any) =>
      nodeIds.includes(node.id)
        ? { ...node, data: { ...node.data, highlight } }
        : { ...node, data: { ...node.data, highlight: [] } },
    );
};
</file>

<file path="src/components/EditableWrapper.tsx">
import { createContext, useContext, useEffect, useRef, useState } from 'react';
import { Input, InputRef, Form, FormInstance } from 'antd';
import styled from 'styled-components';
import { get } from 'lodash';
import EllipsisWrapper from '@/components/EllipsisWrapper';

interface Props {
  children: React.ReactNode;
  dataIndex: string;
  record: any;
  rules?: any[];
  handleSave: (id: string | number, value: { [key: string]: string }) => void;
}

const EditableStyle = styled.div`
  line-height: 24px;
  min-height: 25px;

  .editable-cell-value-wrap {
    padding: 0 7px;
    border: 1px var(--gray-4) solid;
    border-radius: 4px;
    cursor: pointer;

    &:hover {
      border-color: var(--gray-5);
    }
  }
  .ant-form-item-control-input {
    min-height: 24px;
    .ant-input {
      line-height: 24px;
    }
  }
`;

export const EditableContext = createContext<FormInstance<any> | null>(null);

export default function EditableWrapper(props: Props) {
  const { children, dataIndex, record, rules, handleSave } = props;

  const [editing, setEditing] = useState(false);
  const textRef = useRef<HTMLDivElement>(null);
  const inputWidth = useRef(0);
  const inputRef = useRef<InputRef>(null);
  const form = useContext(EditableContext);
  const dataIndexKey = Array.isArray(dataIndex)
    ? dataIndex.join('.')
    : dataIndex;

  useEffect(() => {
    if (editing) inputRef.current!.focus();
  }, [editing]);

  const toggleEdit = () => {
    if (textRef.current) inputWidth.current = textRef.current.clientWidth;
    setEditing(!editing);
    const value = get(record, dataIndexKey);
    form.setFieldsValue({ [dataIndexKey]: value });
  };

  const save = async () => {
    try {
      const values = await form.validateFields();

      toggleEdit();
      handleSave(record.id, values);
    } catch (errInfo) {
      console.log('Save failed:', errInfo);
    }
  };

  const childNode = editing ? (
    <Form.Item style={{ margin: 0 }} name={dataIndexKey} rules={rules}>
      <Input
        size="small"
        ref={inputRef}
        onPressEnter={save}
        onBlur={save}
        style={{ width: inputWidth.current }}
      />
    </Form.Item>
  ) : (
    <div
      ref={textRef}
      className="editable-cell-value-wrap"
      style={{ paddingRight: 24 }}
      onClick={toggleEdit}
    >
      <EllipsisWrapper text={children as string} />
    </div>
  );

  return <EditableStyle>{childNode}</EditableStyle>;
}
</file>

<file path="src/components/editor/AceEditor.tsx">
import AceEditor from 'react-ace';

import 'ace-builds/src-noconflict/mode-sql';
import 'ace-builds/src-noconflict/mode-json';
import 'ace-builds/src-noconflict/theme-tomorrow';
import 'ace-builds/src-noconflict/ext-language_tools';

export default AceEditor;
</file>

<file path="src/components/editor/MarkdownBlock.tsx">
import styled from 'styled-components';
import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';

const ReactMarkdownBlock = styled(ReactMarkdown)`
  h1,
  h2,
  h3,
  h4,
  h5,
  h6 {
    color: var(--gray-10);
    margin-bottom: 8px;
  }
  h1 {
    font-size: 20px;
  }
  h2 {
    font-size: 18px;
  }
  h3 {
    font-size: 16px;
  }
  h4 {
    font-size: 14px;
  }
  hr {
    border-top: 1px solid var(--gray-5);
    border-bottom: none;
    border-left: none;
    border-right: none;
    margin: 18px 0;
  }
  pre {
    background-color: var(--gray-2);
    border: 1px var(--gray-4) solid;
    padding: 16px;
    border-radius: 4px;
  }
  table td,
  table th {
    border: 1px solid var(--gray-4);
    padding: 4px 8px;
  }
  table th {
    background-color: var(--gray-2);
    font-weight: 600;
  }
  table {
    border: 1px solid var(--gray-4);
    border-collapse: collapse;
    margin-bottom: 16px;
  }
  ol,
  ul,
  dl {
    padding-inline-start: 20px;
  }
  h1 code,
  h2 code,
  h3 code,
  h4 code,
  li code,
  p code {
    font-size: 12px;
    background: var(--gray-4);
    color: var(--gray-8);
    padding: 2px 4px;
    border-radius: 4px;
  }
`;

export default function MarkdownBlock(props: { content: string }) {
  return (
    <ReactMarkdownBlock remarkPlugins={[remarkGfm]}>
      {props.content}
    </ReactMarkdownBlock>
  );
}
</file>

<file path="src/components/editor/MarkdownEditor.tsx">
import clsx from 'clsx';
import { Button, Mentions, Typography } from 'antd';
import styled from 'styled-components';
import { useState, useContext, useRef } from 'react';
import ReadOutlined from '@ant-design/icons/ReadOutlined';
import EditOutlined from '@ant-design/icons/EditOutlined';
import { nextTick } from '@/utils/time';
import { Mention } from '@/hooks/useAutoComplete';
import { FormItemInputContext } from 'antd/lib/form/context';
import MarkdownBlock from './MarkdownBlock';

const Wrapper = styled.div`
  transition: all 0.3s cubic-bezier(0.645, 0.045, 0.355, 1);

  &:hover {
    border-color: var(--geekblue-5) !important;
  }

  &.adm-markdown-editor-error {
    border-color: var(--red-5) !important;

    .adm-markdown-editor-length {
      color: var(--red-5) !important;
    }
  }
  &:not(.adm-markdown-editor-error).adm-markdown-editor-focused {
    border-color: var(--geekblue-5) !important;
    box-shadow: 0 0 0 2px rgba(47, 84, 235, 0.2);
  }

  &.adm-markdown-editor-focused.adm-markdown-editor-error {
    borer-color: var(--red-4) !important;
    box-shadow: 0 0 0 2px rgba(255, 77, 79, 0.2);
  }
`;

const OverflowContainer = styled.div`
  overflow-y: auto;
  max-height: 318px;
`;

const LinkButton = styled(Button)`
  color: var(--gray-7);
`;

const StyledTextArea = styled(Mentions)`
  border: none;
  border-radius: 0;

  textarea {
    padding: 16px 16px 16px 20px;
  }
`;

interface Props {
  value?: string;
  onChange?: (value: string) => void;
  maxLength?: number;
  autoFocus?: boolean;
  mentions?: Mention[];
}

const MENTION_PREFIX = '@';

const MentionOption = (props: Mention) => {
  return (
    <Mentions.Option key={props.id} value={props.value}>
      <div className="d-flex align-center justify-space-between">
        <div className="d-flex align-center gray-8">
          {props.icon}
          <Typography.Text
            className="gray-8 mr-2"
            style={{ maxWidth: 240 }}
            ellipsis
          >
            {props.label}
          </Typography.Text>
        </div>
        {props.meta && (
          <div className="gray-6">
            <Typography.Text
              className="gray-6 text-sm mr-1"
              style={{ maxWidth: 240 }}
              ellipsis
            >
              ({props.meta})
            </Typography.Text>
            {props.nodeType}
          </div>
        )}
      </div>
    </Mentions.Option>
  );
};

export default function MarkdownEditor(props: Props) {
  const { value, onChange, maxLength, autoFocus, mentions } = props;
  const $wrapper = useRef<HTMLDivElement>(null);
  const $textarea = useRef<HTMLElement & { textarea: HTMLTextAreaElement }>(
    null,
  );
  const [focused, setFocused] = useState<boolean>(false);
  const [isPreviewMode, setIsPreviewMode] = useState<boolean>(false);

  const formItemContext = useContext(FormItemInputContext);
  const { status } = formItemContext;

  const change = (targetValue: string) => {
    onChange?.(targetValue);
  };

  const select = (option: Mention) => {
    const textarea = $textarea.current?.textarea;
    if (!textarea) return;

    // go to the start of the mention
    const mentionStart = (
      value?.slice(0, textarea.selectionStart) || ''
    ).lastIndexOf(MENTION_PREFIX);
    const start = mentionStart >= 0 ? mentionStart : textarea.selectionStart;
    const end = textarea.selectionEnd;
    const newValue = value?.slice(0, start) + option.value + value?.slice(end);
    // update the value and move the cursor
    onChange?.(newValue || '');
    nextTick().then(() => {
      textarea.selectionStart = textarea.selectionEnd =
        start + option.value.length;
    });
  };

  const keydown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
    if (e.key === 'Tab') {
      e.preventDefault();
      const textarea = e.currentTarget;
      const start = textarea.selectionStart;
      const end = textarea.selectionEnd;
      // Set the value with a tab character or spaces
      const tabCharacter = '  '; // Use '\t' for a tab character or spaces for spaces
      const newValue =
        value?.slice(0, start) + tabCharacter + value?.slice(end);
      // update the value and move the cursor
      onChange?.(newValue || '');
      nextTick().then(() => {
        textarea.selectionStart = textarea.selectionEnd =
          start + tabCharacter.length;
      });
    }
    if (e.key === '`') {
      const textarea = e.currentTarget;
      const start = textarea.selectionStart;
      const end = textarea.selectionEnd;

      if (start !== end) {
        e.preventDefault();
        const selection = `\`${value?.slice(start, end)}\``;
        const newValue = value?.slice(0, start) + selection + value?.slice(end);
        // update the value and move the cursor
        onChange?.(newValue || '');
        nextTick().then(() => {
          textarea.selectionStart = textarea.selectionEnd =
            start + selection.length;
        });
      }
    }
    if (e.key === 'ArrowDown' || e.key === 'ArrowUp') {
      // check if the mention dropdown menu exist
      const dropdownMenu = $wrapper.current?.querySelector(
        '.ant-mentions-dropdown-menu',
      );
      if (dropdownMenu) {
        // delay to make sure the menu active item is rendered
        nextTick().then(() => {
          const activeItem = dropdownMenu.querySelector(
            '.ant-mentions-dropdown-menu-item-active',
          ) as HTMLLIElement;
          if (activeItem) {
            const menuRect = dropdownMenu.getBoundingClientRect();
            const activeRect = activeItem.getBoundingClientRect();
            // check if active item is outside viewport
            if (activeRect.bottom > menuRect.bottom) {
              // scroll down
              dropdownMenu.scrollTo({
                top:
                  dropdownMenu.scrollTop +
                  (activeRect.bottom - menuRect.bottom),
                behavior: 'smooth',
              });
            } else if (activeRect.top < menuRect.top) {
              // scroll up
              dropdownMenu.scrollTo({
                top: dropdownMenu.scrollTop - (menuRect.top - activeRect.top),
                behavior: 'smooth',
              });
            }
          }
        });
      }
    }
  };

  return (
    <Wrapper
      ref={$wrapper}
      className={clsx(
        'border border-gray-5 rounded overflow-hidden',
        status ? `adm-markdown-editor-${status}` : '',
        focused ? 'adm-markdown-editor-focused' : '',
      )}
      tabIndex={-1}
    >
      <div className="bg-gray-3 px-2 py-1 d-flex align-center justify-space-between">
        <div className="adm-markdown-editor-length gray-6 text-sm mr-2">
          {maxLength ? (
            <>
              {value?.length} / {maxLength} characters
            </>
          ) : (
            <>{value?.length} characters</>
          )}
        </div>
        <LinkButton
          icon={isPreviewMode ? <EditOutlined /> : <ReadOutlined />}
          type="link"
          size="small"
          onClick={() => setIsPreviewMode(!isPreviewMode)}
        >
          {isPreviewMode ? 'Edit mode' : 'Read mode'}
        </LinkButton>
      </div>
      <OverflowContainer className={clsx({ 'p-4': isPreviewMode })}>
        {isPreviewMode ? (
          <MarkdownBlock content={value} />
        ) : (
          <StyledTextArea
            ref={$textarea}
            rows={13}
            autoFocus={autoFocus}
            getPopupContainer={() => $wrapper?.current}
            onChange={change}
            onSelect={select}
            onKeyDown={keydown}
            onFocus={() => setFocused(true)}
            onBlur={() => setFocused(false)}
            value={value}
            prefix={MENTION_PREFIX}
            maxLength={maxLength}
          >
            {(mentions || []).map(MentionOption)}
          </StyledTextArea>
        )}
      </OverflowContainer>
    </Wrapper>
  );
}
</file>

<file path="src/components/editor/SQLEditor.tsx">
import clsx from 'clsx';
import { useState, useContext, useRef, useEffect } from 'react';
import styled from 'styled-components';
import AceEditor from '@/components/editor/AceEditor';
import { FormItemInputContext } from 'antd/lib/form/context';
import useAutoComplete from '@/hooks/useAutoComplete';

const Wrapper = styled.div`
  transition: all 0.3s cubic-bezier(0.645, 0.045, 0.355, 1);

  &:hover {
    border-color: var(--geekblue-5) !important;
  }

  &.adm-markdown-editor-error {
    border-color: var(--red-5) !important;

    .adm-markdown-editor-length {
      color: var(--red-5) !important;
    }
  }
  &:not(.adm-markdown-editor-error).adm-markdown-editor-focused {
    border-color: var(--geekblue-5) !important;
    box-shadow: 0 0 0 2px rgba(47, 84, 235, 0.2);
  }

  &.adm-markdown-editor-focused.adm-markdown-editor-error {
    borer-color: var(--red-4) !important;
    box-shadow: 0 0 0 2px rgba(255, 77, 79, 0.2);
  }
`;

const Toolbar = styled.div`
  color: var(--gray-8);
  background-color: var(--gray-3);
  border-bottom: 1px solid var(--gray-5);
  height: 32px;
  padding: 4px 8px;
  border-radius: 4px 4px 0px 0px;
`;

interface Props {
  value?: string;
  onChange?: (value: string) => void;
  autoFocus?: boolean;
  autoComplete?: boolean;
  toolbar?: React.ReactNode;
}

const getLangTools = () => {
  const { ace } = window as any;
  return ace ? ace.require('ace/ext/language_tools') : null;
};

export default function SQLEditor(props: Props) {
  const { value, onChange, autoFocus, autoComplete, toolbar } = props;
  const $wrapper = useRef<HTMLDivElement>(null);
  const [focused, setFocused] = useState<boolean>(false);

  const formItemContext = useContext(FormItemInputContext);
  const { status } = formItemContext;

  const completers = useAutoComplete({
    includeColumns: true,
    skip: !autoComplete,
  });

  const resetCompleters = () => {
    // clear custom completer
    const langTools = getLangTools();
    langTools?.setCompleters([
      langTools.keyWordCompleter,
      langTools.snippetCompleter,
      langTools.textCompleter,
    ]);
  };

  useEffect(() => {
    resetCompleters();
    if (!autoComplete || completers.length === 0) return;

    const langTools = getLangTools();
    const customCompleter = {
      getCompletions: (_editor, _session, _pos, _prefix, callback) => {
        callback(null, completers);
      },
    };
    langTools?.addCompleter(customCompleter);

    return () => resetCompleters();
  }, [focused, autoComplete, completers]);

  const [sql, setSql] = useState(value || '');

  const change = (sql) => {
    setSql(sql);
    onChange?.(sql);
  };

  return (
    <Wrapper
      ref={$wrapper}
      className={clsx(
        'border border-gray-5 rounded overflow-hidden',
        status ? `adm-markdown-editor-${status}` : '',
        focused ? 'adm-markdown-editor-focused' : '',
      )}
      tabIndex={-1}
    >
      {!!toolbar && <Toolbar>{toolbar}</Toolbar>}
      <AceEditor
        mode="sql"
        width="100%"
        height="300px"
        fontSize={14}
        theme="tomorrow"
        value={value || sql}
        onChange={change}
        onFocus={() => setFocused(true)}
        onBlur={() => setFocused(false)}
        name="sql_editor"
        editorProps={{ $blockScrolling: true }}
        enableLiveAutocompletion
        enableBasicAutocompletion
        showPrintMargin={false}
        focus={autoFocus}
      />
    </Wrapper>
  );
}
</file>

<file path="src/components/EllipsisWrapper.tsx">
import { ReactNode, useEffect, useRef, useState } from 'react';
import styled from 'styled-components';

interface Props {
  text?: string;
  children?: ReactNode;
  multipleLine?: number;
  minHeight?: number;
  showMoreCount?: boolean;
}

const Wrapper = styled.div<{ multipleLine?: number }>`
  overflow: hidden;
  text-overflow: ellipsis;
  ${(props) =>
    props.multipleLine
      ? `
  display: -webkit-box;
  -webkit-line-clamp: ${props.multipleLine};
  -webkit-box-orient: vertical;
`
      : `
  white-space: nowrap;
`}
`;

export default function EllipsisWrapper(props: Props) {
  const { text, multipleLine, minHeight, children, showMoreCount } = props;
  const ref = useRef<HTMLDivElement | null>(null);
  const stageRef = useRef<HTMLDivElement | null>(null);
  const [width, setWidth] = useState(undefined);
  const hasWidth = width !== undefined;
  // Stage for counting the children that will be shown
  const [stage, setStage] = useState([]);

  const isStageEnd = useRef(false);
  const calculateStageShow = () => {
    if (isStageEnd.current) return;
    const remainSpace = 60; // remain space for showing more tip
    const stageWidth = stageRef.current?.clientWidth;
    const canPrintNext = stageWidth < width - remainSpace;

    if (canPrintNext) {
      const hasMoreChildren = (children as ReactNode[]).length > stage.length;
      hasMoreChildren && setStage([...stage, children[stage.length]]);
    } else {
      setStage(stage.slice(0, stage.length - 1));
      isStageEnd.current = true;
    }
  };

  // Auto setup client width itself
  useEffect(() => {
    if (ref.current && !hasWidth) {
      const cellWidth = ref.current.clientWidth;
      cellWidth === 0 ? setWidth('auto') : setWidth(cellWidth);
    }

    // Reset state when unmount
    return () => {
      isStageEnd.current = false;
      setStage([]);
      setWidth(undefined);
    };
  }, []);

  // Only work when showMoreCount is provided
  useEffect(() => {
    if (!showMoreCount) return;
    // Run only once when showMoreCount is true
    if (stage.length === 0) {
      setStage([children[0]]);
      return;
    }
    calculateStageShow();
  }, [showMoreCount, stage]);

  const renderContent = () => {
    if (!children) return text || '-';

    // Turn another template if showMoreCount is provided
    if (showMoreCount) {
      const moreCount = (children as ReactNode[]).length - stage.length;
      return (
        <span className="d-inline-block" ref={stageRef}>
          {stage}
          {moreCount > 0 && <span className="gray-7">...{moreCount} more</span>}
        </span>
      );
    }

    return children;
  };

  // Convert to string if React pass its children as array type to props
  const title = Array.isArray(text) ? text.join('') : text;

  return (
    <Wrapper
      ref={ref}
      title={title}
      multipleLine={multipleLine}
      style={{ width, minHeight }}
    >
      {hasWidth ? renderContent() : null}
    </Wrapper>
  );
}
</file>

<file path="src/components/ErrorCollapse.tsx">
import { useState } from 'react';
import { Collapse } from 'antd';
import styled from 'styled-components';
import CaretRightOutlined from '@ant-design/icons/CaretRightOutlined';

const StyledCollapse = styled(Collapse)`
  .ant-collapse-item {
    > .ant-collapse-header {
      user-select: none;
      color: var(--gray-7);
      padding-left: 0;
      padding-right: 0;
      padding-top: 0;
      padding-bottom: 0;

      .ant-collapse-arrow {
        margin-right: 8px;
      }
    }
    > .ant-collapse-content .ant-collapse-content-box {
      color: var(--gray-7);
      padding: 4px 0 0 0;
    }
  }
`;

interface Props {
  message: string;
  className?: string;
  defaultActive?: boolean;
}

export default function ErrorCollapse(props: Props) {
  const { message, className, defaultActive } = props;
  const [activeKey, setActiveKey] = useState<string[]>(
    defaultActive ? ['1'] : [],
  );

  return (
    <StyledCollapse
      className={className}
      ghost
      activeKey={activeKey}
      onChange={(key) => setActiveKey(key as string[])}
      expandIcon={({ isActive }) => (
        <CaretRightOutlined rotate={isActive ? 90 : 0} />
      )}
    >
      <Collapse.Panel key="1" header="Show error messages">
        <pre className="text-sm mb-0 pl-5" style={{ whiteSpace: 'pre-wrap' }}>
          {message}
        </pre>
      </Collapse.Panel>
    </StyledCollapse>
  );
}
</file>

<file path="src/components/HeaderBar.tsx">
import { useRouter } from 'next/router';
import { Button, Layout, Space } from 'antd';
import styled from 'styled-components';
import LogoBar from '@/components/LogoBar';
import { Path } from '@/utils/enum';
import Deploy from '@/components/deploy/Deploy';

const { Header } = Layout;

const StyledButton = styled(Button)<{ $isHighlight: boolean }>`
  background: ${(props) =>
    props.$isHighlight ? 'rgba(255, 255, 255, 0.20)' : 'transparent'};
  font-weight: ${(props) => (props.$isHighlight ? '700' : 'normal')};
  border: none;
  color: var(--gray-1);

  &:hover,
  &:focus {
    background: ${(props) =>
      props.$isHighlight
        ? 'rgba(255, 255, 255, 0.20)'
        : 'rgba(255, 255, 255, 0.05)'};
    color: var(--gray-1);
  }
`;

const StyledHeader = styled(Header)`
  height: 48px;
  border-bottom: 1px solid var(--gray-5);
  background: var(--gray-10);
  padding: 10px 16px;
`;

export default function HeaderBar() {
  const router = useRouter();
  const { pathname } = router;
  const showNav = !pathname.startsWith(Path.Onboarding);
  const isModeling = pathname.startsWith(Path.Modeling);

  return (
    <StyledHeader>
      <div
        className="d-flex justify-space-between align-center"
        style={{ marginTop: -2 }}
      >
        <Space size={[48, 0]}>
          <LogoBar />
          {showNav && (
            <Space size={[16, 0]}>
              <StyledButton
                shape="round"
                size="small"
                $isHighlight={pathname.startsWith(Path.Home)}
                onClick={() => router.push(Path.Home)}
              >
                Home
              </StyledButton>
              <StyledButton
                shape="round"
                size="small"
                $isHighlight={pathname.startsWith(Path.Modeling)}
                onClick={() => router.push(Path.Modeling)}
              >
                Modeling
              </StyledButton>
              <StyledButton
                shape="round"
                size="small"
                $isHighlight={pathname.startsWith(Path.Knowledge)}
                onClick={() => router.push(Path.KnowledgeQuestionSQLPairs)}
              >
                Knowledge
              </StyledButton>
              <StyledButton
                shape="round"
                size="small"
                $isHighlight={pathname.startsWith(Path.APIManagement)}
                onClick={() => router.push(Path.APIManagementHistory)}
              >
                API
              </StyledButton>
            </Space>
          )}
        </Space>
        {isModeling && (
          <Space size={[16, 0]}>
            <Deploy />
          </Space>
        )}
      </div>
    </StyledHeader>
  );
}
</file>

<file path="src/components/layouts/PageLayout.tsx">
import { Typography } from 'antd';

interface PageLayoutProps {
  title: string | React.ReactNode;
  description?: string | React.ReactNode;
  children: React.ReactNode;
  titleExtra?: string | React.ReactNode;
}

export default function PageLayout(props: PageLayoutProps) {
  const { title, titleExtra, description, children } = props;
  return (
    <div className="px-6 py-4">
      <div className="d-flex align-center justify-space-between mb-3">
        <Typography.Title level={4} className="text-medium gray-8 mb-0">
          {title}
        </Typography.Title>
        {titleExtra}
      </div>
      {description && (
        <Typography.Text className="gray-7">{description}</Typography.Text>
      )}
      <div className="mt-3">{children}</div>
    </div>
  );
}
</file>

<file path="src/components/layouts/SiderLayout.tsx">
import { Layout } from 'antd';
import styled, { css } from 'styled-components';
import SimpleLayout from '@/components/layouts/SimpleLayout';
import Sidebar from '@/components/sidebar';
import Settings from '@/components/settings';
import useModalAction from '@/hooks/useModalAction';

const { Sider } = Layout;

const basicStyle = css`
  height: calc(100vh - 48px);
  overflow: auto;
`;

const StyledContentLayout = styled(Layout)<{ color?: string }>`
  position: relative;
  ${basicStyle}
  ${(props) => props.color && `background-color: var(--${props.color});`}
`;

const StyledSider = styled(Sider)`
  ${basicStyle}
`;

type Props = React.ComponentProps<typeof SimpleLayout> & {
  sidebar?: React.ComponentProps<typeof Sidebar>;
  color?: string;
};

export default function SiderLayout(props: Props) {
  const { sidebar, loading, color } = props;
  const settings = useModalAction();

  return (
    <SimpleLayout loading={loading}>
      <Layout className="adm-layout">
        <StyledSider width={280}>
          <Sidebar {...sidebar} onOpenSettings={settings.openModal} />
        </StyledSider>
        <StyledContentLayout color={color}>
          {props.children}
        </StyledContentLayout>
      </Layout>
      <Settings {...settings.state} onClose={settings.closeModal} />
    </SimpleLayout>
  );
}
</file>

<file path="src/components/layouts/SimpleLayout.tsx">
import { Layout } from 'antd';
import HeaderBar from '@/components/HeaderBar';
import PageLoading from '@/components/PageLoading';
import { useWithOnboarding } from '@/hooks/useCheckOnboarding';
import clsx from 'clsx';

const { Content } = Layout;

interface Props {
  children: React.ReactNode;
  loading?: boolean;
}

export default function SimpleLayout(props: Props) {
  const { loading: fetching } = useWithOnboarding();
  const { children, loading } = props;
  const pageLoading = fetching || loading;
  return (
    <Layout
      className={clsx('adm-main bg-gray-3', {
        'overflow-hidden': pageLoading,
      })}
    >
      <HeaderBar />
      <Content className="adm-content">{children}</Content>
      <PageLoading visible={pageLoading} />
    </Layout>
  );
}
</file>

<file path="src/components/learning/guide/index.tsx">
import { driver } from 'driver.js';
import { useRouter } from 'next/router';
import {
  forwardRef,
  useEffect,
  useImperativeHandle,
  useMemo,
  useRef,
} from 'react';
import { Dispatcher, DriverObj } from './utils';
import { makeStoriesPlayer } from './stories';
import { useGetSettingsQuery } from '@/apollo/client/graphql/settings.generated';

import 'driver.js/dist/driver.css';

interface Props {}

interface Attributes {
  play: (id: string, dispatcher: Dispatcher) => void;
}

export default forwardRef<Attributes, Props>(function Guide(_props, ref) {
  const router = useRouter();
  const $driver = useRef<DriverObj>(null);

  const { data: settingsResult } = useGetSettingsQuery();
  const storyPayload = useMemo(() => {
    return {
      sampleDataset: settingsResult?.settings?.dataSource.sampleDataset,
      language: settingsResult?.settings?.language,
    };
  }, [settingsResult?.settings]);

  useEffect(() => {
    if ($driver.current !== null) return;
    $driver.current = driver();
    return () => {
      $driver.current.destroy();
      $driver.current = null;
    };
  }, []);

  const play = (id: string, dispatcher: Dispatcher) => {
    const playStoryWithId = makeStoriesPlayer(
      $driver.current,
      router,
      storyPayload,
    );
    playStoryWithId(id, dispatcher);
  };

  useImperativeHandle(ref, () => ({ play }), [
    $driver.current,
    storyPayload,
    router,
  ]);

  return null;
});
</file>

<file path="src/components/learning/guide/stories.tsx">
import { useState } from 'react';
import { createRoot } from 'react-dom/client';
import { NextRouter } from 'next/router';
import { Select } from 'antd';
import styled from 'styled-components';
import { ModelIcon, TranslateIcon } from '@/utils/icons';
import { RobotSVG } from '@/utils/svgs';
import { renderToString } from 'react-dom/server';
import {
  Dispatcher,
  DriverConfig,
  DriverObj,
  DriverPopoverDOM,
  LEARNING,
} from './utils';
import { Path } from '@/utils/enum';
import {
  ProjectLanguage,
  SampleDatasetName,
} from '@/apollo/client/graphql/__types__';
import { TEMPLATE_OPTIONS as SAMPLE_DATASET_INFO } from '@/components/pages/setup/utils';
import { getLanguageText } from '@/utils/language';
import * as events from '@/utils/events';
import { nextTick } from '@/utils/time';

const RobotIcon = styled(RobotSVG)`
  width: 24px;
  height: 24px;
`;

const defaultConfigs: DriverConfig = {
  progressText: '{{current}} / {{total}}',
  nextBtnText: 'Next',
  prevBtnText: 'Previous',
  showButtons: ['next'],
  allowClose: false,
};

type StoryPayload = {
  sampleDataset: SampleDatasetName;
  language: ProjectLanguage;
};

export const makeStoriesPlayer =
  (...args: [DriverObj, NextRouter, StoryPayload]) =>
  (id: string, dispatcher: Dispatcher) => {
    const action =
      {
        [LEARNING.DATA_MODELING_GUIDE]: () =>
          playDataModelingGuide(...args, dispatcher),
        [LEARNING.SWITCH_PROJECT_LANGUAGE]: () =>
          playSwitchProjectLanguageGuide(...args, dispatcher),
        [LEARNING.KNOWLEDGE_GUIDE]: () =>
          playKnowledgeGuide(...args, dispatcher),
        [LEARNING.SAVE_TO_KNOWLEDGE]: () =>
          playSaveToKnowledgeGuide(...args, dispatcher),
      }[id] || null;
    return action && action();
  };

const resetPopoverStyle = (popoverDom: DriverPopoverDOM, width: number) => {
  const wrapper = popoverDom.wrapper;
  wrapper.style.maxWidth = 'none';
  wrapper.style.width = `${width}px`;
};

const playDataModelingGuide = (
  $driver: DriverObj,
  router: NextRouter,
  payload: StoryPayload,
  dispatcher: Dispatcher,
) => {
  if ($driver === null) {
    console.error('Driver object is not initialized.');
    return;
  }
  if ($driver.isActive()) $driver.destroy();

  const isSampleDataset = !!payload.sampleDataset;
  const sampleDatasetInfo = SAMPLE_DATASET_INFO[payload.sampleDataset];

  $driver.setConfig({ ...defaultConfigs, showProgress: true });
  $driver.setSteps([
    {
      popover: {
        title: renderToString(
          <div className="pt-4">
            <div className="-mx-4" style={{ minHeight: 331 }}>
              <img
                className="mb-4"
                src="/images/learning/data-modeling.jpg"
                alt="data-modeling-guide"
              />
            </div>
            Data modeling guide
          </div>,
        ),
        description: renderToString(
          <>
            Data modeling adds a logical layer over your original data schema,
            organizing relationships, semantics, and calculations. This helps AI
            align with business logic, retrieve precise data, and generate
            meaningful insights.{' '}
            <a
              href="https://docs.getwren.ai/oss/guide/modeling/overview"
              target="_blank"
              rel="noopener noreferrer"
            >
              More details
            </a>
            <br />
            <br />
            {isSampleDataset ? (
              <>
                We use {sampleDatasetInfo.label} Dataset to present the guide.
                To know more, please visit{' '}
                <a
                  href={sampleDatasetInfo.guide}
                  target="_blank"
                  rel="noopener noreferrer"
                >
                  about the {sampleDatasetInfo.label} Dataset.
                </a>
              </>
            ) : null}
          </>,
        ),
        showButtons: ['next', 'close'],
        onPopoverRender: (popoverDom: DriverPopoverDOM) => {
          resetPopoverStyle(popoverDom, 720);
        },
        onCloseClick: () => {
          $driver.destroy();
          window.sessionStorage.setItem('skipDataModelingGuide', '1');
        },
      },
    },
    {
      element: '[data-guideid="add-model"]',
      popover: {
        title: renderToString(
          <>
            <div className="mb-1">
              <ModelIcon style={{ fontSize: 24 }} />
            </div>
            Create a model
          </>,
        ),
        description: renderToString(
          <>Click the add icon to start create your first model.</>,
        ),
      },
    },
    {
      element: '[data-guideid="edit-model-0"]',
      popover: {
        title: renderToString(
          <>
            <div className="-mx-4" style={{ minHeight: 175 }}>
              <img
                className="mb-2"
                src="/images/learning/edit-model.gif"
                alt="edit-model"
              />
            </div>
            Edit a model
          </>,
        ),
        description: renderToString(
          <>Click the more icon to update the columns of model or delete it.</>,
        ),
      },
    },
    {
      element: '[data-guideid="model-0"]',
      popover: {
        title: renderToString(
          <>
            <div className="-mx-4" style={{ minHeight: 214 }}>
              <img
                className="mb-2"
                src="/images/learning/edit-metadata.gif"
                alt="edit-metadata"
              />
            </div>
            Edit metadata
          </>,
        ),
        description: renderToString(
          <>
            You could edit alias (alternative name) and descriptions of models
            and columns.
          </>,
        ),
        onPopoverRender: (popoverDom: DriverPopoverDOM) => {
          resetPopoverStyle(popoverDom, 360);
        },
      },
    },
    {
      element: '[data-guideid="deploy-model"]',
      popover: {
        title: renderToString(
          <>
            <div className="-mx-4" style={{ minHeight: 102 }}>
              <img
                className="mb-2"
                src="/images/learning/deploy-modeling.jpg"
                alt="deploy-modeling"
              />
            </div>
            Deploy modeling
          </>,
        ),
        description: renderToString(
          <>After editing the models, remember to deploy the changes.</>,
        ),
      },
    },
    {
      popover: {
        title: renderToString(
          <>
            <div className="-mx-4" style={{ minHeight: 331 }}>
              <img
                className="mb-2"
                src="/images/learning/ask-question.jpg"
                alt="ask-question"
              />
            </div>
            Ask questions
          </>,
        ),
        description: renderToString(
          <>
            When you finish editing your models, you can visit “Home” and start
            asking questions.
          </>,
        ),
        onPopoverRender: (popoverDom: DriverPopoverDOM) => {
          resetPopoverStyle(popoverDom, 720);
        },
        doneBtnText: 'Go to Home',
        onNextClick: () => {
          router.push(Path.Home);
          $driver.destroy();
          dispatcher?.onDone && dispatcher.onDone();
        },
      },
    },
  ]);
  events.dispatch(events.EVENT_NAME.GO_TO_FIRST_MODEL);
  $driver.drive();
};

// React component for home guide
const LanguageSwitcher = (props: { defaultValue: ProjectLanguage }) => {
  const [value, setValue] = useState(props.defaultValue);
  const languageOptions = Object.keys(ProjectLanguage).map((key) => {
    return { label: getLanguageText(key as ProjectLanguage), value: key };
  });
  const onChange = (value: string) => {
    setValue(value as ProjectLanguage);
  };

  return (
    <>
      <label className="d-block mb-2">Project language</label>
      <Select
        showSearch
        style={{ width: '100%' }}
        options={languageOptions}
        getPopupContainer={(trigger) => trigger.parentElement}
        onChange={onChange}
        value={value}
      />
      <input name="language" type="hidden" value={value} />
    </>
  );
};

const playSwitchProjectLanguageGuide = (
  $driver: DriverObj,
  _router: NextRouter,
  payload: StoryPayload,
  dispatcher: Dispatcher,
) => {
  if ($driver === null) {
    console.error('Driver object is not initialized.');
    return;
  }
  if ($driver.isActive()) $driver.destroy();

  $driver.setConfig({ ...defaultConfigs, showProgress: false });
  $driver.setSteps([
    {
      popover: {
        title: renderToString(
          <>
            <div className="mb-1">
              <TranslateIcon style={{ fontSize: 24 }} />
            </div>
            Switch the language
          </>,
        ),
        description: renderToString(
          <>
            Choose your preferred language. Once set up, AI will respond in your
            chosen language.
            <div className="my-3">
              <div id="projectLanguageContainer" />
            </div>
            You can go to project settings to change it if you change your mind.
          </>,
        ),
        onPopoverRender: (popoverDom: DriverPopoverDOM) => {
          resetPopoverStyle(popoverDom, 400);
          // Render react component to #projectLanguageContainer
          const selectDom = document.getElementById('projectLanguageContainer');
          if (selectDom) {
            createRoot(selectDom).render(
              <LanguageSwitcher defaultValue={payload.language} />,
            );
          }
        },
        showButtons: ['next', 'close'],
        nextBtnText: 'Submit',
        onCloseClick: () => {
          $driver.destroy();
          window.sessionStorage.setItem('skipSwitchProjectLanguageGuide', '1');
        },
        onNextClick: async () => {
          const selectDom = document.getElementById('projectLanguageContainer');
          if (selectDom) {
            const input = selectDom.querySelector(
              'input[name="language"]',
            ) as HTMLInputElement;
            const nextButton = document.querySelectorAll(
              '.driver-popover-next-btn',
            )[0];

            const loadingSvg = document.createElement('span');
            loadingSvg.setAttribute('aria-hidden', 'loading');
            loadingSvg.setAttribute('role', 'img');
            loadingSvg.className =
              'anticon anticon-loading anticon-spin text-sm gray-6 ml-2';
            loadingSvg.innerHTML = `<svg viewBox="0 0 1024 1024" focusable="false" data-icon="loading" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M988 548c-19.9 0-36-16.1-36-36 0-59.4-11.6-117-34.6-171.3a440.45 440.45 0 00-94.3-139.9 437.71 437.71 0 00-139.9-94.3C629 83.6 571.4 72 512 72c-19.9 0-36-16.1-36-36s16.1-36 36-36c69.1 0 136.2 13.5 199.3 40.3C772.3 66 827 103 874 150c47 47 83.9 101.8 109.7 162.7 26.7 63.1 40.2 130.2 40.2 199.3.1 19.9-16 36-35.9 36z"></path></svg>`;
            nextButton.setAttribute('disabled', 'true');
            nextButton.appendChild(loadingSvg);
            await dispatcher
              ?.onSaveLanguage(input.value as ProjectLanguage)
              .catch((err) => console.error(err))
              .finally(() => {
                nextButton.removeAttribute('disabled');
                nextButton.removeChild(loadingSvg);
              });
          }
          $driver.destroy();
          dispatcher?.onDone();
        },
      },
    },
  ]);
  $driver.drive();
};

const playKnowledgeGuide = (
  $driver: DriverObj,
  _router: NextRouter,
  _payload: StoryPayload,
  dispatcher: Dispatcher,
) => {
  if ($driver === null) {
    console.error('Driver object is not initialized.');
    return;
  }

  if ($driver.isActive()) $driver.destroy();

  $driver.setConfig({ ...defaultConfigs, showProgress: true });

  $driver.setSteps([
    {
      element: '[data-guideid="question-sql-pairs"]',
      popover: {
        title: renderToString(
          <div className="pt-4">
            <div className="-mx-4" style={{ minHeight: 317 }}>
              <img
                className="mb-4"
                src="/images/learning/save-to-knowledge.gif"
                alt="question-sql-pairs-guide"
              />
            </div>
            Build knowledge base: Question-SQL pairs
          </div>,
        ),
        description: renderToString(
          <>
            Create and manage <b>Question-SQL pairs</b> to refine Wren AI’s SQL
            generation. You can manually add pairs here or go to Home, ask a
            question, and save the correct answer to Knowledge. The more you
            save, the smarter Wren AI becomes!
          </>,
        ),
        onPopoverRender: (popoverDom: DriverPopoverDOM) => {
          resetPopoverStyle(popoverDom, 640);
        },
      },
    },
    {
      element: '[data-guideid="instructions"]',
      popover: {
        title: renderToString(
          <div className="pt-4">
            <div className="-mx-4" style={{ minHeight: 260 }}>
              <img
                className="mb-4"
                src="/images/learning/instructions.png"
                alt="instructions-guide"
              />
            </div>
            Build knowledge base: Instructions
          </div>,
        ),
        description: renderToString(
          <>
            In addition to Question-SQL pairs, you can create instructions to
            define <b>business rules</b> and <b>query logic</b>. These rules
            guide Wren AI in applying consistent filters, constraints, and best
            practices to SQL queries.
          </>,
        ),
        onPopoverRender: (popoverDom: DriverPopoverDOM) => {
          resetPopoverStyle(popoverDom, 520);
        },
        doneBtnText: 'Got it',
        onNextClick: () => {
          $driver.destroy();
          dispatcher?.onDone && dispatcher.onDone();
        },
      },
    },
  ]);
  $driver.drive();
};

const playSaveToKnowledgeGuide = async (
  $driver: DriverObj,
  _router: NextRouter,
  _payload: StoryPayload,
  dispatcher: Dispatcher,
) => {
  if ($driver === null) {
    console.error('Driver object is not initialized.');
    return;
  }
  if ($driver.isActive()) $driver.destroy();

  $driver.setConfig({ ...defaultConfigs, showProgress: false });

  const selectors = {
    saveToKnowledge:
      '[data-guideid="last-answer-result"] [data-guideid="save-to-knowledge"]',
    previewData:
      '[data-guideid="last-answer-result"] [data-guideid="text-answer-preview-data"]',
  };

  $driver.setSteps([
    {
      element: selectors.saveToKnowledge,
      popover: {
        side: 'top',
        align: 'start',
        title: renderToString(
          <>
            <div className="mb-1">
              <RobotIcon />
            </div>
            Save to knowledge
          </>,
        ),
        description: renderToString(
          <>
            If the AI-generated answer is correct, save it as a{' '}
            <b>Question-SQL pair</b> to improve AI learning. If it's incorrect,
            refine it with follow-ups before saving to ensure accuracy.
          </>,
        ),
        onPopoverRender: (popoverDom: DriverPopoverDOM) => {
          resetPopoverStyle(popoverDom, 360);
        },
        doneBtnText: 'Got it',
        onNextClick: () => {
          $driver.destroy();
          dispatcher?.onDone && dispatcher.onDone();
        },
      },
    },
  ]);

  let mutationObserver: MutationObserver | null = null;
  let intersectionObserver: IntersectionObserver | null = null;

  const cleanMutationObserverup = () => {
    // if MutationObserver is listening to the element, disable it
    if (mutationObserver) {
      mutationObserver.disconnect();
      mutationObserver = null;
    }
  };

  const cleanIntersectionObserverup = () => {
    if (intersectionObserver) {
      intersectionObserver.disconnect();
      intersectionObserver = null;
    }
  };

  const startDriver = () => {
    const target = document.querySelector(
      selectors.previewData,
    ) as HTMLElement | null;

    if (!target) return false;

    cleanMutationObserverup();

    // use IntersectionObserver to ensure the element is in viewport before driving
    intersectionObserver = new IntersectionObserver(
      async (entries) => {
        for (const entry of entries) {
          if (entry.isIntersecting) {
            cleanIntersectionObserverup();

            await nextTick(700);
            $driver.drive();
            return;
          }
        }
      },
      { threshold: 0.5 }, // 50% of the element is visible
    );

    intersectionObserver.observe(target);
    return true;
  };

  // try to start Driver.js
  if (startDriver()) return;

  // if the target element not appear, use MutationObserver to listen DOM changes
  mutationObserver = new MutationObserver(() => {
    if (startDriver()) {
      cleanMutationObserverup();
    }
  });

  mutationObserver.observe(document.body, { childList: true, subtree: true });

  // 60 seconds after, observer will be cleared
  await nextTick(60000);
  cleanMutationObserverup();
  cleanIntersectionObserverup();
};
</file>

<file path="src/components/learning/guide/utils.ts">
import { Driver, Config, Popover, PopoverDOM } from 'driver.js';

export type DriverPopover = Popover;
export type DriverObj = Driver;
export type DriverPopoverDOM = PopoverDOM;
export type DriverConfig = Config;
export type Dispatcher = {
  onDone?: () => Promise<void>;
  onSaveLanguage?: (value: string) => Promise<void>;
};

// NOTE: Don't change the enum values, it's used in save to db
export enum LEARNING {
  // modeling
  DATA_MODELING_GUIDE = 'DATA_MODELING_GUIDE',
  CREATING_MODEL = 'CREATING_MODEL',
  CREATING_VIEW = 'CREATING_VIEW',
  WORKING_RELATIONSHIP = 'WORKING_RELATIONSHIP',
  CONNECT_OTHER_DATA_SOURCES = 'CONNECT_OTHER_DATA_SOURCES',

  // home
  SWITCH_PROJECT_LANGUAGE = 'SWITCH_PROJECT_LANGUAGE',
  SHARE_RESULTS = 'SHARE_RESULTS',
  VIEW_FULL_SQL = 'VIEW_FULL_SQL',

  // knowledge
  KNOWLEDGE_GUIDE = 'KNOWLEDGE_GUIDE',
  SAVE_TO_KNOWLEDGE = 'SAVE_TO_KNOWLEDGE',
}
</file>

<file path="src/components/learning/index.tsx">
import {
  ComponentRef,
  MutableRefObject,
  useEffect,
  useMemo,
  useRef,
  useState,
} from 'react';
import { sortBy } from 'lodash';
import styled from 'styled-components';
import ReadOutlined from '@ant-design/icons/ReadOutlined';
import RightOutlined from '@ant-design/icons/RightOutlined';
import { IterableComponent, makeIterable } from '@/utils/iteration';
import LearningGuide from '@/components/learning/guide';
import { LEARNING } from './guide/utils';
import { useRouter } from 'next/router';
import { Path } from '@/utils/enum';
import {
  useLearningRecordQuery,
  useSaveLearningRecordMutation,
} from '@/apollo/client/graphql/learning.generated';
import { nextTick } from '@/utils/time';
import { ProjectLanguage } from '@/apollo/client/graphql/__types__';
import { useUpdateCurrentProjectMutation } from '@/apollo/client/graphql/settings.generated';

const Progress = styled.div<{ total: number; current: number }>`
  display: block;
  border-radius: 999px;
  height: 6px;
  width: 100%;
  background-color: var(--gray-4);

  &::before {
    content: '';
    display: block;
    border-radius: 999px;
    width: ${({ total, current }) => `${(current / total) * 100}%`};
    height: 100%;
    background: linear-gradient(to left, #75eaff, #6150e0);
    transition: width 0.3s;
  }
`;

const CollapseBlock = styled.div`
  overflow: hidden;
`;

const PlayIcon = styled.div`
  position: relative;
  width: 16px;
  height: 16px;
  border-radius: 50%;
  background-color: var(--gray-5);
  &::before {
    content: '';
    display: block;
    position: absolute;
    top: 50%;
    left: 50%;
    margin-top: -4px;
    margin-left: -2px;
    border-top: 4px solid transparent;
    border-left: 6px solid var(--gray-8);
    border-bottom: 4px solid transparent;
  }
`;

const List = styled.div<{ finished: boolean }>`
  display: flex;
  align-items: center;
  justify-content: space-between;
  cursor: pointer;
  font-size: 12px;
  color: ${({ finished }) => (finished ? 'var(--gray-6)' : 'var(--gray-8)')};
  text-decoration: ${({ finished }) => (finished ? 'line-through' : 'none')};
  padding: 2px 16px;

  &:hover {
    transition: background-color 0.3s;
    background-color: var(--gray-4);
    color: ${({ finished }) => (finished ? 'var(--gray-6)' : 'var(--gray-8)')};
    text-decoration: ${({ finished }) => (finished ? 'line-through' : 'none')};
  }
`;

const ListTemplate = (props: IterableComponent<LearningConfig>) => {
  const { title, onClick, href, finished } = props;
  const as = href ? 'a' : 'div';
  const hrefAttrs = href
    ? { href, target: '_blank', rel: 'noopener noreferrer' }
    : {};
  return (
    <List
      className="select-none"
      finished={finished}
      onClick={onClick}
      as={as}
      {...hrefAttrs}
    >
      {title}
      <PlayIcon />
    </List>
  );
};

const ListIterator = makeIterable(ListTemplate);

interface LearningConfig {
  id: LEARNING;
  title: string;
  onClick?: () => void;
  href?: string;
  finished?: boolean;
}

const getData = (
  $guide: MutableRefObject<ComponentRef<typeof LearningGuide>>,
  pathname: string,
  saveRecord: (id: LEARNING) => Promise<void>,
  saveLanguage: (value: ProjectLanguage) => Promise<void>,
) => {
  const getDispatcher = (id: LEARNING) => ({
    onDone: () => saveRecord(id),
    onSaveLanguage: saveLanguage,
  });

  const modeling = [
    {
      id: LEARNING.DATA_MODELING_GUIDE,
      title: 'Data modeling guide',
      onClick: () =>
        $guide?.current?.play(
          LEARNING.DATA_MODELING_GUIDE,
          getDispatcher(LEARNING.DATA_MODELING_GUIDE),
        ),
    },
    {
      id: LEARNING.CREATING_MODEL,
      title: 'Creating a model',
      href: 'https://docs.getwren.ai/oss/guide/modeling/models',
      onClick: () => saveRecord(LEARNING.CREATING_MODEL),
    },
    {
      id: LEARNING.CREATING_VIEW,
      title: 'Creating a view',
      href: 'https://docs.getwren.ai/oss/guide/modeling/views',
      onClick: () => saveRecord(LEARNING.CREATING_VIEW),
    },
    {
      id: LEARNING.WORKING_RELATIONSHIP,
      title: 'Working on relationship',
      href: 'https://docs.getwren.ai/oss/guide/modeling/relationships',
      onClick: () => saveRecord(LEARNING.WORKING_RELATIONSHIP),
    },
    {
      id: LEARNING.CONNECT_OTHER_DATA_SOURCES,
      title: 'Connect to other data sources',
      href: 'https://docs.getwren.ai/oss/guide/connect/overview',
      onClick: () => saveRecord(LEARNING.CONNECT_OTHER_DATA_SOURCES),
    },
  ] as LearningConfig[];

  const home = [
    {
      id: LEARNING.SWITCH_PROJECT_LANGUAGE,
      title: 'Switch the language',
      onClick: () =>
        $guide?.current?.play(
          LEARNING.SWITCH_PROJECT_LANGUAGE,
          getDispatcher(LEARNING.SWITCH_PROJECT_LANGUAGE),
        ),
    },
    {
      id: LEARNING.SHARE_RESULTS,
      title: 'Export to Excel/Sheets',
      href: 'https://docs.getwren.ai/oss/guide/integrations/excel-add-in',
      onClick: () => saveRecord(LEARNING.SHARE_RESULTS),
    },
    {
      id: LEARNING.VIEW_FULL_SQL,
      title: 'View full SQL',
      href: 'https://docs.getwren.ai/oss/guide/home/answer#view-sqlview-full-sql',
      onClick: () => saveRecord(LEARNING.VIEW_FULL_SQL),
    },
  ];

  if (pathname.startsWith(Path.Modeling)) {
    return modeling;
  } else if (pathname.startsWith(Path.Home)) {
    return home;
  }
  return [];
};

const isLearningAccessible = (pathname: string) =>
  pathname.startsWith(Path.Modeling) || pathname.startsWith(Path.Home);

interface Props {}

export default function SidebarSection(_props: Props) {
  const router = useRouter();
  const [active, setActive] = useState(true);
  const $guide = useRef<ComponentRef<typeof LearningGuide>>(null);
  const $collapseBlock = useRef<HTMLDivElement>(null);

  const { data: learningRecordResult } = useLearningRecordQuery();

  const [saveLearningRecord] = useSaveLearningRecordMutation({
    refetchQueries: ['LearningRecord'],
  });

  const [updateCurrentProject] = useUpdateCurrentProjectMutation({
    refetchQueries: ['GetSettings'],
  });

  const saveRecord = async (path: LEARNING) => {
    await saveLearningRecord({ variables: { data: { path } } });
  };

  const saveLanguage = async (value: ProjectLanguage) => {
    await updateCurrentProject({ variables: { data: { language: value } } });
  };

  const stories = useMemo(() => {
    const learningData = getData(
      $guide,
      router.pathname,
      saveRecord,
      saveLanguage,
    );
    const record = learningRecordResult?.learningRecord.paths || [];
    return sortBy(
      learningData.map((story) => ({
        ...story,
        finished: record.includes(story.id),
      })),
      'finished',
    );
  }, [learningRecordResult?.learningRecord]);

  const total = useMemo(() => stories.length, [stories]);
  const current = useMemo(
    () => stories.filter((item) => item?.finished).length,
    [stories],
  );

  const collapseBlock = async (isActive: boolean) => {
    if ($collapseBlock.current) {
      const blockHeight = $collapseBlock.current.scrollHeight;
      $collapseBlock.current.style.height = isActive
        ? `${blockHeight}px`
        : '0px';
      await nextTick(300);
      $collapseBlock.current &&
        ($collapseBlock.current.style.transition = 'height 0.3s');
    }
  };

  useEffect(() => {
    const learningRecord = learningRecordResult?.learningRecord;
    if (learningRecord) {
      setActive(
        stories.some((item) => !learningRecord.paths.includes(item.id)),
      );

      const routerAction = {
        [Path.Modeling]: async () => {
          const isGuideDone = learningRecord.paths.includes(
            LEARNING.DATA_MODELING_GUIDE,
          );
          const isSkipBefore = !!window.sessionStorage.getItem(
            'skipDataModelingGuide',
          );
          if (!(isGuideDone || isSkipBefore)) {
            await nextTick(1000);
            $guide.current?.play(LEARNING.DATA_MODELING_GUIDE, {
              onDone: () => saveRecord(LEARNING.DATA_MODELING_GUIDE),
            });
          }
        },
        [Path.Home]: async () => {
          const isGuideDone = learningRecord.paths.includes(
            LEARNING.SWITCH_PROJECT_LANGUAGE,
          );
          const isSkipBefore = !!window.sessionStorage.getItem(
            'skipSwitchProjectLanguageGuide',
          );
          if (!(isGuideDone || isSkipBefore)) {
            await nextTick(1000);
            $guide.current?.play(LEARNING.SWITCH_PROJECT_LANGUAGE, {
              onDone: () => saveRecord(LEARNING.SWITCH_PROJECT_LANGUAGE),
              onSaveLanguage: saveLanguage,
            });
          }
        },
        [Path.Thread]: async () => {
          const isGuideDone = learningRecord.paths.includes(
            LEARNING.SAVE_TO_KNOWLEDGE,
          );
          if (!isGuideDone) {
            await nextTick(1500);
            $guide.current?.play(LEARNING.SAVE_TO_KNOWLEDGE, {
              onDone: () => saveRecord(LEARNING.SAVE_TO_KNOWLEDGE),
            });
          }
        },
        [Path.KnowledgeQuestionSQLPairs]: async () => {
          const isGuideDone = learningRecord.paths.includes(
            LEARNING.KNOWLEDGE_GUIDE,
          );
          if (!isGuideDone) {
            await nextTick(1000);
            $guide.current?.play(LEARNING.KNOWLEDGE_GUIDE, {
              onDone: () => saveRecord(LEARNING.KNOWLEDGE_GUIDE),
            });
          }
        },
      };

      routerAction[router.pathname] && routerAction[router.pathname]();
    }
  }, [learningRecordResult?.learningRecord, router.pathname]);

  useEffect(() => {
    collapseBlock(active);
  }, [active]);

  const onCollapseBarClick = () => {
    setActive(!active);
  };

  // Hide learning section if the page not in whitelist
  return (
    <>
      <LearningGuide ref={$guide} />
      {isLearningAccessible(router.pathname) && (
        <div className="border-t border-gray-4">
          <div
            className="px-4 py-1 d-flex align-center cursor-pointer select-none"
            onClick={onCollapseBarClick}
          >
            <div className="flex-grow-1">
              <ReadOutlined className="mr-1" />
              Learning
            </div>
            <RightOutlined
              className="text-sm"
              style={{ transform: `rotate(${active ? '90deg' : '0deg'})` }}
            />
          </div>
          <CollapseBlock ref={$collapseBlock}>
            <ListIterator data={stories} />
            <div className="px-4 py-2 d-flex align-center">
              <Progress total={total} current={current} />
              <span className="text-xs gray-6 text-nowrap pl-2">
                {current}/{total} Finished
              </span>
            </div>
          </CollapseBlock>
        </div>
      )}
    </>
  );
}
</file>

<file path="src/components/Logo.tsx">
interface Props {
  size?: number;
  color?: string;
}

export const Logo = (props: Props) => {
  const { color = 'var(--gray-9)', size = 30 } = props;
  return (
    <svg
      style={{ width: size, height: 'auto' }}
      viewBox="0 0 30 30"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      shapeRendering="geometricPrecision"
    >
      <path
        d="M15.8023 7.82981C16.2779 8.98701 16.0102 10.1784 15.2043 10.491C14.3983 10.8035 13.3594 10.1187 12.8838 8.96153C12.4082 7.80433 12.676 6.61289 13.4819 6.30038C14.2878 5.98786 15.3267 6.67261 15.8023 7.82981Z"
        fill={color}
      />
      <path
        d="M29.2498 21.952C29.6972 22.4662 30.06 23.0215 29.9917 23.685C29.9234 24.3486 29.3086 24.614 28.8987 24.6804C28.4888 24.7467 20.4276 25.8084 19.5396 25.8748C18.7537 25.9335 18.6097 25.8363 18.303 25.6293C18.1647 25.5398 15.0158 22.5446 13.4586 21.0582C12.69 20.502 11.9941 20.0605 11.5031 19.8762C11.0511 19.7065 10.8708 19.0927 11.2918 18.7366L12.3395 17.8503C12.6148 17.6175 13.0379 17.6319 13.2922 17.9027C13.5897 18.1624 14.5664 19.2307 15.0176 19.7324C16.4453 21.0988 18.1849 22.7674 19.1297 23.685C19.8811 23.9504 21.6801 23.6187 22.0672 23.486C22.0672 23.486 19.4312 20.2141 18.8919 19.8065C18.3525 19.3989 17.8676 19.0849 17.4905 18.9339C16.7022 18.5185 17.059 17.9764 17.336 17.7573L18.4758 16.9463C18.7522 16.7496 19.1457 16.7781 19.3852 17.0359C20.803 18.8099 23.7888 22.4906 24.3899 23.0215C25.1414 23.2869 26.8948 22.9994 27.3274 22.8224L21.8995 16.0762C21.0284 15.3386 20.2227 14.7346 19.6677 14.5037C19.2263 14.3201 19.0551 13.6941 19.5023 13.3497L20.6563 12.4606C20.8517 12.3422 21.3174 12.1979 21.6163 12.5686L22.4088 13.5326L29.2498 21.952Z"
        fill={color}
      />
      <path
        d="M11.8478 1.99067C10.5707 1.99067 9.16387 2.29138 7.65774 3.03904C4.50493 4.60413 2.85603 7.82981 2.33475 10.202C1.60286 13.5326 2.02008 17.0359 3.22442 19.2504C4.07463 20.8137 4.76646 21.6232 6.14326 22.773C8.22894 24.5149 9.81294 25.2866 12.5342 25.6205C13.3997 25.7267 14.7668 25.6858 14.7668 25.6858C15.0555 25.6943 15.3305 25.807 15.5383 26.0018L16.946 27.322L18.5323 28.7087C18.8115 28.9528 18.6338 29.4028 18.2581 29.4028H16.4788C16.1959 29.4028 15.9415 29.1595 15.8496 29.0378C15.2849 28.4856 14.3617 27.6654 14.3617 27.6654L12.5949 27.6134L12.0702 29.601C12.0082 29.8358 11.7904 30 11.5408 30H10.8359C10.4826 30 10.2222 29.6793 10.3044 29.3456L10.7754 27.4341C10.4111 27.3614 10.0218 27.2603 9.62389 27.1204L8.89011 29.615C8.82307 29.8429 8.60863 30 8.36462 30H7.57716C7.21754 30 6.95595 29.6684 7.04944 29.3312L7.88561 26.3144C6.21075 25.5469 4.73704 24.2212 4.73704 24.2212C3.61206 23.3518 2.40208 21.6625 1.93772 20.9265C0.758197 18.9403 0.394862 17.7438 0.0906286 15.4688C-0.12877 13.8281 0.0906362 11.06 0.319969 9.83744C1.19531 6.30038 2.88436 3.2418 6.58906 1.34044C8.46832 0.375947 10.2771 0 11.8478 0C13.447 0 15.5446 0.508003 17.1081 1.30947C18.6578 2.10386 19.4247 2.82829 20.4677 3.84627C20.795 4.1666 21.6271 4.79496 22.3369 4.74577C22.7866 4.80486 24.0471 4.75887 25.4919 4.10215C26.2394 3.83912 26.7594 4.35638 26.9213 4.63196C27.103 4.91761 27.3006 5.6137 26.6372 6.11287L21.7843 9.76476C21.5609 10.1265 21.3962 10.4625 21.3325 10.7478C21.1055 11.6585 20.3487 11.25 20.057 11.06C19.7653 10.87 19.0996 9.90218 19.0996 9.90218C18.8562 9.60785 18.9128 9.17176 19.2335 8.94832C19.5878 8.70146 20.7613 7.88917 21.6518 7.34629L22.4617 6.73683C21.868 6.78175 20.3598 6.55944 19.0768 5.3108C19.0768 5.3108 17.441 3.72084 16.1516 3.07001C14.6097 2.29178 13.0964 1.99067 11.8478 1.99067Z"
        fill={color}
      />
    </svg>
  );
};
</file>

<file path="src/components/LogoBar.tsx">
import Image from 'next/image';

export default function LogoBar() {
  return (
    <Image
      src="/images/logo-white-with-text.svg"
      alt="Wren AI"
      width={125}
      height={30}
    />
  );
}
</file>

<file path="src/components/modals/AdjustReasoningStepsModal.tsx">
import { useEffect, useMemo } from 'react';
import { keyBy } from 'lodash';
import styled from 'styled-components';
import { Form, Modal, Select, Tag } from 'antd';
import QuestionCircleOutlined from '@ant-design/icons/QuestionCircleOutlined';
import { ERROR_TEXTS } from '@/utils/error';
import useAutoComplete, { convertMention } from '@/hooks/useAutoComplete';
import { ModalAction } from '@/hooks/useModalAction';
import MarkdownEditor from '@/components/editor/MarkdownEditor';
import { useListModelsQuery } from '@/apollo/client/graphql/model.generated';

const MultiSelect = styled(Select)`
  .ant-select-selector {
    padding-top: 3px;
  }
  .ant-tag {
    padding: 3px 5px;
    margin-right: 3px;
    margin-bottom: 3px;
  }
`;

const TagText = styled.div`
  line-height: 16px;
`;

type Props = ModalAction<{
  responseId: number;
  retrievedTables: string[];
  sqlGenerationReasoning: string;
}> & {
  loading?: boolean;
};

export default function AdjustReasoningStepsModal(props: Props) {
  const { visible, defaultValue, loading, onSubmit, onClose } = props;
  const [form] = Form.useForm();

  const mentions = useAutoComplete({
    convertor: convertMention,
    includeColumns: true,
    skip: !visible,
  });
  const listModelsResult = useListModelsQuery({ skip: !visible });
  const modelNameMap = keyBy(
    listModelsResult.data?.listModels,
    'referenceName',
  );
  const modelOptions = useMemo(() => {
    return listModelsResult.data?.listModels.map((model) => ({
      label: model.displayName,
      value: model.referenceName,
    }));
  }, [listModelsResult.data?.listModels]);

  useEffect(() => {
    if (!visible) return;
    const listModels = listModelsResult.data?.listModels || [];
    const retrievedTables = listModels.reduce((result, model) => {
      if (defaultValue?.retrievedTables.includes(model.referenceName)) {
        result.push(model.referenceName);
      }
      return result;
    }, []);
    form.setFieldsValue({
      tables: retrievedTables,
      sqlGenerationReasoning: defaultValue?.sqlGenerationReasoning,
    });
  }, [form, defaultValue, visible, listModelsResult.data?.listModels]);

  const tagRender = (props) => {
    const { value, closable, onClose } = props;
    const model = modelNameMap[value];
    return (
      <Tag
        onMouseDown={(e) => e.stopPropagation()}
        closable={closable}
        onClose={onClose}
        className="d-flex align-center bg-gray-3 border-gray-3"
        style={{ maxWidth: 140 }}
      >
        <div className="pr-1" style={{ minWidth: 0 }}>
          <TagText className="gray-8 text-truncate" title={model.displayName}>
            {model.displayName}
          </TagText>
          <TagText
            className="gray-7 text-xs text-truncate"
            title={model.referenceName}
          >
            {model.referenceName}
          </TagText>
        </div>
      </Tag>
    );
  };

  const reset = () => {
    form.resetFields();
  };

  const submit = async () => {
    form
      .validateFields()
      .then(async (values) => {
        await onSubmit({
          responseId: defaultValue.responseId,
          data: values,
        });
        onClose();
      })
      .catch(console.error);
  };

  return (
    <Modal
      title="Adjust steps"
      width={640}
      visible={visible}
      okText="Regenerate answer"
      onOk={submit}
      onCancel={onClose}
      confirmLoading={loading}
      maskClosable={false}
      destroyOnClose
      centered
      afterClose={reset}
    >
      <Form form={form} preserve={false} layout="vertical">
        <Form.Item
          label="Selected models"
          name="tables"
          required={false}
          rules={[
            {
              required: true,
              message: ERROR_TEXTS.ADJUST_REASONING.SELECTED_MODELS.REQUIRED,
            },
          ]}
          extra={
            <div className="text-sm gray-6 mt-1">
              Select the tables needed to answer your question.{' '}
              <span className="gray-7">
                Tables not selected won't be used in SQL generation.
              </span>
            </div>
          }
        >
          <MultiSelect
            mode="multiple"
            placeholder="Select models"
            options={modelOptions}
            tagRender={tagRender}
          />
        </Form.Item>
        <Form.Item
          label="Reasoning steps"
          className="pb-0"
          extra={
            <div className="text-sm gray-6 mt-1">
              <QuestionCircleOutlined className="mr-1" />
              Protip: Use @ to choose model in the textarea.
            </div>
          }
        >
          <div className="text-sm gray-6 mb-1">
            Edit the reasoning logic below. Each step should build toward
            answering the question accurately.
          </div>
          <Form.Item
            noStyle
            name="sqlGenerationReasoning"
            required={false}
            rules={[
              {
                required: true,
                message: ERROR_TEXTS.ADJUST_REASONING.STEPS.REQUIRED,
              },
              {
                max: 6000,
                message: ERROR_TEXTS.ADJUST_REASONING.STEPS.MAX_LENGTH,
              },
            ]}
          >
            <MarkdownEditor maxLength={6000} mentions={mentions} />
          </Form.Item>
        </Form.Item>
      </Form>
    </Modal>
  );
}
</file>

<file path="src/components/modals/AdjustSQLModal.tsx">
import { useEffect, useState } from 'react';
import { Alert, Button, Form, Modal, Typography } from 'antd';
import InfoCircleOutlined from '@ant-design/icons/InfoCircleOutlined';
import { ERROR_TEXTS } from '@/utils/error';
import { ModalAction } from '@/hooks/useModalAction';
import SQLEditor from '@/components/editor/SQLEditor';
import { parseGraphQLError } from '@/utils/errorHandler';
import ErrorCollapse from '@/components/ErrorCollapse';
import PreviewData from '@/components/dataPreview/PreviewData';
import { usePreviewSqlMutation } from '@/apollo/client/graphql/sql.generated';

interface AdjustSQLFormValues {
  responseId: number;
  sql: string;
}

type Props = ModalAction<AdjustSQLFormValues, AdjustSQLFormValues> & {
  loading?: boolean;
};

export default function AdjustSQLModal(props: Props) {
  const { defaultValue, loading, onClose, onSubmit, visible } = props;

  const [form] = Form.useForm();
  const [error, setError] =
    useState<ReturnType<typeof parseGraphQLError>>(null);
  const [previewing, setPreviewing] = useState<boolean>(false);
  const [submitting, setSubmitting] = useState<boolean>(false);
  const [showPreview, setShowPreview] = useState<boolean>(false);

  const [previewSqlMutation, previewSqlResult] = usePreviewSqlMutation();

  const sqlValue = Form.useWatch('sql', form);

  useEffect(() => {
    if (visible) {
      form.setFieldsValue({
        sql: defaultValue?.sql,
      });
    }
  }, [visible, defaultValue]);

  const handleReset = () => {
    previewSqlResult.reset();
    setShowPreview(false);
    setError(null);
    form.resetFields();
  };

  const onValidateSQL = async () => {
    await previewSqlMutation({
      variables: {
        data: {
          sql: sqlValue,
          limit: 1,
          dryRun: true,
        },
      },
    });
  };

  const handleError = (error) => {
    const graphQLError = parseGraphQLError(error);
    setError({ ...graphQLError, shortMessage: 'Invalid SQL syntax' });
    console.error(graphQLError);
  };

  const onPreviewData = async () => {
    setError(null);
    setPreviewing(true);
    try {
      await onValidateSQL();
      setShowPreview(true);
      await previewSqlMutation({
        variables: {
          data: {
            sql: sqlValue,
            limit: 50,
          },
        },
      });
    } catch (error) {
      setShowPreview(false);
      handleError(error);
    } finally {
      setPreviewing(false);
    }
  };

  const onSubmitButton = () => {
    setError(null);
    setSubmitting(true);
    setShowPreview(false);
    form
      .validateFields()
      .then(async (values) => {
        try {
          await onValidateSQL();
          await onSubmit({
            responseId: defaultValue?.responseId,
            sql: values.sql,
          });
          onClose();
        } catch (error) {
          handleError(error);
        } finally {
          setSubmitting(false);
        }
      })
      .catch((err) => {
        setSubmitting(false);
        console.error(err);
      });
  };

  const confirmLoading = loading || submitting;
  const disabled = !sqlValue;

  return (
    <Modal
      title="Adjust SQL"
      centered
      closable
      confirmLoading={confirmLoading}
      destroyOnClose
      maskClosable={false}
      onCancel={onClose}
      visible={visible}
      width={640}
      cancelButtonProps={{ disabled: confirmLoading }}
      okButtonProps={{ disabled: previewSqlResult.loading }}
      afterClose={() => handleReset()}
      footer={
        <div className="d-flex justify-space-between align-center">
          <div
            className="text-sm ml-2 d-flex justify-space-between align-center"
            style={{ width: 300 }}
          >
            <InfoCircleOutlined className="mr-2 text-sm gray-7" />
            <Typography.Text
              type="secondary"
              className="text-sm gray-7 text-left"
            >
              The SQL statement used here follows <b>Wren SQL</b>, which is
              based on ANSI SQL and optimized for Wren AI.{` `}
              <Typography.Link
                type="secondary"
                href="https://docs.getwren.ai/oss/guide/home/wren_sql"
                target="_blank"
                rel="noopener noreferrer"
              >
                Learn more about the syntax.
              </Typography.Link>
            </Typography.Text>
          </div>
          <div>
            <Button onClick={onClose}>Cancel</Button>
            <Button
              type="primary"
              onClick={onSubmitButton}
              loading={confirmLoading}
            >
              Submit
            </Button>
          </div>
        </div>
      }
    >
      <Form form={form} preserve={false} layout="vertical">
        <Form.Item
          label="SQL statement"
          name="sql"
          required
          rules={[
            {
              required: true,
              message: ERROR_TEXTS.SQL_PAIR.SQL.REQUIRED,
            },
          ]}
        >
          <SQLEditor autoComplete autoFocus />
        </Form.Item>
      </Form>
      <div className="my-3">
        <Typography.Text className="d-block gray-7 mb-2">
          Data preview (50 rows)
        </Typography.Text>
        <Button
          onClick={onPreviewData}
          loading={previewing}
          disabled={disabled}
        >
          Preview data
        </Button>
        {showPreview && (
          <div className="my-3">
            <PreviewData
              loading={previewing}
              previewData={previewSqlResult?.data?.previewSql}
              copyable={false}
            />
          </div>
        )}
      </div>
      {!!error && (
        <Alert
          showIcon
          type="error"
          message={error.shortMessage}
          description={<ErrorCollapse message={error.message} />}
        />
      )}
    </Modal>
  );
}
</file>

<file path="src/components/modals/CalculatedFieldModal.tsx">
import { useCallback, useEffect, useMemo, useState } from 'react';
import { Modal, Form, Input, Typography, Button, Alert } from 'antd';
import LinkOutlined from '@ant-design/icons/LinkOutlined';
import { FORM_MODE } from '@/utils/enum';
import { ERROR_TEXTS } from '@/utils/error';
import { DiagramModel } from '@/utils/data/type';
import { ModalAction } from '@/hooks/useModalAction';
import {
  createLineageSelectorNameValidator,
  createLineageSelectorValidator,
} from '@/utils/validator';
import { ERROR_CODES, parseGraphQLError } from '@/utils/errorHandler';
import { FieldValue } from '@/components/selectors/lineageSelector/FieldSelect';
import useExpressionFieldOptions from '@/hooks/useExpressionFieldOptions';
import LineageSelector, {
  getLineageOptions,
} from '@/components/selectors/lineageSelector';
import DescriptiveSelector from '@/components/selectors/DescriptiveSelector';
import ErrorCollapse from '@/components/ErrorCollapse';
import { useValidateCalculatedFieldMutation } from '@/apollo/client/graphql/calculatedField.generated';
import { CreateCalculatedFieldInput } from '@/apollo/client/graphql/__types__';

export type CalculatedFieldValue = {
  name: string;
  expression: string;
  lineage: FieldValue[];
  columnId?: number;

  payload: {
    models: DiagramModel[];
    sourceModel: DiagramModel;
  };
};

type Props = ModalAction<
  CalculatedFieldValue,
  { id?: number; data: CreateCalculatedFieldInput }
> & {
  loading?: boolean;
};

export default function AddCalculatedFieldModal(props: Props) {
  const {
    visible,
    loading,
    onSubmit,
    onClose,
    defaultValue,
    payload,
    formMode,
  } = props;

  const isEditMode = formMode === FORM_MODE.EDIT;
  const [error, setError] =
    useState<ReturnType<typeof parseGraphQLError>>(null);

  const [form] = Form.useForm();
  const expression = Form.useWatch('expression', form);
  const lineage = Form.useWatch('lineage', form);

  const expressionOptions = useExpressionFieldOptions();

  const models = useMemo(() => payload?.models, [payload]);
  const sourceModel = useMemo(() => payload?.sourceModel, [payload]);

  const [validateCalculatedField] = useValidateCalculatedFieldMutation();
  const validateCalculatedFieldName = useCallback(
    async (name: string) =>
      await validateCalculatedField({
        variables: {
          data: {
            name,
            modelId: sourceModel.modelId,
            columnId: defaultValue?.columnId,
          },
        },
      }),
    [sourceModel, defaultValue],
  );

  useEffect(() => {
    if (!visible) return;
    form.setFieldsValue(defaultValue || {});
  }, [form, defaultValue, visible]);

  const fetchOptions = useCallback(
    async (value) => {
      const selectedModel = models.find(
        (model) => model.referenceName === value.referenceName,
      );
      // use current model options when initial
      return getLineageOptions({
        model: selectedModel,
        sourceModel,
        expression,
        values: lineage,
      });
    },
    [models, lineage, expression],
  );

  const reset = () => {
    setError(null);
    form.resetFields();
  };

  const submit = () => {
    setError(null);
    form
      .validateFields()
      .then(async (values) => {
        const id = defaultValue?.columnId;
        const modelId = !id ? sourceModel.modelId : undefined;

        await onSubmit({
          id,
          data: {
            modelId,
            expression: values.expression,
            name: values.name,
            // lineage output example: [relationId1, relationId2, columnId], the last item is always a columnId
            lineage: values.lineage.map(
              (field) => field.relationId || field.columnId,
            ),
          },
        });
        onClose();
      })
      .catch((err) => {
        const graphQLError = parseGraphQLError(err);
        if (graphQLError.code === ERROR_CODES.INVALID_CALCULATED_FIELD) {
          setError(graphQLError);
        }
        console.error(err);
      });
  };

  return (
    <Modal
      title={`${isEditMode ? 'Update' : 'Add'} calculated field`}
      width={750}
      visible={visible}
      onCancel={onClose}
      confirmLoading={loading}
      maskClosable={false}
      destroyOnClose
      afterClose={() => reset()}
      footer={
        <div className="d-flex justify-space-between align-center">
          <div className="text-sm ml-2">
            <LinkOutlined className="gray-6 mr-2" />
            <Typography.Link
              type="secondary"
              href="https://docs.getwren.ai/oss/guide/modeling/models#update-primary-key"
              target="_blank"
              rel="noopener noreferrer"
            >
              How to set primary key in a model.
            </Typography.Link>
          </div>
          <div>
            <Button onClick={onClose}>Cancel</Button>
            <Button type="primary" onClick={submit} loading={loading}>
              Save
            </Button>
          </div>
        </div>
      }
    >
      <Form form={form} preserve={false} layout="vertical">
        <Form.Item
          label="Name"
          name="name"
          required
          rules={[
            {
              validator: createLineageSelectorNameValidator(
                validateCalculatedFieldName,
              ),
            },
          ]}
        >
          <Input />
        </Form.Item>

        <Form.Item
          label="Select an expression"
          name="expression"
          required
          rules={[
            {
              required: true,
              message: ERROR_TEXTS.CALCULATED_FIELD.EXPRESSION.REQUIRED,
            },
          ]}
        >
          <DescriptiveSelector
            placeholder="Select an expression"
            options={expressionOptions}
            descriptiveContentRender={(content) => {
              return (
                <>
                  <div className="mb-1">{content?.description || '-'}</div>
                  {content?.expression && (
                    <Typography.Text className="mb-1" code>
                      {content.expression}
                    </Typography.Text>
                  )}
                </>
              );
            }}
          />
        </Form.Item>
        <div className="py-1" />
        {!!expression && (
          <Form.Item
            name="lineage"
            rules={[
              {
                validator: createLineageSelectorValidator(expression),
              },
            ]}
          >
            <LineageSelector
              sourceModel={sourceModel}
              onFetchOptions={fetchOptions}
            />
          </Form.Item>
        )}
      </Form>

      {!!error && (
        <Alert
          showIcon
          type="error"
          message={error.shortMessage}
          description={<ErrorCollapse message={error.message} />}
        />
      )}
    </Modal>
  );
}
</file>

<file path="src/components/modals/DeleteModal.tsx">
import { ReactNode } from 'react';
import { ButtonProps, Modal, ModalProps } from 'antd';
import ExclamationCircleOutlined from '@ant-design/icons/ExclamationCircleOutlined';
import DeleteOutlined from '@ant-design/icons/DeleteOutlined';

type DeleteModalProps = {
  disabled?: boolean;
  modalProps?: ModalProps;
  onConfirm: () => void;
  style?: any;
} & Partial<ButtonProps>;

type Config = {
  icon?: ReactNode;
  itemName?: string;
  content?: string;
};

export const makeDeleteModal =
  (Component, config?: Config) => (props: DeleteModalProps) => {
    const { title, content, modalProps = {}, onConfirm, ...restProps } = props;

    return (
      <Component
        icon={config.icon}
        onClick={() =>
          Modal.confirm({
            autoFocusButton: null,
            cancelText: 'Cancel',
            content:
              config?.content ||
              'This will be permanently deleted, please confirm you want to delete it.',
            icon: <ExclamationCircleOutlined />,
            okText: 'Delete',
            onOk: onConfirm,
            title: `Are you sure you want to delete this ${config?.itemName}?`,
            width: 464,
            ...modalProps,
            okButtonProps: {
              ...modalProps.okButtonProps,
              danger: true,
            },
          })
        }
        {...restProps}
      />
    );
  };

const DefaultDeleteButton = (props) => {
  const { icon = null, disabled, ...restProps } = props;
  return (
    <a className={disabled ? '' : 'red-5'} {...restProps}>
      {icon}Delete
    </a>
  );
};

export default makeDeleteModal(DefaultDeleteButton);

// Customize delete modal
export const DeleteThreadModal = makeDeleteModal(DefaultDeleteButton, {
  icon: <DeleteOutlined className="mr-2" />,
  itemName: 'thread',
  content:
    'This will permanently delete all results history in this thread, please confirm you want to delete it.',
});

export const DeleteViewModal = makeDeleteModal(DefaultDeleteButton, {
  icon: <DeleteOutlined className="mr-2" />,
  itemName: 'view',
  content:
    'This will be permanently deleted, please confirm you want to delete it.',
});

export const DeleteModelModal = makeDeleteModal(DefaultDeleteButton, {
  icon: <DeleteOutlined className="mr-2" />,
  itemName: 'model',
  content:
    'This will be permanently deleted, please confirm you want to delete it.',
});

export const DeleteCalculatedFieldModal = makeDeleteModal(DefaultDeleteButton, {
  icon: <DeleteOutlined className="mr-2" />,
  itemName: 'calculated field',
  content:
    'This will be permanently deleted, please confirm you want to delete it.',
});

export const DeleteRelationshipModal = makeDeleteModal(DefaultDeleteButton, {
  icon: <DeleteOutlined className="mr-2" />,
  itemName: 'relationship',
  content:
    'This will be permanently deleted, please confirm you want to delete it.',
});

export const DeleteDashboardItemModal = makeDeleteModal(DefaultDeleteButton, {
  icon: <DeleteOutlined className="mr-2" />,
  itemName: 'dashboard item',
  content:
    'This will be permanently deleted, please confirm you want to delete it.',
});

export const DeleteQuestionSQLPairModal = makeDeleteModal(DefaultDeleteButton, {
  icon: <DeleteOutlined className="mr-2" />,
  itemName: 'question-SQL pair',
  content:
    'This action is permanent and cannot be undone. Are you sure you want to proceed?',
});

export const DeleteInstructionModal = makeDeleteModal(DefaultDeleteButton, {
  icon: <DeleteOutlined className="mr-2" />,
  itemName: 'instruction',
  content:
    'This action is permanent and cannot be undone. Are you sure you want to proceed?',
});
</file>

<file path="src/components/modals/FixSQLModal.tsx">
import { useEffect, useMemo, useState } from 'react';
import { Button, Form, Modal, Typography, Alert } from 'antd';
import { ERROR_TEXTS } from '@/utils/error';
import { ModalAction } from '@/hooks/useModalAction';
import { attachLoading } from '@/utils/helper';
import { parseGraphQLError } from '@/utils/errorHandler';
import SQLEditor from '@/components/editor/SQLEditor';
import ErrorCollapse from '@/components/ErrorCollapse';
import PreviewData from '@/components/dataPreview/PreviewData';
import { usePreviewSqlMutation } from '@/apollo/client/graphql/sql.generated';

type Props = ModalAction<{ sql: string; responseId: number }> & {
  loading?: boolean;
};

export function FixSQLModal(props: Props) {
  const { visible, defaultValue, loading, onSubmit, onClose } = props;
  const [previewLoading, setPreviewLoading] = useState(false);
  const [form] = Form.useForm();

  const [previewSqlMutation, previewSqlResult] = usePreviewSqlMutation();
  const error = useMemo(() => {
    if (!previewSqlResult.error) return null;
    const graphQLError = parseGraphQLError(previewSqlResult.error);
    return { ...graphQLError, shortMessage: 'Invalid SQL syntax' };
  }, [previewSqlResult.error]);

  useEffect(() => {
    if (!visible) return;
    form.setFieldsValue(defaultValue || {});
  }, [form, defaultValue, visible]);

  const validateSql = async () => {
    const sql = form.getFieldValue('sql');
    await previewSqlMutation({
      variables: { data: { sql, limit: 1, dryRun: true } },
    });
  };

  const previewData = async () => {
    form
      .validateFields()
      .then(async (values) => {
        await attachLoading(
          previewSqlMutation,
          setPreviewLoading,
        )({
          variables: { data: { sql: values.sql, limit: 50 } },
        });
      })
      .catch(console.error);
  };

  const reset = () => {
    form.resetFields();
    previewSqlResult.reset();
  };

  const submit = async () => {
    form
      .validateFields()
      .then(async (values) => {
        await validateSql();
        await onSubmit(values.sql);
        onClose();
      })
      .catch(console.error);
  };

  const showPreview = previewSqlResult.data || previewSqlResult.loading;

  return (
    <Modal
      title="Fix SQL"
      width={640}
      visible={visible}
      okText="Submit"
      onOk={submit}
      onCancel={onClose}
      confirmLoading={loading}
      maskClosable={false}
      destroyOnClose
      centered
      afterClose={reset}
    >
      <Typography.Text className="d-block gray-7 mb-3">
        The following SQL statement needs to be fixed:
      </Typography.Text>
      <Form form={form} preserve={false} layout="vertical">
        <Form.Item
          label="SQL statement"
          name="sql"
          required
          rules={[
            {
              required: true,
              message: ERROR_TEXTS.FIX_SQL.SQL.REQUIRED,
            },
          ]}
        >
          <SQLEditor autoComplete autoFocus />
        </Form.Item>
      </Form>
      <div className="my-3">
        <Typography.Text className="d-block gray-7 mb-2">
          Data preview (50 rows)
        </Typography.Text>
        <Button
          onClick={previewData}
          loading={previewLoading}
          disabled={previewLoading}
        >
          Preview data
        </Button>
        {showPreview && (
          <div className="my-3">
            <PreviewData
              loading={previewLoading}
              previewData={previewSqlResult?.data?.previewSql}
              copyable={false}
            />
          </div>
        )}
      </div>
      {!!error && (
        <Alert
          showIcon
          type="error"
          message={error.shortMessage}
          description={<ErrorCollapse message={error.message} />}
        />
      )}
    </Modal>
  );
}
</file>

<file path="src/components/modals/ImportDataSourceSQLModal.tsx">
import { useMemo } from 'react';
import { Modal, Form, Alert } from 'antd';
import { ModalAction } from '@/hooks/useModalAction';
import { getDataSourceImage, getDataSourceName } from '@/utils/dataSourceType';
import { DATA_SOURCES } from '@/utils/enum';
import { ERROR_TEXTS } from '@/utils/error';
import { parseGraphQLError } from '@/utils/errorHandler';
import SQLEditor from '@/components/editor/SQLEditor';
import ErrorCollapse from '@/components/ErrorCollapse';
import { useModelSubstituteMutation } from '@/apollo/client/graphql/sql.generated';
import { DataSource, DataSourceName } from '@/apollo/client/graphql/__types__';

type Props = ModalAction<{ dataSource: DATA_SOURCES }>;

const Toolbar = (props) => {
  const { dataSource } = props;
  if (!dataSource) return null;
  const logo = getDataSourceImage(dataSource);
  const name = getDataSourceName(dataSource);
  return (
    <>
      <span className="d-flex align-center gx-2">
        <img src={logo} alt="logo" width="20" height="20" />
        {name}
      </span>
    </>
  );
};

export const isSupportSubstitute = (dataSource: DataSource) => {
  // DuckDB not supported, sample dataset as well
  return (
    !dataSource?.sampleDataset && dataSource?.type !== DataSourceName.DUCKDB
  );
};

export default function ImportDataSourceSQLModal(props: Props) {
  const { visible, defaultValue, onSubmit, onClose } = props;
  const name = getDataSourceName(defaultValue?.dataSource) || 'data source';

  const [substituteDialectSQL, modelSubstitudeResult] =
    useModelSubstituteMutation();
  const error = useMemo(
    () =>
      modelSubstitudeResult.error
        ? {
            ...parseGraphQLError(modelSubstitudeResult.error),
            shortMessage: `Invalid ${name} SQL syntax`,
          }
        : null,
    [modelSubstitudeResult.error],
  );

  const [form] = Form.useForm();

  const reset = () => {
    form.resetFields();
    modelSubstitudeResult.reset();
  };

  const submit = async () => {
    form
      .validateFields()
      .then(async (values) => {
        const response = await substituteDialectSQL({
          variables: { data: { sql: values.dialectSql } },
        });
        await onSubmit(response.data?.modelSubstitute);
        onClose();
      })
      .catch(console.error);
  };

  const loading = modelSubstitudeResult.loading;

  return (
    <Modal
      title={`Import from ${name} SQL`}
      centered
      closable
      confirmLoading={loading}
      destroyOnClose
      maskClosable={false}
      onCancel={onClose}
      onOk={submit}
      okText="Convert"
      visible={visible}
      width={600}
      cancelButtonProps={{ disabled: loading }}
      afterClose={() => reset()}
    >
      <Form form={form} layout="vertical">
        <Form.Item
          name="dialectSql"
          label="SQL statement"
          rules={[
            {
              required: true,
              message: ERROR_TEXTS.IMPORT_DATA_SOURCE_SQL.SQL.REQUIRED,
            },
          ]}
        >
          <SQLEditor
            toolbar={<Toolbar dataSource={defaultValue?.dataSource} />}
            autoFocus
          />
        </Form.Item>
      </Form>
      {!!error && (
        <Alert
          showIcon
          type="error"
          message={error.shortMessage}
          description={<ErrorCollapse message={error.message} />}
        />
      )}
    </Modal>
  );
}
</file>

<file path="src/components/modals/InstructionModal.tsx">
import { useEffect } from 'react';
import { Button, Form, Input, Modal, Row, Col, Radio } from 'antd';
import DeleteOutlined from '@ant-design/icons/DeleteOutlined';
import PlusOutlined from '@ant-design/icons/PlusOutlined';
import { isEmpty } from 'lodash';
import { FORM_MODE } from '@/utils/enum';
import { ERROR_TEXTS } from '@/utils/error';
import { ModalAction } from '@/hooks/useModalAction';
import { Instruction } from '@/apollo/client/graphql/__types__';

const MAX_QUESTIONS = 100;

type Props = ModalAction<Instruction> & {
  loading?: boolean;
};

export default function InstructionModal(props: Props) {
  const { defaultValue, formMode, loading, onClose, onSubmit, visible } = props;

  const isCreateMode = formMode === FORM_MODE.CREATE;

  const [form] = Form.useForm();
  const isDefault = Form.useWatch('isDefault', form);

  useEffect(() => {
    if (visible) {
      form.setFieldsValue({
        isDefault: isEmpty(defaultValue) ? true : defaultValue.isDefault,
        instruction: defaultValue?.instruction,
        questions: defaultValue?.questions,
      });
    }
  }, [visible, defaultValue]);

  const onSubmitButton = () => {
    form
      .validateFields()
      .then(async (values) => {
        const data = {
          isDefault: values.isDefault,
          instruction: values.instruction,
          questions: values?.questions || [],
        };
        await onSubmit({ data, id: defaultValue?.id });
        onClose();
      })
      .catch(console.error);
  };

  return (
    <Modal
      title={`${isCreateMode ? 'Add' : 'Update'} an instruction`}
      centered
      closable
      confirmLoading={loading}
      destroyOnClose
      maskClosable={false}
      onCancel={onClose}
      visible={visible}
      width={720}
      cancelButtonProps={{ disabled: loading }}
      okText="Submit"
      onOk={onSubmitButton}
      afterClose={() => form.resetFields()}
    >
      <Form form={form} preserve={false} layout="vertical">
        <Form.Item
          label="Instruction details"
          name="instruction"
          rules={[
            {
              required: true,
              message: ERROR_TEXTS.INSTRUCTION.DETAILS.REQUIRED,
            },
          ]}
        >
          <Input.TextArea
            autoFocus
            placeholder="Enter a rule that Wren AI should follow when generating SQL queries."
            maxLength={1000}
            rows={3}
            showCount
          />
        </Form.Item>
        <Form.Item
          label="Apply instruction to"
          name="isDefault"
          required={false}
          rules={[
            {
              required: true,
              message: ERROR_TEXTS.INSTRUCTION.IS_DEFAULT_GLOBAL.REQUIRED,
            },
          ]}
          extra={
            <>
              Choose whether this instruction applies to{' '}
              <span className="gray-7">all queries</span> or{' '}
              <span className="gray-7">
                only when similar user questions are detected
              </span>
              .
            </>
          }
        >
          <Radio.Group>
            <Radio.Button value={true}>
              Global (applies to all questions)
            </Radio.Button>
            <Radio.Button value={false}>
              Matched to specific questions
            </Radio.Button>
          </Radio.Group>
        </Form.Item>
        {!isDefault && (
          <Form.Item
            label="Matching questions"
            required
            extra="Wren AI will match user queries based on similarity and apply this instruction when relevant."
          >
            <Form.List name="questions" initialValue={['']}>
              {(fields, { add, remove }) => (
                <>
                  {fields.map(({ key, name, ...restField }) => (
                    <Row key={key} wrap={false} gutter={8} className="my-2">
                      <Col flex="1 0">
                        <Form.Item
                          {...restField}
                          name={name}
                          required
                          className="mb-2"
                          style={{ width: '100%' }}
                          rules={[
                            {
                              required: true,
                              whitespace: true,
                              message:
                                ERROR_TEXTS.INSTRUCTION.QUESTIONS.REQUIRED,
                            },
                          ]}
                        >
                          <Input
                            placeholder="Enter an example question that should trigger this instruction."
                            maxLength={100}
                            showCount
                          />
                        </Form.Item>
                      </Col>
                      <Col flex="none" className="p-1">
                        <Button
                          onClick={() => remove(name)}
                          disabled={fields.length <= 1}
                          icon={<DeleteOutlined />}
                          size="small"
                          style={{ border: 'none' }}
                          className="bg-gray-1"
                        />
                      </Col>
                    </Row>
                  ))}
                  <Form.Item noStyle>
                    <Button
                      type="dashed"
                      onClick={() => add()}
                      block
                      icon={<PlusOutlined />}
                      disabled={fields.length >= MAX_QUESTIONS}
                      className="mb-1"
                    >
                      Add a question
                    </Button>
                  </Form.Item>
                </>
              )}
            </Form.List>
          </Form.Item>
        )}
      </Form>
    </Modal>
  );
}
</file>

<file path="src/components/modals/QuestionSQLPairModal.tsx">
import { useEffect, useMemo, useState } from 'react';
import styled from 'styled-components';
import { Alert, Button, Form, Input, Modal, Typography } from 'antd';
import { Logo } from '@/components/Logo';
import InfoCircleOutlined from '@ant-design/icons/InfoCircleOutlined';
import SelectOutlined from '@ant-design/icons/SelectOutlined';
import { ERROR_TEXTS } from '@/utils/error';
import { FORM_MODE } from '@/utils/enum';
import { getDataSourceName } from '@/utils/dataSourceType';
import useModalAction, { ModalAction } from '@/hooks/useModalAction';
import SQLEditor from '@/components/editor/SQLEditor';
import { parseGraphQLError } from '@/utils/errorHandler';
import { createSQLPairQuestionValidator } from '@/utils/validator';
import ErrorCollapse from '@/components/ErrorCollapse';
import PreviewData from '@/components/dataPreview/PreviewData';
import ImportDataSourceSQLModal, {
  isSupportSubstitute,
} from '@/components/modals/ImportDataSourceSQLModal';
import { usePreviewSqlMutation } from '@/apollo/client/graphql/sql.generated';
import { useGetSettingsQuery } from '@/apollo/client/graphql/settings.generated';
import { useGenerateQuestionMutation } from '@/apollo/client/graphql/sql.generated';
import { SqlPair } from '@/apollo/client/graphql/__types__';

type Props = ModalAction<SqlPair> & {
  loading?: boolean;
  payload?: {
    isCreateMode: boolean;
  };
};

const StyledForm = styled(Form)`
  .adm-question-form-item > div > label {
    width: 100%;
  }
`;

const Toolbar = (props: { dataSource: string; onClick: () => void }) => {
  const { dataSource, onClick } = props;
  const name = getDataSourceName(dataSource);
  return (
    <div className="d-flex justify-space-between align-center px-1">
      <span className="d-flex align-center gx-2">
        <Logo size={16} />
        Wren SQL
      </span>
      <Button className="px-0" type="link" size="small" onClick={onClick}>
        <SelectOutlined />
        Import from {name} SQL
      </Button>
    </div>
  );
};

export default function QuestionSQLPairModal(props: Props) {
  const {
    defaultValue,
    formMode,
    loading,
    onClose,
    onSubmit,
    visible,
    payload,
  } = props;

  // pass payload?.isCreateMode to prevent formMode from being set to Update when passing defaultValue, for the 'Add a SQL pair from an existing answer' scenario use.
  const isCreateMode = formMode === FORM_MODE.CREATE || payload?.isCreateMode;
  const importDataSourceSQLModal = useModalAction();

  const { data: settingsResult } = useGetSettingsQuery();
  const settings = settingsResult?.settings;
  const dataSource = useMemo(
    () => ({
      isSupportSubstitute: isSupportSubstitute(settings?.dataSource),
      type: settings?.dataSource?.type,
    }),
    [settings?.dataSource],
  );

  const [form] = Form.useForm();
  const [error, setError] =
    useState<ReturnType<typeof parseGraphQLError>>(null);
  const [previewing, setPreviewing] = useState<boolean>(false);
  const [submitting, setSubmitting] = useState<boolean>(false);
  const [generatingQuestion, setGeneratingQuestion] = useState<boolean>(false);
  const [showPreview, setShowPreview] = useState<boolean>(false);

  const [previewSqlMutation, previewSqlResult] = usePreviewSqlMutation();

  const [generateQuestionMutation] = useGenerateQuestionMutation();

  const sqlValue = Form.useWatch('sql', form);

  useEffect(() => {
    if (visible) {
      form.setFieldsValue({
        question: defaultValue?.question,
        sql: defaultValue?.sql,
      });
    }
  }, [visible, defaultValue]);

  const handleReset = () => {
    previewSqlResult.reset();
    setShowPreview(false);
    setError(null);
    form.resetFields();
  };

  const onValidateSQL = async () => {
    await previewSqlMutation({
      variables: {
        data: {
          sql: sqlValue,
          limit: 1,
          dryRun: true,
        },
      },
    });
  };

  const handleError = (error) => {
    const graphQLError = parseGraphQLError(error);
    setError({ ...graphQLError, shortMessage: 'Invalid SQL syntax' });
    console.error(graphQLError);
  };

  const onPreviewData = async () => {
    setError(null);
    setPreviewing(true);
    try {
      await onValidateSQL();
      setShowPreview(true);
      await previewSqlMutation({
        variables: {
          data: {
            sql: sqlValue,
            limit: 50,
          },
        },
      });
    } catch (error) {
      handleError(error);
    } finally {
      setPreviewing(false);
    }
  };

  const onSubmitButton = () => {
    setError(null);
    setSubmitting(true);
    setShowPreview(false);
    form
      .validateFields()
      .then(async (values) => {
        try {
          await onValidateSQL();
          await onSubmit({ data: values, id: defaultValue?.id });
          onClose();
        } catch (error) {
          handleError(error);
        } finally {
          setSubmitting(false);
        }
      })
      .catch((err) => {
        setSubmitting(false);
        console.error(err);
      });
  };

  const onGenerateQuestion = async () => {
    setGeneratingQuestion(true);
    const { data } = await generateQuestionMutation({
      variables: {
        data: {
          sql: sqlValue,
        },
      },
    });

    form.setFieldsValue({ question: data?.generateQuestion || '' });
    setGeneratingQuestion(false);
  };

  const confirmLoading = loading || submitting;
  const disabled = !sqlValue;

  return (
    <>
      <Modal
        title={`${isCreateMode ? 'Add' : 'Update'} question-SQL pair`}
        centered
        closable
        confirmLoading={confirmLoading}
        destroyOnClose
        maskClosable={false}
        onCancel={onClose}
        visible={visible}
        width={640}
        cancelButtonProps={{ disabled: confirmLoading }}
        okButtonProps={{ disabled: previewSqlResult.loading }}
        afterClose={() => handleReset()}
        footer={
          <div className="d-flex justify-space-between align-center">
            <div
              className="text-sm ml-2 d-flex justify-space-between align-center"
              style={{ width: 300 }}
            >
              <InfoCircleOutlined className="mr-2 text-sm gray-7" />
              <Typography.Text
                type="secondary"
                className="text-sm gray-7 text-left"
              >
                The SQL statement used here follows <b>Wren SQL</b>, which is
                based on ANSI SQL and optimized for Wren AI.{` `}
                <Typography.Link
                  type="secondary"
                  href="https://docs.getwren.ai/oss/guide/home/wren_sql"
                  target="_blank"
                  rel="noopener noreferrer"
                >
                  Learn more about the syntax.
                </Typography.Link>
              </Typography.Text>
            </div>
            <div>
              <Button onClick={onClose}>Cancel</Button>
              <Button
                type="primary"
                onClick={onSubmitButton}
                loading={confirmLoading}
              >
                Submit
              </Button>
            </div>
          </div>
        }
      >
        <StyledForm form={form} preserve={false} layout="vertical">
          <Form.Item
            className="adm-question-form-item"
            label={
              <div
                className="d-flex justify-space-between"
                style={{ width: '100%' }}
              >
                <span>Question</span>
                <div className="gray-8 text-sm">
                  Let AI create a matching question for this SQL statement.
                  <Button
                    className="ml-2"
                    size="small"
                    loading={generatingQuestion}
                    onClick={onGenerateQuestion}
                    disabled={disabled}
                  >
                    <span className="text-sm">Generate question</span>
                  </Button>
                </div>
              </div>
            }
            name="question"
            required
            rules={[
              {
                validator: createSQLPairQuestionValidator(
                  ERROR_TEXTS.SQL_PAIR.QUESTION,
                ),
              },
            ]}
          >
            <Input />
          </Form.Item>
          <Form.Item
            label="SQL statement"
            name="sql"
            required
            rules={[
              {
                required: true,
                message: ERROR_TEXTS.SQL_PAIR.SQL.REQUIRED,
              },
            ]}
          >
            <SQLEditor
              toolbar={
                dataSource.isSupportSubstitute && (
                  <Toolbar
                    dataSource={dataSource.type}
                    onClick={() =>
                      importDataSourceSQLModal.openModal({
                        dataSource: dataSource.type,
                      })
                    }
                  />
                )
              }
              autoComplete
              autoFocus
            />
          </Form.Item>
        </StyledForm>
        <div className="my-3">
          <Typography.Text className="d-block gray-7 mb-2">
            Data preview (50 rows)
          </Typography.Text>
          <Button
            onClick={onPreviewData}
            loading={previewing}
            disabled={disabled}
          >
            Preview data
          </Button>
          {showPreview && (
            <div className="my-3">
              <PreviewData
                loading={previewing}
                previewData={previewSqlResult?.data?.previewSql}
                copyable={false}
              />
            </div>
          )}
        </div>
        {!!error && (
          <Alert
            showIcon
            type="error"
            message={error.shortMessage}
            description={<ErrorCollapse message={error.message} />}
          />
        )}
      </Modal>
      {dataSource.isSupportSubstitute && (
        <ImportDataSourceSQLModal
          {...importDataSourceSQLModal.state}
          onClose={importDataSourceSQLModal.closeModal}
          onSubmit={async (convertedSql: string) => {
            form.setFieldsValue({ sql: convertedSql });
          }}
        />
      )}
    </>
  );
}
</file>

<file path="src/components/modals/RelationModal.tsx">
import { useEffect } from 'react';
import { isEmpty } from 'lodash';
import { Modal, Form, Select } from 'antd';
import { ModalAction } from '@/hooks/useModalAction';
import { ERROR_TEXTS } from '@/utils/error';
import CombineFieldSelector from '@/components/selectors/CombineFieldSelector';
import { JOIN_TYPE, FORM_MODE, convertIdentifierToObject } from '@/utils/enum';
import { getJoinTypeText } from '@/utils/data';
import {
  createRelationshipFromFieldValidator,
  createRelationshipToFieldValidator,
} from '@/utils/validator';
import useCombineFieldOptions, {
  convertDefaultValueToIdentifier,
} from '@/hooks/useCombineFieldOptions';
import { RelationsDataType } from '@/components/table/ModelRelationSelectionTable';
import { SelectedRecommendRelations } from '@/components/pages/setup/DefineRelations';

export const FormFieldKey = {
  FROM_FIELD: 'fromField',
  TO_FIELD: 'toField',
  TYPE: 'type',
};

export interface RelationFormValues {
  fromField: { model: string; field: string };
  toField: { model: string; field: string };
  type?: string;
}

export type RelationFieldValue = Pick<
  RelationsDataType,
  'type' | 'fromField' | 'toField'
>;

type Props = ModalAction<RelationFieldValue, RelationFormValues> & {
  model: string;
  loading?: boolean;
  relations: SelectedRecommendRelations;
  isRecommendMode?: boolean;
};

export default function RelationModal(props: Props) {
  const {
    defaultValue,
    loading,
    model,
    onClose,
    onSubmit,
    relations,
    visible,
    formMode,
    isRecommendMode,
  } = props;
  const [form] = Form.useForm();

  // only suitable use for modeling page
  const isUpdateMode = formMode === FORM_MODE.EDIT;

  const fromCombineField = useCombineFieldOptions({ model });
  const modelValue = fromCombineField.modelOptions.find((option) => {
    const value: any = convertIdentifierToObject(option.value);
    return value.referenceName === model;
  })?.value;

  const toFieldModel = defaultValue?.toField.modelName;
  const toCombineField = useCombineFieldOptions({
    model: toFieldModel,
    excludeModels: [model],
  });

  useEffect(() => {
    if (!visible || isEmpty(defaultValue)) return;

    const transformedValue = convertDefaultValueToIdentifier(defaultValue);
    form.setFieldsValue(transformedValue);

    toCombineField.onModelChange(transformedValue.toField.model);
  }, [form, defaultValue, visible]);

  const relationTypeOptions = Object.keys(JOIN_TYPE).map((key) => ({
    label: getJoinTypeText(key),
    value: JOIN_TYPE[key],
  }));

  const submit = () => {
    form
      .validateFields()
      .then(async (values) => {
        await onSubmit({ ...defaultValue, ...values });
        onClose();
      })
      .catch(console.error);
  };

  return (
    <Modal
      title={`${isEmpty(defaultValue) ? 'Add' : 'Update'} relationship`}
      width={750}
      visible={visible}
      okText="Submit"
      onOk={submit}
      onCancel={onClose}
      confirmLoading={loading}
      maskClosable={false}
      destroyOnClose
      afterClose={() => form.resetFields()}
      centered
    >
      <Form form={form} preserve={false} layout="vertical">
        <Form.Item
          label="From"
          name={FormFieldKey.FROM_FIELD}
          required
          rules={[
            ({ getFieldValue }) => ({
              validator: createRelationshipFromFieldValidator(
                isUpdateMode || isRecommendMode,
                relations,
                getFieldValue,
              ),
            }),
          ]}
        >
          <CombineFieldSelector
            modelValue={modelValue}
            modelDisabled={true}
            fieldDisabled={isUpdateMode}
            onModelChange={fromCombineField.onModelChange}
            modelOptions={fromCombineField.modelOptions}
            fieldOptions={fromCombineField.fieldOptions}
          />
        </Form.Item>
        <Form.Item
          label="To"
          name={FormFieldKey.TO_FIELD}
          required
          rules={[
            ({ getFieldValue }) => ({
              validator: createRelationshipToFieldValidator(
                isUpdateMode || isRecommendMode,
                relations,
                getFieldValue,
              ),
            }),
          ]}
        >
          <CombineFieldSelector
            onModelChange={toCombineField.onModelChange}
            modelOptions={toCombineField.modelOptions}
            fieldOptions={toCombineField.fieldOptions}
            modelDisabled={isUpdateMode}
            fieldDisabled={isUpdateMode}
          />
        </Form.Item>
        <Form.Item
          label="Type"
          name={FormFieldKey.TYPE}
          required
          rules={[
            {
              required: true,
              message: ERROR_TEXTS.ADD_RELATION.RELATION_TYPE.REQUIRED,
            },
          ]}
        >
          <Select
            data-testid="relationship-form__type-select"
            options={relationTypeOptions}
            placeholder="Select a relationship type"
          />
        </Form.Item>
      </Form>
    </Modal>
  );
}
</file>

<file path="src/components/modals/SaveAsViewModal.tsx">
import { Button, Form, Input, Modal, Typography } from 'antd';
import InfoCircleOutlined from '@ant-design/icons/InfoCircleOutlined';
import { ModalAction } from '@/hooks/useModalAction';
import { createViewNameValidator } from '@/utils/validator';
import SQLCodeBlock from '@/components/code/SQLCodeBlock';
import { useValidateViewMutation } from '@/apollo/client/graphql/view.generated';

const { Text } = Typography;

type Props = ModalAction<{ sql: string }> & {
  loading?: boolean;
  defaultValue: { sql: string; responseId: number };
};

export default function SaveAsViewModal(props: Props) {
  const { visible, loading, onSubmit, onClose, defaultValue } = props;
  const [form] = Form.useForm();
  const [validateViewMutation] = useValidateViewMutation({
    fetchPolicy: 'no-cache',
  });

  const submit = () => {
    form
      .validateFields()
      .then(async (values) => {
        await onSubmit({ responseId: defaultValue.responseId, ...values });
        onClose();
      })
      .catch(console.error);
  };

  const sql = defaultValue ? defaultValue.sql : '';

  return (
    <Modal
      title="Save as View"
      centered
      closable
      destroyOnClose
      onCancel={onClose}
      maskClosable={false}
      visible={visible}
      width={600}
      afterClose={() => form.resetFields()}
      footer={
        <div className="d-flex justify-space-between align-center">
          <div
            className="d-flex justify-space-between align-center ml-2"
            style={{ width: 300 }}
          >
            <InfoCircleOutlined className="mr-2 text-sm gray-6" />
            <Text type="secondary" className="text-sm gray-6 text-left">
              After saving, make sure you go to "Modeling Page" to deploy all
              saved views.
            </Text>
          </div>
          <div>
            <Button onClick={onClose}>Cancel</Button>
            <Button type="primary" onClick={submit} loading={loading}>
              Save
            </Button>
          </div>
        </div>
      }
    >
      <Form form={form} preserve={false} layout="vertical">
        <Form.Item
          label="Name"
          name="name"
          required
          rules={[
            {
              required: true,
              validator: createViewNameValidator(validateViewMutation),
            },
          ]}
        >
          <Input />
        </Form.Item>
        <Form.Item label="SQL Statement">
          <SQLCodeBlock code={sql} showLineNumbers maxHeight="300" />
        </Form.Item>
      </Form>
    </Modal>
  );
}
</file>

<file path="src/components/modals/SchemaChangeModal.tsx">
import { useMemo } from 'react';
import {
  Modal,
  Button,
  Table,
  Typography,
  Collapse,
  Alert,
  Tag,
  Popconfirm,
} from 'antd';
import styled from 'styled-components';
import WarningOutlined from '@ant-design/icons/WarningOutlined';
import PlusSquareOutlined from '@ant-design/icons/PlusSquareOutlined';
import LineOutlined from '@ant-design/icons/LineOutlined';
import FileDoneOutlined from '@ant-design/icons/FileDoneOutlined';
import { ModalAction } from '@/hooks/useModalAction';
import EllipsisWrapper from '@/components/EllipsisWrapper';
import {
  DetailedChangeTable,
  DetailedAffectedCalculatedFields,
  DetailedAffectedRelationships,
  NodeType,
  SchemaChange,
  SchemaChangeType,
} from '@/apollo/client/graphql/__types__';

const StyledCollapse = styled(Collapse)`
  border: none;
  background-color: white;
  .ant-collapse-item:last-child,
  .ant-collapse-item:last-child > .ant-collapse-header {
    border-radius: 0;
  }
  .ant-collapse-item,
  .ant-collapse-content {
    border-color: var(--gray-4);
  }
  .ant-collapse-content-box {
    padding: 0;
  }
`;

const StyledTable = styled(Table)`
  padding-left: 36px;
  .ant-table {
    border: none;
    border-radius: 0;

    .non-expandable {
      .ant-table-row-expand-icon {
        display: none;
      }
    }

    .ant-table-expanded-row {
      .ant-table-cell {
        background-color: white;
      }
    }
  }
`;

type Props = ModalAction<SchemaChange> & {
  loading?: boolean;
  payload?: {
    onResolveSchemaChange?: (type: SchemaChangeType) => void;
    isResolving?: boolean;
  };
};

const nestedColumns = [
  {
    title: 'Affected Resource',
    dataIndex: 'resourceType',
    width: 200,
    render: (resourceType: NodeType) => {
      if (resourceType === NodeType.CALCULATED_FIELD) {
        return <Tag className="ant-tag--geekblue">Calculated Field</Tag>;
      }

      if (resourceType === NodeType.RELATION) {
        return <Tag className="ant-tag--citrus">Relationship</Tag>;
      }

      return null;
    },
  },
  {
    title: 'Name',
    dataIndex: 'displayName',
  },
];

const checkIsExpandable = (record: DetailedChangeTable) =>
  record.calculatedFields.length + record.relationships.length > 0
    ? ''
    : 'non-expandable';

const PanelHeader = (props) => {
  const { title, count, onResolve, isResolving } = props;
  const resolve = (event) => {
    event.stopPropagation();
    onResolve();
  };
  return (
    <div
      className="d-flex align-center flex-grow-1"
      style={{ userSelect: 'none' }}
    >
      <b className="text-medium">{title}</b>
      <span className="flex-grow-1 text-right d-flex justify-end">
        <Typography.Text className="gray-6">
          {count} table(s) affected
        </Typography.Text>
        <div style={{ width: 150 }}>
          {!!onResolve && (
            <Popconfirm
              title="Are you sure?"
              okText="Confirm"
              okButtonProps={{ danger: true }}
              onConfirm={resolve}
              onCancel={(event) => event.stopPropagation()}
            >
              <Button
                type="text"
                size="small"
                className="red-5"
                onClick={(event) => event.stopPropagation()}
                loading={isResolving}
                icon={<FileDoneOutlined />}
              >
                Resolve
              </Button>
            </Popconfirm>
          )}
        </div>
      </span>
    </div>
  );
};

interface ExpandedRowsProps {
  record: DetailedChangeTable & {
    resources: Array<
      DetailedAffectedCalculatedFields | DetailedAffectedRelationships
    >;
  };
  tipMessage: string;
}

const ExpandedRows = ({ record, tipMessage }: ExpandedRowsProps) => {
  if (record.resources.length === 0) return null;

  return (
    <div className="pl-12">
      <Alert
        showIcon
        icon={<WarningOutlined className="orange-5" />}
        className="gray-6 ml-2 bg-gray-1 pl-0"
        style={{ border: 'none' }}
        message={tipMessage}
      />
      <Table
        columns={nestedColumns}
        dataSource={record.resources || []}
        pagination={{
          hideOnSinglePage: true,
          size: 'small',
          pageSize: 10,
        }}
        rowKey="rowKey"
        size="small"
        className="adm-nested-table"
      />
    </div>
  );
};

export default function SchemaChangeModal(props: Props) {
  const { visible, onClose, defaultValue: schemaChange, payload } = props;
  const { onResolveSchemaChange, isResolving } = payload || {};

  const { deletedTables, deletedColumns, modifiedColumns } = useMemo(() => {
    const { deletedTables, deletedColumns, modifiedColumns } =
      schemaChange || {};

    if (!schemaChange)
      return {
        deletedTables,
        deletedColumns,
        modifiedColumns,
      };

    // transform data to render UI
    const transformData = (tables: DetailedChangeTable) => ({
      ...tables,
      resources: [
        ...tables.calculatedFields.map(
          (
            calculatedField: DetailedAffectedCalculatedFields,
            index: number,
          ) => ({
            ...calculatedField,
            resourceType: NodeType.CALCULATED_FIELD,
            rowKey: `${tables.sourceTableName}-${calculatedField.referenceName}-${index}`,
          }),
        ),
        ...tables.relationships.map(
          (relationship: DetailedAffectedRelationships, index: number) => ({
            ...relationship,
            resourceType: NodeType.RELATION,
            rowKey: `${tables.sourceTableName}-${relationship.referenceName}-${index}`,
          }),
        ),
      ],
      rowKey: tables.sourceTableName,
    });

    return {
      deletedTables: deletedTables?.map(transformData),
      deletedColumns: deletedColumns?.map(transformData),
      modifiedColumns: modifiedColumns?.map(transformData),
    };
  }, [schemaChange]);

  const columnsOfDeleteTables = [
    { title: 'Affected model', width: 200, dataIndex: 'displayName' },
    { title: 'Source table name', dataIndex: 'sourceTableName' },
  ];

  const columnsOfDeletedColumns = [
    { title: 'Affected model', width: 200, dataIndex: 'displayName' },
    {
      title: 'Deleted columns',
      dataIndex: 'columns',
      render: (columns) => {
        return (
          <EllipsisWrapper showMoreCount>
            {columns.map((column) => (
              <Tag className="ant-tag--geekblue" key={column.sourceColumnName}>
                {column.displayName}
              </Tag>
            ))}
          </EllipsisWrapper>
        );
      },
    },
  ];

  const columnsOfModifiedColumns = [
    { title: 'Affected model', width: 200, dataIndex: 'displayName' },
    {
      title: 'Affected columns',
      dataIndex: 'columns',
      render: (columns) => {
        return (
          <EllipsisWrapper showMoreCount>
            {columns.map((column) => (
              <Tag className="ant-tag--geekblue" key={column.sourceColumnName}>
                {column.displayName}
              </Tag>
            ))}
          </EllipsisWrapper>
        );
      },
    },
  ];

  return (
    <Modal
      title={
        <>
          <WarningOutlined className="orange-5 mr-2" />
          Schema Changes
        </>
      }
      width={750}
      visible={visible}
      onCancel={onClose}
      destroyOnClose
      footer={null}
    >
      <Typography.Paragraph className="gray-6 mb-4">
        We have detected schema changes from your connected data source. Please
        review the impacts of these changes.
      </Typography.Paragraph>
      <Alert
        showIcon
        type="warning"
        className="gray-8 mb-6"
        message={`Please note that clicking \"Resolve\" may automatically delete all affected models, relationships, and calculated fields.`}
      />
      <StyledCollapse
        expandIcon={(panelProps) =>
          panelProps.isActive ? <LineOutlined /> : <PlusSquareOutlined />
        }
      >
        {deletedTables && (
          <Collapse.Panel
            header={
              <PanelHeader
                title="Source table deleted"
                count={deletedTables.length}
                onResolve={() =>
                  onResolveSchemaChange(SchemaChangeType.DELETED_TABLES)
                }
                isResolving={isResolving}
              ></PanelHeader>
            }
            key="deleteTables"
          >
            <StyledTable
              rowKey="rowKey"
              columns={columnsOfDeleteTables}
              dataSource={deletedTables}
              size="small"
              pagination={{
                hideOnSinglePage: true,
                size: 'small',
                pageSize: 10,
              }}
              rowClassName={checkIsExpandable}
              expandable={{
                expandedRowRender: (record: ExpandedRowsProps['record']) => (
                  <ExpandedRows
                    record={record}
                    tipMessage="The following table shows resources affected by this model and will be deleted when resolving."
                  />
                ),
              }}
            />
          </Collapse.Panel>
        )}
        {deletedColumns && (
          <Collapse.Panel
            header={
              <PanelHeader
                title="Source column deleted"
                count={deletedColumns.length}
                onResolve={() =>
                  onResolveSchemaChange(SchemaChangeType.DELETED_COLUMNS)
                }
                isResolving={isResolving}
              ></PanelHeader>
            }
            key="deleteColumns"
          >
            <StyledTable
              rowKey="rowKey"
              columns={columnsOfDeletedColumns}
              dataSource={deletedColumns}
              size="small"
              pagination={{
                hideOnSinglePage: true,
                size: 'small',
                pageSize: 10,
              }}
              rowClassName={checkIsExpandable}
              expandable={{
                expandedRowRender: (record: ExpandedRowsProps['record']) => (
                  <ExpandedRows
                    record={record}
                    tipMessage="The following table shows resources affected by this column of the model and will be deleted when resolving."
                  />
                ),
              }}
            />
          </Collapse.Panel>
        )}
        {modifiedColumns && (
          <Collapse.Panel
            header={
              <PanelHeader
                title="Source column type changed"
                count={modifiedColumns.length}
              ></PanelHeader>
            }
            key="modifiedColumns"
          >
            <StyledTable
              rowKey="rowKey"
              columns={columnsOfModifiedColumns}
              dataSource={modifiedColumns}
              size="small"
              pagination={{
                hideOnSinglePage: true,
                size: 'small',
                pageSize: 10,
              }}
              rowClassName={checkIsExpandable}
              expandable={{
                expandedRowRender: (record: ExpandedRowsProps['record']) => (
                  <ExpandedRows
                    record={record}
                    tipMessage="The following table shows the resources utilized by this column of the model. Please review each resource and manually update the relevant ones if any changes are required."
                  />
                ),
              }}
            />
          </Collapse.Panel>
        )}
      </StyledCollapse>
    </Modal>
  );
}
</file>

<file path="src/components/PageLoading.tsx">
import { Spin } from 'antd';
import styled from 'styled-components';
import LoadingOutlined from '@ant-design/icons/LoadingOutlined';

const Wrapper = styled.div`
  position: absolute;
  top: 48px;
  left: 0;
  right: 0;
  bottom: 0;
  z-index: 9999;
  background-color: white;
  display: none;

  &.isShow {
    display: flex;
  }
`;

interface Props {
  visible?: boolean;
}

interface LoadingProps {
  children?: React.ReactNode | null;
  spinning?: boolean;
  loading?: boolean;
  tip?: string;
  size?: number;
  width?: number;
  height?: number;
  className?: string;
}

export const defaultIndicator = (
  <LoadingOutlined style={{ fontSize: 36 }} spin />
);

export const Spinner = ({ className = '', size = 36 }) => (
  <LoadingOutlined className={className} style={{ fontSize: size }} spin />
);

export default function PageLoading(props: Props) {
  const { visible } = props;
  return (
    <Wrapper
      className={`align-center justify-center${visible ? ' isShow' : ''}`}
    >
      <div className="text-center">
        <Spin indicator={defaultIndicator} />
        <div className="mt-2 geekblue-6">Loading...</div>
      </div>
    </Wrapper>
  );
}

export const FlexLoading = (props) => {
  const { height, tip } = props;
  return (
    <div
      className="d-flex align-center justify-center flex-column geekblue-6"
      style={{ height: height || '100%' }}
    >
      {defaultIndicator}
      {tip && <span className="mt-2">{tip}</span>}
    </div>
  );
};

export const Loading = ({
  children = null,
  spinning = false,
  loading = false,
  tip,
}: LoadingProps) => (
  <Spin indicator={defaultIndicator} spinning={spinning || loading} tip={tip}>
    {children}
  </Spin>
);

interface LoadingWrapperProps {
  loading: boolean;
  tip?: string;
  children: React.ReactElement;
}

export const LoadingWrapper = (props: LoadingWrapperProps) => {
  const { loading, tip, children } = props;
  if (loading) return <FlexLoading tip={tip} />;
  return children;
};
</file>

<file path="src/components/pages/apiManagement/DetailsDrawer.tsx">
import { Drawer, Typography, Row, Col, Tag } from 'antd';
import { getAbsoluteTime } from '@/utils/time';
import { DrawerAction } from '@/hooks/useDrawerAction';
import CheckCircleOutlined from '@ant-design/icons/CheckCircleOutlined';
import CloseCircleOutlined from '@ant-design/icons/CloseCircleOutlined';
import JsonCodeBlock from '@/components/code/JsonCodeBlock';
import { ApiHistoryResponse } from '@/apollo/client/graphql/__types__';

type Props = DrawerAction<ApiHistoryResponse> & {
  loading?: boolean;
};

export default function DetailsDrawer(props: Props) {
  const { visible, onClose, defaultValue } = props;

  const {
    threadId,
    apiType,
    createdAt,
    durationMs,
    statusCode,
    headers,
    requestPayload,
    responsePayload,
  } = defaultValue || {};

  const getStatusTag = (status: number) => {
    const isSuccess = status >= 200 && status < 300;
    return (
      <Tag
        icon={isSuccess ? <CheckCircleOutlined /> : <CloseCircleOutlined />}
        color={isSuccess ? 'success' : 'error'}
      >
        {status}
      </Tag>
    );
  };

  return (
    <Drawer
      visible={visible}
      className="gray-8"
      title="API details"
      width={760}
      closable
      destroyOnClose
      onClose={onClose}
      footer={null}
    >
      <Row className="mb-6">
        <Col span={12}>
          <Typography.Text className="d-block gray-7 mb-2">
            API type
          </Typography.Text>
          <div>
            <Tag className="gray-8">{apiType?.toLowerCase()}</Tag>
          </div>
        </Col>
        <Col span={12}>
          <Typography.Text className="d-block gray-7 mb-2">
            Thread ID
          </Typography.Text>
          <div>{threadId || '-'}</div>
        </Col>
      </Row>
      <Row className="mb-6">
        <Col span={12}>
          <Typography.Text className="d-block gray-7 mb-2">
            Created at
          </Typography.Text>
          <div>{getAbsoluteTime(createdAt)}</div>
        </Col>
        <Col span={12}>
          <Typography.Text className="d-block gray-7 mb-2">
            Duration
          </Typography.Text>
          <div>{durationMs} ms</div>
        </Col>
      </Row>
      <Row className="mb-6">
        <Col span={12}>
          <Typography.Text className="d-block gray-7 mb-2">
            Status code
          </Typography.Text>
          <div>{getStatusTag(statusCode)}</div>
        </Col>
      </Row>

      <div className="mb-6">
        <Typography.Text className="d-block gray-7 mb-2">
          Headers
        </Typography.Text>
        <JsonCodeBlock
          code={headers}
          backgroundColor="var(--gray-2)"
          maxHeight="400"
          copyable
        />
      </div>

      <div className="mb-6">
        <Typography.Text className="d-block gray-7 mb-2">
          Request payload
        </Typography.Text>
        <JsonCodeBlock
          code={requestPayload}
          backgroundColor="var(--gray-2)"
          maxHeight="400"
          copyable
        />
      </div>

      <div className="mb-6">
        <Typography.Text className="d-block gray-7 mb-2">
          Response payload
        </Typography.Text>
        <JsonCodeBlock
          code={responsePayload}
          backgroundColor="var(--gray-2)"
          maxHeight="400"
          copyable
        />
      </div>
    </Drawer>
  );
}
</file>

<file path="src/components/pages/home/dashboardGrid/CacheSettingsDrawer.tsx">
import { useEffect } from 'react';
import { capitalize } from 'lodash';
import { CronExpressionParser } from 'cron-parser';
import moment from 'moment';
import {
  Button,
  Drawer,
  Form,
  Space,
  Switch,
  Select,
  Input,
  Row,
  Col,
  Divider,
  TimePicker,
} from 'antd';
import { browserTimeZone } from '@/utils/time';
import { DrawerAction } from '@/hooks/useDrawerAction';
import { ERROR_TEXTS } from '@/utils/error';
import { isValidCronLength, cronValidator } from '@/utils/validator';
import { CacheScheduleDayEnum } from '@/apollo/client/graphql/__types__';

type Props = DrawerAction & {
  loading?: boolean;
};

export interface Schedule {
  frequency: string;
  day?: string;
  hour?: number;
  minute?: number;
  cron?: string;
  timezone?: string;
}

const timeFormat = 'HH:mm';

const FREQUENCY = {
  DAILY: 'DAILY',
  WEEKLY: 'WEEKLY',
  CUSTOM: 'CUSTOM',
  NEVER: 'NEVER',
};

// This sequence follows the first day of the week
const DAY_OF_WEEK = [
  CacheScheduleDayEnum.SUN,
  CacheScheduleDayEnum.MON,
  CacheScheduleDayEnum.TUE,
  CacheScheduleDayEnum.WED,
  CacheScheduleDayEnum.THU,
  CacheScheduleDayEnum.FRI,
  CacheScheduleDayEnum.SAT,
];

const getDayOfWeekText = (day: CacheScheduleDayEnum) => {
  return (
    {
      [CacheScheduleDayEnum.MON]: 'Monday',
      [CacheScheduleDayEnum.TUE]: 'Tuesday',
      [CacheScheduleDayEnum.WED]: 'Wednesday',
      [CacheScheduleDayEnum.THU]: 'Thursday',
      [CacheScheduleDayEnum.FRI]: 'Friday',
      [CacheScheduleDayEnum.SAT]: 'Saturday',
      [CacheScheduleDayEnum.SUN]: 'Sunday',
    }[day] || ''
  );
};

const getFrequencyText = (frequency: string) => {
  if (frequency === FREQUENCY.NEVER) return 'Manual refresh only';
  return capitalize(frequency);
};

const getInitialSchedule = (frequency: string) => {
  let schedule = {};
  switch (frequency) {
    case FREQUENCY.DAILY:
      schedule = {
        day: null,
        time: moment('00:00', timeFormat),
        cron: null,
      };
      break;
    case FREQUENCY.WEEKLY:
      schedule = {
        day: DAY_OF_WEEK[0],
        time: moment('00:00', timeFormat),
        cron: null,
      };
      break;
    case FREQUENCY.CUSTOM:
      schedule = {
        day: null,
        time: null,
        cron: '0 0 * * *',
      };
      break;
    case FREQUENCY.NEVER:
      schedule = {
        day: null,
        time: null,
        cron: null,
      };
      break;
    default:
      break;
  }
  return schedule;
};

export const getScheduleText = (schedule: Schedule): string => {
  if (!schedule) return '';
  const { frequency } = schedule;

  const convertTime = (schedule: Schedule) => {
    const time = moment(
      `${schedule.hour}:${schedule.minute}`,
      timeFormat,
    ).format(timeFormat);
    return time;
  };

  switch (frequency) {
    case FREQUENCY.DAILY: {
      const time = convertTime(schedule);
      return `Cache refreshes daily at ${time}`;
    }
    case FREQUENCY.WEEKLY: {
      const time = convertTime(schedule);
      return `Cache refreshes every ${getDayOfWeekText(schedule.day as CacheScheduleDayEnum)} at ${time}`;
    }
    case FREQUENCY.CUSTOM: {
      return `Cache refreshes on custom schedule`;
    }
    case FREQUENCY.NEVER: {
      return 'Cache refresh: manual only';
    }
    default: {
      return '';
    }
  }
};

const getNextSchedule = (data: {
  frequency: string;
  day: string;
  time: moment.Moment;
  cron: string;
}) => {
  const { frequency, day, time, cron } = data;
  if (frequency === FREQUENCY.CUSTOM) return getNextScheduleByCron(cron);
  if (frequency === FREQUENCY.NEVER || !time) return null;

  // frequency daily or weekly calculation
  const now = moment();
  const targetTime = moment(
    `${now.format('YYYY-MM-DD')} ${time.format(timeFormat)}`,
  );

  // set the day of the week if it's a weekly schedule
  if (day) {
    const dayIndex = DAY_OF_WEEK.findIndex((d) => d === day);
    targetTime.set({ day: dayIndex });
  }

  // postpond the time if it's already passed
  if (now.isAfter(targetTime)) {
    if (frequency === FREQUENCY.DAILY) {
      targetTime.add(1, 'd');
    } else if (frequency === FREQUENCY.WEEKLY) {
      targetTime.add(7, 'd');
    }
  }

  return targetTime.isValid() ? targetTime.format('YYYY-MM-DD HH:mm') : null;
};

const getNextScheduleByCron = (cron: string) => {
  if (!cron || !isValidCronLength(cron)) return null;
  try {
    const interval = CronExpressionParser.parse(cron, { tz: 'UTC' });
    const targetTime = moment.utc(interval.next().toDate()).local();
    return targetTime.isValid() ? targetTime.format('YYYY-MM-DD HH:mm') : null;
  } catch (error) {
    console.warn(error);
    return null;
  }
};

export default function CacheSettingsDrawer(props: Props) {
  const { visible, defaultValue, loading, onClose, onSubmit } = props;
  const [form] = Form.useForm();

  const cacheEnabled = Form.useWatch('cacheEnabled', form);

  useEffect(() => {
    if (visible) {
      const { schedule, ...restValues } = defaultValue || {};
      form.setFieldsValue({
        ...restValues,
        schedule: {
          day: schedule?.day,
          frequency: schedule?.frequency,
          time:
            schedule?.hour.toString() && schedule?.minute.toString()
              ? moment(`${schedule?.hour}:${schedule?.minute}`, timeFormat)
              : null,
          cron: schedule?.cron,
        },
      });
    }
  }, [visible, defaultValue]);

  const afterVisibleChange = (visible: boolean) => {
    if (!visible) {
      form.resetFields();
    }
  };

  const submit = () => {
    form
      .validateFields()
      .then(async (values) => {
        const { schedule } = values;
        await onSubmit({
          ...values,
          schedule: values.cacheEnabled
            ? {
                frequency: schedule?.frequency,
                day: schedule?.day,
                hour: schedule?.time?.hour(),
                minute: schedule?.time?.minute(),
                cron: schedule?.cron,
                timezone: browserTimeZone,
              }
            : null,
        });
        onClose();
      })
      .catch(console.error);
  };

  return (
    <Drawer
      visible={visible}
      title="Cache settings"
      width={410}
      closable
      destroyOnClose
      maskClosable={false}
      afterVisibleChange={afterVisibleChange}
      onClose={onClose}
      footer={
        <Space className="d-flex justify-end">
          <Button onClick={onClose} disabled={loading}>
            Cancel
          </Button>
          <Button
            type="primary"
            onClick={submit}
            loading={loading}
            disabled={loading}
          >
            Submit
          </Button>
        </Space>
      }
    >
      <Form form={form} layout="vertical">
        <Form.Item
          label="Enable caching"
          name="cacheEnabled"
          valuePropName="checked"
          extra="Enable caching to speed up dashboard loading by reusing recent results. Choose a refresh schedule that fits your needs below."
        >
          <Switch />
        </Form.Item>
        {cacheEnabled && <Schedule />}
      </Form>
    </Drawer>
  );
}

function Schedule() {
  const form = Form.useFormInstance();
  const frequency = Form.useWatch(['schedule', 'frequency'], form);
  const day = Form.useWatch(['schedule', 'day'], form);
  const time = Form.useWatch(['schedule', 'time'], form);
  const cron = Form.useWatch(['schedule', 'cron'], form);

  const onFrequencyChange = (value: string) => {
    form.setFieldsValue({
      schedule: { frequency: value, ...getInitialSchedule(value) },
    });
  };

  const nextSchedule = getNextSchedule({ frequency, day, time, cron });

  return (
    <>
      <Divider className="gray-6 text-sm">Refresh settings</Divider>
      <Form.Item label="Frequency" name={['schedule', 'frequency']}>
        <Select
          placeholder="Select frequency"
          options={Object.keys(FREQUENCY).map((key) => ({
            label: getFrequencyText(key),
            value: FREQUENCY[key],
          }))}
          onChange={onFrequencyChange}
        />
      </Form.Item>

      {frequency === FREQUENCY.DAILY && <DailyTimeSelection />}
      {frequency === FREQUENCY.WEEKLY && <WeeklyTimeSelection />}
      {frequency === FREQUENCY.CUSTOM && (
        <Form.Item
          label="Cron expression"
          name={['schedule', 'cron']}
          required={false}
          rules={[{ validator: cronValidator }]}
          extra="Cron expression will be executed in UTC timezone (e.g. '0 0 * * *' for daily at midnight UTC)"
        >
          <Input style={{ maxWidth: 200 }} placeholder="* * * * *" />
        </Form.Item>
      )}

      {nextSchedule && (
        <div className="gray-7">
          Next scheduled refresh:
          <div className="gray-8">
            {nextSchedule} {browserTimeZone && <span>({browserTimeZone})</span>}
          </div>
        </div>
      )}
    </>
  );
}

function DailyTimeSelection() {
  return (
    <>
      <Form.Item
        label="Time"
        name={['schedule', 'time']}
        required={false}
        rules={[
          {
            required: true,
            message: ERROR_TEXTS.CACHE_SETTINGS.TIME.REQUIRED,
          },
        ]}
      >
        <TimePicker minuteStep={10} format={timeFormat} />
      </Form.Item>
    </>
  );
}

function WeeklyTimeSelection() {
  return (
    <>
      <Row gutter={16}>
        <Col>
          <Form.Item
            label="Day"
            name={['schedule', 'day']}
            required={false}
            rules={[
              {
                required: true,
                message: ERROR_TEXTS.CACHE_SETTINGS.DAY.REQUIRED,
              },
            ]}
          >
            <Select
              style={{ minWidth: 123 }}
              options={DAY_OF_WEEK.map((value) => ({
                label: getDayOfWeekText(value),
                value,
              }))}
              placeholder="Select day"
            />
          </Form.Item>
        </Col>
        <Col>
          <Form.Item
            label="Time"
            name={['schedule', 'time']}
            required={false}
            rules={[
              {
                required: true,
                message: ERROR_TEXTS.CACHE_SETTINGS.TIME.REQUIRED,
              },
            ]}
          >
            <TimePicker minuteStep={10} format={timeFormat} />
          </Form.Item>
        </Col>
      </Row>
    </>
  );
}
</file>

<file path="src/components/pages/home/dashboardGrid/DashboardHeader.tsx">
import { Button, Tooltip } from 'antd';
import styled from 'styled-components';
import { MoreIcon } from '@/utils/icons';
import { MORE_ACTION } from '@/utils/enum';
import { getCompactTime } from '@/utils/time';
import { DashboardDropdown } from '@/components/diagram/CustomDropdown';
import {
  Schedule,
  getScheduleText,
} from '@/components/pages/home/dashboardGrid/CacheSettingsDrawer';

interface Props {
  isSupportCached: boolean;
  nextScheduleTime?: string;
  schedule?: Schedule;
  onCacheSettings?: () => void;
  onRefreshAll?: () => void;
}

const StyledHeader = styled.div`
  display: flex;
  align-items: center;
  justify-content: space-between;
  min-height: 49px;
  padding: 8px 16px;
  background-color: white;
  border-bottom: 1px solid var(--gray-4);
`;

export default function DashboardHeader(props: Props) {
  const {
    isSupportCached,
    nextScheduleTime,
    schedule,
    onCacheSettings,
    onRefreshAll,
  } = props;

  const scheduleTime = getScheduleText(schedule);

  const onMoreClick = async (action: MORE_ACTION) => {
    if (action === MORE_ACTION.CACHE_SETTINGS) {
      onCacheSettings?.();
    } else if (action === MORE_ACTION.REFRESH) {
      onRefreshAll?.();
    }
  };

  return (
    <StyledHeader>
      <div />
      <div>
        {schedule && (
          <div className="d-flex align-center gray-6 gx-2">
            {isSupportCached && (
              <>
                {nextScheduleTime ? (
                  <Tooltip
                    placement="bottom"
                    title={
                      <>
                        <div>
                          <span className="gray-6">Next schedule:</span>{' '}
                          {getCompactTime(nextScheduleTime)}
                        </div>
                        {schedule.cron && (
                          <div>
                            <span className="gray-6">Cron expression:</span>{' '}
                            {schedule.cron}
                          </div>
                        )}
                      </>
                    }
                  >
                    <span className="cursor-pointer">{scheduleTime}</span>
                  </Tooltip>
                ) : (
                  scheduleTime
                )}
              </>
            )}
            <DashboardDropdown
              onMoreClick={onMoreClick}
              isSupportCached={isSupportCached}
            >
              <Button type="text" icon={<MoreIcon className="gray-8" />} />
            </DashboardDropdown>
          </div>
        )}
      </div>
    </StyledHeader>
  );
}
</file>

<file path="src/components/pages/home/dashboardGrid/EmptyDashboard.tsx">
import Link from 'next/link';
import Image from 'next/image';
import { Row, Col } from 'antd';
import { Logo } from '@/components/Logo';
import { makeIterable } from '@/utils/iteration';

const StepTemplate = (props: { title: string; image: string }) => {
  return (
    <Col>
      <div
        className="p-3 rounded bg-gray-1 border border-gray-5"
        style={{ boxShadow: '2px 2px 2px 0px #00000006' }}
      >
        <div className="mb-2">
          <span
            className="d-inline-block bg-geekblue-1 geekblue-6 rounded-pill text-sm px-2"
            style={{ lineHeight: '22px' }}
          >
            {props.title}
          </span>
        </div>
        <Image
          className="rounded border border-gray-4"
          src={props.image}
          width={160}
          height={80}
          alt={props.title}
        />
      </div>
    </Col>
  );
};

const StepIterator = makeIterable(StepTemplate);

const EmptyDashboard = (props: {
  show: boolean;
  children: React.ReactNode;
}) => {
  const { show, children } = props;
  if (show) {
    return (
      <div
        className="d-flex align-center justify-center flex-column -mt-8"
        style={{ height: '100%' }}
      >
        <Logo size={48} color="var(--gray-8)" />
        <div className="text-lg text-medium text-center gray-8 mt-3">
          No charts have been added yet
        </div>
        <div className="gray-7">
          Follow these steps to pin charts to your dashboard.{' '}
          <Link
            className="gray-8 underline"
            href="https://docs.getwren.ai/oss/guide/home/dashboard"
            rel="noopener noreferrer"
            target="_blank"
          >
            Learn more
          </Link>
        </div>
        <Row className="mt-4" gutter={[16, 16]}>
          <StepIterator
            data={[
              {
                title: '1. Create a thread',
                image: '/images/dashboard/s1.jpg',
              },
              {
                title: '2. Generate a chart',
                image: '/images/dashboard/s2.jpg',
              },
              {
                title: '3. Pin to dashboard',
                image: '/images/dashboard/s3.jpg',
              },
            ]}
          />
        </Row>
      </div>
    );
  }
  return <>{children}</>;
};

export default EmptyDashboard;
</file>

<file path="src/components/pages/home/dashboardGrid/index.tsx">
import dynamic from 'next/dynamic';
import React, {
  useEffect,
  useMemo,
  useRef,
  useState,
  createRef,
  forwardRef,
  useImperativeHandle,
} from 'react';
import { Button, Form } from 'antd';
import styled from 'styled-components';
import GridLayout, { Layout } from 'react-grid-layout';
import { MoreIcon } from '@/utils/icons';
import { MORE_ACTION } from '@/utils/enum';
import { getCompactTime, nextTick } from '@/utils/time';
import { LoadingWrapper } from '@/components/PageLoading';
import { DashboardItemDropdown } from '@/components/diagram/CustomDropdown';
import EditableWrapper, { EditableContext } from '@/components/EditableWrapper';
import {
  DashboardItem,
  ItemLayoutInput,
} from '@/apollo/client/graphql/__types__';
import {
  usePreviewItemSqlMutation,
  useUpdateDashboardItemMutation,
} from '@/apollo/client/graphql/dashboard.generated';

import 'react-grid-layout/css/styles.css';
import 'react-resizable/css/styles.css';

const Chart = dynamic(() => import('@/components/chart'), {
  ssr: false,
});

const StyledDashboardGrid = styled.div`
  flex: 1;
  padding: 16px;

  .react-grid-layout {
    width: 100%;
    height: 100%;
  }

  .adm-pinned-item {
    cursor: grab;
    background-color: white;
    height: 100%;
    border-radius: 4px;
    border: 2px solid transparent;
    box-shadow: rgba(45, 62, 80, 0.12) 0px 1px 5px 0px;
    transition: border-color 0.2s ease;

    &:hover {
      border-color: var(--geekblue-6);
    }
  }

  .adm-pinned-item-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 16px 8px 0 16px;
    * {
      min-width: 0;
    }
  }

  .adm-pinned-item-title {
    font-size: 14px;
    font-weight: 700;
    flex-grow: 1;
  }

  .adm-pinned-actions {
    display: flex;
    gap: 4px;
    align-items: center;
    flex-shrink: 0;
  }

  .adm-pinned-content {
    height: calc(100% - 40px);
    padding: 16px 12px 16px;

    &-overflow {
      overflow: auto;
      height: calc(100% - 18px);
      padding: 8px 12px;
    }

    &-info {
      font-size: 12px;
      color: var(--gray-6);
      text-align: right;
      user-select: none;
    }
  }

  .adm-pinned-item-chart {
    height: 100%;
  }

  .react-grid-placeholder {
    background-color: var(--blue-6);
  }
`;

const GUTTER = 8;
const COLUMN_COUNT = 6;

const calculateLayoutWidth = (itemWidth: number) => {
  return itemWidth * COLUMN_COUNT + GUTTER * COLUMN_COUNT;
};

const calculateColumnSize = (containerWidth: number) => {
  return (containerWidth - GUTTER * COLUMN_COUNT) / COLUMN_COUNT;
};

const getLayoutToGrid = (item: DashboardItem) => {
  return {
    i: item.id.toString(),
    x: item.layout.x,
    y: item.layout.y,
    w: item.layout.w,
    h: item.layout.h,
  };
};

const getLayoutToUpdateItem = (layout: Layout) => {
  return {
    itemId: Number(layout.i),
    x: layout.x,
    y: layout.y,
    w: layout.w,
    h: layout.h,
  };
};

interface Props {
  items: DashboardItem[];
  isSupportCached: boolean;
  onUpdateChange: (layouts: ItemLayoutInput[]) => void;
  onDelete: (id: number) => Promise<void>;
}

const DashboardGrid = forwardRef(
  (props: Props, ref: React.RefObject<{ onRefreshAll: () => void }>) => {
    const { items, isSupportCached, onUpdateChange, onDelete } = props;
    const itemRefs = useRef<{
      [key: string]: React.RefObject<{ onRefresh: () => void }>;
    }>({});
    const $container = useRef<HTMLDivElement>(null);
    const [size, setSize] = useState(250);

    // set up initial item refs
    useEffect(() => {
      items.forEach((item) => {
        itemRefs.current[item.id] = createRef();
      });
    }, [items]);

    useImperativeHandle(
      ref,
      () => ({
        onRefreshAll: () => {
          Object.values(itemRefs.current).forEach((itemRef) => {
            itemRef.current?.onRefresh();
          });
        },
      }),
      [items],
    );

    const layouts = useMemo(() => {
      return items.map((item) => getLayoutToGrid(item));
    }, [items]);

    const getGridItemLayouts = () =>
      items.map((item) => {
        return (
          <div key={item.id}>
            <PinnedItem
              ref={itemRefs.current[item.id]}
              isSupportCached={isSupportCached}
              item={item}
              onDelete={onDelete}
            />
          </div>
        );
      });

    useEffect(() => {
      const renderColumnSize = () => {
        if (!$container.current) return;
        const sidebarWidth = 280;
        const padding = 16 * 2;
        const containerWidth = window.innerWidth - sidebarWidth - padding;

        const minContainerWidth = 1024;
        let calculatedWidth = containerWidth;
        if (containerWidth <= minContainerWidth) {
          calculatedWidth = minContainerWidth;
          $container.current.style.minWidth = `${minContainerWidth + padding}px`;
        } else {
          $container.current.style.minWidth = '100%';
        }

        const columnSize = calculateColumnSize(calculatedWidth);
        setSize(columnSize);
      };
      renderColumnSize();
      window.addEventListener('resize', renderColumnSize);
      return () => {
        window.removeEventListener('resize', renderColumnSize);
      };
    }, [$container]);

    const onLayoutChange = (layouts: Layout[]) => {
      onUpdateChange(layouts.map((layout) => getLayoutToUpdateItem(layout)));
    };

    return (
      <StyledDashboardGrid ref={$container}>
        <GridLayout
          layout={layouts}
          cols={COLUMN_COUNT}
          margin={[GUTTER, GUTTER]}
          containerPadding={[0, 0]}
          rowHeight={size}
          width={calculateLayoutWidth(size)}
          onLayoutChange={onLayoutChange}
        >
          {getGridItemLayouts()}
        </GridLayout>
      </StyledDashboardGrid>
    );
  },
);

export default DashboardGrid;

const PinnedItemTitle = (props: { id: number; title: string }) => {
  const { title } = props;
  const [form] = Form.useForm();

  const [updateDashboardItem] = useUpdateDashboardItemMutation({
    onError: (error) => console.error(error),
  });

  const handleSave = (dashboardItemId: number, values: { title: string }) => {
    if (values.title === title) return;
    updateDashboardItem({
      variables: {
        where: { id: dashboardItemId },
        data: {
          displayName: values.title.trim(),
        },
      },
    });
  };

  return (
    <EditableContext.Provider value={form}>
      <Form className="d-flex" form={form}>
        <EditableWrapper
          record={props}
          dataIndex="title"
          handleSave={handleSave}
        >
          {title}
        </EditableWrapper>
      </Form>
    </EditableContext.Provider>
  );
};

const PinnedItem = forwardRef(
  (
    props: {
      item: DashboardItem;
      isSupportCached: boolean;
      onDelete: (id: number) => Promise<void>;
    },
    ref: React.RefObject<{ onRefresh: () => void }>,
  ) => {
    const { item, isSupportCached, onDelete } = props;
    const { detail } = item;
    const [isHideLegend, setIsHideLegend] = useState(true);
    const [forceLoading, setForceLoading] = useState(false);
    const [forceUpdate, setForceUpdate] = useState(0);

    useImperativeHandle(
      ref,
      () => ({
        onRefresh: () => {
          previewItemSQL({
            variables: { data: { itemId: item.id, refresh: isSupportCached } },
          });
        },
      }),
      [item.id],
    );

    const [previewItemSQL, previewItemSQLResult] = usePreviewItemSqlMutation();
    const previewItem = previewItemSQLResult.data?.previewItemSQL;
    const lastRefreshTime =
      previewItem?.cacheOverrodeAt || previewItem?.cacheCreatedAt;

    useEffect(() => {
      previewItemSQL({ variables: { data: { itemId: item.id } } });
    }, [item.id]);

    useEffect(() => {
      setForceLoading(true);
      nextTick(200).then(() => {
        setForceUpdate((prev) => prev + 1);
        setForceLoading(false);
      });
    }, [item.layout]);

    const title = useMemo(() => {
      return item.displayName || item.detail.chartSchema?.title || '';
    }, [item.displayName, item.detail.chartSchema?.title]);

    const onHideLegend = () => {
      setIsHideLegend(!isHideLegend);
      setForceUpdate((prev) => prev + 1);
    };

    const onMoreClick = async (action: MORE_ACTION) => {
      if (action === MORE_ACTION.DELETE) {
        await onDelete(item.id);
      } else if (action === MORE_ACTION.REFRESH) {
        previewItemSQL({
          variables: { data: { itemId: item.id, refresh: isSupportCached } },
        });
      } else if (action === MORE_ACTION.HIDE_CATEGORY) {
        onHideLegend();
      }
    };

    const loading = forceLoading || previewItemSQLResult.loading;

    return (
      <div className="adm-pinned-item">
        <div className="adm-pinned-item-header">
          <div
            className="adm-pinned-item-title"
            title={title}
            onMouseDown={(e) => e.stopPropagation()}
          >
            <PinnedItemTitle id={item.id} title={title} />
          </div>

          <div className="adm-pinned-actions">
            <DashboardItemDropdown
              onMoreClick={onMoreClick}
              isHideLegend={isHideLegend}
              isSupportCached={isSupportCached}
            >
              <Button
                className="adm-pinned-more gray-8"
                type="text"
                size="small"
                icon={<MoreIcon />}
                onMouseDown={(e) => e.stopPropagation()}
              />
            </DashboardItemDropdown>
          </div>
        </div>
        <div className="adm-pinned-content">
          <div className="adm-pinned-content-overflow adm-scrollbar-track">
            <LoadingWrapper loading={loading} tip="Loading...">
              <Chart
                className="adm-pinned-item-chart"
                width="100%"
                height="100%"
                spec={detail.chartSchema}
                values={previewItem?.data}
                forceUpdate={forceUpdate}
                autoFilter
                hideActions
                hideTitle
                hideLegend={isHideLegend}
              />
            </LoadingWrapper>
          </div>
          {lastRefreshTime && (
            <div className="adm-pinned-content-info">
              Last refreshed: {getCompactTime(lastRefreshTime)}
            </div>
          )}
        </div>
      </div>
    );
  },
);
</file>

<file path="src/components/pages/home/preparation/ErrorBoundary.tsx">
import { Button, Typography, Timeline } from 'antd';
import CloseCircleFilled from '@ant-design/icons/CloseCircleFilled';
import ToolOutlined from '@ant-design/icons/ToolOutlined';
import useModalAction from '@/hooks/useModalAction';
import ErrorCollapse from '@/components/ErrorCollapse';
import { FixSQLModal } from '@/components/modals/FixSQLModal';
import { Error } from '@/apollo/client/graphql/__types__';

export interface Props {
  children: React.ReactNode;
  error?: Error & {
    invalidSql?: string;
    fixStatement?: (sql: string) => Promise<void>;
    fixStatementLoading?: boolean;
  };
}

export default function ErrorBoundary({ children, error }: Props) {
  const fixItModal = useModalAction();
  if (!error) return <>{children}</>;
  const hasInvalidSql = !!error.invalidSql;
  return (
    <Timeline className="px-1 -mb-4">
      <Timeline.Item dot={<CloseCircleFilled className="red-5" />}>
        <Typography.Text className="gray-8">
          {hasInvalidSql
            ? 'Failed to generate SQL statement'
            : error.shortMessage}
        </Typography.Text>
        <div className="gray-7 text-sm mt-1">
          <div>
            {hasInvalidSql
              ? 'We tried to generate SQL based on your question but encountered a small issue. Help us fix it!'
              : error.message}
          </div>
          {hasInvalidSql && (
            <>
              <div className="bg-gray-2 p-2 my-4">
                <ErrorCollapse message={error.message} defaultActive />
              </div>
              <Button
                className="mt-2 adm-fix-it-btn"
                icon={<ToolOutlined />}
                size="small"
                onClick={() => fixItModal.openModal({ sql: error.invalidSql })}
              >
                Fix it
              </Button>
              <FixSQLModal
                {...fixItModal.state}
                loading={error.fixStatementLoading}
                onClose={fixItModal.closeModal}
                onSubmit={async (sql: string) => {
                  await error.fixStatement(sql);
                }}
              />
            </>
          )}
        </div>
      </Timeline.Item>
    </Timeline>
  );
}
</file>

<file path="src/components/pages/home/preparation/index.tsx">
import clsx from 'clsx';
import Image from 'next/image';
import { useEffect, useMemo, useState } from 'react';
import { Typography, Collapse } from 'antd';
import DownOutlined from '@ant-design/icons/DownOutlined';
import ErrorBoundary from './ErrorBoundary';
import PreparationStatus from './PreparationStatus';
import PreparationSteps from './PreparationSteps';
import { IPromptThreadStore } from '@/components/pages/home/promptThread/store';
import {
  ThreadResponse,
  AskingTaskStatus,
  AskingTask,
  AdjustmentTask,
} from '@/apollo/client/graphql/__types__';

export type Props = IPromptThreadStore['preparation'] & {
  className?: string;
  data: ThreadResponse;
  minimized?: boolean;
};

export type PreparedTask = AskingTask &
  AdjustmentTask & { isAdjustment: boolean };

export default function Preparation(props: Props) {
  const { className, data, minimized, onFixSQLStatement, fixStatementLoading } =
    props;
  const { askingTask, adjustmentTask, adjustment, id: responseId, sql } = data;

  const [isActive, setIsActive] = useState(!sql);

  // Adapt askingTask and adjustmentTask for preparation steps
  const preparedTask = useMemo(() => {
    if (askingTask === null && adjustmentTask === null) return null;
    const { payload } = adjustment || {};
    return {
      candidates: [],
      invalidSql: '',
      retrievedTables: payload?.retrievedTables || [],
      sqlGenerationReasoning: payload?.sqlGenerationReasoning || '',
      isAdjustment: !!adjustmentTask,
      ...(askingTask || {}),
      ...(adjustmentTask || {}),
    } as PreparedTask;
  }, [askingTask?.status, adjustmentTask?.status, adjustment?.payload]);

  // wrapping up after answer is prepared
  useEffect(() => {
    setIsActive(!minimized);
  }, [minimized]);
  const error = useMemo(() => {
    return preparedTask?.error && !sql
      ? {
          ...preparedTask.error,
          invalidSql: preparedTask?.invalidSql,
          fixStatement: (sql: string) => onFixSQLStatement(responseId, sql),
          fixStatementLoading,
        }
      : null;
  }, [preparedTask, responseId, sql, fixStatementLoading]);

  if (preparedTask === null) return null;

  const isStopped = preparedTask.status === AskingTaskStatus.STOPPED;

  return (
    <div className={clsx('border border-gray-4 rounded', className)}>
      <Collapse
        className="bg-gray-1"
        bordered={false}
        expandIconPosition="right"
        expandIcon={({ isActive }) =>
          !isStopped && (
            <DownOutlined
              className="gray-6 text-sm"
              rotate={isActive ? 180 : 0}
            />
          )
        }
        activeKey={isActive && !isStopped ? 'preparation' : undefined}
        onChange={([key]) => setIsActive(key === 'preparation')}
      >
        <Collapse.Panel
          key="preparation"
          header={
            <div className="flex-grow-1 d-flex align-center justify-space-between gx-2 select-none">
              <Typography.Title level={5} className="gray-8 text-medium mb-0">
                <Image
                  src="/images/icon/message-ai.svg"
                  alt="Answer Preparation Steps"
                  width={24}
                  height={24}
                  className="mr-1"
                />
                Answer preparation steps
              </Typography.Title>
              <PreparationStatus {...props} preparedTask={preparedTask} />
            </div>
          }
        >
          <ErrorBoundary error={error}>
            <PreparationSteps
              {...props}
              preparedTask={preparedTask}
              className="px-1 -mb-4"
            />
          </ErrorBoundary>
        </Collapse.Panel>
      </Collapse>
    </div>
  );
}
</file>

<file path="src/components/pages/home/preparation/PreparationStatus.tsx">
import { useState } from 'react';
import { Button, Tag, Space } from 'antd';
import StopOutlined from '@ant-design/icons/StopOutlined';
import ReloadOutlined from '@ant-design/icons/ReloadOutlined';
import { attachLoading } from '@/utils/helper';
import { getIsFinished } from '@/hooks/useAskPrompt';
import { AskingTaskStatus } from '@/apollo/client/graphql/__types__';
import type { PreparedTask, Props } from './index';

export default function PreparationStatus(
  props: Props & { preparedTask: PreparedTask },
) {
  const {
    data,
    preparedTask,
    onStopAskingTask,
    onReRunAskingTask,
    onStopAdjustTask,
    onReRunAdjustTask,
  } = props;
  const [stopLoading, setStopLoading] = useState(false);
  const [reRunLoading, setReRunLoading] = useState(false);
  const isProcessing = !getIsFinished(preparedTask.status);

  const onCancel = (e) => {
    e.stopPropagation();
    const stopPreparedTask = preparedTask.isAdjustment
      ? onStopAdjustTask
      : onStopAskingTask;
    const stopAskingTask = attachLoading(stopPreparedTask, setStopLoading);
    stopAskingTask(preparedTask.queryId);
  };

  const onReRun = (e) => {
    e.stopPropagation();
    const reRunPreparedTask = preparedTask.isAdjustment
      ? onReRunAdjustTask
      : onReRunAskingTask;
    const reRunAskingTask = attachLoading(reRunPreparedTask, setReRunLoading);
    reRunAskingTask(data);
  };

  if (isProcessing) {
    return (
      <Button
        icon={<StopOutlined />}
        danger
        size="small"
        onClick={onCancel}
        loading={stopLoading}
      >
        Cancel
      </Button>
    );
  } else if (preparedTask.status === AskingTaskStatus.STOPPED) {
    return (
      <Space className="-mr-4">
        <Tag color="red">Cancelled by user</Tag>
        <Button
          icon={<ReloadOutlined />}
          className="gray-7"
          size="small"
          type="text"
          onClick={onReRun}
          loading={reRunLoading}
        >
          Re-run
        </Button>
      </Space>
    );
  } else if (preparedTask.status === AskingTaskStatus.FINISHED) {
    const showView = data.view !== null;
    const showSqlPair = !!preparedTask?.candidates[0]?.sqlPair;
    return (
      <div className="gray-6">
        {showView || showSqlPair ? '1 step' : '3 steps'}
      </div>
    );
  }

  return null;
}
</file>

<file path="src/components/pages/home/preparation/PreparationSteps.tsx">
import { useMemo } from 'react';
import styled from 'styled-components';
import { Timeline, Badge } from 'antd';
import FileDoneOutlined from '@ant-design/icons/FileDoneOutlined';
import Retrieving from './step/Retrieving';
import Organizing from './step/Organizing';
import Generating from './step/Generating';
import FixedSQLFinished from './step/FixedSQLFinished';
import ViewFinished from './step/ViewFinished';
import SQLPairFinished from './step/SQLPairFinished';
import { PROCESS_STATE } from '@/utils/enum';
import {
  ProcessStateMachine,
  convertAskingTaskToProcessState,
} from '@/hooks/useAskProcessState';
import type { Props, PreparedTask } from './index';

const StyledBadge = styled(Badge)`
  position: absolute;
  top: -5px;
  left: -3px;
  .ant-badge-status-dot {
    width: 7px;
    height: 7px;
  }
  .ant-badge-status-text {
    display: none;
  }
`;

const retrievingNextStates = ProcessStateMachine.getAllNextStates(
  PROCESS_STATE.SEARCHING,
  true,
);
const organizingNextStates = ProcessStateMachine.getAllNextStates(
  PROCESS_STATE.PLANNING,
  true,
);
const generatingNextStates = ProcessStateMachine.getAllNextStates(
  PROCESS_STATE.GENERATING,
  true,
);

const getProcessDot = (processing: boolean) => {
  return processing ? (
    <StyledBadge color="geekblue" status="processing" />
  ) : null;
};

export default function PreparationSteps(
  props: Props & { preparedTask: PreparedTask },
) {
  const { className, data, askingStreamTask, minimized, preparedTask } = props;
  const { view, sql } = data;

  const processState = useMemo(
    () => convertAskingTaskToProcessState(preparedTask),
    [preparedTask],
  );
  const isFixedSQL = useMemo(() => {
    return sql && preparedTask?.invalidSql;
  }, [sql, preparedTask?.invalidSql]);

  // displays
  const showView = !!view;
  const showSqlPair = !!preparedTask?.candidates[0]?.sqlPair;
  const showRetrieving = retrievingNextStates.includes(processState);
  const showOrganizing = organizingNextStates.includes(processState);
  const showGenerating = generatingNextStates.includes(processState);

  // data
  const retrievedTables = preparedTask?.retrievedTables || [];
  const sqlGenerationReasoning =
    preparedTask?.sqlGenerationReasoning || askingStreamTask || '';

  // loadings
  const retrieving = processState === PROCESS_STATE.SEARCHING;
  const organizing = processState === PROCESS_STATE.PLANNING;
  const generating = processState === PROCESS_STATE.GENERATING;
  const correcting = processState === PROCESS_STATE.CORRECTING;
  const wrapping = !minimized;

  // templates
  if (showView) return <ViewTimelineSteps {...props} />;
  if (showSqlPair) return <SQLPairTimelineSteps {...props} />;
  if (isFixedSQL) return <FixedSQLTimelineSteps {...props} />;

  // default
  return (
    <Timeline className={className}>
      {showRetrieving && (
        <Timeline.Item dot={getProcessDot(retrieving)}>
          <Retrieving
            loading={retrieving}
            tables={retrievedTables}
            isAdjustment={preparedTask.isAdjustment}
          />
        </Timeline.Item>
      )}
      {showOrganizing && (
        <Timeline.Item dot={getProcessDot(organizing)}>
          <Organizing
            loading={organizing}
            stream={sqlGenerationReasoning}
            isAdjustment={preparedTask.isAdjustment}
          />
        </Timeline.Item>
      )}
      {showGenerating && (
        <Timeline.Item dot={getProcessDot(generating || correcting)}>
          <Generating
            generating={generating}
            correcting={correcting}
            loading={wrapping}
          />
        </Timeline.Item>
      )}
    </Timeline>
  );
}

const fileDone = (
  <FileDoneOutlined
    className="gray-6"
    style={{ position: 'relative', top: -2, left: 2 }}
  />
);

function FixedSQLTimelineSteps(props: Props) {
  const { className } = props;

  return (
    <Timeline className={className}>
      <Timeline.Item dot={fileDone}>
        <FixedSQLFinished />
      </Timeline.Item>
    </Timeline>
  );
}

function ViewTimelineSteps(props: Props) {
  const { className } = props;

  return (
    <Timeline className={className}>
      <Timeline.Item dot={fileDone}>
        <ViewFinished />
      </Timeline.Item>
    </Timeline>
  );
}

function SQLPairTimelineSteps(props: Props) {
  const { className } = props;

  return (
    <Timeline className={className}>
      <Timeline.Item dot={fileDone}>
        <SQLPairFinished />
      </Timeline.Item>
    </Timeline>
  );
}
</file>

<file path="src/components/pages/home/preparation/step/FixedSQLFinished.tsx">
import { Typography } from 'antd';

export default function FixedSQLFinished() {
  return (
    <>
      <Typography.Text className="gray-8">
        User-Provided SQL applied
      </Typography.Text>
      <div className="gray-7 text-sm mt-1">
        System encountered an issue generating SQL. The manually submitted query
        is now being processed.
      </div>
    </>
  );
}
</file>

<file path="src/components/pages/home/preparation/step/Generating.tsx">
import { Typography } from 'antd';
import { Spinner } from '@/components/PageLoading';

interface Props {
  generating?: boolean;
  correcting?: boolean;
  loading?: boolean;
}

export default function Generating(props: Props) {
  const { loading, generating, correcting } = props;

  return (
    <>
      <Typography.Text className="gray-8">
        Generating SQL statement
      </Typography.Text>
      <div className="gray-7 text-sm mt-1">
        {generating || correcting ? (
          <div className="d-flex align-center gx-2">
            {correcting ? 'Correcting SQL statement' : 'Generating'}
            <Spinner className="gray-6" size={12} />
          </div>
        ) : (
          <>
            <div>Successfully generated SQL statement</div>
            {loading && (
              <div className="d-flex align-center gx-2 mt-1">
                Wrapping up <Spinner className="gray-6" size={16} />
              </div>
            )}
          </>
        )}
      </div>
    </>
  );
}
</file>

<file path="src/components/pages/home/preparation/step/Organizing.tsx">
import { useEffect, useRef } from 'react';
import { Typography } from 'antd';
import MarkdownBlock from '@/components/editor/MarkdownBlock';
import { Spinner } from '@/components/PageLoading';

interface Props {
  stream: string;
  loading?: boolean;
  isAdjustment?: boolean;
}

export default function Organizing(props: Props) {
  const $wrapper = useRef<HTMLDivElement>(null);
  const { stream, loading, isAdjustment } = props;

  const isDone = stream && !loading;

  const scrollBottom = () => {
    if ($wrapper.current) {
      $wrapper.current.scrollTo({
        top: $wrapper.current.scrollHeight,
      });
    }
  };

  useEffect(() => {
    scrollBottom();
  }, [stream]);

  useEffect(() => {
    if (isDone) scrollBottom();
  }, [isDone]);

  const title = isAdjustment
    ? 'User-provided reasoning steps applied'
    : 'Organizing thoughts';

  return (
    <>
      <Typography.Text className="gray-8">{title}</Typography.Text>
      <div
        ref={$wrapper}
        className="gray-7 text-sm mt-2"
        style={{ maxHeight: 'calc(100vh - 550px)', overflowY: 'auto' }}
      >
        {loading && !stream ? (
          <div className="d-flex align-center gx-2">
            Thinking
            <Spinner className="gray-6" size={12} />
          </div>
        ) : (
          <MarkdownBlock content={stream} />
        )}
      </div>
    </>
  );
}
</file>

<file path="src/components/pages/home/preparation/step/Retrieving.tsx">
import { Typography, Tag } from 'antd';
import { makeIterable } from '@/utils/iteration';
import { Spinner } from '@/components/PageLoading';

interface Props {
  tables: string[];
  loading?: boolean;
  isAdjustment?: boolean;
}

const TagTemplate = ({ name }: { name: string }) => {
  return <Tag className="gray-7 mb-2">{name}</Tag>;
};

const TagIterator = makeIterable(TagTemplate);

export default function Retrieving(props: Props) {
  const { tables, loading, isAdjustment } = props;

  const data = tables.map((table) => ({ name: table }));

  const title = isAdjustment
    ? 'User-selected models applied'
    : 'Retrieving top 10 model candidates';

  const modelDescription = isAdjustment ? (
    <>{tables.length} models applied</>
  ) : (
    <>Top {tables.length} model candidates identified</>
  );

  return (
    <>
      <Typography.Text className="gray-8">{title}</Typography.Text>
      <div className="gray-7 text-sm mt-1">
        {loading ? (
          <div className="d-flex align-center gx-2">
            Searching
            <Spinner className="gray-6" size={12} />
          </div>
        ) : (
          <>
            <div className="mb-1">{modelDescription}</div>
            <TagIterator data={data} />
          </>
        )}
      </div>
    </>
  );
}
</file>

<file path="src/components/pages/home/preparation/step/SQLPairFinished.tsx">
import { Typography } from 'antd';

export default function SQLPairFinished() {
  return (
    <>
      <Typography.Text className="gray-8">
        Using question-SQL pair
      </Typography.Text>
      <div className="gray-7 text-sm mt-1">
        <div>
          Matching question-SQL pair found. Returning results instantly.
        </div>
      </div>
    </>
  );
}
</file>

<file path="src/components/pages/home/preparation/step/ViewFinished.tsx">
import { Typography } from 'antd';

export default function ViewFinished() {
  return (
    <>
      <Typography.Text className="gray-8">Using pre-saved view</Typography.Text>
      <div className="gray-7 text-sm mt-1">
        <div>Matching saved view found. Returning results instantly.</div>
      </div>
    </>
  );
}
</file>

<file path="src/components/pages/home/prompt/DemoPrompt.tsx">
import { Row, Col } from 'antd';
import styled from 'styled-components';
import { makeIterable } from '@/utils/iteration';
import EllipsisWrapper from '@/components/EllipsisWrapper';

const DemoBlock = styled.div`
  user-select: none;
  height: 150px;
  &:hover {
    border-color: var(--geekblue-6) !important;
    transition: border-color ease 0.2s;
  }
`;

interface Props {
  demo: any[];
  onSelect: (data: { label: string; question: string }) => void;
}

const DemoTemplate = ({ label, question, onSelect }) => {
  return (
    <Col span={8}>
      <DemoBlock
        className="border border-gray-5 rounded px-3 pt-3 pb-4 cursor-pointer"
        onClick={() => onSelect({ label, question })}
      >
        <div className="d-flex justify-space-between align-center text-sm mb-3">
          <div className="border border-gray-5 px-2 rounded-pill">{label}</div>
        </div>
        <EllipsisWrapper multipleLine={4} text={question} />
      </DemoBlock>
    </Col>
  );
};

const DemoColumnIterator = makeIterable(DemoTemplate);

export default function DemoPrompt(props: Props) {
  const { demo, onSelect } = props;
  return (
    <div className="gray-8" style={{ width: 580 }}>
      <div className="text-center mt-3 mb-2">Try asking...</div>
      <Row gutter={16}>
        <DemoColumnIterator data={demo} onSelect={onSelect} />
      </Row>
    </div>
  );
}
</file>

<file path="src/components/pages/home/prompt/index.tsx">
import {
  useEffect,
  useMemo,
  useState,
  forwardRef,
  useImperativeHandle,
} from 'react';
import styled from 'styled-components';
import { PROCESS_STATE } from '@/utils/enum';
import PromptInput from '@/components/pages/home/prompt/Input';
import PromptResult from '@/components/pages/home/prompt/Result';
import useAskProcessState, {
  getIsProcessing,
} from '@/hooks/useAskProcessState';
import { AskPromptData } from '@/hooks/useAskPrompt';
import {
  CreateThreadInput,
  CreateThreadResponseInput,
} from '@/apollo/client/graphql/__types__';

interface Props {
  onCreateResponse: (
    payload: CreateThreadInput | CreateThreadResponseInput,
  ) => Promise<void>;
  onStop: () => void;
  onSubmit: (value: string) => Promise<void>;
  onStopPolling: () => void;
  onStopStreaming: () => void;
  onStopRecommend: () => void;
  data: AskPromptData;
  loading: boolean;
  inputProps: {
    placeholder: string;
  };
}

interface Attributes {
  submit: (value: string) => void;
  close: () => void;
}

const PromptStyle = styled.div`
  position: fixed;
  width: 680px;
  left: 50%;
  margin-left: calc(-340px + 133px);
  bottom: 18px;
  z-index: 999;
  box-shadow:
    rgba(0, 0, 0, 0.1) 0px 10px 15px -3px,
    rgba(0, 0, 0, 0.05) 0px 4px 6px -2px;
`;

export default forwardRef<Attributes, Props>(function Prompt(props, ref) {
  const {
    data,
    loading,
    onSubmit,
    onStop,
    onCreateResponse,
    onStopStreaming,
    onStopRecommend,
    inputProps,
  } = props;
  const askProcessState = useAskProcessState();

  const {
    originalQuestion,
    askingTask,
    askingStreamTask,
    recommendedQuestions,
  } = data;

  const result = useMemo(
    () => ({
      type: askingTask?.type, // question's type
      originalQuestion, // original question
      askingStreamTask, // for general answer
      recommendedQuestions, // guiding user to ask
      intentReasoning: askingTask?.intentReasoning || '',
    }),
    [data],
  );
  const error = useMemo(() => askingTask?.error || null, [askingTask?.error]);
  const [showResult, setShowResult] = useState(false);
  const [question, setQuestion] = useState('');
  const currentProcessState = useMemo(
    () => askProcessState.currentState,
    [askProcessState.currentState],
  );
  const isProcessing = useMemo(
    () => getIsProcessing(currentProcessState),
    [currentProcessState],
  );

  useEffect(() => {
    if (askingTask) {
      const processState = askProcessState.matchedState(askingTask);
      askProcessState.transitionTo(processState);
    }
  }, [askingTask]);

  useEffect(() => {
    if (error) {
      !askProcessState.isFailed() &&
        askProcessState.transitionTo(PROCESS_STATE.FAILED);
    }
  }, [error]);

  // create thread response for recommended question
  const selectRecommendedQuestion = async (payload: {
    question: string;
    sql: string;
  }) => {
    onCreateResponse && (await onCreateResponse(payload));
    closeResult();
  };

  // create thread response for text to sql
  const intentSQLAnswer = async () => {
    onCreateResponse &&
      (await onCreateResponse({ question, taskId: askingTask?.queryId }));
    setShowResult(false);
  };

  const closeResult = () => {
    askProcessState.resetState();
    setQuestion('');
    onStopStreaming && onStopStreaming();
    onStopRecommend && onStopRecommend();
  };

  const stopProcess = async () => {
    onStop && (await onStop());
    setShowResult(false);
    askProcessState.resetState();
  };

  const submitAsk = async (value: string) => {
    setQuestion(value);
    if (isProcessing || !value) return;
    // start the state as understanding when user submit question
    askProcessState.transitionTo(PROCESS_STATE.UNDERSTANDING);
    setShowResult(true);
    onSubmit && (await onSubmit(value));
  };

  useImperativeHandle(
    ref,
    () => ({
      submit: submitAsk,
      close: closeResult,
    }),
    [question, isProcessing, setQuestion],
  );

  return (
    <PromptStyle className="d-flex align-end bg-gray-2 p-3 border border-gray-3 rounded">
      <PromptInput
        question={question}
        isProcessing={isProcessing}
        onAsk={submitAsk}
        inputProps={inputProps}
      />

      {showResult && (
        <PromptResult
          data={result}
          error={error}
          loading={loading}
          processState={currentProcessState}
          onSelectRecommendedQuestion={selectRecommendedQuestion}
          onIntentSQLAnswer={intentSQLAnswer}
          onClose={closeResult}
          onStop={stopProcess}
        />
      )}
    </PromptStyle>
  );
});
</file>

<file path="src/components/pages/home/prompt/Input.tsx">
import { useEffect, useRef, useState } from 'react';
import { Input, Button } from 'antd';
import styled from 'styled-components';
import { attachLoading } from '@/utils/helper';

const PromptButton = styled(Button)`
  min-width: 72px;
`;

interface Props {
  question: string;
  isProcessing: boolean;
  onAsk: (value: string) => Promise<void>;
  inputProps: {
    placeholder?: string;
  };
}

export default function PromptInput(props: Props) {
  const { onAsk, isProcessing, question, inputProps } = props;
  const $promptInput = useRef<HTMLTextAreaElement>(null);
  const [inputValue, setInputValue] = useState('');
  const [innerLoading, setInnerLoading] = useState(false);

  useEffect(() => {
    if (question) setInputValue(question);
  }, [question]);

  useEffect(() => {
    if (!isProcessing) {
      $promptInput.current?.focus();
      setInputValue('');
    }
  }, [isProcessing]);

  const syncInputValue = (event) => {
    setInputValue(event.target.value);
  };

  const handleAsk = () => {
    const trimmedValue = inputValue.trim();
    if (!trimmedValue) return;
    const startAsking = attachLoading(onAsk, setInnerLoading);
    startAsking(trimmedValue);
  };

  const inputEnter = (event: React.KeyboardEvent<HTMLTextAreaElement>) => {
    if (event.shiftKey) return;
    event.preventDefault();
    handleAsk();
  };

  const isDisabled = innerLoading || isProcessing;

  return (
    <>
      <Input.TextArea
        ref={$promptInput}
        // disable grammarly
        data-gramm="false"
        size="large"
        autoSize
        value={inputValue}
        onInput={syncInputValue}
        onPressEnter={inputEnter}
        disabled={isDisabled}
        {...inputProps}
      />
      <PromptButton
        type="primary"
        size="large"
        className="ml-3"
        onClick={handleAsk}
        disabled={isDisabled}
      >
        Ask
      </PromptButton>
    </>
  );
}
</file>

<file path="src/components/pages/home/prompt/RecommendedQuestionsPrompt.tsx">
import { useState, useMemo } from 'react';
import clsx from 'clsx';
import styled from 'styled-components';
import { Space, Button, Row, Col } from 'antd';
import ColumnHeightOutlined from '@ant-design/icons/ColumnHeightOutlined';
import MinusOutlined from '@ant-design/icons/MinusOutlined';
import EllipsisWrapper from '@/components/EllipsisWrapper';
import LoadingOutlined from '@ant-design/icons/LoadingOutlined';
import { Logo } from '@/components/Logo';
import { makeIterable } from '@/utils/iteration';
import { GroupedQuestion } from '@/hooks/useRecommendedQuestionsInstruction';

const CategorySectionBlock = styled.div`
  background: var(--gray-1);
  border: 1px solid var(--gray-4);
  border-radius: 4px;
  padding: 16px;
`;

const QuestionBlock = styled.div`
  background: var(--gray-1);
  user-select: none;
  height: 150px;
  transition: border-color ease 0.2s;

  &:hover:not(.is-disabled) {
    border-color: var(--geekblue-6) !important;
  }

  &.is-active {
    border-color: var(--geekblue-6) !important;
  }

  &.is-disabled {
    opacity: 0.8;
  }
`;

const MAX_EXPANDED_QUESTIONS = 9;

interface Props {
  onSelect: (payload: { sql: string; question: string }) => void;
  recommendedQuestions: GroupedQuestion[];
  loading: boolean;
}

const QuestionTemplate = ({
  category,
  sql,
  question,
  onSelect,
  loading,
  selectedQuestion,
}) => {
  const isSelected = selectedQuestion === question;
  const isDisabled = loading && !isSelected;

  const onClick = () => {
    if (loading) return;
    onSelect({ sql, question });
  };

  return (
    <Col span={8}>
      <QuestionBlock
        className={clsx(
          'border border-gray-5 rounded px-3 pt-3 pb-4',
          loading ? 'cursor-wait' : 'cursor-pointer',
          {
            'is-active': isSelected,
            'is-disabled cursor-not-allowed': isDisabled,
          },
        )}
        onClick={onClick}
      >
        <div className="d-flex justify-space-between align-center text-sm mb-3">
          <div
            className="border border-gray-5 px-2 rounded-pill text-truncate"
            title={category}
          >
            {category}
          </div>
          {isSelected && loading && <LoadingOutlined className="ml-1 gray-7" />}
        </div>
        <EllipsisWrapper multipleLine={4} text={question} />
      </QuestionBlock>
    </Col>
  );
};

const QuestionColumnIterator = makeIterable(QuestionTemplate);

export default function RecommendedQuestionsPrompt(props: Props) {
  const { onSelect, recommendedQuestions, loading } = props;

  const [isExpanded, setIsExpanded] = useState<boolean>(false);
  const [selectedQuestion, setSelectedQuestion] = useState<string>('');

  const questionList = useMemo(() => {
    return recommendedQuestions.slice(
      0,
      isExpanded ? undefined : MAX_EXPANDED_QUESTIONS,
    );
  }, [recommendedQuestions, isExpanded]);

  const onHandleToggle = () => setIsExpanded((prev) => !prev);

  const showExpandButton = recommendedQuestions.length > MAX_EXPANDED_QUESTIONS;

  const onSelectQuestion = (payload: { sql: string; question: string }) => {
    onSelect(payload);
    setSelectedQuestion(payload.question);
  };

  return (
    <div className="bg-gray-2 px-10 py-6">
      <div className="d-flex align-center mb-3">
        <Logo size={24} color="var(--gray-8)" />
        <div className="text-md text-medium gray-8 mx-3">
          Know more about your data.
        </div>
        <div className="text-medium gray-7">
          Try asking some of the following questions
        </div>
      </div>
      <Space
        style={{ width: 680 }}
        className="gray-8"
        direction="vertical"
        size={[0, 16]}
      >
        <CategorySectionBlock>
          <Row gutter={[16, 16]} className="mt-3">
            <QuestionColumnIterator
              data={questionList}
              onSelect={onSelectQuestion}
              loading={loading}
              selectedQuestion={selectedQuestion}
            />
          </Row>
          {showExpandButton && (
            <div className="text-right">
              <Button
                onClick={() => onHandleToggle()}
                className="gray-6 mt-3"
                type="text"
                size="small"
                icon={isExpanded ? <MinusOutlined /> : <ColumnHeightOutlined />}
              >
                {isExpanded ? 'Collapse' : 'Expand all'}
              </Button>
            </div>
          )}
        </CategorySectionBlock>
      </Space>
    </div>
  );
}
</file>

<file path="src/components/pages/home/prompt/Result.tsx">
import clsx from 'clsx';
import { ReactNode, useEffect, useRef, memo, useState } from 'react';
import { Button } from 'antd';
import styled from 'styled-components';
import { PROCESS_STATE } from '@/utils/enum';
import { attachLoading } from '@/utils/helper';
import CloseOutlined from '@ant-design/icons/CloseOutlined';
import StopOutlined from '@ant-design/icons/StopFilled';
import LoadingOutlined from '@ant-design/icons/LoadingOutlined';
import CloseCircleFilled from '@ant-design/icons/CloseCircleFilled';
import WarningOutlined from '@ant-design/icons/WarningOutlined';
import MessageOutlined from '@ant-design/icons/MessageOutlined';
import ErrorCollapse from '@/components/ErrorCollapse';
import InfoCircleOutlined from '@ant-design/icons/InfoCircleOutlined';
import RecommendedQuestions, {
  getRecommendedQuestionProps,
} from '@/components/pages/home/RecommendedQuestions';
import MarkdownBlock from '@/components/editor/MarkdownBlock';
import {
  AskingTaskType,
  RecommendedQuestionsTask,
} from '@/apollo/client/graphql/__types__';

const StyledResult = styled.div`
  position: absolute;
  bottom: calc(100% + 12px);
  left: 0;
  width: 100%;
  background: white;
  box-shadow:
    rgba(0, 0, 0, 0.1) 0px 10px 15px -3px,
    rgba(0, 0, 0, 0.05) 0px 4px 6px -2px;
`;

interface Props {
  processState: PROCESS_STATE;
  data: {
    type: AskingTaskType;
    originalQuestion: string;
    askingStreamTask: string;
    recommendedQuestions: RecommendedQuestionsTask;
    intentReasoning: string;
  };
  error?: any;
  onIntentSQLAnswer: () => void;
  onSelectRecommendedQuestion: ({
    question,
    sql,
  }: {
    question: string;
    sql: string;
  }) => void;
  onClose: () => void;
  onStop: () => Promise<void>;
  loading?: boolean;
}

const Wrapper = ({ children }) => {
  return (
    <StyledResult
      className="border border-gray-3 rounded p-4"
      data-testid="prompt__result"
    >
      {children}
    </StyledResult>
  );
};

const makeProcessing = (text: string) => (props: Props) => {
  const { onStop } = props;
  const [loading, setLoading] = useState(false);
  return (
    <Wrapper>
      <div className="d-flex justify-space-between">
        <span>
          <LoadingOutlined className="mr-2 geekblue-6 text-lg" spin />
          {text}
        </span>
        <Button
          className={clsx(
            'adm-btn-no-style bg-gray-3 text-sm px-2',
            loading ? 'gray-6' : 'gray-7',
          )}
          type="text"
          size="small"
          onClick={attachLoading(onStop, setLoading)}
          disabled={loading}
        >
          <StopOutlined className="-mr-1" />
          Stop
        </Button>
      </div>
    </Wrapper>
  );
};

const makeProcessingError =
  (config: { icon: ReactNode; title?: string; description?: string }) =>
  (props: Props) => {
    const { onClose, onSelectRecommendedQuestion, data, error } = props;
    const { message, shortMessage, stacktrace } = error || {};
    const hasStacktrace = !!stacktrace;

    const recommendedQuestionProps = getRecommendedQuestionProps(
      data?.recommendedQuestions,
    );

    return (
      <Wrapper>
        <div className="d-flex justify-space-between text-medium mb-2">
          <div className="d-flex align-center">
            {config.icon}
            {config.title || shortMessage}
          </div>
          <Button
            className="adm-btn-no-style gray-7 bg-gray-3 text-sm px-2"
            type="text"
            size="small"
            onClick={onClose}
          >
            <CloseOutlined className="-mr-1" />
            Close
          </Button>
        </div>
        <div className="gray-7">
          {config.description || data.intentReasoning || message}
        </div>
        {hasStacktrace && (
          <ErrorCollapse className="mt-2" message={stacktrace.join('\n')} />
        )}

        {recommendedQuestionProps.show && (
          <RecommendedQuestions
            className="mt-2"
            {...recommendedQuestionProps.state}
            onSelect={onSelectRecommendedQuestion}
          />
        )}
      </Wrapper>
    );
  };

const ErrorIcon = () => <CloseCircleFilled className="mr-2 red-5 text-lg" />;

const Failed = makeProcessingError({
  icon: <ErrorIcon />,
});

const Understanding = makeProcessing('Understanding question');

const IntentionFinished = (props: Props) => {
  const { data, onIntentSQLAnswer } = props;
  const { type } = data;

  useEffect(() => {
    // create an empty response first if this is a text to sql task
    if (type === AskingTaskType.TEXT_TO_SQL) {
      onIntentSQLAnswer && onIntentSQLAnswer();
    }
  }, [type]);

  // To keep the UI result keep showing as understanding
  return <Understanding {...props} />;
};

const GeneralAnswer = (props: Props) => {
  const { onClose, onSelectRecommendedQuestion, data, loading } = props;
  const $wrapper = useRef<HTMLDivElement>(null);

  const { originalQuestion, askingStreamTask, recommendedQuestions } = data;
  const isDone = askingStreamTask && !loading;

  const scrollBottom = () => {
    if ($wrapper.current) {
      $wrapper.current.scrollTo({
        top: $wrapper.current.scrollHeight,
      });
    }
  };

  useEffect(() => {
    scrollBottom();
  }, [askingStreamTask]);

  useEffect(() => {
    if (isDone) scrollBottom();
  }, [isDone]);

  const recommendedQuestionProps =
    getRecommendedQuestionProps(recommendedQuestions);

  return (
    <Wrapper>
      <div className="d-flex justify-space-between">
        <div className="d-flex align-start">
          <MessageOutlined className="mr-2 mt-1 geekblue-6" />
          <b className="text-semi-bold">{originalQuestion}</b>
        </div>
        <Button
          className="adm-btn-no-style gray-7 bg-gray-3 text-sm px-2"
          type="text"
          size="small"
          onClick={onClose}
        >
          <CloseOutlined className="-mr-1" />
          Close
        </Button>
      </div>
      <div className="py-3">
        <div
          ref={$wrapper}
          className="py-2 px-3"
          style={{ maxHeight: 'calc(100vh - 420px)', overflowY: 'auto' }}
        >
          <MarkdownBlock content={askingStreamTask} />
          {isDone && (
            <div className="gray-6">
              <InfoCircleOutlined className="mr-2" />
              For the most accurate semantics, please visit the modeling page.
            </div>
          )}
        </div>
      </div>

      {recommendedQuestionProps.show && (
        <RecommendedQuestions
          {...recommendedQuestionProps.state}
          onSelect={onSelectRecommendedQuestion}
        />
      )}
    </Wrapper>
  );
};

const MisleadingQuery = makeProcessingError({
  icon: <WarningOutlined className="mr-2 text-lg gold-6" />,
  title: 'Clarification needed',
});

const getGeneralAnswerStateComponent = (state: PROCESS_STATE) => {
  return (
    {
      [PROCESS_STATE.FINISHED]: GeneralAnswer,
    }[state] || null
  );
};

const getMisleadingQueryStateComponent = (state: PROCESS_STATE) => {
  return (
    {
      [PROCESS_STATE.FINISHED]: MisleadingQuery,
    }[state] || null
  );
};

const getDefaultStateComponent = (state: PROCESS_STATE) => {
  return (
    {
      [PROCESS_STATE.UNDERSTANDING]: Understanding,
      // Polling AI status for every 1 second might skip the searching state.
      [PROCESS_STATE.SEARCHING]: IntentionFinished,
      [PROCESS_STATE.PLANNING]: IntentionFinished,
      [PROCESS_STATE.GENERATING]: IntentionFinished,
      // The finished status will respond by AI directly if viewId found, so we need to handle with intention finished.
      [PROCESS_STATE.FINISHED]: IntentionFinished,
      [PROCESS_STATE.FAILED]: Failed,
    }[state] || null
  );
};

const makeProcessStateStrategy = (type: AskingTaskType) => {
  // note that the asking task type only has value when the asking status was finished
  // by default, we use the default state component (also the text to sql state component)
  if (type === AskingTaskType.GENERAL) return getGeneralAnswerStateComponent;
  if (type === AskingTaskType.MISLEADING_QUERY)
    return getMisleadingQueryStateComponent;
  return getDefaultStateComponent;
};

export default memo(function PromptResult(props: Props) {
  const { processState, data } = props;

  const getProcessStateComponent = makeProcessStateStrategy(data?.type);
  const StateComponent = getProcessStateComponent(processState);

  if (StateComponent === null) return null;

  return <StateComponent {...props} />;
});
</file>

<file path="src/components/pages/home/promptThread/AnswerResult.tsx">
import { useEffect, useMemo } from 'react';
import { isEmpty, debounce } from 'lodash';
import clsx from 'clsx';
import { Button, Typography, Tabs, Tag, Tooltip } from 'antd';
import styled from 'styled-components';
import CheckCircleFilled from '@ant-design/icons/CheckCircleFilled';
import CodeFilled from '@ant-design/icons/CodeFilled';
import PieChartFilled from '@ant-design/icons/PieChartFilled';
import MessageOutlined from '@ant-design/icons/MessageOutlined';
import ShareAltOutlined from '@ant-design/icons/ShareAltOutlined';
import { RobotSVG } from '@/utils/svgs';
import { ANSWER_TAB_KEYS } from '@/utils/enum';
import { canGenerateAnswer } from '@/hooks/useAskPrompt';
import usePromptThreadStore from './store';
import { RecommendedQuestionsProps } from '@/components/pages/home/promptThread';
import RecommendedQuestions, {
  getRecommendedQuestionProps,
} from '@/components/pages/home/RecommendedQuestions';
import ViewBlock from '@/components/pages/home/promptThread/ViewBlock';
import ViewSQLTabContent from '@/components/pages/home/promptThread/ViewSQLTabContent';
import TextBasedAnswer, {
  getAnswerIsFinished,
} from '@/components/pages/home/promptThread/TextBasedAnswer';
import ChartAnswer from '@/components/pages/home/promptThread/ChartAnswer';
import Preparation from '@/components/pages/home/preparation';
import {
  AskingTaskStatus,
  ThreadResponse,
  ThreadResponseAnswerDetail,
  ThreadResponseAnswerStatus,
  ThreadResponseAdjustment,
  ThreadResponseAdjustmentType,
} from '@/apollo/client/graphql/__types__';

const { Title, Text } = Typography;

const adjustmentType = {
  [ThreadResponseAdjustmentType.APPLY_SQL]: 'User-provided SQL applied',
  [ThreadResponseAdjustmentType.REASONING]: 'Reasoning steps adjusted',
};

const knowledgeTooltip = (
  <>
    Store this answer as a Question-SQL pair to help Wren AI improve SQL
    generation.
    <br />
    <Typography.Link
      className="gray-1 underline"
      href="https://docs.getwren.ai/oss/guide/knowledge/question-sql-pairs#save-to-knowledge"
      target="_blank"
      rel="noopener noreferrer"
    >
      Learn more
    </Typography.Link>
  </>
);

const StyledTabs = styled(Tabs)`
  .ant-tabs-nav {
    margin-bottom: 0;
  }

  .ant-tabs-content-holder {
    border-left: 1px var(--gray-4) solid;
    border-right: 1px var(--gray-4) solid;
    border-bottom: 1px var(--gray-4) solid;
  }

  .ant-tabs-tab {
    .ant-typography {
      color: var(--gray-6);
    }

    [aria-label='check-circle'] {
      color: var(--gray-5);
    }

    [aria-label='code'] {
      color: var(--gray-5);
    }

    [aria-label='pie-chart'] {
      color: var(--gray-5);
    }

    &.ant-tabs-tab-active {
      .ant-typography {
        color: var(--gray-8);
      }

      [aria-label='check-circle'] {
        color: var(--green-5);
      }

      [aria-label='code'] {
        color: var(--geekblue-5);
      }

      [aria-label='pie-chart'] {
        color: var(--gold-6);
      }

      .adm-beta-tag {
        background-color: var(--geekblue-2);
        color: var(--geekblue-5);
      }
    }

    .adm-beta-tag {
      padding: 0 4px;
      line-height: 18px;
      margin: 0 0 0 6px;
      border-radius: 2px;
      background-color: var(--gray-5);
      color: white;
      border: none;
    }
  }
`;

export interface Props {
  motion: boolean;
  threadResponse: ThreadResponse;
  isLastThreadResponse: boolean;
  onInitPreviewDone: () => void;
}

const QuestionTitle = (props) => {
  const { question, className } = props;
  return (
    <Title
      className={clsx('d-flex bg-gray-1 rounded mt-0', className)}
      level={4}
    >
      <MessageOutlined className="geekblue-5 mt-1 mr-3" />
      <Text className="text-medium gray-8">{question}</Text>
    </Title>
  );
};

const renderRecommendedQuestions = (
  isLastThreadResponse: boolean,
  recommendedQuestionProps,
  onSelect: RecommendedQuestionsProps['onSelect'],
) => {
  if (!isLastThreadResponse || !recommendedQuestionProps.show) return null;

  return (
    <RecommendedQuestions
      className="mt-5 mb-4"
      {...recommendedQuestionProps.state}
      onSelect={onSelect}
    />
  );
};

const AdjustmentInformation = (props: {
  adjustment: ThreadResponseAdjustment;
}) => {
  const { adjustment } = props;

  return (
    <div className="rounded bg-gray-3 gray-6 py-2 px-3 mb-2">
      <div className="d-flex align-center gx-2">
        <ShareAltOutlined className="gray-7" />
        <div className="flex-grow-1 gray-7">
          Adjusted answer
          <Tag className="gray-6 border border-gray-5 bg-gray-3 ml-3 text-medium">
            {adjustmentType[adjustment.type]}
          </Tag>
        </div>
      </div>
    </div>
  );
};

const isNeedGenerateAnswer = (answerDetail: ThreadResponseAnswerDetail) => {
  const isFinished = getAnswerIsFinished(answerDetail?.status);
  // it means the background task has not started yet, but answer is pending for generating
  const isProcessing = [
    ThreadResponseAnswerStatus.NOT_STARTED,
    ThreadResponseAnswerStatus.PREPROCESSING,
    ThreadResponseAnswerStatus.FETCHING_DATA,
  ].includes(answerDetail?.status);
  return answerDetail?.queryId === null && !isFinished && !isProcessing;
};

export default function AnswerResult(props: Props) {
  const { threadResponse, isLastThreadResponse } = props;

  const {
    onOpenSaveAsViewModal,
    onGenerateThreadRecommendedQuestions,
    onGenerateTextBasedAnswer,
    onGenerateChartAnswer,
    onOpenSaveToKnowledgeModal,
    // recommend questions
    recommendedQuestions,
    showRecommendedQuestions,
    onSelectRecommendedQuestion,
    preparation,
  } = usePromptThreadStore();

  const {
    askingTask,
    adjustmentTask,
    answerDetail,
    breakdownDetail,
    id,
    question,
    sql,
    view,
    adjustment,
  } = threadResponse;

  const resultStyle = isLastThreadResponse
    ? { minHeight: 'calc(100vh - (194px))' }
    : null;

  const isAdjustment = !!adjustment;

  const recommendedQuestionProps = getRecommendedQuestionProps(
    recommendedQuestions,
    showRecommendedQuestions,
  );

  const isAnswerPrepared = !!answerDetail?.queryId || !!answerDetail?.status;
  const isBreakdownOnly = useMemo(() => {
    // we support rendering different types of answers now, so we need to check if it's old data.
    // existing thread response's answerDetail is null.
    return answerDetail === null && !isEmpty(breakdownDetail);
  }, [answerDetail, breakdownDetail]);

  // initialize generate answer
  useEffect(() => {
    if (isBreakdownOnly) return;
    if (
      canGenerateAnswer(askingTask, adjustmentTask) &&
      isNeedGenerateAnswer(answerDetail)
    ) {
      const debouncedGenerateAnswer = debounce(
        () => {
          onGenerateTextBasedAnswer(id);
          onGenerateThreadRecommendedQuestions();
        },
        250,
        { leading: false, trailing: true },
      );
      debouncedGenerateAnswer();

      return () => {
        debouncedGenerateAnswer.cancel();
      };
    }
  }, [
    isBreakdownOnly,
    askingTask?.status,
    adjustmentTask?.status,
    answerDetail?.status,
  ]);

  const onTabClick = (activeKey: string) => {
    if (activeKey === ANSWER_TAB_KEYS.CHART && !threadResponse.chartDetail) {
      onGenerateChartAnswer(id);
    }
  };

  const showAnswerTabs =
    askingTask?.status === AskingTaskStatus.FINISHED ||
    isAnswerPrepared ||
    isBreakdownOnly;

  return (
    <div style={resultStyle} data-jsid="answerResult">
      {isAdjustment && <AdjustmentInformation adjustment={adjustment} />}
      <QuestionTitle className="mb-4" question={question} />
      <Preparation
        className="mb-3"
        {...preparation}
        data={threadResponse}
        minimized={isAnswerPrepared}
      />
      {showAnswerTabs && (
        <>
          <StyledTabs type="card" size="small" onTabClick={onTabClick}>
            {!isBreakdownOnly && (
              <Tabs.TabPane
                key={ANSWER_TAB_KEYS.ANSWER}
                tab={
                  <div className="select-none">
                    <CheckCircleFilled className="mr-2" />
                    <Text>Answer</Text>
                  </div>
                }
              >
                <TextBasedAnswer {...props} />
              </Tabs.TabPane>
            )}
            <Tabs.TabPane
              key={ANSWER_TAB_KEYS.VIEW_SQL}
              tab={
                <div className="select-none">
                  <CodeFilled className="mr-2" />
                  <Text>View SQL</Text>
                </div>
              }
            >
              <ViewSQLTabContent {...props} />
            </Tabs.TabPane>
            <Tabs.TabPane
              key="chart"
              tab={
                <div className="select-none">
                  <PieChartFilled className="mr-2" />
                  <Text>
                    Chart<Tag className="adm-beta-tag">Beta</Tag>
                  </Text>
                </div>
              }
            >
              <ChartAnswer {...props} />
            </Tabs.TabPane>
          </StyledTabs>
          <div className="mt-2 d-flex align-center">
            <Tooltip
              overlayInnerStyle={{ width: 'max-content' }}
              placement="topLeft"
              title={knowledgeTooltip}
            >
              <Button
                type="link"
                size="small"
                className="mr-2"
                onClick={() =>
                  onOpenSaveToKnowledgeModal(
                    {
                      question:
                        threadResponse?.askingTask?.rephrasedQuestion ||
                        question,
                      sql,
                    },
                    { isCreateMode: true },
                  )
                }
                data-guideid="save-to-knowledge"
              >
                <div className="d-flex align-center">
                  <RobotSVG className="mr-2" />
                  Save to knowledge
                </div>
              </Button>
            </Tooltip>
            <ViewBlock
              view={view}
              onClick={() => onOpenSaveAsViewModal({ sql, responseId: id })}
            />
          </div>
          {renderRecommendedQuestions(
            isLastThreadResponse,
            recommendedQuestionProps,
            onSelectRecommendedQuestion,
          )}
        </>
      )}
    </div>
  );
}
</file>

<file path="src/components/pages/home/promptThread/ChartAnswer.tsx">
import clsx from 'clsx';
import dynamic from 'next/dynamic';
import styled from 'styled-components';
import { useEffect, useMemo, useState } from 'react';
import { Alert, Form, Button, Skeleton, Modal, message } from 'antd';
import { attachLoading } from '@/utils/helper';
import ReloadOutlined from '@ant-design/icons/ReloadOutlined';
import BasicProperties from '@/components/chart/properties/BasicProperties';
import DonutProperties from '@/components/chart/properties/DonutProperties';
import LineProperties from '@/components/chart/properties/LineProperties';
import StackedBarProperties from '@/components/chart/properties/StackedBarProperties';
import GroupedBarProperties from '@/components/chart/properties/GroupedBarProperties';
import { Props as AnswerResultProps } from '@/components/pages/home/promptThread/AnswerResult';
import { ChartTaskStatus, ChartType } from '@/apollo/client/graphql/__types__';
import { usePreviewDataMutation } from '@/apollo/client/graphql/home.generated';
import { isEmpty, isEqual } from 'lodash';
import {
  getChartSpecFieldTitleMap,
  getChartSpecOptionValues,
} from '@/components/chart/handler';
import { useCreateDashboardItemMutation } from '@/apollo/client/graphql/dashboard.generated';
import { DashboardItemType } from '@/apollo/server/repositories';
import usePromptThreadStore from './store';

const Chart = dynamic(() => import('@/components/chart'), {
  ssr: false,
});

const StyledSkeleton = styled(Skeleton)`
  padding: 16px;
  .ant-skeleton-paragraph {
    margin-bottom: 0;
  }
`;

const ChartWrapper = styled.div`
  position: relative;
  padding-top: 0;
  transition: padding-top 0.2s ease-out;
  &.isEditMode {
    padding-top: 72px;
  }
`;

const Toolbar = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  background-color: var(--gray-3);
  padding: 8px 16px;
  position: absolute;
  top: -72px;
  left: 0;
  right: 0;
  transition: top 0.2s ease-out;
  &.isEditMode {
    top: 0;
  }
`;

export const getIsChartFinished = (status: ChartTaskStatus) => {
  return [
    ChartTaskStatus.FINISHED,
    ChartTaskStatus.FAILED,
    ChartTaskStatus.STOPPED,
  ].includes(status);
};

const getDynamicProperties = (chartType: ChartType) => {
  const propertiesMap = {
    [ChartType.GROUPED_BAR]: GroupedBarProperties,
    [ChartType.STACKED_BAR]: StackedBarProperties,
    [ChartType.LINE]: LineProperties,
    [ChartType.MULTI_LINE]: LineProperties,
    [ChartType.PIE]: DonutProperties,
  };
  return propertiesMap[chartType] || BasicProperties;
};

export default function ChartAnswer(props: AnswerResultProps) {
  const { onGenerateChartAnswer, onAdjustChartAnswer } = usePromptThreadStore();
  const { threadResponse } = props;
  const [regenerating, setRegenerating] = useState(false);
  const [isEditMode, setIsEditMode] = useState(false);
  const [newValues, setNewValues] = useState(null);

  const [form] = Form.useForm();
  const chartType = Form.useWatch('chartType', form);
  const { chartDetail } = threadResponse;
  const { error, status, adjustment } = chartDetail || {};

  const [previewData, previewDataResult] = usePreviewDataMutation({
    onError: (error) => console.error(error),
  });

  const [createDashboardItem] = useCreateDashboardItemMutation({
    onError: (error) => console.error(error),
    onCompleted: () => {
      message.success('Successfully pinned chart to dashboard.');
    },
  });

  // initial trigger when render
  useEffect(() => {
    previewData({
      variables: { where: { responseId: threadResponse.id } },
    });
  }, []);

  const chartSpec = useMemo(() => {
    if (
      !chartDetail?.chartSchema ||
      (getIsChartFinished(status) && isEmpty(chartDetail?.chartSchema))
    )
      return null;
    return chartDetail.chartSchema;
  }, [chartDetail]);

  const chartOptionValues = useMemo(() => {
    return getChartSpecOptionValues(chartDetail);
  }, [chartDetail]);

  const chartSpecFieldTitleMap = useMemo(() => {
    return getChartSpecFieldTitleMap(chartSpec?.encoding);
  }, [chartSpec]);

  useEffect(() => {
    form.setFieldsValue(chartOptionValues);
  }, [chartOptionValues]);

  const isAdjusted = useMemo(() => {
    return newValues !== null && !isEqual(chartOptionValues, newValues);
  }, [chartOptionValues, newValues]);

  const dataValues = useMemo(() => {
    const { data, columns } = previewDataResult.data?.previewData || {};
    return (data || []).map((val) => {
      return (columns || []).reduce((acc, col, index) => {
        acc[col.name] = val[index];
        return acc;
      }, {});
    });
  }, [previewDataResult.data]);

  const dataColumns = useMemo(() => {
    const { columns } = previewDataResult.data?.previewData || {};
    return columns || [];
  }, [previewDataResult.data]);

  const loading =
    previewDataResult.loading || !getIsChartFinished(status) || regenerating;

  const DynamicProperties = getDynamicProperties(chartType as ChartType);

  const onFormChange = () => {
    setNewValues(form.getFieldsValue());
  };

  const onRegenerate = () => {
    attachLoading(onGenerateChartAnswer, setRegenerating)(threadResponse.id);
    onResetState();
  };

  const onResetState = () => {
    setIsEditMode(false);
    setNewValues(null);
    form.resetFields();
  };

  const onReload = () => {
    Modal.confirm({
      title: 'Are you sure you want to regenerate the chart?',
      onOk: onRegenerate,
    });
  };

  const onEdit = () => {
    setIsEditMode(!isEditMode);
  };

  const onPin = () => {
    Modal.confirm({
      title: 'Are you sure you want to pin this chart to the dashboard?',
      okText: 'Save',
      onOk: async () =>
        await createDashboardItem({
          variables: {
            data: {
              // DashboardItemType is compatible with ChartType
              itemType: chartType as unknown as DashboardItemType,
              responseId: threadResponse.id,
            },
          },
        }),
    });
  };

  const onResetAdjustment = () => {
    setNewValues(null);
    form.resetFields();
  };

  const onAdjustChart = async () => {
    attachLoading(onAdjustChartAnswer, setRegenerating)(
      threadResponse.id,
      form.getFieldsValue(),
    );
    onResetState();
  };

  const regenerateBtn = (
    <div className="text-center mt-4">
      <Button icon={<ReloadOutlined />} onClick={onReload}>
        Regenerate
      </Button>
    </div>
  );

  if (error) {
    return (
      <div className="p-6">
        <Alert
          message={error.shortMessage}
          description={error.message}
          type="error"
          showIcon
        />
        {regenerateBtn}
      </div>
    );
  }

  const chartRegenerateBtn = adjustment ? regenerateBtn : null;

  return (
    <StyledSkeleton
      active
      loading={loading}
      paragraph={{ rows: 4 }}
      title={false}
    >
      <div className="text-md gray-10 p-6">
        {chartDetail?.description}
        {chartSpec ? (
          <ChartWrapper
            className={clsx(
              'border border-gray-4 rounded mt-4 pb-3 overflow-hidden',
              { isEditMode: isEditMode },
            )}
          >
            <Toolbar className={clsx({ isEditMode: isEditMode })}>
              <Form
                size="small"
                style={{ width: '100%' }}
                form={form}
                initialValues={chartOptionValues}
                onFieldsChange={onFormChange}
              >
                <div className="d-flex justify-content-between align-center">
                  <div className="flex-grow-1">
                    <DynamicProperties
                      columns={dataColumns}
                      titleMap={chartSpecFieldTitleMap}
                    />
                  </div>
                  {isAdjusted && (
                    <div className="d-flex flex-column">
                      <Button className="ml-4 mb-2" onClick={onResetAdjustment}>
                        Reset
                      </Button>
                      <Button
                        className="ml-4"
                        type="primary"
                        onClick={onAdjustChart}
                      >
                        Adjust
                      </Button>
                    </div>
                  )}
                </div>
              </Form>
            </Toolbar>
            <Chart
              width={700}
              spec={chartSpec}
              values={dataValues}
              onEdit={onEdit}
              onReload={onReload}
              onPin={onPin}
            />
          </ChartWrapper>
        ) : (
          chartRegenerateBtn
        )}
      </div>
    </StyledSkeleton>
  );
}
</file>

<file path="src/components/pages/home/promptThread/index.tsx">
import { useRouter } from 'next/router';
import { useEffect, useMemo, useRef } from 'react';
import { Divider } from 'antd';
import styled from 'styled-components';
import { nextTick } from '@/utils/time';
import usePromptThreadStore from './store';
import AnswerResult from './AnswerResult';
import { makeIterable, IterableComponent } from '@/utils/iteration';
import { getIsFinished } from '@/hooks/useAskPrompt';
import { getAnswerIsFinished } from '@/components/pages/home/promptThread/TextBasedAnswer';
import {
  RecommendedQuestionsTask,
  ThreadResponse,
} from '@/apollo/client/graphql/__types__';
import { SelectQuestionProps } from '@/components/pages/home/RecommendedQuestions';

export interface RecommendedQuestionsProps {
  data: RecommendedQuestionsTask;
  show: boolean;
  onSelect: ({ question, sql }: SelectQuestionProps) => void;
}

const StyledPromptThread = styled.div`
  width: 768px;
  margin-left: auto;
  margin-right: auto;

  h4.ant-typography {
    margin-top: 10px;
  }

  .ant-typography pre {
    border: none;
    border-radius: 4px;
  }

  button {
    vertical-align: middle;
  }
`;

const AnswerResultTemplate: React.FC<
  IterableComponent<ThreadResponse> & {
    motion: boolean;
    onInitPreviewDone: () => void;
  }
> = ({ data, index, motion, onInitPreviewDone, ...threadResponse }) => {
  const { id } = threadResponse;
  const lastResponseId = data[data.length - 1].id;
  const isLastThreadResponse = id === lastResponseId;

  return (
    <div
      key={`${id}-${index}`}
      data-guideid={isLastThreadResponse ? `last-answer-result` : undefined}
    >
      {index > 0 && <Divider />}
      <AnswerResult
        motion={motion}
        isLastThreadResponse={isLastThreadResponse}
        onInitPreviewDone={onInitPreviewDone}
        threadResponse={threadResponse}
      />
    </div>
  );
};

const AnswerResultIterator = makeIterable(AnswerResultTemplate);

export default function PromptThread() {
  const router = useRouter();
  const divRef = useRef<HTMLDivElement>(null);
  const store = usePromptThreadStore();
  const { data } = store;

  const responses = useMemo(() => data?.responses || [], [data?.responses]);

  const triggerScrollToBottom = (behavior?: ScrollBehavior) => {
    if (responses.length <= 1) return;
    const contentLayout = divRef.current?.parentElement;
    const allElements = (divRef.current?.querySelectorAll(
      '[data-jsid="answerResult"]',
    ) || []) as HTMLElement[];
    const lastAnswerResult = allElements[allElements.length - 1];

    const dividerSpace = 48;
    if (contentLayout && lastAnswerResult) {
      contentLayout.scrollTo({
        top: lastAnswerResult.offsetTop - dividerSpace,
        behavior,
      });
    }
  };

  useEffect(() => {
    // reset to top when thread page changes
    const contentLayout = divRef.current?.parentElement;
    if (contentLayout) contentLayout.scrollTo({ top: 0 });
  }, [router.query]);

  useEffect(() => {
    const lastResponse = responses[responses.length - 1];
    const isLastResponseFinished =
      getIsFinished(lastResponse?.askingTask?.status) ||
      getAnswerIsFinished(lastResponse?.answerDetail?.status);
    nextTick().then(() => {
      triggerScrollToBottom(isLastResponseFinished ? 'auto' : 'smooth');
    });
  }, [responses.length]);

  const onInitPreviewDone = () => {
    triggerScrollToBottom();
  };

  return (
    <StyledPromptThread className="mt-12" ref={divRef}>
      <AnswerResultIterator
        data={responses}
        onInitPreviewDone={onInitPreviewDone}
      />
    </StyledPromptThread>
  );
}
</file>

<file path="src/components/pages/home/promptThread/store.tsx">
import { useEffect } from 'react';
import useStoreContext, { STORE } from '@/hooks/useStoreContext';
import {
  AdjustThreadResponseChartInput,
  DetailedThread,
  RecommendedQuestionsTask,
  ThreadResponse,
} from '@/apollo/client/graphql/__types__';
import { SelectQuestionProps } from '@/components/pages/home/RecommendedQuestions';

export type IPromptThreadStore = {
  data: DetailedThread;
  recommendedQuestions: RecommendedQuestionsTask;
  showRecommendedQuestions: boolean;
  preparation: {
    askingStreamTask?: string;
    onStopAskingTask?: (queryId?: string) => Promise<void>;
    onStopAdjustTask?: (queryId?: string) => Promise<void>;
    onReRunAskingTask?: (threadResponse: ThreadResponse) => Promise<void>;
    onReRunAdjustTask?: (threadResponse: ThreadResponse) => Promise<void>;
    onFixSQLStatement?: (responseId: number, sql: string) => Promise<void>;
    fixStatementLoading?: boolean;
  };
  onOpenSaveAsViewModal: (data: { sql: string; responseId: number }) => void;
  onSelectRecommendedQuestion: ({
    question,
    sql,
  }: SelectQuestionProps) => Promise<void>;
  onGenerateThreadRecommendedQuestions: () => Promise<void>;
  onGenerateTextBasedAnswer: (responseId: number) => Promise<void>;
  onGenerateChartAnswer: (responseId: number) => Promise<void>;
  onAdjustChartAnswer: (
    responseId: number,
    data: AdjustThreadResponseChartInput,
  ) => Promise<void>;
  onOpenSaveToKnowledgeModal: (
    data: { sql: string; question: string },
    payload: { isCreateMode: boolean },
  ) => void;
  onOpenAdjustReasoningStepsModal: (data: {
    responseId: number;
    retrievedTables: string[];
    sqlGenerationReasoning: string;
  }) => void;
  onOpenAdjustSQLModal: (data: { responseId: number; sql: string }) => void;
};

// Register store provider
export const PromptThreadProvider = (props: {
  children: React.ReactNode;
  value: IPromptThreadStore;
}) => {
  const storeContext = useStoreContext();
  const PromptThreadContext = storeContext.createStore(STORE.PROMPT_THREAD);
  // clear store when unmount
  useEffect(() => {
    return () => storeContext.clearStore(STORE.PROMPT_THREAD);
  }, []);
  return (
    <PromptThreadContext.Provider value={props.value}>
      {props.children}
    </PromptThreadContext.Provider>
  );
};

// Use store
export default function usePromptThreadStore() {
  const storeContext = useStoreContext();
  return storeContext.useStore(STORE.PROMPT_THREAD) as IPromptThreadStore;
}
</file>

<file path="src/components/pages/home/promptThread/TextBasedAnswer.tsx">
import { useEffect, useMemo, useState } from 'react';
import { Alert, Button, Skeleton, Typography } from 'antd';
import ReloadOutlined from '@ant-design/icons/ReloadOutlined';
import LoadingOutlined from '@ant-design/icons/LoadingOutlined';
import CaretDownOutlined from '@ant-design/icons/CaretDownOutlined';
import EditOutlined from '@ant-design/icons/EditOutlined';
import styled from 'styled-components';
import { BinocularsIcon } from '@/utils/icons';
import { nextTick } from '@/utils/time';
import { MORE_ACTION } from '@/utils/enum';
import usePromptThreadStore from './store';
import useDropdown from '@/hooks/useDropdown';
import useTextBasedAnswerStreamTask from '@/hooks/useTextBasedAnswerStreamTask';
import { Props as AnswerResultProps } from '@/components/pages/home/promptThread/AnswerResult';
import MarkdownBlock from '@/components/editor/MarkdownBlock';
import PreviewData from '@/components/dataPreview/PreviewData';
import { AdjustAnswerDropdown } from '@/components/diagram/CustomDropdown';
import { usePreviewDataMutation } from '@/apollo/client/graphql/home.generated';
import { ThreadResponseAnswerStatus } from '@/apollo/client/graphql/__types__';

const { Text } = Typography;

const StyledSkeleton = styled(Skeleton)`
  padding: 16px;
  .ant-skeleton-paragraph {
    margin-bottom: 0;
  }
`;

export const getAnswerIsFinished = (status: ThreadResponseAnswerStatus) =>
  [
    ThreadResponseAnswerStatus.FINISHED,
    ThreadResponseAnswerStatus.FAILED,
    ThreadResponseAnswerStatus.INTERRUPTED,
  ].includes(status);

const getIsLoadingFinished = (status: ThreadResponseAnswerStatus) =>
  getAnswerIsFinished(status) ||
  status === ThreadResponseAnswerStatus.STREAMING;

export default function TextBasedAnswer(props: AnswerResultProps) {
  const {
    onGenerateTextBasedAnswer,
    onOpenAdjustReasoningStepsModal,
    onOpenAdjustSQLModal,
  } = usePromptThreadStore();
  const { isLastThreadResponse, onInitPreviewDone, threadResponse } = props;
  const { id } = threadResponse;
  const { content, error, numRowsUsedInLLM, status } =
    threadResponse?.answerDetail || {};

  const [textAnswer, setTextAnswer] = useState<string>('');
  const adjustResultsDropdown = useDropdown();

  const [fetchAnswerStreamingTask, answerStreamTaskResult] =
    useTextBasedAnswerStreamTask();

  const answerStreamTask = answerStreamTaskResult.data;

  const isStreaming = useMemo(
    () => status === ThreadResponseAnswerStatus.STREAMING,
    [status],
  );

  // Adapt askingTask and adjustment reasoning data to dropdown
  const adjustAnswerDropdownData = useMemo(() => {
    const { payload } = threadResponse.adjustment || {};
    return {
      responseId: threadResponse.id,
      sql: threadResponse.sql,
      retrievedTables:
        threadResponse.askingTask?.retrievedTables ||
        payload?.retrievedTables ||
        [],
      sqlGenerationReasoning:
        threadResponse.askingTask?.sqlGenerationReasoning ||
        payload?.sqlGenerationReasoning ||
        '',
    };
  }, [
    threadResponse.id,
    threadResponse.sql,
    threadResponse.adjustment?.payload,
    threadResponse.askingTask?.retrievedTables,
    threadResponse.askingTask?.sqlGenerationReasoning,
  ]);

  useEffect(() => {
    if (isStreaming) {
      setTextAnswer(answerStreamTask);
    } else {
      setTextAnswer(content);
    }
  }, [answerStreamTask, isStreaming, content]);

  useEffect(() => {
    if (isStreaming) {
      fetchAnswerStreamingTask(id);
    }
  }, [isStreaming, id]);

  useEffect(() => {
    return () => {
      answerStreamTaskResult.onReset();
    };
  }, []);

  const rowsUsed = useMemo(
    () =>
      status === ThreadResponseAnswerStatus.FINISHED ? numRowsUsedInLLM : 0,
    [numRowsUsedInLLM, status],
  );

  const allowPreviewData = useMemo(() => Boolean(rowsUsed > 0), [rowsUsed]);

  const [previewData, previewDataResult] = usePreviewDataMutation({
    onError: (error) => console.error(error),
  });

  const onPreviewData = async () => {
    await previewData({ variables: { where: { responseId: id } } });
  };

  const autoTriggerPreviewDataButton = async () => {
    await nextTick();
    await onPreviewData();
  };

  useEffect(() => {
    if (isLastThreadResponse) {
      if (allowPreviewData) {
        autoTriggerPreviewDataButton();
      }

      onInitPreviewDone();
    }
  }, [isLastThreadResponse, allowPreviewData]);

  const loading = !getIsLoadingFinished(status);

  const onRegenerateAnswer = () => {
    setTextAnswer('');
    onGenerateTextBasedAnswer(id);
  };

  const onMoreClick = async (payload: {
    type: MORE_ACTION;
    data: typeof adjustAnswerDropdownData;
  }) => {
    const { type, data } = payload;
    if (type === MORE_ACTION.ADJUST_STEPS) {
      onOpenAdjustReasoningStepsModal({
        responseId: data.responseId,
        retrievedTables: data.retrievedTables,
        sqlGenerationReasoning: data.sqlGenerationReasoning,
      });
    } else if (type === MORE_ACTION.ADJUST_SQL) {
      onOpenAdjustSQLModal({ responseId: id, sql: data.sql });
    }
  };

  const adjustAnswerDropdown = (
    <AdjustAnswerDropdown
      onMoreClick={onMoreClick}
      data={adjustAnswerDropdownData}
      onDropdownVisibleChange={adjustResultsDropdown.onVisibleChange}
    >
      <Button
        className="px-0"
        type="link"
        size="small"
        icon={<EditOutlined />}
        onClick={(event) => event.stopPropagation()}
      >
        Adjust the answer
        <CaretDownOutlined
          className="ml-1"
          rotate={adjustResultsDropdown.visible ? 180 : 0}
        />
      </Button>
    </AdjustAnswerDropdown>
  );

  if (error) {
    return (
      <>
        <div className="py-4 px-6">
          <div className="text-right">{adjustAnswerDropdown}</div>
          <Alert
            className="mt-4 mb-2"
            message={error.shortMessage}
            description={error.message}
            type="error"
            showIcon
          />
        </div>
      </>
    );
  }

  return (
    <StyledSkeleton
      active
      loading={loading}
      paragraph={{ rows: 4 }}
      title={false}
    >
      <div className="text-md gray-10 py-4 px-6">
        <div className="text-right mb-4">{adjustAnswerDropdown}</div>
        <MarkdownBlock content={textAnswer} />
        {isStreaming && <LoadingOutlined className="geekblue-6" spin />}
        {status === ThreadResponseAnswerStatus.INTERRUPTED && (
          <div className="mt-2 text-right">
            <Button
              icon={<ReloadOutlined />}
              size="small"
              type="link"
              title="Regenerate answer"
              onClick={onRegenerateAnswer}
            >
              Regenerate
            </Button>
          </div>
        )}
        {allowPreviewData ? (
          <div className="mt-6">
            <Button
              size="small"
              icon={
                <BinocularsIcon
                  style={{
                    paddingBottom: 2,
                    marginRight: 8,
                  }}
                />
              }
              loading={previewDataResult.loading}
              onClick={onPreviewData}
              data-ph-capture="true"
              data-ph-capture-attribute-name="cta_text-answer_preview_data"
            >
              View results
            </Button>

            {previewDataResult?.data?.previewData && (
              <div
                className="mt-2 mb-3"
                data-guideid="text-answer-preview-data"
              >
                <Text type="secondary" className="text-sm">
                  Considering the limit of the context window, we retrieve up to
                  500 rows of results to generate the answer.
                </Text>
                <PreviewData
                  error={previewDataResult.error}
                  loading={previewDataResult.loading}
                  previewData={previewDataResult?.data?.previewData}
                />
              </div>
            )}
          </div>
        ) : (
          <>
            {!isStreaming && (
              <Alert
                message={
                  <>
                    Click <b>View SQL</b> to review the step-by-step query logic
                    and verify why the data is unavailable.
                  </>
                }
                type="info"
              />
            )}
          </>
        )}
      </div>
    </StyledSkeleton>
  );
}
</file>

<file path="src/components/pages/home/promptThread/ViewBlock.tsx">
import Link from 'next/link';
import { Button } from 'antd';
import FileDoneOutlined from '@ant-design/icons/FileDoneOutlined';
import SaveOutlined from '@ant-design/icons/SaveOutlined';
import { Path } from '@/utils/enum';
import { ViewInfo } from '@/apollo/client/graphql/__types__';

interface Props {
  view?: ViewInfo;
  onClick: () => void;
}

export default function ViewBlock({ view, onClick }: Props) {
  const isViewSaved = !!view;

  if (isViewSaved) {
    return (
      <div className="gray-6 text-medium">
        <FileDoneOutlined className="mr-2" />
        Generated from saved view{' '}
        <Link
          className="gray-7"
          href={`${Path.Modeling}?viewId=${view.id}&openMetadata=true`}
          target="_blank"
          rel="noreferrer noopener"
        >
          {view.displayName}
        </Link>
      </div>
    );
  }

  return (
    <Button
      className="gray-6"
      type="text"
      size="small"
      icon={<SaveOutlined />}
      onClick={onClick}
    >
      Save as View
    </Button>
  );
}
</file>

<file path="src/components/pages/home/promptThread/ViewSQLTabContent.tsx">
import dynamic from 'next/dynamic';
import Image from 'next/image';
import { useEffect } from 'react';
import styled from 'styled-components';
import {
  Alert,
  Button,
  Divider,
  Empty,
  message,
  Space,
  Switch,
  Typography,
} from 'antd';
import CheckOutlined from '@ant-design/icons/CheckOutlined';
import CloseOutlined from '@ant-design/icons/CloseOutlined';
import CodeFilled from '@ant-design/icons/CodeFilled';
import { BinocularsIcon } from '@/utils/icons';
import { nextTick } from '@/utils/time';
import useNativeSQL from '@/hooks/useNativeSQL';
import { DATA_SOURCE_OPTIONS } from '@/components/pages/setup/utils';
import { Logo } from '@/components/Logo';
import { Props as AnswerResultProps } from '@/components/pages/home/promptThread/AnswerResult';
import usePromptThreadStore from '@/components/pages/home/promptThread/store';
import PreviewData from '@/components/dataPreview/PreviewData';
import { usePreviewDataMutation } from '@/apollo/client/graphql/home.generated';

const SQLCodeBlock = dynamic(() => import('@/components/code/SQLCodeBlock'), {
  ssr: false,
});

const { Text } = Typography;

const StyledPre = styled.pre`
  .adm_code-block {
    border-top: none;
    border-radius: 0px 0px 4px 4px;
  }
`;

const StyledToolBar = styled.div`
  background-color: var(--gray-2);
  height: 32px;
  padding: 4px 8px;
  border: 1px solid var(--gray-3);
  border-radius: 4px 4px 0px 0px;
`;

export default function ViewSQLTabContent(props: AnswerResultProps) {
  const { isLastThreadResponse, onInitPreviewDone, threadResponse } = props;

  const { onOpenAdjustSQLModal } = usePromptThreadStore();
  const { fetchNativeSQL, nativeSQLResult } = useNativeSQL();
  const [previewData, previewDataResult] = usePreviewDataMutation({
    onError: (error) => console.error(error),
  });

  const onPreviewData = async () => {
    await previewData({ variables: { where: { responseId: id } } });
  };

  const autoTriggerPreviewDataButton = async () => {
    await nextTick();
    await onPreviewData();
    await nextTick();
    onInitPreviewDone();
  };

  // when is the last step of the last thread response, auto trigger preview data button
  useEffect(() => {
    if (isLastThreadResponse) {
      autoTriggerPreviewDataButton();
    }
  }, [isLastThreadResponse]);

  const { id, sql } = threadResponse;

  const { hasNativeSQL, dataSourceType } = nativeSQLResult;
  const showNativeSQL = hasNativeSQL;

  const sqls =
    nativeSQLResult.nativeSQLMode && nativeSQLResult.loading === false
      ? nativeSQLResult.data
      : sql;

  const onChangeNativeSQL = async (checked: boolean) => {
    nativeSQLResult.setNativeSQLMode(checked);
    checked && fetchNativeSQL({ variables: { responseId: id } });
  };

  const onCopy = () => {
    if (!nativeSQLResult.nativeSQLMode) {
      message.success(
        <>
          You copied Wren SQL. This dialect is for the Wren Engine and may not
          run directly on your database.
          {hasNativeSQL && (
            <>
              {' '}
              Click “<b>Show original SQL</b>” to get the executable version.
            </>
          )}
        </>,
      );
    }
  };

  return (
    <div className="text-md gray-10 p-6 pb-4">
      <Alert
        banner
        className="mb-3 adm-alert-info"
        message={
          <>
            You’re viewing Wren SQL by default. If you want to run this query on
            your own database, click “Show original SQL” to get the exact
            syntax.
            <Typography.Link
              className="underline ml-1"
              href="https://docs.getwren.ai/oss/guide/home/wren_sql"
              target="_blank"
              rel="noopener noreferrer"
            >
              Learn more about Wren SQL
            </Typography.Link>
          </>
        }
        type="info"
      />
      <StyledPre className="p-0 mb-3">
        <StyledToolBar className="d-flex align-center justify-space-between text-family-base">
          <div>
            {nativeSQLResult.nativeSQLMode ? (
              <>
                <Image
                  className="mr-2"
                  src={DATA_SOURCE_OPTIONS[dataSourceType].logo}
                  alt={DATA_SOURCE_OPTIONS[dataSourceType].label}
                  width="22"
                  height="22"
                />
                <Text className="gray-8 text-medium text-sm">
                  {DATA_SOURCE_OPTIONS[dataSourceType].label}
                </Text>
              </>
            ) : (
              <span className="d-flex align-center gx-2">
                <Logo size={18} />
                <Text className="gray-8 text-medium text-sm">Wren SQL</Text>
              </span>
            )}
          </div>
          <Space split={<Divider type="vertical" className="m-0" />}>
            {showNativeSQL && (
              <div
                className="d-flex align-center cursor-pointer"
                onClick={() =>
                  onChangeNativeSQL(!nativeSQLResult.nativeSQLMode)
                }
              >
                <Switch
                  checkedChildren={<CheckOutlined />}
                  unCheckedChildren={<CloseOutlined />}
                  className="mr-2"
                  size="small"
                  checked={nativeSQLResult.nativeSQLMode}
                  loading={nativeSQLResult.loading}
                />
                <Text className="gray-8 text-medium text-base">
                  Show original SQL
                </Text>
              </div>
            )}
            <Button
              type="link"
              data-ph-capture="true"
              data-ph-capture-attribute-name="view_sql_copy_sql"
              icon={<CodeFilled />}
              size="small"
              onClick={() => onOpenAdjustSQLModal({ sql, responseId: id })}
            >
              Adjust SQL
            </Button>
          </Space>
        </StyledToolBar>
        <SQLCodeBlock
          code={sqls}
          showLineNumbers
          maxHeight="300"
          loading={nativeSQLResult.loading}
          copyable
          onCopy={onCopy}
        />
      </StyledPre>
      <div className="mt-6">
        <Button
          size="small"
          icon={
            <BinocularsIcon
              style={{
                paddingBottom: 2,
                marginRight: 8,
              }}
            />
          }
          loading={previewDataResult.loading}
          onClick={onPreviewData}
          data-ph-capture="true"
          data-ph-capture-attribute-name="view_sql_preview_data"
        >
          View results
        </Button>
        {previewDataResult?.data?.previewData && (
          <div className="mt-2 mb-3">
            <PreviewData
              error={previewDataResult.error}
              loading={previewDataResult.loading}
              previewData={previewDataResult?.data?.previewData}
              locale={{
                emptyText: (
                  <Empty
                    image={Empty.PRESENTED_IMAGE_SIMPLE}
                    description="Sorry, we couldn't find any records that match your search criteria."
                  />
                ),
              }}
            />
            <div className="text-right">
              <Text className="text-base gray-6">Showing up to 500 rows</Text>
            </div>
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="src/components/pages/home/RecommendedQuestions.tsx">
import clsx from 'clsx';
import styled from 'styled-components';
import { useMemo } from 'react';
import { Skeleton } from 'antd';
import BulbOutlined from '@ant-design/icons/BulbOutlined';
import { makeIterable } from '@/utils/iteration';
import {
  RecommendedQuestionsTask,
  RecommendedQuestionsTaskStatus,
} from '@/apollo/client/graphql/__types__';

export interface SelectQuestionProps {
  question: string;
  sql: string;
}

interface Props {
  items: { question: string; sql: string }[];
  loading?: boolean;
  error?: {
    shortMessage?: string;
    code?: string;
    message?: string;
    stacktrace?: string[];
  };
  className?: string;
  onSelect: ({ question, sql }: SelectQuestionProps) => void;
}

const StyledSkeleton = styled(Skeleton)`
  padding: 4px 0;
  .ant-skeleton-paragraph {
    margin-bottom: 0;
    li {
      height: 14px;
      + li {
        margin-top: 12px;
      }
    }
  }
`;

export const getRecommendedQuestionProps = (
  data: RecommendedQuestionsTask,
  show = true,
) => {
  if (!data || !show) return { show: false };
  const questions = (data?.questions || []).slice(0, 3).map((item) => ({
    question: item.question,
    sql: item.sql,
  }));
  const loading = data?.status === RecommendedQuestionsTaskStatus.GENERATING;
  return {
    show: loading || questions.length > 0,
    state: {
      items: questions,
      loading,
      error: data?.error,
    },
  };
};

const QuestionItem = (props: {
  index: number;
  question: string;
  sql: string;
  onSelect: ({ question, sql }: SelectQuestionProps) => void;
}) => {
  const { index, question, sql, onSelect } = props;
  return (
    <div className={clsx(index > 0 && 'mt-1')}>
      <span
        className="cursor-pointer hover:text"
        onClick={() => onSelect({ question, sql })}
      >
        {question}
      </span>
    </div>
  );
};
const QuestionList = makeIterable(QuestionItem);

export default function RecommendedQuestions(props: Props) {
  const { items, loading, className, onSelect } = props;

  const data = useMemo(
    () => items.map(({ question, sql }) => ({ question, sql })),
    [items],
  );

  return (
    <div className={clsx('bg-gray-2 rounded p-3', className)}>
      <div className="mb-2">
        <BulbOutlined className="mr-1 gray-6" />
        <b className="text-semi-bold text-sm gray-7">Recommended questions</b>
      </div>
      <div className="pl-1 gray-8">
        <StyledSkeleton
          active
          loading={loading}
          paragraph={{ rows: 3 }}
          title={false}
        >
          <QuestionList data={data} onSelect={onSelect} />
        </StyledSkeleton>
      </div>
    </div>
  );
}
</file>

<file path="src/components/pages/knowledge/GlobalLabel.tsx">
import { Typography } from 'antd';
import GlobalOutlined from '@ant-design/icons/GlobalOutlined';

const { Text } = Typography;

export default function GlobalLabel() {
  return (
    <>
      <GlobalOutlined className="mr-2" />
      <Text className="gray-9">Global</Text>
    </>
  );
}
</file>

<file path="src/components/pages/knowledge/InstructionDrawer.tsx">
import { Drawer, Tag, Typography } from 'antd';
import { getCompactTime } from '@/utils/time';
import QuestionOutlined from '@ant-design/icons/QuestionOutlined';
import { DrawerAction } from '@/hooks/useDrawerAction';
import GlobalLabel from '@/components/pages/knowledge/GlobalLabel';
import { Instruction } from '@/apollo/client/graphql/__types__';

const { Text } = Typography;

type Props = DrawerAction<Instruction>;

export default function InstructionDrawer(props: Props) {
  const { visible, defaultValue, onClose } = props;

  return (
    <Drawer
      closable
      destroyOnClose
      onClose={onClose}
      title="View instruction"
      visible={visible}
      width={760}
    >
      <div className="mb-6">
        <Typography.Text className="gray-7 mb-2">
          Instruction details
        </Typography.Text>
        <div>{defaultValue?.instruction || '-'}</div>
      </div>
      <div className="mb-6">
        <Typography.Text className="gray-7 mb-2">
          Matching questions
        </Typography.Text>
        <div>
          {defaultValue?.isDefault ? (
            <>
              <GlobalLabel />
              <Text className="gray-7 ml-2" type="secondary">
                (applies to all questions)
              </Text>
            </>
          ) : (
            defaultValue?.questions.map((question, index) => (
              <div key={`${question}-${index}`} className="my-2">
                <Tag className="bg-gray-1 border-gray-5">
                  <QuestionOutlined className="geekblue-6" />
                  <Text className="gray-9">{question}</Text>
                </Tag>
              </div>
            ))
          )}
        </div>
      </div>
      <div className="mb-6">
        <Typography.Text className="gray-7 mb-2">Created time</Typography.Text>
        <div>
          {defaultValue?.createdAt
            ? getCompactTime(defaultValue.createdAt)
            : '-'}
        </div>
      </div>
    </Drawer>
  );
}
</file>

<file path="src/components/pages/knowledge/SQLPairDrawer.tsx">
import { Drawer, Typography } from 'antd';
import { getCompactTime } from '@/utils/time';
import { DrawerAction } from '@/hooks/useDrawerAction';
import SQLCodeBlock from '@/components/code/SQLCodeBlock';
import { SqlPair } from '@/apollo/client/graphql/__types__';

type Props = DrawerAction<SqlPair>;

export default function SQLPairDrawer(props: Props) {
  const { visible, defaultValue, onClose } = props;

  return (
    <Drawer
      closable
      destroyOnClose
      onClose={onClose}
      title="View question-SQL pair"
      visible={visible}
      width={760}
    >
      <div className="mb-6">
        <Typography.Text className="gray-7 mb-2">Question</Typography.Text>
        <div>{defaultValue?.question || '-'}</div>
      </div>
      <div className="mb-6">
        <Typography.Text className="gray-7 mb-2">SQL statement</Typography.Text>
        <SQLCodeBlock
          code={defaultValue?.sql || ''}
          showLineNumbers
          maxHeight="500"
        />
      </div>
      <div className="mb-6">
        <Typography.Text className="gray-7 mb-2">Created time</Typography.Text>
        <div>
          {defaultValue?.createdAt
            ? getCompactTime(defaultValue.createdAt)
            : '-'}
        </div>
      </div>
    </Drawer>
  );
}
</file>

<file path="src/components/pages/modeling/EditMetadataModal.tsx">
import { Modal, Form } from 'antd';
import { ModalAction } from '@/hooks/useModalAction';
import { NODE_TYPE } from '@/utils/enum';
import { EditableContext } from '@/components/EditableWrapper';
import EditModelMetadata, {
  Props as EditModelProps,
} from '@/components/pages/modeling/metadata/EditModelMetadata';
import EditViewMetadata, {
  Props as EditViewProps,
} from '@/components/pages/modeling/metadata/EditViewMetadata';

type DefaultValue = (EditModelProps | EditViewProps) & {
  nodeType: NODE_TYPE;
};

type Props = ModalAction<DefaultValue> & {
  loading?: boolean;
};

const formNamespace = 'metadata';

export default function EditMetadataModal(props: Props) {
  const { visible, defaultValue, loading, onSubmit, onClose } = props;
  const { nodeType } = defaultValue || {};

  const [form] = Form.useForm();

  const submit = async () => {
    form
      .validateFields()
      .then(async () => {
        // Get the saved metadata values to submit if there is no editing failed
        const values = form.getFieldValue(formNamespace);
        await onSubmit({ data: values, nodeType });
        onClose();
      })
      .catch(console.error);
  };

  return (
    <Modal
      title="Edit metadata"
      width={800}
      visible={visible}
      okText="Submit"
      onOk={submit}
      onCancel={onClose}
      confirmLoading={loading}
      maskClosable={false}
      destroyOnClose
      centered
      afterClose={() => form.resetFields()}
    >
      <EditableContext.Provider value={form}>
        <Form form={form} component={false}>
          {nodeType === NODE_TYPE.MODEL && (
            <EditModelMetadata
              formNamespace={formNamespace}
              {...(defaultValue as EditModelProps)}
            />
          )}

          {nodeType === NODE_TYPE.VIEW && (
            <EditViewMetadata
              formNamespace={formNamespace}
              {...(defaultValue as EditViewProps)}
            />
          )}
        </Form>
      </EditableContext.Provider>
    </Modal>
  );
}
</file>

<file path="src/components/pages/modeling/form/ModelForm.tsx">
import { useEffect, useMemo, useState } from 'react';
import { Form, FormInstance, Select } from 'antd';
import { TransferItem } from 'antd/es/transfer';
import { isEmpty } from 'lodash';
import { FORM_MODE } from '@/utils/enum';
import { DiagramModelField } from '@/utils/data';
import { ERROR_TEXTS } from '@/utils/error';
import { DrawerAction } from '@/hooks/useDrawerAction';
import { Loading } from '@/components/PageLoading';
import TableTransfer, {
  defaultColumns,
} from '@/components/table/TableTransfer';
import { useListDataSourceTablesQuery } from '@/apollo/client/graphql/dataSource.generated';
import { useListModelsQuery } from '@/apollo/client/graphql/model.generated';
import { CompactTable, CompactColumn } from '@/apollo/client/graphql/__types__';

const { Option } = Select;

const FormFieldKey = {
  SOURCE_TABLE: 'sourceTableName',
  COLUMNS: 'fields',
  PRIMARY_KEY: 'primaryKey',
};

type Props = Pick<DrawerAction, 'defaultValue' | 'formMode'> & {
  form: FormInstance;
};

const primaryKeyValidator =
  (selectedColumns: string[]) => async (_rule: any, value: string) => {
    if (value && !selectedColumns.includes(value)) {
      return Promise.reject(
        ERROR_TEXTS.MODELING_CREATE_MODEL.PRIMARY_KEY.INVALID,
      );
    }

    return Promise.resolve();
  };

export default function ModelForm(props: Props) {
  const { defaultValue, form, formMode } = props;

  const [selectedColumns, setSelectedColumns] = useState<string[]>([]);
  const [sourceTableName, setSourceTableName] = useState<string>(undefined);
  const sourceTableFieldValue = Form.useWatch(FormFieldKey.SOURCE_TABLE, form);

  const isUpdateMode = formMode === FORM_MODE.EDIT;

  const { data: listModelsQueryResult, loading: listModelsQueryLoading } =
    useListModelsQuery({
      fetchPolicy: 'cache-and-network',
      skip: isUpdateMode,
    });

  const { data, loading: fetching } = useListDataSourceTablesQuery({
    fetchPolicy: 'cache-and-network',
    onError: (error) => console.error(error),
  });

  const dataSourceTables = data?.listDataSourceTables || [];
  const existingModels = listModelsQueryResult?.listModels;
  const inUsedModelList = useMemo(
    () => (existingModels || []).map((model) => model.sourceTableName),
    [existingModels],
  );

  useEffect(() => {
    if (isUpdateMode) return;

    // for create mode, reset selected columns when source table changes
    setSelectedColumns([]);
    form.resetFields([FormFieldKey.PRIMARY_KEY]);
  }, [formMode, sourceTableName]);

  // for create mode
  useEffect(() => {
    if (sourceTableFieldValue) {
      setSourceTableName(sourceTableFieldValue);
    }
  }, [sourceTableFieldValue]);

  const columns: Array<{
    key: string;
    name: string;
    type: string;
  }> = useMemo(() => {
    if (isEmpty(sourceTableName)) return [];

    const table = dataSourceTables.find(
      (table) => table.name === sourceTableName,
    )!;
    if (!table) return [];

    return table.columns.map((column: CompactColumn) => ({
      ...column,
      key: column.name,
    }));
  }, [dataSourceTables, sourceTableName]);

  useEffect(() => {
    if (defaultValue) {
      const fields: string[] = defaultValue.fields
        .map((field: DiagramModelField) => field.referenceName)
        .filter((col) => columns.find((c) => c.name === col));

      const primaryKeyField = defaultValue.fields.find(
        (field: DiagramModelField) => field.isPrimaryKey,
      );

      form.setFieldsValue({
        [FormFieldKey.COLUMNS]: fields,
        [FormFieldKey.PRIMARY_KEY]: primaryKeyField?.referenceName,
      });

      setSourceTableName(defaultValue.sourceTableName);
      setSelectedColumns(fields);
    }
  }, [defaultValue, form, columns]);

  const tableOptions: JSX.Element[] = dataSourceTables.map(
    (table: CompactTable) => {
      const disabled = inUsedModelList.includes(table.name);
      const option = {
        disabled,
        children: table.name,
        value: table.name,
      };

      return <Option {...option} key={option.value} />;
    },
  );

  const onChangeColumns = (newKeys: string[]) => setSelectedColumns(newKeys);

  const dataSourceTablesLoading = fetching || listModelsQueryLoading;

  return (
    <>
      <Form form={form} layout="vertical">
        {!isUpdateMode && (
          <div>
            <Form.Item
              label="Select a table"
              name={FormFieldKey.SOURCE_TABLE}
              required
              rules={[
                {
                  required: true,
                  message: ERROR_TEXTS.MODELING_CREATE_MODEL.TABLE.REQUIRED,
                },
              ]}
            >
              <Select
                getPopupContainer={(trigger) => trigger.parentElement!}
                placeholder="Select a table"
                showSearch
                loading={dataSourceTablesLoading}
                disabled={isUpdateMode}
              >
                {tableOptions}
              </Select>
            </Form.Item>
          </div>
        )}
        <Loading spinning={isUpdateMode ? dataSourceTablesLoading : false}>
          <Form.Item
            label="Select columns"
            name={FormFieldKey.COLUMNS}
            rules={[
              {
                required: true,
                message: ERROR_TEXTS.MODELING_CREATE_MODEL.COLUMNS.REQUIRED,
              },
            ]}
          >
            <TableTransfer
              dataSource={columns}
              targetKeys={selectedColumns}
              onChange={onChangeColumns}
              filterOption={(inputValue: string, item: TransferItem) =>
                item.name.toLowerCase().indexOf(inputValue.toLowerCase()) !==
                  -1 ||
                item.type.toLowerCase().indexOf(inputValue.toLowerCase()) !== -1
              }
              leftColumns={defaultColumns}
              rightColumns={defaultColumns}
              titles={['Available Columns', 'Target Columns']}
              showSearch
            />
          </Form.Item>
        </Loading>
        <Form.Item
          label="Select primary key"
          name={FormFieldKey.PRIMARY_KEY}
          rules={[
            {
              validator: primaryKeyValidator(selectedColumns),
            },
          ]}
        >
          <Select
            getPopupContainer={(trigger) => trigger.parentElement!}
            placeholder="Select a column"
            showSearch
            allowClear
          >
            {selectedColumns.map((column) => (
              <Option key={column} value={column}>
                {column}
              </Option>
            ))}
          </Select>
        </Form.Item>
      </Form>
    </>
  );
}
</file>

<file path="src/components/pages/modeling/metadata/EditBasicMetadata.tsx">
import { useEffect, useState } from 'react';
import { Typography, Row, Col } from 'antd';
import { cloneDeep, set } from 'lodash';
import { NODE_TYPE } from '@/utils/enum';
import EditableWrapper from '@/components/EditableWrapper';

interface Props {
  dataSource: any;
  onChange?: (value: any) => void;
  nodeType: NODE_TYPE;
  rules?: Record<string, any[]>;
}

export default function EditBasicMetadata(props: Props) {
  const { dataSource, onChange, nodeType, rules } = props;
  const [data, setData] = useState(dataSource);

  const isModel = nodeType === NODE_TYPE.MODEL;
  const isView = nodeType === NODE_TYPE.VIEW;

  useEffect(() => {
    // bind changeable metadata values
    onChange &&
      onChange({
        displayName: data.displayName,
        description: data.description,
      });
  }, [data]);

  const handleSave = (_, value) => {
    const [dataIndexKey] = Object.keys(value);

    const newData = cloneDeep(data);
    set(newData, dataIndexKey, value[dataIndexKey]);
    setData(newData);
  };

  return (
    <>
      {isModel && (
        <Row>
          <Col span={12}>
            <div className="mb-6" data-testid="edit-metadata__name">
              <Typography.Text className="d-block gray-7 mb-2">
                Name
              </Typography.Text>
              <div>{data.referenceName}</div>
            </div>
          </Col>
          <Col span={12} data-testid="edit-metadata__alias">
            <div className="mb-6" data-testid="metadata__name">
              <Typography.Text className="d-block gray-7 mb-2">
                Alias
              </Typography.Text>
              <EditableWrapper
                record={data}
                dataIndex="displayName"
                handleSave={handleSave}
              >
                {data.displayName || '-'}
              </EditableWrapper>
            </div>
          </Col>
        </Row>
      )}

      {isView && (
        <div className="mb-6" data-testid="edit-metadata__name">
          <Typography.Text className="d-block gray-7 mb-2">
            Name
          </Typography.Text>
          <EditableWrapper
            record={data}
            dataIndex="displayName"
            handleSave={handleSave}
            rules={rules?.displayName}
          >
            {data.displayName || '-'}
          </EditableWrapper>
        </div>
      )}

      <div className="mb-6" data-testid="edit-metadata__description">
        <Typography.Text className="d-block gray-7 mb-2">
          Description
        </Typography.Text>
        <EditableWrapper
          record={data}
          dataIndex="description"
          handleSave={handleSave}
        >
          {data.description || '-'}
        </EditableWrapper>
      </div>
    </>
  );
}
</file>

<file path="src/components/pages/modeling/metadata/EditModelMetadata.tsx">
import { useContext } from 'react';
import { Typography } from 'antd';
import { NODE_TYPE } from '@/utils/enum';
import FieldTable from '@/components/table/FieldTable';
import CalculatedFieldTable from '@/components/table/CalculatedFieldTable';
import RelationTable from '@/components/table/RelationTable';
import { makeEditableBaseTable } from '@/components/table/EditableBaseTable';
import { COLUMN } from '@/components/table/BaseTable';
import { EditableContext } from '@/components/EditableWrapper';
import EditBasicMetadata from './EditBasicMetadata';
import NestedFieldTable from '@/components/table/NestedFieldTable';

export interface Props {
  formNamespace: string;
  displayName: string;
  referenceName: string;
  fields: any[];
  calculatedFields?: any[];
  relationFields: any[];
  description: string;
  properties: Record<string, any>;
  nodeType: NODE_TYPE;
  modelId: number;
}

const FIELDS_NAME = {
  FIELDS: 'columns',
  NESTED_FIELDS: 'nestedColumns',
  CALCULATED_FIELDS: 'calculatedFields',
  RELATIONSHIPS: 'relationships',
};

const FieldEditableTable = makeEditableBaseTable(FieldTable);
const NestedFieldEditableTable = makeEditableBaseTable(NestedFieldTable as any);
const CalculatedFieldEditableTable =
  makeEditableBaseTable(CalculatedFieldTable);
const RelationshipEditableTable = makeEditableBaseTable(RelationTable);

export default function EditModelMetadata(props: Props) {
  const {
    formNamespace,
    displayName,
    referenceName,
    fields = [],
    calculatedFields = [],
    relationFields = [],
    description,
    nodeType,
    modelId,
  } = props || {};

  const form = useContext(EditableContext);

  const onChange = (value) => {
    form.setFieldsValue({
      [formNamespace]: {
        ...(form.getFieldValue(formNamespace) || {}),
        ...value,
        modelId,
      },
    });
  };

  const handleMetadataChange = (fieldsName: string) => (value: any[]) => {
    // bind changeable metadata values
    onChange({
      [fieldsName]: value.map((item) => ({
        id: item.relationId || item.columnId || item.nestedColumnId,
        description: item.description,
        // Only models & fields, nested fields have alias
        ...([FIELDS_NAME.FIELDS, FIELDS_NAME.NESTED_FIELDS].includes(fieldsName)
          ? { displayName: item.displayName }
          : {}),
      })),
    });
  };

  return (
    <>
      <EditBasicMetadata
        dataSource={{ displayName, referenceName, description }}
        onChange={onChange}
        nodeType={nodeType}
      />

      <div className="mb-6">
        <Typography.Text className="d-block gray-7 mb-2">
          Columns ({fields.length})
        </Typography.Text>
        <FieldEditableTable
          dataSource={fields}
          columns={[
            COLUMN.NAME,
            COLUMN.ALIAS,
            { ...COLUMN.TYPE, width: 150 },
            { ...COLUMN.DESCRIPTION, width: 280 },
          ]}
          onChange={handleMetadataChange(FIELDS_NAME.FIELDS)}
          showExpandable
          expandable={{
            expandedRowRender: (record) => (
              <div className="px-3 py-2">
                <NestedFieldEditableTable
                  dataSource={record.nestedFields as any}
                  columns={[
                    COLUMN.NAME,
                    COLUMN.ALIAS,
                    COLUMN.TYPE,
                    COLUMN.DESCRIPTION,
                  ]}
                  onChange={handleMetadataChange(FIELDS_NAME.NESTED_FIELDS)}
                />
              </div>
            ),
            rowExpandable: (record) => !!record.nestedFields,
          }}
        />
      </div>

      {!!calculatedFields.length && (
        <div className="mb-6">
          <Typography.Text className="d-block gray-7 mb-2">
            Calculated fields ({calculatedFields.length})
          </Typography.Text>
          <CalculatedFieldEditableTable
            dataSource={calculatedFields}
            columns={[
              { ...COLUMN.NAME, dataIndex: 'displayName', width: 160 },
              COLUMN.EXPRESSION,
              { ...COLUMN.DESCRIPTION, width: 280 },
            ]}
            onChange={handleMetadataChange(FIELDS_NAME.CALCULATED_FIELDS)}
          />
        </div>
      )}

      {!!relationFields.length && (
        <div className="mb-6">
          <Typography.Text className="d-block gray-7 mb-2">
            Relationships ({relationFields.length})
          </Typography.Text>
          <RelationshipEditableTable
            dataSource={relationFields}
            columns={[
              { ...COLUMN.NAME, dataIndex: 'displayName' },
              COLUMN.RELATION_FROM,
              COLUMN.RELATION_TO,
              { ...COLUMN.RELATION, width: 130 },
              { ...COLUMN.DESCRIPTION, width: 200 },
            ]}
            onChange={handleMetadataChange(FIELDS_NAME.RELATIONSHIPS)}
          />
        </div>
      )}
    </>
  );
}
</file>

<file path="src/components/pages/modeling/metadata/EditViewMetadata.tsx">
import { useContext } from 'react';
import { Typography } from 'antd';
import { NODE_TYPE } from '@/utils/enum';
import FieldTable from '@/components/table/FieldTable';
import { makeEditableBaseTable } from '@/components/table/EditableBaseTable';
import { createViewNameValidator } from '@/utils/validator';
import { COLUMN } from '@/components/table/BaseTable';
import { EditableContext } from '@/components/EditableWrapper';
import EditBasicMetadata from './EditBasicMetadata';
import { useValidateViewMutation } from '@/apollo/client/graphql/view.generated';

export interface Props {
  formNamespace: string;
  displayName: string;
  fields: any[];
  description: string;
  properties: Record<string, any>;
  nodeType: NODE_TYPE;
  viewId: number;
}

const FIELDS_NAME = {
  FIELDS: 'columns',
};

const FieldEditableTable = makeEditableBaseTable(FieldTable);

export default function EditViewMetadata(props: Props) {
  const {
    formNamespace,
    displayName,
    fields = [],
    description,
    nodeType,
    viewId,
  } = props || {};

  const form = useContext(EditableContext);

  const [validateViewMutation] = useValidateViewMutation({
    fetchPolicy: 'no-cache',
  });

  const onChange = (value) => {
    form.setFieldsValue({
      [formNamespace]: {
        ...(form.getFieldValue(formNamespace) || {}),
        ...value,
        viewId,
      },
    });
  };

  const handleMetadataChange = (fieldsName: string) => (value: any[]) => {
    // bind changeable metadata values
    // The view's columns don't have their own column IDs, so we use the referenceName
    onChange({
      [fieldsName]: value.map((item) => ({
        referenceName: item.referenceName,
        description: item.description,
      })),
    });
  };

  return (
    <>
      <EditBasicMetadata
        dataSource={{ displayName, description }}
        onChange={onChange}
        nodeType={nodeType}
        rules={{
          // View display name changing will trigger re-generate reference name
          // So we need to validate the display name
          displayName: [
            {
              required: true,
              validator: createViewNameValidator(validateViewMutation),
            },
          ],
        }}
      />

      <div className="mb-6">
        <Typography.Text className="d-block gray-7 mb-2">
          Columns ({fields.length})
        </Typography.Text>
        <FieldEditableTable
          dataSource={fields}
          columns={[
            COLUMN.NAME,
            { ...COLUMN.TYPE },
            { ...COLUMN.DESCRIPTION, width: 280 },
          ]}
          onChange={handleMetadataChange(FIELDS_NAME.FIELDS)}
        />
      </div>
    </>
  );
}
</file>

<file path="src/components/pages/modeling/metadata/ModelMetadata.tsx">
import { useMemo } from 'react';
import { keyBy } from 'lodash';
import { Col, Row, Typography, Button } from 'antd';
import FieldTable from '@/components/table/FieldTable';
import CalculatedFieldTable from '@/components/table/CalculatedFieldTable';
import RelationTable from '@/components/table/RelationTable';
import PreviewData from '@/components/dataPreview/PreviewData';
import { DiagramModel } from '@/utils/data';
import { usePreviewModelDataMutation } from '@/apollo/client/graphql/model.generated';

export type Props = DiagramModel;

export default function ModelMetadata(props: Props) {
  const {
    modelId,
    displayName,
    referenceName,
    fields = [],
    calculatedFields = [],
    relationFields = [],
    description,
  } = props || {};

  const [previewModelData, previewModelDataResult] =
    usePreviewModelDataMutation({
      onError: (error) => console.error(error),
    });

  // Model preview data should show alias as column name.
  const fieldsMap = useMemo(() => keyBy(fields, 'referenceName'), [fields]);
  const previewData = useMemo(() => {
    const previewModelData = previewModelDataResult.data?.previewModelData;
    const columns = (previewModelData?.columns || []).map((column) => {
      const alias = fieldsMap[column.name]?.displayName;
      return { ...column, name: alias || column.name };
    });
    return { ...previewModelData, columns };
  }, [fieldsMap, previewModelDataResult.data]);

  const onPreviewData = () => {
    previewModelData({ variables: { where: { id: modelId } } });
  };

  return (
    <>
      <Row className="mb-6">
        <Col span={12} data-testid="metadata__name">
          <Typography.Text className="d-block gray-7 mb-2">
            Name
          </Typography.Text>
          <div>{referenceName || '-'}</div>
        </Col>
        <Col span={12} data-testid="metadata__alias">
          <Typography.Text className="d-block gray-7 mb-2">
            Alias
          </Typography.Text>
          <div>{displayName || '-'}</div>
        </Col>
      </Row>
      <div className="mb-6" data-testid="metadata__description">
        <Typography.Text className="d-block gray-7 mb-2">
          Description
        </Typography.Text>
        <div>{description || '-'}</div>
      </div>

      <div className="mb-6" data-testid="metadata__columns">
        <Typography.Text className="d-block gray-7 mb-2">
          Columns ({fields.length})
        </Typography.Text>
        <FieldTable dataSource={fields} showExpandable />
      </div>

      {!!calculatedFields.length && (
        <div className="mb-6" data-testid="metadata__calculated-fields">
          <Typography.Text className="d-block gray-7 mb-2">
            Calculated fields ({calculatedFields.length})
          </Typography.Text>
          <CalculatedFieldTable dataSource={calculatedFields} showExpandable />
        </div>
      )}

      {!!relationFields.length && (
        <div className="mb-6" data-testid="metadata__relationships">
          <Typography.Text className="d-block gray-7 mb-2">
            Relationships ({relationFields.length})
          </Typography.Text>
          <RelationTable dataSource={relationFields} showExpandable />
        </div>
      )}

      <div className="mb-6" data-testid="metadata__preview-data">
        <Typography.Text className="d-block gray-7 mb-2">
          Data preview (100 rows)
        </Typography.Text>
        <Button
          onClick={onPreviewData}
          loading={previewModelDataResult.loading}
        >
          Preview data
        </Button>
        <div className="my-3">
          <PreviewData
            error={previewModelDataResult.error}
            loading={previewModelDataResult.loading}
            previewData={previewData}
          />
        </div>
      </div>
    </>
  );
}
</file>

<file path="src/components/pages/modeling/metadata/ViewMetadata.tsx">
import { Button, Typography } from 'antd';
import SQLCodeBlock from '@/components/code/SQLCodeBlock';
import PreviewData from '@/components/dataPreview/PreviewData';
import { COLUMN } from '@/components/table/BaseTable';
import FieldTable from '@/components/table/FieldTable';
import { DiagramView } from '@/utils/data';
import { usePreviewViewDataMutation } from '@/apollo/client/graphql/view.generated';

export type Props = DiagramView;

export default function ViewMetadata(props: Props) {
  const {
    displayName,
    description,
    fields = [],
    statement,
    viewId,
  } = props || {};

  const [previewViewData, previewViewDataResult] = usePreviewViewDataMutation({
    onError: (error) => console.error(error),
  });

  const onPreviewData = () => {
    previewViewData({ variables: { where: { id: viewId } } });
  };

  // View only can input Name (alias), so it should show alias as Name in metadata.
  return (
    <>
      <div className="mb-6" data-testid="metadata__name">
        <Typography.Text className="d-block gray-7 mb-2">Name</Typography.Text>
        <div>{displayName || '-'}</div>
      </div>

      <div className="mb-6" data-testid="metadata__description">
        <Typography.Text className="d-block gray-7 mb-2">
          Description
        </Typography.Text>
        <div>{description || '-'}</div>
      </div>

      <div className="mb-6" data-testid="metadata__columns">
        <Typography.Text className="d-block gray-7 mb-2">
          Columns ({fields.length})
        </Typography.Text>
        <FieldTable
          columns={[COLUMN.NAME, COLUMN.TYPE, COLUMN.DESCRIPTION]}
          dataSource={fields}
          showExpandable
        />
      </div>

      <div className="mb-6" data-testid="metadata__sql-statement">
        <Typography.Text className="d-block gray-7 mb-2">
          SQL statement
        </Typography.Text>
        <SQLCodeBlock code={statement} showLineNumbers maxHeight="300" />
      </div>

      <div className="mb-6" data-testid="metadata__preview-data">
        <Typography.Text className="d-block gray-7 mb-2">
          Data preview (100 rows)
        </Typography.Text>
        <Button onClick={onPreviewData} loading={previewViewDataResult.loading}>
          Preview data
        </Button>
        <div className="my-3">
          <PreviewData
            error={previewViewDataResult.error}
            loading={previewViewDataResult.loading}
            previewData={previewViewDataResult?.data?.previewViewData}
          />
        </div>
      </div>
    </>
  );
}
</file>

<file path="src/components/pages/modeling/MetadataDrawer.tsx">
import { Button, Drawer } from 'antd';
import { NODE_TYPE } from '@/utils/enum';
import EditOutlined from '@ant-design/icons/EditOutlined';
import { DrawerAction } from '@/hooks/useDrawerAction';
import ModelMetadata, {
  Props as ModelMetadataProps,
} from './metadata/ModelMetadata';
import ViewMetadata, {
  Props as ViewMetadataProps,
} from './metadata/ViewMetadata';

type Metadata = {
  nodeType: NODE_TYPE;
} & ModelMetadataProps &
  ViewMetadataProps;

type Props = DrawerAction<Metadata> & { onEditClick: (value?: any) => void };

export default function MetadataDrawer(props: Props) {
  const { visible, defaultValue, onClose, onEditClick } = props;
  const { displayName, nodeType = NODE_TYPE.MODEL } = defaultValue || {};
  const isModel = nodeType === NODE_TYPE.MODEL;
  const isView = nodeType === NODE_TYPE.VIEW;

  return (
    <Drawer
      visible={visible}
      title={displayName}
      width={760}
      closable
      destroyOnClose
      onClose={onClose}
      extra={
        <Button
          icon={<EditOutlined />}
          onClick={() => onEditClick(defaultValue)}
        >
          Edit
        </Button>
      }
    >
      {isModel && <ModelMetadata {...defaultValue} />}
      {isView && <ViewMetadata {...defaultValue} />}
    </Drawer>
  );
}
</file>

<file path="src/components/pages/modeling/ModelDrawer.tsx">
import { Button, Drawer, Form, Space } from 'antd';
import { FORM_MODE } from '@/utils/enum';
import { DrawerAction } from '@/hooks/useDrawerAction';
import ModelForm from './form/ModelForm';

type Props = DrawerAction & {
  submitting: boolean;
};

const getDrawerTitle = (formMode: FORM_MODE, name?: string) =>
  ({
    [FORM_MODE.CREATE]: 'Create a data model',
    [FORM_MODE.EDIT]: name,
  })[formMode];

export default function ModelDrawer(props: Props) {
  const { visible, formMode, defaultValue, submitting, onClose, onSubmit } =
    props;
  const [form] = Form.useForm();

  const afterVisibleChange = (visible: boolean) => {
    if (!visible) {
      form.resetFields();
    }
  };

  const submit = () => {
    form
      .validateFields()
      .then(async (values) => {
        await onSubmit({ data: values, id: defaultValue?.modelId });
        onClose();
      })
      .catch(console.error);
  };

  return (
    <Drawer
      visible={visible}
      title={getDrawerTitle(formMode, defaultValue?.displayName)}
      width={750}
      closable
      destroyOnClose
      afterVisibleChange={afterVisibleChange}
      onClose={onClose}
      footer={
        <Space className="d-flex justify-end">
          <Button onClick={onClose} disabled={submitting}>
            Cancel
          </Button>
          <Button
            type="primary"
            onClick={submit}
            loading={submitting}
            disabled={submitting}
          >
            Submit
          </Button>
        </Space>
      }
    >
      <ModelForm formMode={formMode} form={form} defaultValue={defaultValue} />
    </Drawer>
  );
}
</file>

<file path="src/components/pages/setup/ButtonItem.tsx">
import Image from 'next/image';
import { Button } from 'antd';
import styled from 'styled-components';
import Icon from '@/import/icon';
import { IterableComponent } from '@/utils/iteration';
import { ButtonOption } from './utils';
import { SampleDatasetName } from '@/apollo/client/graphql/__types__';

const StyledButton = styled(Button)`
  border: 2px var(--gray-4) solid;
  background-color: var(--gray-2);
  border-radius: 4px;
  width: 100%;
  height: auto;

  &:focus {
    border: 2px var(--gray-4) solid;
    background-color: var(--gray-2);
  }

  &:hover {
    border-color: var(--geekblue-6);
    background-color: var(--gray-2);
  }

  &.is-active {
    border-color: var(--geekblue-6) !important;
    background-color: var(--gray-2) !important;
  }

  &:disabled {
    opacity: 0.5;
  }

  // loading of button
  .ant-btn-loading-icon .anticon {
    font-size: 24px;
  }
`;

const StyledIcon = styled(Icon)`
  width: 40px;
  height: 40px;
  font-size: 32px;
  display: inline-flex;
  justify-content: center;
  align-items: center;
`;

const PlainImage = styled.div`
  border: 1px var(--gray-4) solid;
  background-color: white;
  width: 40px;
  height: 40px;
`;

const ComingSoon = styled.div`
  border: 1px var(--gray-7) solid;
  color: var(--gray-7);
  font-size: 8px;
  padding: 2px 6px;
  border-radius: 999px;
  &:before {
    content: 'COMING SOON';
  }
`;

type Props = ButtonOption & {
  selectedTemplate: SampleDatasetName;
  onSelect: (value: string) => void;
};

export default function ButtonItem(props: IterableComponent<Props>) {
  const {
    value,
    disabled,
    submitting,
    logo,
    IconComponent,
    label,
    onSelect,
    selectedTemplate,
  } = props;

  const isSelected = selectedTemplate === value;
  const loading = isSelected && submitting;

  return (
    <StyledButton
      className={[
        'px-4 py-2 gray-8 d-flex align-center',
        loading ? 'flex-start' : 'justify-space-between',
        isSelected ? 'is-active' : '',
      ].join(' ')}
      disabled={disabled || submitting}
      loading={loading}
      onClick={() => onSelect(value)}
    >
      <div className="d-flex align-center" style={{ width: '100%' }}>
        {logo ? (
          <Image
            className="mr-2"
            src={logo}
            alt={label}
            width="40"
            height="40"
          />
        ) : IconComponent ? (
          <StyledIcon component={IconComponent} className="mr-2" />
        ) : (
          <PlainImage className="mr-2" />
        )}
        {label}
      </div>
      {disabled && <ComingSoon />}
    </StyledButton>
  );
}
</file>

<file path="src/components/pages/setup/ConnectDataSource.tsx">
import Image from 'next/image';
import Link from 'next/link';
import { Alert, Typography, Form, Row, Col, Button } from 'antd';
import styled from 'styled-components';
import { DATA_SOURCES } from '@/utils/enum/dataSources';
import { getDataSource, getPostgresErrorMessage } from './utils';

const StyledForm = styled(Form)`
  border: 1px var(--gray-4) solid;
  border-radius: 4px;
`;

const DataSource = styled.div`
  border: 1px var(--gray-4) solid;
  border-radius: 4px;
`;

interface Props {
  dataSource: DATA_SOURCES;
  onNext: (data: any) => void;
  onBack: () => void;
  submitting: boolean;
  connectError?: Record<string, any>;
}

export default function ConnectDataSource(props: Props) {
  const { connectError, dataSource, submitting, onNext, onBack } = props;
  const [form] = Form.useForm();
  const current = getDataSource(dataSource);

  const submit = () => {
    form
      .validateFields()
      .then((values) => {
        onNext && onNext({ properties: values });
      })
      .catch((error) => {
        console.error(error);
      });
  };

  return (
    <>
      <Typography.Title level={1} className="mb-3">
        Connect the data source
      </Typography.Title>
      <Typography.Text>
        Vote for your favorite data sources on{' '}
        <Link
          href="https://github.com/Canner/WrenAI/discussions/327"
          target="_blank"
          rel="noopener noreferrer"
        >
          GitHub
        </Link>
        .
      </Typography.Text>

      <StyledForm form={form} layout="vertical" className="p-6 my-6">
        <Row align="middle" className="mb-6">
          <Col span={12}>
            <DataSource className="d-inline-block px-4 py-2 bg-gray-2 gray-8">
              <Image
                className="mr-2"
                src={current.logo}
                alt={dataSource}
                width="40"
                height="40"
              />
              {current.label}
            </DataSource>
          </Col>
          <Col className="text-right" span={12}>
            Learn more information in the {current.label}{' '}
            <Link
              href={current.guide}
              target="_blank"
              rel="noopener noreferrer"
            >
              setup guide
            </Link>
            .
          </Col>
        </Row>
        <current.component />
      </StyledForm>

      {connectError && (
        <Alert
          message={connectError.shortMessage}
          description={
            dataSource === DATA_SOURCES.POSTGRES
              ? getPostgresErrorMessage(connectError)
              : connectError.message
          }
          type="error"
          showIcon
          className="my-6"
        />
      )}

      <Row gutter={16} className="pt-6">
        <Col span={12}>
          <Button
            onClick={onBack}
            size="large"
            className="adm-onboarding-btn"
            disabled={submitting}
          >
            Back
          </Button>
        </Col>
        <Col className="text-right" span={12}>
          <Button
            type="primary"
            size="large"
            onClick={submit}
            loading={submitting}
            className="adm-onboarding-btn"
          >
            Next
          </Button>
        </Col>
      </Row>
    </>
  );
}
</file>

<file path="src/components/pages/setup/ContainerCard.tsx">
import styled from 'styled-components';
import { Card, Steps } from 'antd';

const Container = styled.div<{ maxWidth?: number }>`
  max-width: ${(props) => props.maxWidth || 1200}px;
  margin: 68px auto;
`;

interface Props {
  step: number;
  children: React.ReactNode;
  maxWidth?: number;
}

export default function ContainerCard(props: Props) {
  const { step, maxWidth } = props;

  return (
    <Container maxWidth={maxWidth}>
      <Card>
        <Steps current={step} className="mb-12">
          <Steps.Step title="Connect" />
          <Steps.Step title="Select Tables" />
          <Steps.Step title="Define Relationships" />
        </Steps>
        <div className="px-12 pb-6">{props.children}</div>
      </Card>
    </Container>
  );
}
</file>

<file path="src/components/pages/setup/dataSources/AthenaProperties.tsx">
import { Form, Input } from 'antd';
import { FORM_MODE } from '@/utils/enum';
import { ERROR_TEXTS } from '@/utils/error';

interface Props {
  mode?: FORM_MODE;
}

export default function AthenaProperties(props: Props) {
  const { mode } = props;
  const isEditMode = mode === FORM_MODE.EDIT;
  return (
    <>
      <Form.Item
        label="Display name"
        name="displayName"
        required
        rules={[
          {
            required: true,
            message: ERROR_TEXTS.CONNECTION.DISPLAY_NAME.REQUIRED,
          },
        ]}
      >
        <Input />
      </Form.Item>
      <Form.Item
        label="Database (schema)"
        name="schema"
        extra="The Athena database (also called schema) that contains the tables you want to query."
        required
        rules={[
          {
            required: true,
            message: ERROR_TEXTS.CONNECTION.DATABASE.REQUIRED,
          },
        ]}
      >
        <Input disabled={isEditMode} />
      </Form.Item>
      <Form.Item
        label="S3 staging directory"
        name="s3StagingDir"
        required
        extra={
          <>
            The S3 path where Athena stores query results and metadata.
            <br />
            You can find this in the Athena console under{' '}
            <b>Settings {'>'} Query result location</b>.
          </>
        }
        rules={[
          {
            required: true,
            message: ERROR_TEXTS.CONNECTION.S3_STAGING_DIR.REQUIRED,
          },
        ]}
      >
        <Input placeholder="s3://bucket/path" />
      </Form.Item>
      <Form.Item
        label="AWS region"
        name="awsRegion"
        required
        rules={[
          {
            required: true,
            message: ERROR_TEXTS.CONNECTION.AWS_REGION.REQUIRED,
          },
        ]}
      >
        <Input placeholder="us-east-1" disabled={isEditMode} />
      </Form.Item>
      <Form.Item
        label="AWS access key ID"
        name="awsAccessKey"
        required
        rules={[
          {
            required: true,
            message: ERROR_TEXTS.CONNECTION.AWS_ACCESS_KEY.REQUIRED,
          },
        ]}
      >
        <Input />
      </Form.Item>
      <Form.Item
        label="AWS secret access key"
        name="awsSecretKey"
        required
        rules={[
          {
            required: true,
            message: ERROR_TEXTS.CONNECTION.AWS_SECRET_KEY.REQUIRED,
          },
        ]}
      >
        <Input.Password />
      </Form.Item>
    </>
  );
}
</file>

<file path="src/components/pages/setup/dataSources/BigQueryProperties.tsx">
import { useEffect, useState } from 'react';
import { Form, Input, Button, Upload } from 'antd';
import UploadOutlined from '@ant-design/icons/UploadOutlined';
import { UploadFile } from 'antd/lib/upload/interface';
import { ERROR_TEXTS } from '@/utils/error';
import { FORM_MODE } from '@/utils/enum';

interface Props {
  mode?: FORM_MODE;
}

const UploadCredentials = (props) => {
  const { onChange, value } = props;

  const [fileList, setFileList] = useState<UploadFile[]>([]);

  useEffect(() => {
    if (!value) setFileList([]);
  }, [value]);

  const convertFileToJSON = (file: any, callback: (value: JSON) => void) => {
    const reader = new FileReader();
    reader.onloadend = (_e) => {
      const result = reader.result;

      if (result) {
        const fileContent: JSON = JSON.parse(String(result));
        callback(fileContent);
      }
    };

    reader.readAsText(file);
  };

  const onUploadChange = (info) => {
    const { file, fileList } = info;
    if (fileList.length) {
      const uploadFile = fileList[0];
      convertFileToJSON(file.originFileObj, (fileContent: JSON) => {
        onChange && onChange(fileContent);
      });
      setFileList([uploadFile]);
    }
  };

  const onRemove = () => {
    setFileList([]);
    onChange && onChange(undefined);
  };

  return (
    <Upload
      accept=".json"
      fileList={fileList}
      onChange={onUploadChange}
      onRemove={onRemove}
      maxCount={1}
    >
      <Button icon={<UploadOutlined />}>Click to upload JSON key file</Button>
    </Upload>
  );
};

export default function BigQueryProperties(props: Props) {
  const { mode } = props;
  const isEditMode = mode === FORM_MODE.EDIT;

  return (
    <>
      <Form.Item
        label="Display name"
        required
        name="displayName"
        rules={[
          {
            required: true,
            message: ERROR_TEXTS.CONNECTION.DISPLAY_NAME.REQUIRED,
          },
        ]}
      >
        <Input placeholder="Our BigQuery" />
      </Form.Item>
      <Form.Item
        label="Project ID"
        required
        name="projectId"
        rules={[
          {
            required: !isEditMode,
            message: ERROR_TEXTS.CONNECTION.PROJECT_ID.REQUIRED,
          },
        ]}
      >
        <Input placeholder="The GCP project ID" disabled={isEditMode} />
      </Form.Item>
      <Form.Item
        label="Dataset ID"
        required
        name="datasetId"
        rules={[
          {
            required: !isEditMode,
            message: ERROR_TEXTS.CONNECTION.DATASET_ID.REQUIRED,
          },
        ]}
      >
        <Input disabled={isEditMode} />
      </Form.Item>
      <Form.Item
        label="Credentials"
        required={!isEditMode}
        name="credentials"
        rules={[
          {
            required: !isEditMode,
            message: ERROR_TEXTS.CONNECTION.CREDENTIAL.REQUIRED,
          },
        ]}
      >
        <UploadCredentials />
      </Form.Item>
    </>
  );
}
</file>

<file path="src/components/pages/setup/dataSources/ClickHouseProperties.tsx">
import { Form, Input, Switch } from 'antd';
import { ERROR_TEXTS } from '@/utils/error';
import { FORM_MODE } from '@/utils/enum';
import { hostValidator } from '@/utils/validator';

interface Props {
  mode?: FORM_MODE;
}

export default function ClickHouseProperties(props: Props) {
  const { mode } = props;
  const isEditMode = mode === FORM_MODE.EDIT;
  return (
    <>
      <Form.Item
        label="Display name"
        name="displayName"
        required
        rules={[
          {
            required: true,
            message: ERROR_TEXTS.CONNECTION.DISPLAY_NAME.REQUIRED,
          },
        ]}
      >
        <Input />
      </Form.Item>
      <Form.Item
        label="Host"
        name="host"
        required
        rules={[
          {
            required: true,
            validator: hostValidator,
          },
        ]}
      >
        <Input
          placeholder="<your_click_house_account>.clickhouse.cloud"
          disabled={isEditMode}
        />
      </Form.Item>
      <Form.Item
        label="Port"
        name="port"
        required
        rules={[
          {
            required: true,
            message: ERROR_TEXTS.CONNECTION.PORT.REQUIRED,
          },
        ]}
      >
        <Input placeholder="8443" disabled={isEditMode} />
      </Form.Item>
      <Form.Item
        label="Username"
        name="user"
        rules={[
          {
            required: true,
            message: ERROR_TEXTS.CONNECTION.USERNAME.REQUIRED,
          },
        ]}
      >
        <Input />
      </Form.Item>
      <Form.Item
        label="Password"
        name="password"
        required
        rules={[
          {
            required: true,
            message: ERROR_TEXTS.CONNECTION.PASSWORD.REQUIRED,
          },
        ]}
      >
        <Input.Password placeholder="input password" />
      </Form.Item>
      <Form.Item
        label="Database name"
        name="database"
        required
        rules={[
          {
            required: true,
            message: ERROR_TEXTS.CONNECTION.DATABASE.REQUIRED,
          },
        ]}
      >
        <Input placeholder="ClickHouse database name" disabled={isEditMode} />
      </Form.Item>
      <Form.Item label="Use SSL" name="ssl" valuePropName="checked">
        <Switch />
      </Form.Item>
    </>
  );
}
</file>

<file path="src/components/pages/setup/dataSources/DuckDBProperties.tsx">
import Link from 'next/link';
import { Col, Form, Input, Button, Row } from 'antd';
import { ERROR_TEXTS } from '@/utils/error';
import DeleteOutlined from '@ant-design/icons/DeleteOutlined';
import PlusOutlined from '@ant-design/icons/PlusOutlined';

const { TextArea } = Input;

export default function DuckDBProperties() {
  return (
    <>
      <Form.Item
        label="Display name"
        name="displayName"
        rules={[
          {
            required: true,
            message: ERROR_TEXTS.CONNECTION.DISPLAY_NAME.REQUIRED,
          },
        ]}
      >
        <Input placeholder="DuckDB" />
      </Form.Item>
      <Form.Item
        label="Initial SQL statements"
        name="initSql"
        extra="These statements are meant to be executed only once during initialization."
        rules={[
          {
            required: true,
            message: ERROR_TEXTS.CONNECTION.INIT_SQL.REQUIRED,
          },
        ]}
      >
        <TextArea
          placeholder="CREATE TABLE new_tbl AS SELECT * FROM read_csv('input.csv');"
          rows={4}
        />
      </Form.Item>

      <Form.Item
        label="Configuration options"
        extra={
          <>
            DuckDB offers various configuration options that can modify the
            system's behavior.{' '}
            <Link
              href="https://duckdb.org/docs/configuration/overview.html"
              target="_blank"
              rel="noopener noreferrer"
            >
              Learn more
            </Link>
          </>
        }
      >
        <Form.List name="configurations" initialValue={[{}]}>
          {(fields, { add, remove }) => (
            <>
              {fields.map(({ key, name, ...restField }) => (
                <Row key={key} wrap={false} gutter={8}>
                  <Col flex="1 0">
                    <Form.Item
                      {...restField}
                      name={[name, 'key']}
                      style={{ width: '100%' }}
                      rules={[
                        ({ getFieldValue }) => ({
                          validator(_, value) {
                            if (
                              getFieldValue(['configurations', name, 'value'])
                            ) {
                              if (!value) {
                                return Promise.reject(
                                  ERROR_TEXTS.CONNECTION.CONFIGURATION.KEY
                                    .REQUIRED,
                                );
                              }
                            }

                            return Promise.resolve();
                          },
                        }),
                      ]}
                    >
                      <Input placeholder="Key" />
                    </Form.Item>
                  </Col>
                  <Col flex="1 0">
                    <Form.Item
                      {...restField}
                      name={[name, 'value']}
                      style={{ width: '100%' }}
                      rules={[
                        ({ getFieldValue }) => ({
                          validator(_, value) {
                            if (
                              getFieldValue(['configurations', name, 'key'])
                            ) {
                              if (!value) {
                                return Promise.reject(
                                  ERROR_TEXTS.CONNECTION.CONFIGURATION.VALUE
                                    .REQUIRED,
                                );
                              }
                            }

                            return Promise.resolve();
                          },
                        }),
                      ]}
                    >
                      <Input placeholder="Value" />
                    </Form.Item>
                  </Col>
                  <Col flex="none" className="p-1">
                    <DeleteOutlined onClick={() => remove(name)} />
                  </Col>
                </Row>
              ))}
              <Form.Item noStyle>
                <Button
                  type="dashed"
                  onClick={() => add()}
                  block
                  icon={<PlusOutlined />}
                >
                  Add an option
                </Button>
              </Form.Item>
            </>
          )}
        </Form.List>
      </Form.Item>
      <Form.Item
        label="Extensions"
        extra={
          <>
            DuckDB has an extension mechanism that enables the dynamic loading
            of extensions.{' '}
            <Link
              href="https://duckdb.org/docs/extensions/overview.html"
              target="_blank"
              rel="noopener noreferrer"
            >
              Learn more
            </Link>
          </>
        }
      >
        <Form.List name="extensions" initialValue={['']}>
          {(fields, { add, remove }) => (
            <>
              {fields.map(({ key, name, ...restField }) => (
                <Row key={key} wrap={false} gutter={8} className="my-2">
                  <Col flex="1 0">
                    <Form.Item
                      {...restField}
                      name={name}
                      noStyle
                      style={{ width: '100%' }}
                    >
                      <Input placeholder="Extension name" />
                    </Form.Item>
                  </Col>
                  <Col flex="none" className="p-1">
                    <DeleteOutlined onClick={() => remove(name)} />
                  </Col>
                </Row>
              ))}
              <Form.Item noStyle>
                <Button
                  type="dashed"
                  onClick={() => add()}
                  block
                  icon={<PlusOutlined />}
                >
                  Add an extension
                </Button>
              </Form.Item>
            </>
          )}
        </Form.List>
      </Form.Item>
    </>
  );
}
</file>

<file path="src/components/pages/setup/dataSources/MySQLProperties.tsx">
import { Form, Input, Switch } from 'antd';
import { ERROR_TEXTS } from '@/utils/error';
import { FORM_MODE } from '@/utils/enum';
import { hostValidator } from '@/utils/validator';

interface Props {
  mode?: FORM_MODE;
}

export default function MySQLProperties(props: Props) {
  const { mode } = props;
  const isEditMode = mode === FORM_MODE.EDIT;
  return (
    <>
      <Form.Item
        label="Display name"
        name="displayName"
        required
        rules={[
          {
            required: true,
            message: ERROR_TEXTS.CONNECTION.DISPLAY_NAME.REQUIRED,
          },
        ]}
      >
        <Input />
      </Form.Item>
      <Form.Item
        label="Host"
        name="host"
        required
        rules={[
          {
            required: true,
            validator: hostValidator,
          },
        ]}
      >
        <Input placeholder="10.1.1.1" disabled={isEditMode} />
      </Form.Item>
      <Form.Item
        label="Port"
        name="port"
        required
        rules={[
          {
            required: true,
            message: ERROR_TEXTS.CONNECTION.PORT.REQUIRED,
          },
        ]}
      >
        <Input placeholder="3306" disabled={isEditMode} />
      </Form.Item>
      <Form.Item
        label="Username"
        name="user"
        rules={[
          {
            required: true,
            message: ERROR_TEXTS.CONNECTION.USERNAME.REQUIRED,
          },
        ]}
      >
        <Input />
      </Form.Item>
      <Form.Item label="Password" name="password">
        <Input.Password placeholder="input password" />
      </Form.Item>
      <Form.Item
        label="Database name"
        name="database"
        required
        rules={[
          {
            required: true,
            message: ERROR_TEXTS.CONNECTION.DATABASE.REQUIRED,
          },
        ]}
      >
        <Input placeholder="MySQL database name" disabled={isEditMode} />
      </Form.Item>
      <Form.Item label="Use SSL" name="ssl" valuePropName="checked">
        <Switch />
      </Form.Item>
    </>
  );
}
</file>

<file path="src/components/pages/setup/dataSources/OracleProperties.tsx">
import { Form, Input } from 'antd';
import { ERROR_TEXTS } from '@/utils/error';
import { FORM_MODE } from '@/utils/enum';
import { hostValidator } from '@/utils/validator';

interface Props {
  mode?: FORM_MODE;
}

export default function OracleProperties(props: Props) {
  const { mode } = props;
  const isEditMode = mode === FORM_MODE.EDIT;
  return (
    <>
      <Form.Item
        label="Display name"
        name="displayName"
        required
        rules={[
          {
            required: true,
            message: ERROR_TEXTS.CONNECTION.DISPLAY_NAME.REQUIRED,
          },
        ]}
      >
        <Input />
      </Form.Item>
      <Form.Item
        label="Host"
        name="host"
        rules={[
          {
            required: false,
            validator: (_, value) => {
              if (value) {
                return hostValidator(_, value);
              }
              return Promise.resolve();
            },
          },
        ]}
      >
        <Input placeholder="10.1.1.1" disabled={isEditMode} />
      </Form.Item>
      <Form.Item
        label="Port"
        name="port"
        rules={[
          {
            message: ERROR_TEXTS.CONNECTION.PORT.REQUIRED,
          },
        ]}
      >
        <Input placeholder="1521" disabled={isEditMode} />
      </Form.Item>
      <Form.Item
        label="Username"
        name="user"
        rules={[
          {
            required: true,
            message: ERROR_TEXTS.CONNECTION.USERNAME.REQUIRED,
          },
        ]}
      >
        <Input />
      </Form.Item>
      <Form.Item
        label="Password"
        name="password"
        required
        rules={[
          {
            required: true,
            message: ERROR_TEXTS.CONNECTION.PASSWORD.REQUIRED,
          },
        ]}
      >
        <Input.Password placeholder="input password" />
      </Form.Item>
      <Form.Item
        label="Database name"
        name="database"
        rules={[
          {
            message: ERROR_TEXTS.CONNECTION.DATABASE.REQUIRED,
          },
        ]}
      >
        <Input placeholder="Oracle database name" disabled={isEditMode} />
      </Form.Item>
      <Form.Item
        label="DSN"
        name="dsn"
        tooltip="Oracle Data Source Name (DSN) - Alternative to host/port/database configuration"
      >
        <Input placeholder="(DESCRIPTION=(ADDRESS=(PROTOCOL=TCP)(HOST=host)(PORT=port))(CONNECT_DATA=(SERVICE_NAME=service)))" />
      </Form.Item>
    </>
  );
}
</file>

<file path="src/components/pages/setup/dataSources/PostgreSQLProperties.tsx">
import { Form, Input, Switch } from 'antd';
import { ERROR_TEXTS } from '@/utils/error';
import { FORM_MODE } from '@/utils/enum';
import { hostValidator } from '@/utils/validator';

interface Props {
  mode?: FORM_MODE;
}

export default function PostgreSQLProperties(props: Props) {
  const { mode } = props;
  const isEditMode = mode === FORM_MODE.EDIT;
  return (
    <>
      <Form.Item
        label="Display name"
        name="displayName"
        required
        rules={[
          {
            required: true,
            message: ERROR_TEXTS.CONNECTION.DISPLAY_NAME.REQUIRED,
          },
        ]}
      >
        <Input />
      </Form.Item>
      <Form.Item
        label="Host"
        name="host"
        required
        rules={[
          {
            required: true,
            validator: hostValidator,
          },
        ]}
      >
        <Input placeholder="10.1.1.1" disabled={isEditMode} />
      </Form.Item>
      <Form.Item
        label="Port"
        name="port"
        required
        rules={[
          {
            required: true,
            message: ERROR_TEXTS.CONNECTION.PORT.REQUIRED,
          },
        ]}
      >
        <Input placeholder="5432" disabled={isEditMode} />
      </Form.Item>
      <Form.Item
        label="Username"
        name="user"
        rules={[
          {
            required: true,
            message: ERROR_TEXTS.CONNECTION.USERNAME.REQUIRED,
          },
        ]}
      >
        <Input />
      </Form.Item>
      <Form.Item
        label="Password"
        name="password"
        required
        rules={[
          {
            required: true,
            message: ERROR_TEXTS.CONNECTION.PASSWORD.REQUIRED,
          },
        ]}
      >
        <Input.Password placeholder="input password" />
      </Form.Item>
      <Form.Item
        label="Database name"
        name="database"
        required
        rules={[
          {
            required: true,
            message: ERROR_TEXTS.CONNECTION.DATABASE.REQUIRED,
          },
        ]}
      >
        <Input placeholder="PostgreSQL database name" disabled={isEditMode} />
      </Form.Item>
      <Form.Item label="Use SSL" name="ssl" valuePropName="checked">
        <Switch />
      </Form.Item>
    </>
  );
}
</file>

<file path="src/components/pages/setup/dataSources/RedshiftProperties.tsx">
import { useEffect, useRef } from 'react';
import { Form, Input, Radio } from 'antd';
import { FORM_MODE, REDSHIFT_AUTH_METHOD } from '@/utils/enum';
import { ERROR_TEXTS } from '@/utils/error';
import { hostValidator } from '@/utils/validator';

interface Props {
  mode?: FORM_MODE;
}

function RedshiftPasswordFields(props: { isEditMode: boolean }) {
  const { isEditMode } = props;
  return (
    <>
      <Form.Item
        label="Host"
        name="host"
        required
        rules={[
          {
            required: true,
            validator: hostValidator,
          },
        ]}
      >
        <Input
          placeholder="mycluster.cmeaswqeuae.us-east-2.redshift.amazonaws.com"
          disabled={isEditMode}
        />
      </Form.Item>
      <Form.Item
        label="Port"
        name="port"
        required
        rules={[
          {
            required: true,
            message: ERROR_TEXTS.CONNECTION.PORT.REQUIRED,
          },
        ]}
      >
        <Input placeholder="5439" />
      </Form.Item>
      <Form.Item
        label="Username"
        name="user"
        rules={[
          {
            required: true,
            message: ERROR_TEXTS.CONNECTION.USERNAME.REQUIRED,
          },
        ]}
      >
        <Input />
      </Form.Item>
      <Form.Item
        label="Password"
        name="password"
        required
        rules={[
          {
            required: true,
            message: ERROR_TEXTS.CONNECTION.PASSWORD.REQUIRED,
          },
        ]}
      >
        <Input.Password placeholder="input password" />
      </Form.Item>
      <Form.Item
        label="Database"
        name="database"
        required
        rules={[
          {
            required: true,
            message: ERROR_TEXTS.CONNECTION.DATABASE.REQUIRED,
          },
        ]}
      >
        <Input disabled={isEditMode} />
      </Form.Item>
    </>
  );
}

function RedshiftIAMFields(props: { isEditMode: boolean }) {
  const { isEditMode } = props;
  return (
    <>
      <Form.Item
        label="Cluster identifier"
        name="clusterIdentifier"
        required
        rules={[
          {
            required: true,
            message: ERROR_TEXTS.CONNECTION.CLUSTER_IDENTIFIER.REQUIRED,
          },
        ]}
      >
        <Input placeholder="redshift-cluster-1" disabled={isEditMode} />
      </Form.Item>
      <Form.Item
        label="Username"
        name="user"
        extra="The Redshift database username specified in DB user permissions."
        rules={[
          {
            required: true,
            message: ERROR_TEXTS.CONNECTION.USERNAME.REQUIRED,
          },
        ]}
      >
        <Input />
      </Form.Item>
      <Form.Item
        label="Database"
        name="database"
        required
        rules={[
          {
            required: true,
            message: ERROR_TEXTS.CONNECTION.DATABASE.REQUIRED,
          },
        ]}
      >
        <Input disabled={isEditMode} />
      </Form.Item>
      <Form.Item
        label="AWS region"
        name="awsRegion"
        required
        rules={[
          {
            required: true,
            message: ERROR_TEXTS.CONNECTION.AWS_REGION.REQUIRED,
          },
        ]}
      >
        <Input placeholder="us-east-1" disabled={isEditMode} />
      </Form.Item>
      <Form.Item
        label="AWS access key ID"
        name="awsAccessKey"
        required
        rules={[
          {
            required: true,
            message: ERROR_TEXTS.CONNECTION.AWS_ACCESS_KEY.REQUIRED,
          },
        ]}
      >
        <Input />
      </Form.Item>
      <Form.Item
        label="AWS secret access key"
        name="awsSecretKey"
        required
        rules={[
          {
            required: true,
            message: ERROR_TEXTS.CONNECTION.AWS_SECRET_KEY.REQUIRED,
          },
        ]}
      >
        <Input.Password />
      </Form.Item>
    </>
  );
}

export default function RedshiftProperties(props: Props) {
  const { mode } = props;
  const isEditMode = mode === FORM_MODE.EDIT;

  const initialRedshiftTypeRef = useRef<REDSHIFT_AUTH_METHOD | null>(null);

  const form = Form.useFormInstance();
  const redshiftType = Form.useWatch(
    'redshiftType',
    form,
  ) as REDSHIFT_AUTH_METHOD;

  useEffect(() => {
    if (!isEditMode) {
      form.setFieldsValue({
        redshiftType: REDSHIFT_AUTH_METHOD.redshift,
      });
    }
  }, [isEditMode, form]);

  useEffect(() => {
    if (isEditMode && redshiftType && initialRedshiftTypeRef.current === null) {
      initialRedshiftTypeRef.current = redshiftType;
    }
  }, [isEditMode, redshiftType]);

  const getIsEditModeForComponent = (componentType: REDSHIFT_AUTH_METHOD) => {
    if (!isEditMode) return false;

    const initialType = initialRedshiftTypeRef.current || redshiftType;
    return initialType === componentType;
  };

  return (
    <>
      <Form.Item
        label="Display name"
        name="displayName"
        required
        rules={[
          {
            required: true,
            message: ERROR_TEXTS.CONNECTION.DISPLAY_NAME.REQUIRED,
          },
        ]}
      >
        <Input />
      </Form.Item>
      <Form.Item label="Authentication method" name="redshiftType">
        <Radio.Group buttonStyle="solid">
          <Radio.Button value={REDSHIFT_AUTH_METHOD.redshift}>
            Username and password
          </Radio.Button>
          <Radio.Button value={REDSHIFT_AUTH_METHOD.redshift_iam}>
            AWS credentials
          </Radio.Button>
        </Radio.Group>
      </Form.Item>
      {redshiftType === REDSHIFT_AUTH_METHOD.redshift && (
        <RedshiftPasswordFields
          isEditMode={getIsEditModeForComponent(REDSHIFT_AUTH_METHOD.redshift)}
        />
      )}
      {redshiftType === REDSHIFT_AUTH_METHOD.redshift_iam && (
        <RedshiftIAMFields
          isEditMode={getIsEditModeForComponent(
            REDSHIFT_AUTH_METHOD.redshift_iam,
          )}
        />
      )}
    </>
  );
}
</file>

<file path="src/components/pages/setup/dataSources/SnowflakeProperties.tsx">
import { Form, Input } from 'antd';
import { ERROR_TEXTS } from '@/utils/error';
import { FORM_MODE } from '@/utils/enum';

interface Props {
  mode?: FORM_MODE;
}

export default function SnowflakeProperties(props: Props) {
  const { mode } = props;
  const isEditMode = mode === FORM_MODE.EDIT;
  return (
    <>
      <Form.Item
        label="Display name"
        name="displayName"
        required
        rules={[
          {
            required: true,
            message: ERROR_TEXTS.CONNECTION.DISPLAY_NAME.REQUIRED,
          },
        ]}
      >
        <Input />
      </Form.Item>
      <Form.Item
        label="Username"
        name="user"
        rules={[
          {
            required: true,
            message: ERROR_TEXTS.CONNECTION.USERNAME.REQUIRED,
          },
        ]}
      >
        <Input />
      </Form.Item>
      <Form.Item
        label="Password"
        name="password"
        required
        rules={[
          {
            required: true,
            message: ERROR_TEXTS.CONNECTION.PASSWORD.REQUIRED,
          },
        ]}
      >
        <Input.Password placeholder="input password" />
      </Form.Item>
      <Form.Item
        label="Account"
        name="account"
        required
        rules={[
          {
            required: true,
            message: ERROR_TEXTS.CONNECTION.ACCOUNT.REQUIRED,
          },
        ]}
      >
        <Input
          placeholder="<snowflake_org_id>-<snowflake_user_id>"
          disabled={isEditMode}
        />
      </Form.Item>
      <Form.Item
        label="Database name"
        name="database"
        required
        rules={[
          {
            required: true,
            message: ERROR_TEXTS.CONNECTION.DATABASE.REQUIRED,
          },
        ]}
      >
        <Input placeholder="Snowflake database name" disabled={isEditMode} />
      </Form.Item>
      <Form.Item
        label="Schema"
        name="schema"
        required
        rules={[
          {
            required: true,
            message: ERROR_TEXTS.CONNECTION.SCHEMA.REQUIRED,
          },
        ]}
      >
        <Input />
      </Form.Item>
    </>
  );
}
</file>

<file path="src/components/pages/setup/dataSources/SQLServerProperties.tsx">
import { Form, Input, Switch } from 'antd';
import { ERROR_TEXTS } from '@/utils/error';
import { FORM_MODE } from '@/utils/enum';
import { hostValidator } from '@/utils/validator';

interface Props {
  mode?: FORM_MODE;
}

export default function SQLServerProperties(props: Props) {
  const { mode } = props;
  const isEditMode = mode === FORM_MODE.EDIT;
  return (
    <>
      <Form.Item
        label="Display name"
        name="displayName"
        required
        rules={[
          {
            required: true,
            message: ERROR_TEXTS.CONNECTION.DISPLAY_NAME.REQUIRED,
          },
        ]}
      >
        <Input />
      </Form.Item>
      <Form.Item
        label="Host"
        name="host"
        required
        rules={[
          {
            required: true,
            validator: hostValidator,
          },
        ]}
      >
        <Input placeholder="10.1.1.1" disabled={isEditMode} />
      </Form.Item>
      <Form.Item
        label="Port"
        name="port"
        required
        rules={[
          {
            required: true,
            message: ERROR_TEXTS.CONNECTION.PORT.REQUIRED,
          },
        ]}
      >
        <Input placeholder="1433" disabled={isEditMode} />
      </Form.Item>
      <Form.Item
        label="Username"
        name="user"
        rules={[
          {
            required: true,
            message: ERROR_TEXTS.CONNECTION.USERNAME.REQUIRED,
          },
        ]}
      >
        <Input />
      </Form.Item>
      <Form.Item
        label="Password"
        name="password"
        required
        rules={[
          {
            required: true,
            message: ERROR_TEXTS.CONNECTION.PASSWORD.REQUIRED,
          },
        ]}
      >
        <Input.Password placeholder="input password" />
      </Form.Item>
      <Form.Item
        label="Database name"
        name="database"
        required
        rules={[
          {
            required: true,
            message: ERROR_TEXTS.CONNECTION.DATABASE.REQUIRED,
          },
        ]}
      >
        <Input placeholder="SQL Server database name" disabled={isEditMode} />
      </Form.Item>
      <Form.Item
        extra="This parameter is used to skip server certificate validation. If you are using a trusted certificate, you can disable it."
        label="Enable Trust Server Certificate"
        name="trustServerCertificate"
        valuePropName="checked"
        initialValue={true}
      >
        <Switch />
      </Form.Item>
    </>
  );
}
</file>

<file path="src/components/pages/setup/dataSources/TrinoProperties.tsx">
import { Form, Input, Switch } from 'antd';
import { ERROR_TEXTS } from '@/utils/error';
import { FORM_MODE } from '@/utils/enum';
import { hostValidator } from '@/utils/validator';

interface Props {
  mode?: FORM_MODE;
}

export default function TrinoProperties({ mode }: Props) {
  const isEditMode = mode === FORM_MODE.EDIT;
  return (
    <>
      <Form.Item
        label="Display name"
        name="displayName"
        required
        rules={[
          {
            required: true,
            message: ERROR_TEXTS.CONNECTION.DISPLAY_NAME.REQUIRED,
          },
        ]}
      >
        <Input />
      </Form.Item>
      <Form.Item
        label="Host"
        name="host"
        required
        rules={[
          {
            required: true,
            validator: hostValidator,
          },
        ]}
      >
        <Input placeholder="10.1.1.1" disabled={isEditMode} />
      </Form.Item>
      <Form.Item
        label="Port"
        name="port"
        required
        rules={[
          {
            required: true,
            message: ERROR_TEXTS.CONNECTION.PORT.REQUIRED,
          },
        ]}
      >
        <Input disabled={isEditMode} />
      </Form.Item>
      <Form.Item
        label="Schemas"
        name="schemas"
        required
        rules={[
          {
            required: true,
            message: ERROR_TEXTS.CONNECTION.SCHEMAS.REQUIRED,
          },
        ]}
      >
        <Input placeholder="catalog.schema1, catalog.schema2" />
      </Form.Item>
      <Form.Item
        label="Username"
        name="username"
        required
        rules={[
          {
            required: true,
            message: ERROR_TEXTS.CONNECTION.USERNAME.REQUIRED,
          },
        ]}
      >
        <Input />
      </Form.Item>
      <Form.Item
        label="Password"
        name="password"
        required
        rules={[
          {
            required: false,
            message: ERROR_TEXTS.CONNECTION.PASSWORD.REQUIRED,
          },
        ]}
      >
        <Input.Password placeholder="Input password" />
      </Form.Item>
      <Form.Item label="Use SSL" name="ssl" valuePropName="checked">
        <Switch />
      </Form.Item>
    </>
  );
}
</file>

<file path="src/components/pages/setup/DefineRelations.tsx">
import { useEffect, useState } from 'react';
import { omit } from 'lodash';
import {
  Button,
  Col,
  Popconfirm,
  Row,
  Space,
  Spin,
  Typography,
  Alert,
} from 'antd';
import type { ColumnsType } from 'antd/es/table';
import DeleteOutlined from '@ant-design/icons/DeleteOutlined';
import EditOutlined from '@ant-design/icons/EditOutlined';
import PlusOutlined from '@ant-design/icons/PlusOutlined';
import ModelRelationSelectionTable, {
  RelationsDataType,
} from '@/components/table/ModelRelationSelectionTable';
import { getJoinTypeText } from '@/utils/data';
import useModalAction from '@/hooks/useModalAction';
import RelationModal, {
  RelationFieldValue,
  RelationFormValues,
} from '@/components/modals/RelationModal';
import { convertFormValuesToIdentifier } from '@/hooks/useCombineFieldOptions';

const { Title, Text } = Typography;

// for omit keys
const relationKeys = ['name', 'isAutoGenerated'];

export interface SelectedRecommendRelations {
  [modelName: string]: RelationsDataType[];
}

interface Props {
  fetching: boolean;
  recommendRelations: SelectedRecommendRelations;
  recommendNameMapping: Record<string, string>;
  onNext: (data: { relations: SelectedRecommendRelations }) => void;
  onBack: () => void;
  onSkip: () => void;
  submitting: boolean;
}

interface EditableRelationTableProps {
  index: number;
  modelName: string;
  onSetRelation: (payload: {
    modelName: string;
    defaultValue?: RelationsDataType;
  }) => void;
  onDeleteRow: (modelName: string, selectedRelation: RelationsDataType) => void;
  relations: RelationsDataType[];
  recommendNameMapping: Record<string, string>;
}

function EditableRelationTable(props: EditableRelationTableProps) {
  const {
    index,
    modelName,
    onSetRelation,
    onDeleteRow,
    relations,
    recommendNameMapping,
  } = props;

  const columns: ColumnsType<RelationsDataType> = [
    {
      title: 'From',
      dataIndex: 'fromField',
      key: 'fromField',
      render: (fromField) => `${fromField.modelName}.${fromField.fieldName}`,
      width: '35%',
    },
    {
      title: 'To',
      dataIndex: 'toField',
      key: 'toField',
      render: (toField) => `${toField.modelName}.${toField.fieldName}`,
      width: '35%',
    },
    {
      title: 'Type',
      dataIndex: 'type',
      key: 'type',
      render: (type, relation) => (
        <>
          {getJoinTypeText(type)}
          {relation.isAutoGenerated && (
            <Text className="pl-1" type="secondary">
              (auto-generated)
            </Text>
          )}
        </>
      ),
      width: '30%',
    },
    {
      title: '',
      key: 'action',
      width: 48,
      align: 'center',
      render: (_, record) => (
        <Space size={[16, 0]}>
          <EditOutlined
            onClick={() =>
              onSetRelation({
                modelName,
                defaultValue: record,
              })
            }
          />
          <Popconfirm
            title="Confirm to delete?"
            okText="Delete"
            okButtonProps={{ danger: true }}
            onConfirm={() => onDeleteRow(modelName, record)}
          >
            <DeleteOutlined />
          </Popconfirm>
        </Space>
      ),
    },
  ];

  return (
    <div className="mt-6">
      <ModelRelationSelectionTable
        columns={columns}
        dataSource={relations}
        tableTitle={recommendNameMapping[modelName]}
        extra={(onCollapseOpen) => (
          <Button
            onClick={(event) => {
              onSetRelation({ modelName });
              onCollapseOpen(event, recommendNameMapping[modelName]);
            }}
            size="small"
            title="Add relationship"
          >
            <PlusOutlined />
            Add
          </Button>
        )}
        rowKey={(record: RelationsDataType) =>
          `${modelName}-${record.fromField.fieldName}-${record.toField.modelName}-${record.toField.fieldName}-${index}`
        }
      />
    </div>
  );
}

export default function DefineRelations(props: Props) {
  const {
    fetching,
    recommendRelations,
    recommendNameMapping,
    onBack,
    onNext,
    onSkip,
    submitting,
  } = props;

  const [relations, setRelations] =
    useState<SelectedRecommendRelations>(recommendRelations);

  const [selectedRelation, setSelectedRelation] = useState<{
    modelName: string;
    defaultValue?: RelationsDataType;
  }>(null);

  const [showNoRecommendationAlert, setShowNoRecommendationAlert] =
    useState<boolean>(false);

  useEffect(() => {
    setRelations(recommendRelations);

    const recommendRelationsValues = Object.values(recommendRelations);
    if (recommendRelationsValues.length === 0) return;

    const allEmpty = recommendRelationsValues.every(
      (value) => value.length === 0,
    );
    setShowNoRecommendationAlert(allEmpty);
  }, [recommendRelations]);

  const relationModal = useModalAction();

  // check is the relation is auto-generated or not
  const isRecommendRelation = (
    modelName: string,
    relation: RelationsDataType,
  ) => {
    const isOriginalRelation = (recommendRelations[modelName] || []).find(
      (originalRelation) =>
        JSON.stringify(omit(originalRelation, relationKeys)) ===
        JSON.stringify(omit(relation, relationKeys)),
    );

    return isOriginalRelation?.isAutoGenerated || false;
  };

  const onAddRelation = (relationFormValues: RelationFormValues) => {
    const relation = convertFormValuesToIdentifier(relationFormValues);
    const modelName = relation.fromField.modelName;
    const isAutoGenerated = isRecommendRelation(modelName, relation);
    const newRelations = {
      ...relations,
      [modelName]: [
        ...(relations[modelName] || []),
        { ...relation, isAutoGenerated },
      ],
    };
    setRelations(newRelations);
  };

  const onCloseModal = () => {
    setSelectedRelation(null);
    relationModal.closeModal();
  };

  const onDeleteRow = (
    modelName: string,
    selectedRelation: RelationsDataType,
  ) => {
    const newRelations = {
      ...relations,
      [modelName]: relations[modelName].filter(
        (relation) =>
          JSON.stringify(relation) !== JSON.stringify(selectedRelation),
      ),
    };
    setRelations(newRelations);
  };

  const onSetRelation = (payload: {
    modelName: string;
    defaultValue?: RelationsDataType;
  }) => {
    setSelectedRelation(payload);
    relationModal.openModal();
  };

  const onUpdateRelation = (
    modelName: string,
    originalRelationValue: RelationsDataType,
    newRelationValue: RelationFormValues,
  ) => {
    const newRelation = convertFormValuesToIdentifier(newRelationValue);
    const isAutoGenerated = isRecommendRelation(modelName, newRelation);
    const newRelations = {
      ...relations,
      [modelName]: relations[modelName].map((relation) => {
        if (
          JSON.stringify(relation) === JSON.stringify(originalRelationValue)
        ) {
          return { ...newRelation, isAutoGenerated };
        }
        return relation;
      }),
    };

    setRelations(newRelations);
  };

  const submit = () => {
    onNext && onNext({ relations });
  };

  return (
    <div>
      <Title level={1} className="mb-3">
        Define relationships
      </Title>
      <Text>
        You can create relationships between selected tables. We provide
        suggested relationships based on primary and foreign keys defined in
        your data source. The relationships are then added to data models.
      </Text>
      {showNoRecommendationAlert && (
        <Alert
          message="No recommended relationships"
          description="No relationships are recommended because no primary or foreign keys were detected."
          type="info"
          showIcon
          className="my-6"
        />
      )}
      <div className="my-6 text-center">
        {Object.entries(relations).map(
          ([modelReferenceName, relations = []], index) => (
            <EditableRelationTable
              key={`${modelReferenceName}-${relations.length}`}
              index={index}
              modelName={modelReferenceName}
              relations={relations}
              onSetRelation={onSetRelation}
              onDeleteRow={onDeleteRow}
              recommendNameMapping={recommendNameMapping}
            />
          ),
        )}
        <Spin spinning={fetching} tip="Loading..." className="my-15" />
      </div>
      <Row gutter={16} className="pt-6">
        <Col span={12}>
          <Button onClick={onBack} size="large" className="adm-onboarding-btn">
            Back
          </Button>
        </Col>
        <Col className="text-right" span={12}>
          <Button
            className="mr-4 gray-7 adm-onboarding-btn"
            type="text"
            size="large"
            onClick={onSkip}
            disabled={submitting}
            data-ph-capture="true"
            data-ph-capture-attribute-name="cta_skip_define_relationship"
          >
            Skip this step
          </Button>
          <Button
            type="primary"
            size="large"
            onClick={submit}
            className="adm-onboarding-btn"
            loading={submitting}
            disabled={fetching}
            data-ph-capture="true"
            data-ph-capture-attribute-name="cta_finish_define_relationship"
          >
            Finish
          </Button>
        </Col>
      </Row>
      <RelationModal
        {...relationModal.state}
        model={selectedRelation?.modelName}
        onSubmit={async (values) => {
          if (selectedRelation?.defaultValue) {
            onUpdateRelation(
              selectedRelation.modelName,
              selectedRelation.defaultValue,
              values,
            );
          } else {
            onAddRelation(values);
          }
          setSelectedRelation(null);
        }}
        onClose={onCloseModal}
        defaultValue={
          selectedRelation?.defaultValue
            ? (omit(
                selectedRelation.defaultValue,
                relationKeys,
              ) as RelationFieldValue)
            : undefined
        }
        relations={relations}
        isRecommendMode={Boolean(selectedRelation?.defaultValue)}
      />
    </div>
  );
}
</file>

<file path="src/components/pages/setup/SelectModels.tsx">
import Link from 'next/link';
import { Button, Col, Form, Row, Typography } from 'antd';
import type { ColumnsType } from 'antd/es/table';
import { ERROR_TEXTS } from '@/utils/error';
import MultiSelectBox from '@/components/table/MultiSelectBox';
import { CompactTable } from '@/apollo/client/graphql/__types__';

const { Title, Text } = Typography;

interface Props {
  fetching: boolean;
  tables: CompactTable[];
  onNext: (data: { selectedTables: string[] }) => void;
  onBack: () => void;
  submitting: boolean;
}

const columns: ColumnsType<CompactTable> = [
  {
    title: 'Table name',
    dataIndex: 'name',
  },
];

export default function SelectModels(props: Props) {
  const { fetching, tables, onBack, onNext, submitting } = props;
  const [form] = Form.useForm();

  const items = tables.map((item) => ({
    ...item,
    value: item.name,
  }));

  const submit = () => {
    form
      .validateFields()
      .then((values) => {
        onNext && onNext({ selectedTables: values.tables });
      })
      .catch((error) => {
        console.error(error);
      });
  };

  return (
    <div>
      <Title level={1} className="mb-3">
        Select tables to create data models
      </Title>
      <Text>
        We will create data models based on selected tables to help AI better
        understand your data.
        <br />
        <Link
          href="https://docs.getwren.ai/oss/guide/modeling/overview"
          target="_blank"
          rel="noopener noreferrer"
        >
          Learn more
        </Link>{' '}
        about data models.
      </Text>
      <div className="my-6">
        <Form form={form} layout="vertical" style={{ marginTop: 8 }}>
          <Form.Item
            name="tables"
            rules={[
              {
                required: true,
                message: ERROR_TEXTS.SETUP_MODEL.TABLE.REQUIRED,
              },
            ]}
          >
            <MultiSelectBox
              columns={columns}
              items={items}
              loading={fetching}
            />
          </Form.Item>
        </Form>
      </div>
      <Row gutter={16} className="pt-6">
        <Col span={12}>
          <Button
            onClick={onBack}
            size="large"
            className="adm-onboarding-btn"
            disabled={submitting}
          >
            Back
          </Button>
        </Col>
        <Col className="text-right" span={12}>
          <Button
            type="primary"
            size="large"
            onClick={submit}
            className="adm-onboarding-btn"
            loading={submitting}
          >
            Next
          </Button>
        </Col>
      </Row>
    </div>
  );
}
</file>

<file path="src/components/pages/setup/Starter.tsx">
import Link from 'next/link';
import { ComponentProps, useState } from 'react';
import { Typography, Row, Col } from 'antd';
import { getDataSources, getTemplates } from './utils';
import { makeIterable } from '@/utils/iteration';
import ButtonItem from './ButtonItem';
import {
  DataSourceName,
  SampleDatasetName,
} from '@/apollo/client/graphql/__types__';

const ButtonTemplate = (props: ComponentProps<typeof ButtonItem>) => {
  return (
    <Col span={6} key={props.label}>
      <ButtonItem {...props} />
    </Col>
  );
};

const DataSourceIterator = makeIterable(ButtonTemplate);
const TemplatesIterator = makeIterable(ButtonTemplate);

export default function Starter(props) {
  const { onNext, submitting } = props;

  const [template, setTemplate] = useState<SampleDatasetName>();

  const dataSources = getDataSources();
  const templates = getTemplates();

  const onSelectDataSource = (value: DataSourceName) => {
    onNext && onNext({ dataSource: value });
  };

  const onSelectTemplate = (value: string) => {
    setTemplate(value as SampleDatasetName);
    onNext && onNext({ template: value });
  };

  return (
    <>
      <Typography.Title level={1} className="mb-3">
        Connect a data source
      </Typography.Title>
      <Typography.Text>
        Vote for your favorite data sources on{' '}
        <Link
          href="https://github.com/Canner/WrenAI/discussions/327"
          target="_blank"
          rel="noopener noreferrer"
        >
          GitHub
        </Link>
        .
      </Typography.Text>
      <Row className="mt-6" gutter={[16, 16]}>
        <DataSourceIterator
          data={dataSources}
          onSelect={onSelectDataSource}
          submitting={submitting}
        />
      </Row>

      <div className="py-8" />

      <Typography.Title level={1} className="mb-3">
        Play around with sample data
      </Typography.Title>
      <Row className="mt-6" gutter={[16, 16]}>
        <TemplatesIterator
          data={templates}
          onSelect={onSelectTemplate}
          submitting={submitting}
          selectedTemplate={template}
        />
      </Row>

      <div className="py-12" />
    </>
  );
}
</file>

<file path="src/components/pages/setup/utils.tsx">
import { merge } from 'lodash';
import { IconComponentProps } from '@/import/icon';
import ShoppingCartOutlined from '@ant-design/icons/ShoppingCartOutlined';
import IdCardOutlined from '@ant-design/icons/IdcardOutlined';
import { SETUP, DATA_SOURCES } from '@/utils/enum';
import Starter from './Starter';
import ConnectDataSource from './ConnectDataSource';
import SelectModels from './SelectModels';
import DefineRelations from './DefineRelations';
import { SampleDatasetName } from '@/apollo/client/graphql/__types__';
import { ERROR_CODES } from '@/utils/errorHandler';
import {
  getDataSourceConfig,
  getDataSourceFormComponent,
} from '@/utils/dataSourceType';

type SetupStep = {
  step: number;
  component: (
    props?: React.ComponentProps<typeof Starter> &
      React.ComponentProps<typeof ConnectDataSource> &
      React.ComponentProps<typeof SelectModels> &
      React.ComponentProps<typeof DefineRelations>,
  ) => JSX.Element;
  maxWidth?: number;
};

export type ButtonOption = {
  label: string;
  logo?: string;
  IconComponent?: IconComponentProps['component'];
  guide?: string;
  disabled?: boolean;
  submitting?: boolean;
  value?: string;
};

export const SETUP_STEPS = {
  [SETUP.STARTER]: {
    step: 0,
    component: Starter,
  },
  [SETUP.CREATE_DATA_SOURCE]: {
    step: 0,
    component: ConnectDataSource,
    maxWidth: 960,
  },
  [SETUP.SELECT_MODELS]: {
    step: 1,
    component: SelectModels,
    maxWidth: 960,
  },
  [SETUP.DEFINE_RELATIONS]: {
    step: 2,
    component: DefineRelations,
  },
} as { [key: string]: SetupStep };

export const DATA_SOURCE_OPTIONS = {
  [DATA_SOURCES.BIG_QUERY]: {
    ...getDataSourceConfig(DATA_SOURCES.BIG_QUERY),
    guide: 'https://docs.getwren.ai/oss/guide/connect/bigquery',
    disabled: false,
  },
  [DATA_SOURCES.DUCKDB]: {
    ...getDataSourceConfig(DATA_SOURCES.DUCKDB),
    guide: 'https://docs.getwren.ai/oss/guide/connect/duckdb',
    disabled: false,
  },
  [DATA_SOURCES.POSTGRES]: {
    ...getDataSourceConfig(DATA_SOURCES.POSTGRES),
    guide: 'https://docs.getwren.ai/oss/guide/connect/postgresql',
    disabled: false,
  },
  [DATA_SOURCES.MYSQL]: {
    ...getDataSourceConfig(DATA_SOURCES.MYSQL),
    guide: 'https://docs.getwren.ai/oss/guide/connect/mysql',
    disabled: false,
  },
  [DATA_SOURCES.ORACLE]: {
    ...getDataSourceConfig(DATA_SOURCES.ORACLE),
    guide: 'https://docs.getwren.ai/oss/guide/connect/oracle',
    disabled: false,
  },
  [DATA_SOURCES.MSSQL]: {
    ...getDataSourceConfig(DATA_SOURCES.MSSQL),
    guide: 'https://docs.getwren.ai/oss/guide/connect/sqlserver',
    disabled: false,
  },
  [DATA_SOURCES.CLICK_HOUSE]: {
    ...getDataSourceConfig(DATA_SOURCES.CLICK_HOUSE),
    guide: 'https://docs.getwren.ai/oss/guide/connect/clickhouse',
    disabled: false,
  },
  [DATA_SOURCES.TRINO]: {
    ...getDataSourceConfig(DATA_SOURCES.TRINO),
    guide: 'https://docs.getwren.ai/oss/guide/connect/trino',
    disabled: false,
  },
  [DATA_SOURCES.SNOWFLAKE]: {
    ...getDataSourceConfig(DATA_SOURCES.SNOWFLAKE),
    guide: 'https://docs.getwren.ai/oss/guide/connect/snowflake',
    disabled: false,
  },
  [DATA_SOURCES.ATHENA]: {
    ...getDataSourceConfig(DATA_SOURCES.ATHENA),
    guide: 'https://docs.getwren.ai/oss/guide/connect/athena',
    disabled: false,
  },
  [DATA_SOURCES.REDSHIFT]: {
    ...getDataSourceConfig(DATA_SOURCES.REDSHIFT),
    guide: 'https://docs.getwren.ai/oss/guide/connect/redshift',
    disabled: false,
  },
} as { [key: string]: ButtonOption };

export const TEMPLATE_OPTIONS = {
  [SampleDatasetName.ECOMMERCE]: {
    label: 'E-commerce',
    IconComponent: ShoppingCartOutlined,
    guide: 'https://docs.getwren.ai/oss/getting_started/sample_data/ecommerce',
  },
  [SampleDatasetName.HR]: {
    label: 'Human Resource',
    IconComponent: IdCardOutlined,
    guide: 'https://docs.getwren.ai/oss/getting_started/sample_data/hr',
  },
};

export const getDataSources = () => {
  return Object.values(DATA_SOURCE_OPTIONS) as ButtonOption[];
};

export const getDataSource = (dataSource: DATA_SOURCES) => {
  return merge(
    DATA_SOURCE_OPTIONS[dataSource],
    getDataSourceFormComponent(dataSource),
  );
};

export const getTemplates = () => {
  return Object.keys(TEMPLATE_OPTIONS).map((key) => ({
    ...TEMPLATE_OPTIONS[key],
    value: key,
  })) as ButtonOption[];
};

export const getPostgresErrorMessage = (error: Record<string, any>) => {
  if (error.code === ERROR_CODES.CONNECTION_REFUSED) {
    return (
      <div>
        {error.message}. <br />
        If you are having trouble connecting to your PostgreSQL database, please
        refer to our{' '}
        <a
          href="https://docs.getwren.ai/oss/guide/connect/postgresql#connect"
          target="_blank"
          rel="noopener noreferrer"
        >
          documentation
        </a>{' '}
        for detailed instructions.
      </div>
    );
  }
  return error.message;
};
</file>

<file path="src/components/selectors/CombineFieldSelector.tsx">
import { useEffect, useState } from 'react';
import { Select, Input } from 'antd';

interface Value {
  model?: string;
  field?: string;
}

interface Props {
  modelOptions: { label: string; value: string }[];
  fieldOptions: { label: string; value: string }[];
  modelDisabled?: boolean;
  fieldDisabled?: boolean;
  modelValue?: string;
  fieldValue?: string;
  value?: Value;
  onModelChange?: (modelLabel: string) => void;
  onFieldChange?: (fieldLabel: string) => void;
  onChange?: (value: Value) => void;
}

export default function CombineFieldSelector(props: Props) {
  const {
    modelValue,
    fieldValue,
    value = {},
    onModelChange,
    onFieldChange,
    onChange,
    modelOptions,
    fieldOptions,
    modelDisabled,
    fieldDisabled,
  } = props;

  const [internalValue, setInternalValue] = useState<Value>({
    model: modelValue,
    field: fieldValue,
    ...value,
  });

  const syncOnChange = () => {
    if (internalValue?.model && internalValue?.field) {
      onChange && onChange(internalValue);
    }
  };

  useEffect(syncOnChange, [internalValue]);

  const changeModel = (model: string) => {
    onModelChange && onModelChange(model);
    const newInternalValue = { model, field: undefined };
    setInternalValue(newInternalValue);
    onChange && onChange(newInternalValue);
  };

  const changeField = (field: string) => {
    onFieldChange && onFieldChange(field);
    setInternalValue({ ...internalValue, field });
  };

  return (
    <Input.Group className="d-flex" compact>
      <Select
        style={{ width: '35%' }}
        options={modelOptions}
        onChange={changeModel}
        placeholder="Model"
        value={value?.model || modelValue}
        disabled={modelDisabled}
        showSearch
        optionFilterProp="label"
        data-testid="common__models-select"
      />
      <Select
        className="flex-grow-1"
        options={fieldOptions}
        onChange={changeField}
        placeholder="Field"
        value={value?.field || fieldValue}
        disabled={fieldDisabled}
        showSearch
        optionFilterProp="label"
        data-testid="common__fields-select"
      />
    </Input.Group>
  );
}
</file>

<file path="src/components/selectors/DescriptiveSelector.tsx">
import React, { useState } from 'react';
import { Select, SelectProps, Space, Typography } from 'antd';
import styled from 'styled-components';
import { omit } from 'lodash';

interface Props extends SelectProps {
  listHeight?: number;
  descriptiveContentRender?: (option: any) => React.ReactNode;
  dropdownMatchSelectWidth?: number | boolean;
}

const { Title } = Typography;

const DescribeBox = styled.div`
  display: flex;
  .rc-virtual-list {
    min-width: 230px;
  }

  .describeBox {
    &-codeBlock {
      background: var(--gray-3);
      border-radius: 4px;
      padding: 6px 8px;
    }
  }
`;

const defaultDescriptiveContentRender = (content: Record<string, any>) => {
  return (
    <Space style={{ width: '100%' }} size={[0, 16]} direction="vertical">
      <div>
        <div style={{ marginBottom: 4 }}>
          <b>Description</b>
        </div>
        {content?.description || '-'}
      </div>
      <div>
        <div style={{ marginBottom: 4 }}>
          <b>Example</b>
        </div>
        {content?.example ? (
          <div className="describeBox-codeBlock">{content?.example}</div>
        ) : (
          '-'
        )}
      </div>
    </Space>
  );
};

export default function DescriptiveSelector(props: Props) {
  const {
    mode,
    value,
    options,
    onChange,
    descriptiveContentRender,
    listHeight,
    placeholder,
    dropdownMatchSelectWidth,
  } = props;
  // Condition when met group option
  const [firstOption] = options;
  const [currentOption, setCurrentOption] = useState<any>(
    firstOption.options ? firstOption.options[0] : firstOption,
  );
  // if descriptiveContentRender is not provided, the maxHeight will auto set for defaultDescriptiveContentRender
  const maxHeight = descriptiveContentRender ? listHeight : 193;

  const renderDescriptiveMenu = (menu: React.ReactNode) => {
    return (
      <DescribeBox>
        {menu}
        <div
          style={{
            width: '100%',
            borderLeft: '1px solid var(--gray-3)',
            margin: '-4px 0',
            minWidth: 0,
          }}
        >
          <Title
            level={5}
            ellipsis
            style={{
              padding: '8px 16px',
              borderBottom: '1px solid var(--gray-3)',
            }}
          >
            {currentOption?.label || currentOption?.value}
          </Title>
          <div style={{ padding: '4px 16px 12px' }}>
            {(descriptiveContentRender
              ? descriptiveContentRender
              : defaultDescriptiveContentRender)(currentOption?.content)}
          </div>
        </div>
      </DescribeBox>
    );
  };

  const extendOptionMouseEnter = (option) => {
    setCurrentOption(option);
  };

  const getOptionStructure = (option) => ({
    ...omit(option, ['content']),
    'data-value': option.value,
    onMouseEnter: (event) => {
      extendOptionMouseEnter(option);
      option.onMouseEnter && option.onMouseEnter(event);
    },
  });

  const mainOptions = options.map((option) => {
    const isOptionGroup = Boolean(option.options);
    return isOptionGroup
      ? { ...option, options: option.options!.map(getOptionStructure) }
      : getOptionStructure(option);
  }) as SelectProps['options'];

  return (
    <Select
      style={{ width: '100%' }}
      mode={mode}
      options={mainOptions}
      value={value}
      onChange={onChange}
      dropdownRender={renderDescriptiveMenu}
      listHeight={maxHeight}
      placeholder={placeholder}
      dropdownMatchSelectWidth={dropdownMatchSelectWidth}
      data-testid="common__descriptive-select"
    />
  );
}
</file>

<file path="src/components/selectors/lineageSelector/FieldSelect.tsx">
import { useEffect, useState } from 'react';
import styled from 'styled-components';
import { NODE_TYPE } from '@/utils/enum';
import { ModelIcon } from '@/utils/icons';
import { IterableComponent } from '@/utils/iteration';
import Selector, { Option } from '@/components/selectors/Selector';

const FieldBox = styled.div`
  user-select: none;
  border-radius: 4px;
  background-color: white;
  width: 170px;
  box-shadow:
    0px 9px 28px 8px rgba(0, 0, 0, 0.05),
    0px 6px 16px 0px rgba(0, 0, 0, 0.08),
    0px 3px 6px -4px rgba(0, 0, 0, 0.12);

  + .adm-fieldBox {
    position: relative;
    margin-left: 40px;
    &:before {
      content: '';
      position: absolute;
      top: 50%;
      left: -40px;
      width: 40px;
      height: 1px;
      background-color: var(--gray-8);
    }
  }

  .ant-select-selection-placeholder {
    color: var(--geekblue-6);
  }

  &:last-child {
    border: 1px var(--geekblue-6) solid;
  }
`;

const FieldHeader = styled.div`
  display: flex;
  align-items: center;
  border-bottom: 1px var(--gray-4) solid;
`;

const StyledSelector = styled(Selector)`
  &.ant-select-status-error.ant-select:not(.ant-select-disabled):not(
      .ant-select-customize-input
    )
    .ant-select-selector {
    border-color: transparent !important;
  }
`;

export type FieldOption = Option;

export interface FieldValue {
  nodeType: NODE_TYPE;
  referenceName: string;
  displayName: string;
  type?: string;
  relationId?: number;
  columnId?: number;
}

type Props = FieldValue & {
  options: FieldOption[];
  onChange?: (value: any, index: number) => void;
  onFetchOptions?: (item: any, index: number) => Promise<FieldOption[]>;
};

export const getFieldValue = (field): FieldValue => {
  return {
    nodeType: field.nodeType,
    referenceName: field.referenceName,
    displayName: field.displayName,
    type: field.type,
    relationId: field?.relationId,
    columnId: field?.columnId,
  };
};

export default function FieldSelect(props: IterableComponent<Props>) {
  const {
    nodeType,
    referenceName,
    displayName,

    data,
    onFetchOptions,
    onChange,
    index,
  } = props;
  const selectedValue = data[index + 1];
  const isModelOrRelationshipNode = [
    NODE_TYPE.MODEL,
    NODE_TYPE.RELATION,
  ].includes(nodeType);
  const [options, setOptions] = useState([]);

  const getOptions = async () => {
    const result = onFetchOptions && (await onFetchOptions(props, index));
    setOptions(result || []);
  };

  // Get options when field select has value at the beginning (edit mode)
  useEffect(() => {
    if (selectedValue) getOptions();
  }, []);

  const onDropdownVisibleChange = async (open: boolean) => {
    if (!open) return;
    getOptions();
  };

  return isModelOrRelationshipNode ? (
    <FieldBox
      className="adm-fieldBox flex-shrink-0"
      data-testid="common__lineage-field-block"
    >
      <FieldHeader className="py-1 px-3">
        <ModelIcon className="mr-1 flex-shrink-0" />
        <div
          className="text-truncate flex-grow-1"
          title={displayName || referenceName}
        >
          {displayName || referenceName}
        </div>
      </FieldHeader>

      {selectedValue?.nodeType === NODE_TYPE.RELATION && (
        <div className="gray-7 text-sm px-3 pt-1">Relationships</div>
      )}

      <StyledSelector
        bordered={false}
        options={options}
        optionLabelProp="label"
        placeholder="Select field"
        suffixIcon={null}
        value={selectedValue}
        dropdownClassName="adm-model-field-select-dropdown"
        onDropdownVisibleChange={onDropdownVisibleChange}
        onSelect={(value) => {
          onChange && onChange(value, index);
        }}
        data-testid="common__lineage-fields-select"
      />
    </FieldBox>
  ) : null;
}
</file>

<file path="src/components/selectors/lineageSelector/index.tsx">
import { useRef, useContext, useMemo } from 'react';
import styled from 'styled-components';
import { compact } from 'lodash';
import FieldSelect, {
  FieldValue,
  FieldOption,
  getFieldValue,
} from './FieldSelect';
import { nextTick } from '@/utils/time';
import { makeIterable } from '@/utils/iteration';
import { NODE_TYPE } from '@/utils/enum';
import { compactObject, parseJson } from '@/utils/helper';
import {
  FormItemInputContext,
  FormItemStatusContextProps,
} from 'antd/lib/form/context';
import { DiagramModel } from '@/utils/data';
import { getNodeTypeIcon } from '@/utils/nodeType';
import { aggregations } from '@/utils/expressionType';
import { ExpressionName } from '@/apollo/client/graphql/__types__';
import {
  checkStringFunctionAllowType,
  checkNumberFunctionAllowType,
} from '@/utils/validator';

interface Props {
  sourceModel: DiagramModel;
  onChange?: (value: FieldValue[]) => void;
  onFetchOptions?: (value: any, index: number) => Promise<FieldOption[]>;
  value?: FieldValue[];
}

const Wrapper = styled.div`
  border: 1px var(--gray-5) solid;
  border-radius: 4px;
  overflow-x: auto;

  &.adm-error {
    border-color: var(--red-5);
  }
`;

const SelectResult = makeIterable(FieldSelect);

export default function LineageSelector(props: Props) {
  const wrapper = useRef<HTMLDivElement | null>(null);
  const { sourceModel, value = [], onChange, onFetchOptions } = props;

  const formItemContext =
    useContext<FormItemStatusContextProps>(FormItemInputContext);
  const { status } = formItemContext;

  // prepare value & options here
  const data = useMemo(() => {
    // always add model as the first item
    const selectedData = [
      {
        referenceName: sourceModel.referenceName,
        displayName: sourceModel.displayName,
        nodeType: NODE_TYPE.MODEL,
      },
      ...value,
    ];

    return selectedData;
  }, [sourceModel, value]);

  const change = async (selectValue, index) => {
    const parsePayload = parseJson(selectValue) as FieldValue;

    const prevValue = value.slice(0, index);
    const nextValue = [...prevValue, parsePayload];
    onChange && onChange(nextValue);

    await nextTick();
    wrapper.current?.scrollTo({ left: wrapper.current?.scrollWidth });
  };

  return (
    <Wrapper
      ref={wrapper}
      className={`d-flex align-center bg-gray-3 px-8 py-12${
        status ? ` adm-${status}` : ''
      }`}
      data-testid="common__lineage"
    >
      <SelectResult
        data={data}
        onChange={change}
        onFetchOptions={onFetchOptions}
      />
    </Wrapper>
  );
}

export const getLineageOptions = (data: {
  model: DiagramModel;
  sourceModel: DiagramModel;
  expression: ExpressionName;
  values: FieldValue[];
}) => {
  const { model, sourceModel, expression, values = [] } = data;
  const hasPrimaryKey = model.fields.some((field) => field.isPrimaryKey);
  const isSourceModel = model.modelId === sourceModel.modelId;

  const convertor = (field) => {
    const value = compactObject(getFieldValue(field));
    const isRelationship = field.nodeType === NODE_TYPE.RELATION;
    // check if source model's calculated field
    const isSourceModelCalculatedField =
      isSourceModel && field.nodeType === NODE_TYPE.CALCULATED_FIELD;
    // check if user select aggregation functions, then the source model fields cannot be selected
    const isSourceModelFieldsWithAggregation =
      aggregations.includes(expression) && isSourceModel && !isRelationship;
    // check if the relationship is in used
    const isInUsedRelationship =
      isRelationship &&
      values.some(
        (item) => item.relationId && item.relationId === value.relationId,
      );
    // The relationship options available only if the model has a primary key
    const isRelationshipWithoutPrimaryKey = isRelationship && !hasPrimaryKey;

    // check if the field type is valid for the expression
    let isInvalidType = false;
    let invalidTypeMessage = '';
    if (!checkStringFunctionAllowType(expression, value)) {
      isInvalidType = true;
      invalidTypeMessage = 'Please select a string type field.';
    } else if (!checkNumberFunctionAllowType(expression, value)) {
      isInvalidType = true;
      invalidTypeMessage = 'Please select a number type field.';
    }

    const disabled =
      isSourceModelFieldsWithAggregation ||
      isRelationshipWithoutPrimaryKey ||
      isSourceModelCalculatedField ||
      isInUsedRelationship ||
      isInvalidType;

    let title = undefined;
    if (isSourceModelFieldsWithAggregation) {
      title =
        "Aggregation functions don't allow selecting from source model fields to prevent unexpected outcomes.";
    } else if (isRelationshipWithoutPrimaryKey) {
      title =
        'Please set a primary key within this model to use it in a calculated field.';
    } else if (isSourceModelCalculatedField) {
      title = 'Calculated field from the source model is not supported.';
    } else if (isInUsedRelationship) {
      title = 'This relationship is in use.';
    } else if (isInvalidType) {
      title = invalidTypeMessage;
    }

    return {
      label: (
        <div className="d-flex align-center">
          {getNodeTypeIcon(
            { nodeType: field.nodeType, type: field.type },
            { className: 'mr-1 flex-shrink-0', title: field.type },
          )}
          <div
            // only show column full title when it's not disabled
            title={!disabled ? field.displayName : null}
            className="text-truncate"
          >
            {field.displayName}
          </div>
        </div>
      ),
      value,
      title,
      disabled,
    };
  };
  const fields = [...(model?.fields || [])].map(convertor);
  const calculatedFields = (model?.calculatedFields || []).map(convertor);
  const relationships = (model?.relationFields || []).map(convertor);
  return compact([
    ...fields,
    calculatedFields.length
      ? { label: 'Calculated fields', options: calculatedFields }
      : undefined,
    relationships.length
      ? { label: 'Relationships', options: relationships }
      : undefined,
  ]);
};
</file>

<file path="src/components/selectors/Selector.tsx">
import React, { useCallback, useMemo } from 'react';
import { Select } from 'antd';
import { compactObject, parseJson } from '@/utils/helper';

export interface Option {
  label: string | JSX.Element;
  value?: any;
  options?: Option[];
}

interface Props extends React.ComponentProps<typeof Select> {
  options: Option[];
}

const getOption = (item) => {
  const value =
    typeof item.value === 'object' ? JSON.stringify(item.value) : item.value;
  return {
    ...item,
    value,
    'data-testid': 'common__fields__select-option',
  };
};

export default function Selector(props: Props) {
  const { value, onChange, options, ...restProps } = props;

  const handleChange = useCallback((optionValue, option) => {
    const parsedValue = Array.isArray(optionValue)
      ? optionValue.map((value) => parseJson(value))
      : parseJson(optionValue);

    onChange && onChange(parsedValue, option);
  }, []);

  const antdSelectOptions = useMemo(() => {
    return options.map((item) =>
      compactObject({
        ...getOption(item),
        options: item.options?.map(getOption),
      }),
    );
  }, [options]);

  const antdValue = useMemo(() => {
    return Array.isArray(value)
      ? value.map((item) => JSON.stringify(item))
      : JSON.stringify(value);
  }, [value]);

  return (
    <Select
      value={antdValue}
      options={antdSelectOptions}
      onChange={handleChange}
      {...restProps}
    />
  );
}
</file>

<file path="src/components/settings/DataSourceSettings.tsx">
import { useRouter } from 'next/router';
import Image from 'next/image';
import { useEffect, useMemo } from 'react';
import { Button, Form, Modal, message, Alert } from 'antd';
import { makeIterable } from '@/utils/iteration';
import { DATA_SOURCES, FORM_MODE, Path } from '@/utils/enum';
import { getDataSource, getTemplates } from '@/components/pages/setup/utils';
import { FlexLoading } from '@/components/PageLoading';
import ButtonItem from '@/components/pages/setup/ButtonItem';
import {
  transformFormToProperties,
  transformPropertiesToForm,
} from '@/hooks/useSetupConnectionDataSource';
import { parseGraphQLError } from '@/utils/errorHandler';
import {
  useStartSampleDatasetMutation,
  useUpdateDataSourceMutation,
} from '@/apollo/client/graphql/dataSource.generated';
import {
  DataSourceName,
  SampleDatasetName,
} from '@/apollo/client/graphql/__types__';

interface Props {
  type: DataSourceName;
  properties: Record<string, any>;
  sampleDataset: SampleDatasetName;
  refetchSettings: () => void;
  closeModal: () => void;
}

const SampleDatasetIterator = makeIterable(ButtonItem);

const SampleDatasetPanel = (props: Props) => {
  const router = useRouter();
  const { sampleDataset, closeModal } = props;
  const templates = getTemplates();
  const [startSampleDataset] = useStartSampleDatasetMutation({
    onError: (error) => console.error(error),
    onCompleted: () => {
      router.push(Path.Home);
      closeModal();
    },
    refetchQueries: 'active',
  });

  const onSelect = (name: SampleDatasetName) => {
    const isCurrentTemplate = sampleDataset === name;
    if (!isCurrentTemplate) {
      const template = templates.find((item) => item.value === name);
      Modal.confirm({
        title: `Are you sure you want to change to "${template.label}" dataset?`,
        okButtonProps: { danger: true },
        okText: 'Change',
        onOk: async () => {
          await startSampleDataset({ variables: { data: { name } } });
        },
      });
    }
  };

  return (
    <>
      <div className="mb-2">Change sample dataset</div>
      <div className="d-grid grid-columns-3 g-4">
        <SampleDatasetIterator
          data={templates}
          selectedTemplate={sampleDataset}
          onSelect={onSelect}
        />
      </div>
      <div className="gray-6 mt-1">
        Please be aware that choosing another sample dataset will delete all
        thread records in the Home page.
      </div>
    </>
  );
};

const DataSourcePanel = (props: Props) => {
  const { type, properties, refetchSettings } = props;

  const current = getDataSource(type as unknown as DATA_SOURCES);
  const [form] = Form.useForm();

  const [updateDataSource, { loading, error }] = useUpdateDataSourceMutation({
    onError: (error) => console.error(error),
    onCompleted: async () => {
      refetchSettings();
      message.success('Successfully update data source.');
    },
  });

  const updateError = useMemo(() => parseGraphQLError(error), [error]);

  useEffect(() => properties && reset(), [properties]);

  const reset = () => {
    form.setFieldsValue(transformPropertiesToForm(properties, type));
  };

  const submit = () => {
    form
      .validateFields()
      .then((values) => {
        updateDataSource({
          variables: {
            data: { properties: transformFormToProperties(values, type) },
          },
        });
      })
      .catch((error) => {
        console.error(error);
      });
  };

  if (!type) return <FlexLoading align="center" height={150} />;

  return (
    <>
      <div className="d-flex align-center">
        <Image
          className="mr-2"
          src={current.logo}
          alt={current.label}
          width="24"
          height="24"
        />
        {current.label}
      </div>
      <Form form={form} layout="vertical" className="py-3 px-4">
        <current.component mode={FORM_MODE.EDIT} />

        {updateError && (
          <Alert
            message={updateError.shortMessage}
            description={updateError.message}
            type="error"
            showIcon
            className="my-6"
          />
        )}

        <div className="py-2 text-right">
          <Button className="mr-2" style={{ width: 80 }} onClick={reset}>
            Cancel
          </Button>
          <Button
            type="primary"
            style={{ width: 80 }}
            onClick={submit}
            loading={loading}
          >
            Save
          </Button>
        </div>
      </Form>
    </>
  );
};

export default function DataSourceSettings(props: Props) {
  const { sampleDataset } = props;
  const Component = sampleDataset ? SampleDatasetPanel : DataSourcePanel;
  return (
    <div className="py-3 px-4">
      <Component {...props} />
    </div>
  );
}
</file>

<file path="src/components/settings/index.tsx">
import { useEffect, useMemo, useState } from 'react';
import { Modal, Layout, Button } from 'antd';
import styled from 'styled-components';
import { SETTINGS } from '@/utils/enum';
import { makeIterable } from '@/utils/iteration';
import { ModalAction } from '@/hooks/useModalAction';
import SettingOutlined from '@ant-design/icons/SettingOutlined';
import InfoCircleOutlined from '@ant-design/icons/InfoCircleOutlined';
import DataSourceSettings from './DataSourceSettings';
import ProjectSettings from './ProjectSettings';
import { getSettingMenu } from './utils';
import {
  useGetSettingsLazyQuery,
  GetSettingsQuery,
} from '@/apollo/client/graphql/settings.generated';

const { Sider, Content } = Layout;

type Props = ModalAction<any, any> & {
  loading?: boolean;
};

const StyledSider = styled(Sider)`
  .ant-layout-sider-children {
    display: flex;
    flex-direction: column;
    height: 100%;
  }
`;

const StyledModal = styled(Modal)`
  .ant-modal-content {
    overflow: hidden;
  }
  .ant-modal-close-x {
    width: 48px;
    height: 48px;
    line-height: 48px;
  }
`;

const StyledButton = styled(Button)`
  display: flex;
  align-items: center;
  padding: 12px 8px;
  margin-bottom: 4px;
`;

const DynamicComponent = ({
  menu,
  data,
  refetch,
  closeModal,
}: {
  menu: SETTINGS;
  data?: GetSettingsQuery['settings'];
  refetch: () => void;
  closeModal: () => void;
}) => {
  const { dataSource, language } = data || {};
  return (
    {
      [SETTINGS.DATA_SOURCE]: (
        <DataSourceSettings
          type={dataSource?.type}
          sampleDataset={dataSource?.sampleDataset}
          properties={dataSource?.properties}
          refetchSettings={refetch}
          closeModal={closeModal}
        />
      ),
      [SETTINGS.PROJECT]: <ProjectSettings data={{ language }} />,
    }[menu] || null
  );
};

const MenuTemplate = ({ currentMenu, value, onClick }) => {
  const current = getSettingMenu(value);
  return (
    <StyledButton
      className={currentMenu === value ? 'geekblue-6 bg-gray-4' : 'gray-8'}
      type="text"
      block
      onClick={() => onClick({ value })}
      icon={<current.icon />}
    >
      {current.label}
    </StyledButton>
  );
};

const MenuIterator = makeIterable(MenuTemplate);

export default function Settings(props: Props) {
  const { onClose, visible } = props;
  const [menu, setMenu] = useState<SETTINGS>(SETTINGS.DATA_SOURCE);
  const current = getSettingMenu(menu);
  const menuList = Object.keys(SETTINGS).map((key) => ({
    key,
    value: SETTINGS[key],
  }));
  const [fetchSettings, { data, refetch }] = useGetSettingsLazyQuery({
    fetchPolicy: 'cache-and-network',
  });

  const productVersion = useMemo(() => {
    return data?.settings?.productVersion;
  }, [data?.settings]);

  useEffect(() => {
    if (visible) fetchSettings();
  }, [visible]);

  const onMenuClick = ({ value }) => setMenu(value);

  return (
    <StyledModal
      width={950}
      bodyStyle={{ padding: 0, height: 700 }}
      visible={visible}
      footer={null}
      onCancel={onClose}
      destroyOnClose
      centered
    >
      <Layout style={{ height: '100%' }}>
        <StyledSider width={310} className="border-r border-gray-4">
          <div className="gray-9 text-bold py-3 px-5">
            <SettingOutlined className="mr-2" />
            Settings
          </div>
          <div className="p-3 flex-grow-1">
            <MenuIterator
              data={menuList}
              currentMenu={menu}
              onClick={onMenuClick}
            />
          </div>
          {!!productVersion && (
            <div className="gray-7 d-flex align-center p-3 px-5">
              <InfoCircleOutlined className="mr-2 text-sm" />
              Wren AI version: {productVersion}
            </div>
          )}
        </StyledSider>
        <Content className="d-flex flex-column">
          <div className="d-flex align-center gray-9 border-b border-gray-4 text-bold py-3 px-4">
            <current.icon className="mr-2" />
            {current.label}
          </div>
          <div className="flex-grow-1" style={{ overflowY: 'auto' }}>
            <DynamicComponent
              menu={menu}
              data={data?.settings}
              refetch={refetch}
              closeModal={onClose}
            />
          </div>
        </Content>
      </Layout>
    </StyledModal>
  );
}
</file>

<file path="src/components/settings/ProjectSettings.tsx">
import { Button, Modal, Select, Row, Col, Form, message } from 'antd';
import { useRouter } from 'next/router';
import { Path } from '@/utils/enum';
import {
  useResetCurrentProjectMutation,
  useUpdateCurrentProjectMutation,
} from '@/apollo/client/graphql/settings.generated';
import { getLanguageText } from '@/utils/language';
import { ProjectLanguage } from '@/apollo/client/graphql/__types__';

interface Props {
  data: { language: string };
}

export default function ProjectSettings(props: Props) {
  const { data } = props;
  const router = useRouter();
  const [form] = Form.useForm();
  const [resetCurrentProject, { client }] = useResetCurrentProjectMutation();
  const languageOptions = Object.keys(ProjectLanguage).map((key) => {
    return { label: getLanguageText(key as ProjectLanguage), value: key };
  });

  const [updateCurrentProject, { loading }] = useUpdateCurrentProjectMutation({
    refetchQueries: ['GetSettings'],
    onError: (error) => console.error(error),
    onCompleted: () => {
      message.success('Successfully updated project language.');
    },
  });

  const reset = () => {
    Modal.confirm({
      title: 'Are you sure you want to reset?',
      okButtonProps: { danger: true },
      okText: 'Reset',
      onOk: async () => {
        await resetCurrentProject();
        client.clearStore();
        router.push(Path.OnboardingConnection);
      },
    });
  };

  const submit = () => {
    form
      .validateFields()
      .then((values) => {
        updateCurrentProject({ variables: { data: values } });
      })
      .catch((error) => console.error(error));
  };

  return (
    <div className="py-3 px-4">
      <Form
        form={form}
        layout="vertical"
        initialValues={{ language: data.language }}
      >
        <Form.Item
          label="Project language"
          extra="This setting will affect the language in which the AI responds to you."
        >
          <Row gutter={16} wrap={false}>
            <Col className="flex-grow-1">
              <Form.Item name="language" noStyle>
                <Select
                  placeholder="Select a language"
                  showSearch
                  options={languageOptions}
                />
              </Form.Item>
            </Col>
            <Col>
              <Button
                type="primary"
                style={{ width: 70 }}
                onClick={submit}
                loading={loading}
              >
                Save
              </Button>
            </Col>
          </Row>
        </Form.Item>
      </Form>
      <div className="gray-8 mb-2">Reset project</div>
      <Button type="primary" style={{ width: 70 }} danger onClick={reset}>
        Reset
      </Button>
      <div className="gray-6 mt-1">
        Please be aware that resetting will delete all current settings and
        records, including those in the Modeling Page and Home Page threads.
      </div>
    </div>
  );
}
</file>

<file path="src/components/settings/utils.tsx">
import { SETTINGS } from '@/utils/enum';
import DatabaseOutlined from '@ant-design/icons/DatabaseOutlined';
import ProjectOutlined from '@ant-design/icons/ProjectOutlined';

export const getSettingMenu = (menu: SETTINGS) =>
  ({
    [SETTINGS.DATA_SOURCE]: {
      icon: DatabaseOutlined,
      label: 'Data source settings',
    },
    [SETTINGS.PROJECT]: {
      icon: ProjectOutlined,
      label: 'Project settings',
    },
  })[menu] || null;
</file>

<file path="src/components/sidebar/APIManagement.tsx">
import Link from 'next/link';
import { useRouter } from 'next/router';
import styled from 'styled-components';
import { Path, MENU_KEY } from '@/utils/enum';
import { OpenInNewIcon } from '@/utils/icons';
import ApiOutlined from '@ant-design/icons/ApiOutlined';
import ReadOutlined from '@ant-design/icons/ReadOutlined';
import SidebarMenu from '@/components/sidebar/SidebarMenu';

const Layout = styled.div`
  padding: 16px 0;
  position: absolute;
  z-index: 1;
  left: 0;
  top: 0;
  width: 100%;
  background-color: var(--gray-2);
  overflow: hidden;
`;

const MENU_KEY_MAP = {
  [Path.APIManagementHistory]: MENU_KEY.API_HISTORY,
};

const linkStyle = { color: 'inherit', transition: 'none' };

export default function APIManagement() {
  const router = useRouter();

  const menuItems = [
    {
      'data-guideid': 'api-history',
      label: (
        <Link style={linkStyle} href={Path.APIManagementHistory}>
          API history
        </Link>
      ),
      icon: <ApiOutlined />,
      key: MENU_KEY.API_HISTORY,
      className: 'pl-4',
    },
    {
      label: (
        <Link
          className="gray-8 d-inline-flex align-center"
          href="https://wrenai.readme.io/reference/sql-generation"
          target="_blank"
          rel="noopener noreferrer"
        >
          API reference
          <OpenInNewIcon className="ml-1" />
        </Link>
      ),
      icon: <ReadOutlined />,
      key: MENU_KEY.API_REFERENCE,
      className: 'pl-4',
    },
  ];

  return (
    <Layout>
      <SidebarMenu
        items={menuItems}
        selectedKeys={MENU_KEY_MAP[router.pathname]}
      />
    </Layout>
  );
}
</file>

<file path="src/components/sidebar/Home.tsx">
import clsx from 'clsx';
import { useEffect } from 'react';
import { useRouter } from 'next/router';
import { useParams } from 'next/navigation';
import styled from 'styled-components';
import { Path } from '@/utils/enum';
import FundViewOutlined from '@ant-design/icons/FundViewOutlined';
import SidebarTree, {
  StyledTreeNodeLink,
  useSidebarTreeState,
} from './SidebarTree';
import ThreadTree, { ThreadData } from './home/ThreadTree';

export interface Props {
  data: {
    threads: ThreadData[];
  };
  onSelect: (selectKeys) => void;
  onDelete: (id: string) => Promise<void>;
  onRename: (id: string, newName: string) => Promise<void>;
}

export const StyledSidebarTree = styled(SidebarTree)`
  .adm-treeNode {
    &.adm-treeNode__thread {
      padding: 0px 16px 0px 4px !important;

      .ant-tree-title {
        flex-grow: 1;
        display: inline-flex;
        align-items: center;
        span:first-child,
        .adm-treeTitle__title {
          flex-grow: 1;
        }
      }
    }
  }
`;

export default function Home(props: Props) {
  const { data, onSelect, onRename, onDelete } = props;
  const router = useRouter();
  const params = useParams<{ id: string }>();
  const { threads } = data;

  const { treeSelectedKeys, setTreeSelectedKeys } = useSidebarTreeState();

  useEffect(() => {
    params?.id && setTreeSelectedKeys([params.id] as string[]);
  }, [params?.id]);

  const onDeleteThread = async (threadId: string) => {
    await onDelete(threadId);
    if (params?.id == threadId) {
      router.push(Path.Home);
    }
  };

  const onTreeSelect = (selectedKeys: React.Key[], _info: any) => {
    // prevent deselected
    if (selectedKeys.length === 0) return;

    setTreeSelectedKeys(selectedKeys);
    onSelect(selectedKeys);
  };

  return (
    <>
      <StyledTreeNodeLink
        className={clsx({
          'adm-treeNode--selected': router.pathname === Path.HomeDashboard,
        })}
        href={Path.HomeDashboard}
      >
        <FundViewOutlined className="mr-2" />
        <span className="text-medium">Dashboard</span>
      </StyledTreeNodeLink>
      <ThreadTree
        threads={threads}
        selectedKeys={treeSelectedKeys}
        onSelect={onTreeSelect}
        onRename={onRename}
        onDeleteThread={onDeleteThread}
      />
    </>
  );
}
</file>

<file path="src/components/sidebar/home/ThreadTree.tsx">
import { useState, useEffect } from 'react';
import styled from 'styled-components';
import { DataNode } from 'antd/lib/tree';
import { Path } from '@/utils/enum';
import { useParams, useRouter } from 'next/navigation';
import PlusOutlined from '@ant-design/icons/PlusOutlined';
import SidebarTree, {
  sidebarCommonStyle,
} from '@/components/sidebar/SidebarTree';
import {
  createTreeGroupNode,
  GroupActionButton,
} from '@/components/sidebar/utils';
import TreeTitle from './TreeTitle';

const StyledSidebarTree = styled(SidebarTree)`
  ${sidebarCommonStyle}

  .adm-treeNode {
    &.adm-treeNode__thread {
      padding: 0px 16px 0px 4px !important;

      .ant-tree-title {
        flex-grow: 1;
        display: inline-flex;
        align-items: center;
        span:first-child,
        .adm-treeTitle__title {
          flex-grow: 1;
        }
      }
    }
  }
`;

export interface ThreadData {
  id: string;
  name: string;
}

interface Props {
  threads: ThreadData[];
  selectedKeys: React.Key[];
  onSelect: (selectKeys: React.Key[], info: any) => void;
  onRename: (id: string, newName: string) => Promise<void>;
  onDeleteThread: (id: string) => Promise<void>;
}

export default function ThreadTree(props: Props) {
  const params = useParams<{ id: string }>();
  const router = useRouter();
  const {
    threads = [],
    selectedKeys,
    onSelect,
    onRename,
    onDeleteThread,
  } = props;

  const getThreadGroupNode = createTreeGroupNode({
    groupName: 'Threads',
    groupKey: 'threads',
    actions: [
      {
        key: 'new-thread',
        render: () => (
          <GroupActionButton
            size="small"
            icon={<PlusOutlined />}
            onClick={() => router.push(Path.Home)}
          >
            New
          </GroupActionButton>
        ),
      },
    ],
  });

  const [tree, setTree] = useState<DataNode[]>(getThreadGroupNode());

  useEffect(() => {
    setTree((_tree) =>
      getThreadGroupNode({
        quotaUsage: threads.length,
        children: threads.map((thread) => {
          const nodeKey = thread.id;

          return {
            className: 'adm-treeNode adm-treeNode__thread',
            id: nodeKey,
            isLeaf: true,
            key: nodeKey,
            title: (
              <TreeTitle
                id={nodeKey}
                title={thread.name}
                onRename={onRename}
                onDelete={onDeleteThread}
              />
            ),
          };
        }),
      }),
    );
  }, [params?.id, threads]);

  return (
    <StyledSidebarTree
      treeData={tree}
      selectedKeys={selectedKeys}
      onSelect={onSelect}
    />
  );
}
</file>

<file path="src/components/sidebar/home/TreeTitle.tsx">
import { useState } from 'react';
import styled from 'styled-components';
import { Dropdown, Menu } from 'antd';
import EditOutlined from '@ant-design/icons/EditOutlined';
import MoreOutlined from '@ant-design/icons/MoreOutlined';
import LabelTitle from '@/components/sidebar/LabelTitle';
import TreeTitleInput from '@/components/sidebar/home/TreeTitleInput';
import { DeleteThreadModal } from '@/components/modals/DeleteModal';

const MENU_ITEM_KEYS = {
  RENAME: 'rename',
  DELETE: 'delete',
};

const StyledMenu = styled(Menu)`
  a:hover {
    color: white;
  }
`;

interface TreeTitleProps {
  id: string;
  title: string;
  onDelete?: (id: string) => void;
  onRename?: (id: string, newName: string) => void;
}

export default function TreeTitle(props: TreeTitleProps) {
  const { id, onDelete, onRename } = props;
  const [title, setTitle] = useState(props.title);
  const [isEditing, setIsEditing] = useState(false);

  const onCancelChange = () => {
    setIsEditing(false);
    setTitle(props.title);
  };

  const onChangeTitle = (newThreadTitle: string) => {
    setIsEditing(false);
    setTitle(newThreadTitle);
    onRename && onRename(id, newThreadTitle);
  };

  const onDeleteData = (id: string) => {
    onDelete && onDelete(id);
  };

  return isEditing ? (
    <TreeTitleInput
      title={title}
      onCancelChange={onCancelChange}
      onSetTitle={setTitle}
      onRename={onChangeTitle}
    />
  ) : (
    <LabelTitle
      title={title}
      appendIcon={
        <Dropdown
          trigger={['click']}
          overlayStyle={{ userSelect: 'none', minWidth: 150 }}
          overlay={
            <StyledMenu
              items={[
                {
                  label: (
                    <>
                      <EditOutlined className="mr-2" />
                      Rename
                    </>
                  ),
                  key: MENU_ITEM_KEYS.RENAME,
                  onClick: ({ domEvent }) => {
                    domEvent.stopPropagation();
                    setIsEditing(true);
                  },
                },
                {
                  label: (
                    <DeleteThreadModal onConfirm={() => onDeleteData(id)} />
                  ),
                  key: MENU_ITEM_KEYS.DELETE,
                  onClick: ({ domEvent }) => {
                    domEvent.stopPropagation();
                  },
                },
              ]}
            />
          }
        >
          <MoreOutlined onClick={(event) => event.stopPropagation()} />
        </Dropdown>
      }
    />
  );
}
</file>

<file path="src/components/sidebar/home/TreeTitleInput.tsx">
import { Input } from 'antd';

const ESCAPE = 'escape';

export default function TreeTitleInput(props: {
  title: string;
  onCancelChange: () => void;
  onSetTitle: (newTitle: string) => void;
  onRename: (newName: string) => void;
}) {
  const { title, onCancelChange, onRename, onSetTitle } = props;

  return (
    <Input
      autoFocus
      size="small"
      value={title}
      onClick={(e) => e.stopPropagation()}
      onKeyDown={(e: React.KeyboardEvent) => {
        // change back to the original title
        if (e.key.toLowerCase() === ESCAPE) onCancelChange();
      }}
      onChange={(e: React.ChangeEvent<HTMLInputElement>) =>
        onSetTitle(e.target.value)
      }
      onPressEnter={(_e) => onRename(title)}
      onBlur={(_e) => onRename(title)}
    />
  );
}
</file>

<file path="src/components/sidebar/index.tsx">
import Link from 'next/link';
import { useRouter } from 'next/router';
import { Button } from 'antd';
import styled from 'styled-components';
import { Path } from '@/utils/enum';
import { DiscordIcon, GithubIcon } from '@/utils/icons';
import SettingOutlined from '@ant-design/icons/SettingOutlined';
import Home, { Props as HomeSidebarProps } from './Home';
import Modeling, { Props as ModelingSidebarProps } from './Modeling';
import Knowledge from './Knowledge';
import APIManagement from './APIManagement';
import LearningSection from '@/components/learning';

const Layout = styled.div`
  position: relative;
  height: 100%;
  background-color: var(--gray-2);
  color: var(--gray-8);
  padding-bottom: 12px;
  overflow-x: hidden;
`;

const Content = styled.div`
  flex-grow: 1;
  overflow-y: auto;
`;

const StyledButton = styled(Button)`
  cursor: pointer;
  display: flex;
  align-items: center;
  padding-left: 16px;
  padding-right: 16px;
  color: var(--gray-8) !important;
  border-radius: 0;

  &:hover,
  &:focus {
    background-color: var(--gray-4);
  }
`;

type Props = (ModelingSidebarProps | HomeSidebarProps) & {
  onOpenSettings?: () => void;
};

const DynamicSidebar = (
  props: Props & {
    pathname: string;
  },
) => {
  const { pathname, ...restProps } = props;

  const getContent = () => {
    if (pathname.startsWith(Path.Home)) {
      return <Home {...(restProps as HomeSidebarProps)} />;
    }

    if (pathname.startsWith(Path.Modeling)) {
      return <Modeling {...(restProps as ModelingSidebarProps)} />;
    }

    if (pathname.startsWith(Path.Knowledge)) {
      return <Knowledge />;
    }

    if (pathname.startsWith(Path.APIManagement)) {
      return <APIManagement />;
    }

    return null;
  };

  return <Content>{getContent()}</Content>;
};

export default function Sidebar(props: Props) {
  const { onOpenSettings } = props;
  const router = useRouter();

  const onSettingsClick = (event) => {
    onOpenSettings && onOpenSettings();
    event.target.blur();
  };

  return (
    <Layout className="d-flex flex-column">
      <DynamicSidebar {...props} pathname={router.pathname} />
      <LearningSection />
      <div className="border-t border-gray-4 pt-2">
        <StyledButton type="text" block onClick={onSettingsClick}>
          <SettingOutlined className="text-md" />
          Settings
        </StyledButton>
        <StyledButton type="text" block>
          <Link
            className="d-flex align-center"
            href="https://discord.com/invite/5DvshJqG8Z"
            target="_blank"
            rel="noopener noreferrer"
            data-ph-capture="true"
            data-ph-capture-attribute-name="cta_go_to_discord"
          >
            <DiscordIcon className="mr-2" style={{ width: 16 }} /> Discord
          </Link>
        </StyledButton>
        <StyledButton type="text" block>
          <Link
            className="d-flex align-center"
            href="https://github.com/Canner/WrenAI"
            target="_blank"
            rel="noopener noreferrer"
            data-ph-capture="true"
            data-ph-capture-attribute-name="cta_go_to_github"
          >
            <GithubIcon className="mr-2" style={{ width: 16 }} /> GitHub
          </Link>
        </StyledButton>
      </div>
    </Layout>
  );
}
</file>

<file path="src/components/sidebar/Knowledge.tsx">
import Link from 'next/link';
import { useRouter } from 'next/router';
import styled from 'styled-components';
import FunctionOutlined from '@ant-design/icons/FunctionOutlined';
import { Path, MENU_KEY } from '@/utils/enum';
import { InstructionsSVG } from '@/utils/svgs';
import SidebarMenu from '@/components/sidebar/SidebarMenu';

const Layout = styled.div`
  padding: 16px 0;
  position: absolute;
  z-index: 1;
  left: 0;
  top: 0;
  width: 100%;
  background-color: var(--gray-2);
  overflow: hidden;
`;

const MENU_KEY_MAP = {
  [Path.KnowledgeQuestionSQLPairs]: MENU_KEY.QUESTION_SQL_PAIRS,
  [Path.KnowledgeInstructions]: MENU_KEY.INSTRUCTIONS,
};

const linkStyle = { color: 'inherit', transition: 'none' };

export default function Knowledge() {
  const router = useRouter();

  const menuItems = [
    {
      'data-guideid': 'question-sql-pairs',
      label: (
        <Link style={linkStyle} href={Path.KnowledgeQuestionSQLPairs}>
          Question-SQL pairs
        </Link>
      ),
      icon: <FunctionOutlined />,
      key: MENU_KEY.QUESTION_SQL_PAIRS,
      className: 'pl-4',
    },
    {
      'data-guideid': 'instructions',
      label: (
        <Link style={linkStyle} href={Path.KnowledgeInstructions}>
          Instructions
        </Link>
      ),
      icon: <InstructionsSVG />,
      key: MENU_KEY.INSTRUCTIONS,
      className: 'pl-4',
    },
  ];

  return (
    <Layout>
      <SidebarMenu
        items={menuItems}
        selectedKeys={MENU_KEY_MAP[router.pathname]}
      />
    </Layout>
  );
}
</file>

<file path="src/components/sidebar/LabelTitle.tsx">
interface LabelTitleProps {
  title: string;
  appendIcon?: React.ReactNode | null;
}

export default function LabelTitle({
  title,
  appendIcon = null,
}: LabelTitleProps) {
  return (
    <>
      <span className="adm-treeTitle__title" title={title}>
        {title}
      </span>
      {appendIcon && <span className="adm-actionIcon">{appendIcon}</span>}
    </>
  );
}
</file>

<file path="src/components/sidebar/Modeling.tsx">
import styled from 'styled-components';
import SidebarTree, { sidebarCommonStyle } from './SidebarTree';
import ModelTree from './modeling/ModelTree';
import { Diagram } from '@/utils/data';
import ViewTree from './modeling/ViewTree';

export const StyledSidebarTree = styled(SidebarTree)`
  ${sidebarCommonStyle}

  .adm-treeNode {
    .ant-tree-title {
      display: inline-flex;
      flex-wrap: nowrap;
      min-width: 1px;
      flex-grow: 0;
    }
  }
`;

export interface Props {
  data: Diagram;
  onOpenModelDrawer: () => void;
  onSelect: (selectKeys) => void;
}

export default function Modeling(props: Props) {
  const { data, onSelect, onOpenModelDrawer } = props;
  const { models = [], views = [] } = data || {};

  return (
    <>
      <ModelTree
        models={models}
        onSelect={onSelect}
        selectedKeys={[]}
        onOpenModelDrawer={onOpenModelDrawer}
      />
      <ViewTree views={views} onSelect={onSelect} selectedKeys={[]} />
    </>
  );
}
</file>

<file path="src/components/sidebar/modeling/GroupTreeTitle.tsx">
import { Fragment } from 'react';
import Icon from '@/import/icon';

export type ActionType = {
  icon?: React.ComponentType<{ className?: string }>;
  key: React.Key;
  className?: string;
  style?: React.CSSProperties;
  disabled?: boolean;
  render?: (props: { key: React.Key; disabled: boolean }) => React.ReactNode;
};

interface GroupTitleProps {
  title: string;
  quotaUsage?: number;
  appendSlot?: React.ReactNode;
  actions: ActionType[];
}

const Actions = ({ actions }: { actions: ActionType[] }) => {
  const iconComponents = (actions || []).map(
    ({ key, icon, render, disabled = false, className = '', ...restProps }) =>
      icon ? (
        <Icon
          key={key}
          component={icon}
          className={`adm-actionIcon ${className} ${
            disabled ? 'adm-actionIcon--disabled' : ''
          }`}
          {...restProps}
        />
      ) : render ? (
        <Fragment key={key}>{render({ key, disabled })}</Fragment>
      ) : null,
  );

  return (
    <span className="d-inline-flex align-center flex-shrink-0 g-2">
      {iconComponents}
    </span>
  );
};

export default function GroupTreeTitle({
  title,
  quotaUsage = 0,
  appendSlot,
  ...restProps
}: GroupTitleProps) {
  return (
    <>
      <span className="d-inline-flex align-center">
        {title}
        <span className="adm-treeNode-group-count ml-1 text-xs flex-grow-0">
          ({quotaUsage})
        </span>
        {appendSlot}
      </span>
      <Actions {...restProps} />
    </>
  );
}
</file>

<file path="src/components/sidebar/modeling/ModelTree.tsx">
import { useEffect, useMemo, useState } from 'react';
import { message } from 'antd';
import { DataNode } from 'antd/es/tree';
import { DiagramModel } from '@/utils/data';
import { getNodeTypeIcon } from '@/utils/nodeType';
import {
  createTreeGroupNode,
  getColumnNode,
  GroupActionButton,
} from '@/components/sidebar/utils';
import useModalAction from '@/hooks/useModalAction';
import LabelTitle from '@/components/sidebar/LabelTitle';
import PlusOutlined from '@ant-design/icons/PlusOutlined';
import WarningOutlined from '@ant-design/icons/WarningOutlined';
import ReloadOutlined from '@ant-design/icons/ReloadOutlined';
import { StyledSidebarTree } from '@/components/sidebar/Modeling';
import SchemaChangeModal from '@/components/modals/SchemaChangeModal';
import {
  SchemaChange,
  SchemaChangeType,
} from '@/apollo/client/graphql/__types__';
import {
  useResolveSchemaChangeMutation,
  useSchemaChangeQuery,
  useTriggerDataSourceDetectionMutation,
} from '@/apollo/client/graphql/dataSource.generated';
import { DIAGRAM } from '@/apollo/client/graphql/diagram';
import { LIST_MODELS } from '@/apollo/client/graphql/model';
import { getRelativeTime } from '@/utils/time';

interface Props {
  [key: string]: any;
  models: DiagramModel[];
  onOpenModelDrawer: () => void;
}

const getHasSchemaChange = (schemaChange: SchemaChange) => {
  return [
    schemaChange?.deletedTables,
    schemaChange?.deletedColumns,
    schemaChange?.modifiedColumns,
  ].some((changes) => !!changes);
};

export default function ModelTree(props: Props) {
  const { onOpenModelDrawer, models } = props;

  const schemaChangeModal = useModalAction();
  const [triggerDataSourceDetection, { loading: isDetecting }] =
    useTriggerDataSourceDetectionMutation({
      onError: (error) => console.error(error),
      onCompleted: async (data) => {
        if (data.triggerDataSourceDetection) {
          message.warning('Schema change detected.');
        } else {
          message.success('There is no schema change.');
        }
        await refetchSchemaChange();
      },
    });
  const [resolveSchemaChange, { loading: isResolving }] =
    useResolveSchemaChangeMutation({
      onError: (error) => console.error(error),
      onCompleted: async (_, options) => {
        const { type } = options.variables?.where;
        if (type === SchemaChangeType.DELETED_TABLES) {
          message.success('Source table deleted resolved successfully.');
        } else if (type === SchemaChangeType.DELETED_COLUMNS) {
          message.success('Source column deleted resolved successfully.');
        }

        const { data } = await refetchSchemaChange();
        // if all schema changes are resolved, close the modal
        if (!getHasSchemaChange(data.schemaChange)) {
          schemaChangeModal.closeModal();
        }
      },
      refetchQueries: [{ query: DIAGRAM }, { query: LIST_MODELS }],
    });
  const { data: schemaChangeData, refetch: refetchSchemaChange } =
    useSchemaChangeQuery({
      fetchPolicy: 'cache-and-network',
    });
  const hasSchemaChange = useMemo(
    () => getHasSchemaChange(schemaChangeData?.schemaChange),
    [schemaChangeData],
  );
  const onOpenSchemaChange = () => {
    schemaChangeModal.openModal();
  };
  const onResolveSchemaChange = (type: SchemaChangeType) => {
    resolveSchemaChange({ variables: { where: { type } } });
  };

  const getModelGroupNode = createTreeGroupNode({
    groupName: 'Models',
    groupKey: 'models',
    actions: [
      {
        key: 'trigger-schema-detection',
        disabled: isDetecting,
        icon: () => (
          <ReloadOutlined
            spin={isDetecting}
            title={
              schemaChangeData?.schemaChange.lastSchemaChangeTime
                ? `Last refresh ${getRelativeTime(schemaChangeData?.schemaChange.lastSchemaChangeTime)}`
                : ''
            }
            onClick={() => triggerDataSourceDetection()}
          />
        ),
      },
      {
        key: 'add-model',
        render: () => (
          <GroupActionButton
            data-guideid="add-model"
            data-testid="add-model"
            icon={<PlusOutlined />}
            size="small"
            onClick={() => onOpenModelDrawer()}
          >
            New
          </GroupActionButton>
        ),
      },
    ],
  });

  const [tree, setTree] = useState<DataNode[]>(getModelGroupNode());

  useEffect(() => {
    setTree((_tree) =>
      getModelGroupNode({
        quotaUsage: models.length,
        appendSlot: hasSchemaChange && (
          <span className="adm-actionIcon mx-2" onClick={onOpenSchemaChange}>
            <WarningOutlined
              className="orange-5"
              title="Review schema change impacts"
            />
          </span>
        ),
        children: models.map((model) => {
          const nodeKey = model.id;

          const children = [
            ...getColumnNode(nodeKey, [
              ...model.fields,
              ...model.calculatedFields,
            ]),
          ];

          return {
            children,
            className: 'adm-treeNode',
            icon: getNodeTypeIcon({ nodeType: model.nodeType }),
            id: nodeKey,
            isLeaf: false,
            key: nodeKey,
            title: <LabelTitle title={model.displayName} />,
            type: model.nodeType,
          };
        }),
      }),
    );
  }, [models, hasSchemaChange, schemaChangeData, isDetecting]);

  return (
    <>
      <StyledSidebarTree {...props} treeData={tree} />
      <SchemaChangeModal
        {...schemaChangeModal.state}
        defaultValue={schemaChangeData?.schemaChange}
        payload={{ onResolveSchemaChange, isResolving }}
        onClose={schemaChangeModal.closeModal}
      />
    </>
  );
}
</file>

<file path="src/components/sidebar/modeling/ViewTree.tsx">
import Link from 'next/link';
import { useEffect, useState } from 'react';
import { Modal } from 'antd';
import { DataNode } from 'antd/es/tree';
import PlusOutlined from '@ant-design/icons/PlusOutlined';
import { Path } from '@/utils/enum';
import { DiagramView } from '@/utils/data';
import { getNodeTypeIcon } from '@/utils/nodeType';
import {
  createTreeGroupNode,
  getColumnNode,
  GroupActionButton,
} from '@/components/sidebar/utils';
import LabelTitle from '@/components/sidebar/LabelTitle';
import { StyledSidebarTree } from '@/components/sidebar/Modeling';

interface Props {
  [key: string]: any;
  views: DiagramView[];
}

export default function ViewTree(props: Props) {
  const { views } = props;

  const onAddView = () => {
    Modal.info({
      title: 'How to create a View?',
      content: (
        <div>
          Pose your questions at{' '}
          <Link
            href={Path.Home}
            data-ph-capture="true"
            data-ph-capture-attribute-name="cta_add_view_navigate_to_home"
          >
            homepage
          </Link>
          , and get some helpful answers to save as views.
        </div>
      ),
      okButtonProps: {
        ['data-ph-capture']: true,
        ['data-ph-capture-attribute-name']: 'cta_add_view_ok_btn',
      } as any,
    });
  };

  const getViewGroupNode = createTreeGroupNode({
    groupName: 'Views',
    groupKey: 'views',
    actions: [
      {
        key: 'add-view-info',
        render: () => (
          <GroupActionButton
            icon={<PlusOutlined />}
            size="small"
            onClick={onAddView}
            data-ph-capture="true"
            data-ph-capture-attribute-name="cta_add_view"
          >
            New
          </GroupActionButton>
        ),
      },
    ],
  });

  const [tree, setTree] = useState<DataNode[]>(getViewGroupNode());

  useEffect(() => {
    setTree((_tree) =>
      getViewGroupNode({
        quotaUsage: views.length,
        children: views.map((view) => {
          const nodeKey = view.id;
          const children = getColumnNode(nodeKey, view.fields || []);

          return {
            children,
            className: 'adm-treeNode',
            icon: getNodeTypeIcon({ nodeType: view.nodeType }),
            id: nodeKey,
            isLeaf: false,
            key: nodeKey,
            title: <LabelTitle title={view.displayName} />,
            type: view.nodeType,
          };
        }),
      }),
    );
  }, [views]);

  return <StyledSidebarTree {...props} treeData={tree} />;
}
</file>

<file path="src/components/sidebar/SidebarMenu.tsx">
import React from 'react';
import styled from 'styled-components';
import { Menu, MenuProps } from 'antd';

const StyledMenu = styled(Menu)`
  &.ant-menu {
    background-color: transparent;
    border-right: 0;
    color: var(--gray-8);

    &:not(.ant-menu-horizontal) {
      .ant-menu-item-selected {
        color: var(--gray-8);
        background-color: var(--gray-5);
      }
    }

    .ant-menu-item-group {
      margin-top: 20px;

      &:first-child {
        margin-top: 0;
      }
    }

    .ant-menu-item-group-title {
      font-size: 12px;
      font-weight: 700;
      padding: 5px 16px;
    }

    .ant-menu-item {
      line-height: 28px;
      height: auto;
      margin: 0;
      font-weight: 500;

      &:not(last-child) {
        margin-bottom: 0;
      }

      &:not(.ant-menu-item-disabled):hover {
        color: inherit;
        background-color: var(--gray-4);
      }

      &:not(.ant-menu-item-disabled):active {
        background-color: var(--gray-6);
      }

      &:active {
        background-color: transparent;
      }

      &-selected {
        color: var(--gray-8);

        &:after {
          display: none;
        }

        &:hover {
          color: var(--gray-8);
        }
      }
    }
  }
`;

export default function SidebarMenu({
  items,
  selectedKeys,
  onSelect,
}: MenuProps) {
  return (
    <StyledMenu
      mode="inline"
      items={items}
      selectedKeys={selectedKeys}
      onSelect={onSelect}
    />
  );
}
</file>

<file path="src/components/sidebar/SidebarTree.tsx">
import Link from 'next/link';
import { useState } from 'react';
import styled, { css } from 'styled-components';
import { Tree, TreeProps } from 'antd';

const anticonStyle = css`
  [class^='anticon anticon-'] {
    transition: background-color ease-out 0.12s;
    border-radius: 2px;
    width: 12px;
    height: 12px;
    font-size: 12px;
    vertical-align: middle;

    &:hover {
      background-color: var(--gray-5);
    }
    &:active {
      background-color: var(--gray-6);
    }

    &[disabled] {
      cursor: not-allowed;
      color: var(--gray-6);
      &:hover,
      &:active {
        background-color: transparent;
      }
    }
  }
  .anticon + .anticon {
    margin-left: 4px;
  }
`;

const StyledTree = styled(Tree)`
  &.ant-tree {
    background-color: transparent;
    color: var(--gray-8);

    .ant-tree-indent-unit {
      width: 12px;
    }

    .ant-tree-node-content-wrapper {
      display: flex;
      align-items: center;
      line-height: 18px;
      min-height: 28px;
      min-width: 1px;
      padding: 0;
    }

    .ant-tree-node-content-wrapper:hover,
    .ant-tree-node-content-wrapper.ant-tree-node-selected {
      background-color: transparent;
    }

    .ant-tree-treenode {
      padding: 0 16px;
      background-color: transparent;
      transition: background-color ease-out 0.12s;

      &-selected {
        color: var(--geekblue-6);
        background-color: var(--gray-4);
      }

      .ant-tree-switcher {
        width: 12px;
        align-self: center;
        .ant-tree-switcher-icon {
          font-size: 12px;
          vertical-align: middle;
        }
        ${anticonStyle}
      }

      .ant-tree-iconEle {
        flex-shrink: 0;
      }
    }

    .adm {
      &-treeTitle__title {
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }

      &-treeNode {
        &:hover {
          background-color: var(--gray-4);
        }
        &:active {
          background-color: var(--gray-6);
        }

        .ant-tree-title {
          display: inline-flex;
          flex-wrap: nowrap;
          min-width: 1px;
        }

        &--relation,
        &--primary {
          margin-left: 4px;
        }

        &--group {
          color: var(--gray-8);
          margin-top: 16px;

          font-size: 14px;
          font-weight: 500;

          .ant-tree-switcher-noop {
            display: none;
          }

          > * {
            cursor: inherit;
          }
        }

        &--empty {
          color: var(--gray-7);
          font-size: 12px;
          .ant-tree-switcher {
            display: none;
          }
          .ant-tree-node-content-wrapper {
            min-height: auto;
          }
        }

        &--selectNode {
          * {
            cursor: auto;
          }
          &:hover,
          &:active {
            background-color: transparent;
          }
        }

        &--subtitle {
          color: var(--gray-7);
          font-size: 12px;
          font-weight: 500;
          .ant-tree-switcher {
            display: none;
          }
          .ant-tree-node-content-wrapper {
            min-height: auto;
          }
        }

        &--selectNone {
          * {
            cursor: auto;
          }
          &:hover,
          &:active {
            background-color: transparent;
          }
        }
      }

      &-actionIcon {
        font-size: 14px;
        border-radius: 2px;
        margin-right: -3px;
        &:not(.adm-actionIcon--disabled) {
          cursor: pointer;
          &:hover {
            background-color: var(--gray-5);
          }
        }
        .anticon {
          padding: 2px;
          cursor: inherit;
        }
        &--disabled {
          color: var(--gray-6);
          cursor: not-allowed;
        }
      }
    }
  }
`;

export const sidebarCommonStyle = css`
  .ant-tree-title {
    flex-grow: 1;
    display: inline-flex;
    align-items: center;
    span:first-child,
    .adm-treeTitle__title {
      flex-grow: 1;
    }
  }
`;

export const StyledTreeNodeLink = styled(Link)`
  display: block;
  cursor: pointer;
  user-select: none;
  margin-top: 16px;
  padding: 0 16px;
  line-height: 28px;
  color: var(--gray-8);
  &:hover {
    background-color: var(--gray-4);
  }
  &:active {
    background-color: var(--gray-6);
  }
  &.adm-treeNode--selected {
    background-color: var(--gray-4);
    color: var(--geekblue-6);
  }
`;

export const useSidebarTreeState = () => {
  const [treeSelectedKeys, setTreeSelectedKeys] = useState<React.Key[]>([]);
  const [treeExpandKeys, setTreeExpandKeys] = useState<React.Key[]>([]);
  const [treeLoadedKeys, setTreeLoadedKeys] = useState<React.Key[]>([]);
  const [autoExpandParent, setAutoExpandParent] = useState(true);

  return {
    treeSelectedKeys,
    treeExpandKeys,
    treeLoadedKeys,
    autoExpandParent,
    setTreeSelectedKeys,
    setTreeExpandKeys,
    setTreeLoadedKeys,
    setAutoExpandParent,
  };
};

export default function SidebarTree(props: TreeProps) {
  return (
    <StyledTree
      blockNode
      showIcon
      motion={null} // https://github.com/ant-design/ant-design/issues/16943#issuecomment-859966751
      {...props}
    />
  );
}
</file>

<file path="src/components/sidebar/utils.tsx">
import styled from 'styled-components';
import { Button } from 'antd';
import { DataNode } from 'antd/lib/tree';
import { getColumnTypeIcon } from '@/utils/columnType';
import { PrimaryKeyIcon, RelationshipIcon } from '@/utils/icons';
import { ComposeDiagramField } from '@/utils/data';
import { assign, isEmpty, snakeCase, lowerCase } from 'lodash';
import GroupTreeTitle, { ActionType } from './modeling/GroupTreeTitle';
import { getJoinTypeText } from '@/utils/data';
import { NODE_TYPE } from '@/utils/enum';
import { getNodeTypeIcon } from '@/utils/nodeType';

type TreeNode = DataNode;

const ColumnNode = ({ title, relation, primary }) => {
  const append = (
    <>
      {relation && (
        <span
          className="adm-treeNode--relation"
          title={`${relation.name}: ${getJoinTypeText(relation.joinType)}`}
        >
          <RelationshipIcon />
        </span>
      )}
      {primary && (
        <span className="adm-treeNode--primary" title="Primary Key">
          <PrimaryKeyIcon />
        </span>
      )}
    </>
  );

  return (
    <>
      <span title={title}>{title}</span>
      {append}
    </>
  );
};

const getChildrenSubtitle = (nodeKey: string, title: string) => [
  {
    title,
    key: `${nodeKey}_${snakeCase(title)}`,
    className: 'adm-treeNode--subtitle adm-treeNode--selectNone',
    selectable: false,
    isLeaf: true,
  },
];

export const getColumnNode = (
  nodeKey: string,
  columns: ComposeDiagramField[],
  title?: string,
): TreeNode[] => {
  if (columns.length === 0) return [];

  return [
    ...(title ? getChildrenSubtitle(nodeKey, title) : []),
    ...columns.map((column): TreeNode => {
      // show the model icon for relation item
      const isRelation = column.nodeType === NODE_TYPE.RELATION;
      const icon = isRelation
        ? getNodeTypeIcon({ nodeType: NODE_TYPE.MODEL })
        : getColumnTypeIcon(column, { title: column.type });

      return {
        icon,
        className: 'adm-treeNode adm-treeNode-column adm-treeNode--selectNode',
        title: (
          <ColumnNode
            title={column.displayName}
            relation={isRelation ? column : null}
            primary={column?.isPrimaryKey}
          />
        ),
        key: column.id,
        selectable: false,
        isLeaf: true,
      };
    }),
  ];
};

interface GroupSet {
  groupName: string;
  groupKey: string;
  quotaUsage?: number;
  appendSlot?: React.ReactNode;
  children?: DataNode[];
  actions: ActionType[];
}

export const createTreeGroupNode =
  (sourceData: GroupSet) => (updatedData?: Partial<GroupSet>) => {
    const {
      groupName = '',
      groupKey = '',
      quotaUsage,
      actions,
      children = [],
      appendSlot,
    } = assign(sourceData, updatedData);

    const emptyChildren = [
      {
        title: `No ${lowerCase(groupName)}`,
        key: `${groupKey}-empty`,
        selectable: false,
        className: 'adm-treeNode adm-treeNode--empty adm-treeNode--selectNode',
      },
    ];
    const childrenData = isEmpty(children) ? emptyChildren : children;

    return [
      {
        className: 'adm-treeNode--group',
        title: (
          <GroupTreeTitle
            title={groupName}
            quotaUsage={quotaUsage}
            appendSlot={appendSlot}
            actions={actions}
          />
        ),
        key: groupKey,
        selectable: false,
        isLeaf: true,
      },
      ...childrenData,
    ];
  };

export const GroupActionButton = styled(Button)`
  font-size: 12px;
  height: auto;
  background: transparent;
  color: var(--gray-8);
  &:hover {
    background-color: transparent;
  }
  &:focus {
    border-color: var(--gray-5);
    background: transparent;
    color: var(--gray-8);
  }
`;
</file>

<file path="src/components/table/BaseTable.tsx">
import { useMemo } from 'react';
import { Table, TableProps, Row, Col } from 'antd';
import EllipsisWrapper from '@/components/EllipsisWrapper';
import SQLCodeBlock from '@/components/code/SQLCodeBlock';
import { getColumnTypeIcon } from '@/utils/columnType';
import { ComposeDiagramField, getJoinTypeText } from '@/utils/data';
import { makeIterable } from '@/utils/iteration';

export const COLUMN = {
  ALIAS: {
    title: 'Alias',
    dataIndex: 'displayName',
    key: 'alias',
    ellipsis: true,
    render: (name) => name || '-',
  },
  NAME: {
    title: 'Name',
    dataIndex: 'referenceName',
    key: 'referenceName',
    ellipsis: true,
    render: (name) => name || '-',
  },
  TYPE: {
    title: 'Type',
    dataIndex: 'type',
    render: (type) => {
      return (
        <div className="d-flex align-center">
          {getColumnTypeIcon({ type }, { className: 'mr-2' })}
          {type}
        </div>
      );
    },
  },
  EXPRESSION: {
    title: 'Expression',
    dataIndex: 'expression',
    key: 'expression',
    render: (expression) => {
      return (
        <EllipsisWrapper text={expression}>
          <SQLCodeBlock code={expression} inline />
        </EllipsisWrapper>
      );
    },
  },
  RELATION_FROM: {
    title: 'From',
    key: 'fromField',
    ellipsis: true,
    render: (relation) =>
      `${relation.fromModelDisplayName}.${relation.fromColumnDisplayName}`,
  },
  RELATION_TO: {
    title: 'To',
    key: 'toField',
    ellipsis: true,
    render: (relation) =>
      `${relation.toModelDisplayName}.${relation.toColumnDisplayName}`,
  },
  RELATION: {
    title: 'Type',
    dataIndex: 'type',
    key: 'joinType',
    render: (joinType) => getJoinTypeText(joinType),
  },
  DESCRIPTION: {
    title: 'Description',
    dataIndex: 'description',
    key: 'description',
    ellipsis: true,
    render: (text) => text || '-',
  },
};

type BaseTableProps = TableProps<ComposeDiagramField>;

export type Props = BaseTableProps & {
  showExpandable?: boolean;
  actionColumns?: BaseTableProps['columns'];
};

export default function BaseTable(props: Props) {
  const { dataSource = [], columns = [], actionColumns, ...restProps } = props;

  const tableColumns = useMemo(
    () => columns.concat(actionColumns || []),
    [dataSource],
  );

  const tableData = useMemo(
    () =>
      (dataSource || []).map((record, index) => ({
        ...record,
        key: `${record.id}-${index}`,
      })),
    [dataSource],
  );

  return (
    <Table
      {...restProps}
      dataSource={tableData}
      showHeader={tableData.length > 0}
      columns={tableColumns}
      pagination={{
        hideOnSinglePage: true,
        pageSize: 10,
        size: 'small',
      }}
    />
  );
}

const ExpandableRowIterator = makeIterable((props) => {
  const { title, value, index } = props;
  return (
    <>
      {index > 0 && <div className="border-b border-gray-5" />}
      <Row wrap={false} className="py-1 px-2">
        <Col span={6} className="gray-6">
          {title}
        </Col>
        <Col style={{ wordBreak: 'break-word' }}>{value}</Col>
      </Row>
    </>
  );
});

export function ExpandableRows(props) {
  const { data, extra } = props;
  return (
    <div className="pl-12 text-sm gray-8 -my-1">
      <ExpandableRowIterator data={data} />
      {extra}
    </div>
  );
}
</file>

<file path="src/components/table/CalculatedFieldTable.tsx">
import BaseTable, {
  Props,
  COLUMN,
  ExpandableRows,
} from '@/components/table/BaseTable';

export default function CalculatedFieldTable(props: Props) {
  const { columns, showExpandable } = props;
  return (
    <BaseTable
      {...props}
      columns={
        columns || [
          { ...COLUMN.NAME, dataIndex: 'displayName', width: 160 },
          COLUMN.EXPRESSION,
          { ...COLUMN.DESCRIPTION, width: 160 },
        ]
      }
      expandable={
        showExpandable
          ? {
              expandedRowRender: (record) => (
                <ExpandableRows
                  data={[
                    { title: 'Description', value: record.description || '-' },
                  ]}
                />
              ),
            }
          : null
      }
    />
  );
}
</file>

<file path="src/components/table/EditableBaseTable.tsx">
import React, { useEffect, useState } from 'react';
import { set, cloneDeep, isEmpty } from 'lodash';
import { COLUMN, Props as BaseTableProps } from '@/components/table/BaseTable';
import EditableWrapper from '@/components/EditableWrapper';

type Props = Omit<BaseTableProps, 'onChange'> & {
  onChange?: (value: any) => void;
};

const EditableCell = (props) => {
  const {
    className,
    colSpan,
    title,
    editable,
    record,
    handleSave,
    dataIndex,
    children,
  } = props;
  const childNode = editable ? (
    <EditableWrapper
      record={record}
      dataIndex={dataIndex}
      handleSave={handleSave}
    >
      {children}
    </EditableWrapper>
  ) : (
    children
  );
  return (
    <td className={className} title={title} colSpan={colSpan}>
      {childNode}
    </td>
  );
};

export const makeEditableBaseTable = (BaseTable: React.FC<BaseTableProps>) => {
  const EditableBaseTable = (props: Props) => {
    const { columns, dataSource, onChange, ...restProps } = props;
    const [data, setData] = useState(dataSource);
    const components = {
      body: { cell: !isEmpty(dataSource) ? EditableCell : undefined },
    };

    useEffect(() => {
      onChange && onChange(data);
    }, [data]);

    const handleSave = (id: string, value: { [key: string]: string }) => {
      const [dataIndexKey] = Object.keys(value);

      // sync value back to data state
      const newData = cloneDeep(data);
      newData.forEach((item) => {
        if (id === item.id) set(item, dataIndexKey, value[dataIndexKey]);
      });

      setData(newData);
    };

    const tableColumns = columns.map((column) => ({
      ...column,
      onCell: (record) => ({
        editable: [COLUMN.ALIAS.title, COLUMN.DESCRIPTION.title].includes(
          column.title as string,
        ),
        dataIndex: (column as any).dataIndex,
        record,
        handleSave,
      }),
    })) as Props['columns'];

    return (
      <BaseTable
        {...restProps}
        size="small"
        dataSource={data}
        columns={tableColumns}
        components={components}
      />
    );
  };

  return EditableBaseTable;
};
</file>

<file path="src/components/table/FieldTable.tsx">
import { Row, Col } from 'antd';
import BaseTable, {
  Props,
  COLUMN,
  ExpandableRows,
} from '@/components/table/BaseTable';
import NestedFieldTable from '@/components/table/NestedFieldTable';

export default function FieldTable(props: Props) {
  const { columns, showExpandable, expandable } = props;
  return (
    <BaseTable
      {...props}
      columns={
        columns || [COLUMN.NAME, COLUMN.ALIAS, COLUMN.TYPE, COLUMN.DESCRIPTION]
      }
      expandable={
        showExpandable
          ? expandable || {
              expandedRowRender: (record) => {
                return (
                  <>
                    <ExpandableRows
                      data={[
                        {
                          title: 'Description',
                          value: record.description || '-',
                        },
                      ]}
                      extra={
                        record.nestedFields && (
                          <div>
                            <Row wrap={false} className="py-1 px-2">
                              <Col span={6} className="gray-6">
                                Nested columns
                              </Col>
                              <Col style={{ wordBreak: 'break-word' }}>
                                {record.nestedFields.length} column(s)
                              </Col>
                            </Row>
                            <NestedFieldTable
                              dataSource={record.nestedFields as any}
                            />
                          </div>
                        )
                      }
                    />
                  </>
                );
              },
            }
          : null
      }
    />
  );
}
</file>

<file path="src/components/table/ModelRelationSelectionTable.tsx">
import type { ColumnsType } from 'antd/es/table';
import { JOIN_TYPE } from '@/utils/enum';
import { ModelIcon } from '@/utils/icons';
import SelectionTable from '@/components/table/SelectionTable';

interface ModelField {
  modelId: string;
  modelName: string;
  fieldId: string;
  fieldName: string;
}

export interface RelationsDataType {
  name: string;
  fromField: ModelField;
  isAutoGenerated: boolean;
  type: JOIN_TYPE;
  toField: ModelField;
  properties: Record<string, any>;
}

interface Props {
  columns: ColumnsType<RelationsDataType>;
  dataSource: RelationsDataType[];
  enableRowSelection?: boolean;
  extra?: (
    onCollapseOpen: (
      event: React.MouseEvent<HTMLElement, MouseEvent>,
      key: string,
    ) => void,
  ) => React.ReactNode;
  onChange?: (value: any | null) => void;
  tableTitle: string;
  rowKey: (record: RelationsDataType) => string;
}

export default function ModelRelationSelectionTable(props: Props) {
  return (
    <SelectionTable
      {...props}
      tableHeader={
        <>
          <ModelIcon className="pr-2 text-md" />
          {props.tableTitle}
        </>
      }
    />
  );
}
</file>

<file path="src/components/table/MultiSelectBox.tsx">
import { useState, useMemo, useContext } from 'react';
import styled from 'styled-components';
import { isString, difference } from 'lodash';
import { Input, Table } from 'antd';
import { ColumnsType } from 'antd/lib/table';
import SearchOutlined from '@ant-design/icons/SearchOutlined';
import {
  FormItemInputContext,
  FormItemStatusContextProps,
} from 'antd/lib/form/context';

const StyledBox = styled.div`
  border: 1px solid var(--gray-5);
  border-radius: 4px;

  &.multiSelectBox-input-error {
    border-color: var(--red-5);
  }

  .ant-table {
    border: 0;
  }
  .ant-table-body,
  .ant-table-placeholder {
    height: 195px;
  }
`;

const StyledTotal = styled.div`
  padding: 8px 12px;
  border-bottom: 1px var(--gray-3) solid;
`;

interface Props {
  columns: ColumnsType<any>;
  loading: boolean;
  items: { [key: string]: any; value: string }[];
  value?: string[];
  onChange?: (value: string[]) => void;
}

export default function MultiSelectBox(props: Props) {
  const { columns, loading, items, onChange, value } = props;
  const [selectedRowKeys, setSelectedRowKeys] = useState<Set<string>>(
    new Set(value),
  );
  const [searchValue, setSearchValue] = useState<string>('');
  const formItemContext =
    useContext<FormItemStatusContextProps>(FormItemInputContext);
  const { status } = formItemContext;

  const dataSource = useMemo(() => {
    return searchValue
      ? items.filter((item) =>
          columns
            .map((column) => item[column['dataIndex']])
            .some((value) => isString(value) && value.includes(searchValue)),
        )
      : items;
  }, [items, searchValue]);

  const onSelect = (rowKey: string) => {
    const newSelectedRowKey = new Set(selectedRowKeys);
    if (newSelectedRowKey.has(rowKey)) {
      newSelectedRowKey.delete(rowKey);
    } else {
      newSelectedRowKey.add(rowKey);
    }
    setSelectedRowKeys(newSelectedRowKey);
    onChange && onChange(Array.from(newSelectedRowKey));
  };

  const onSearchChange = (event) => {
    event.persist();
    const { value } = event.target;
    setSearchValue(value);
  };

  const total =
    selectedRowKeys.size === 0
      ? items.length
      : `${selectedRowKeys.size}/${items.length}`;

  return (
    <StyledBox
      className={status ? `multiSelectBox-input-${status}` : undefined}
    >
      <StyledTotal>{total} table(s)</StyledTotal>
      <div className="p-2">
        <Input
          prefix={<SearchOutlined />}
          onChange={onSearchChange}
          placeholder="Search here"
          allowClear
        />
      </div>
      <Table
        rowSelection={{
          type: 'checkbox',
          selectedRowKeys: Array.from(selectedRowKeys),
          onSelect: (record) => onSelect(record['value']),
          onChange(keys) {
            // deselect all
            if (keys.length === 0) {
              const tableKeys = dataSource.map((item) => item.value);
              const newSelectedRowKeys = difference(
                [...selectedRowKeys.values()],
                tableKeys,
              );
              const newSelectedRowKeySet = new Set(newSelectedRowKeys);
              setSelectedRowKeys(newSelectedRowKeySet);
              onChange && onChange(Array.from(newSelectedRowKeySet));
              return;
            }
            // select all
            if (keys.length === dataSource.length) {
              const newSelectedRowKeys = [
                ...selectedRowKeys,
                ...(keys as string[]),
              ];
              const newSelectedRowKeysSet = new Set(newSelectedRowKeys);
              setSelectedRowKeys(newSelectedRowKeysSet);
              onChange && onChange(Array.from(newSelectedRowKeysSet));
            }
          },
        }}
        rowKey={(record) => record.value}
        columns={columns}
        dataSource={dataSource}
        scroll={{ y: 195 }}
        pagination={false}
        loading={loading}
      />
    </StyledBox>
  );
}
</file>

<file path="src/components/table/NestedFieldTable.tsx">
import { COLUMN } from '@/components/table/BaseTable';
import { Table, TableProps } from 'antd';
import { DiagramModelNestedField } from '@/apollo/client/graphql/__types__';

type Props = TableProps<DiagramModelNestedField>;

export default function NestedFieldTable(props: Props) {
  const { columns } = props;
  return (
    <Table
      {...props}
      columns={
        columns || [
          { ...COLUMN.NAME, width: 70 },
          { ...COLUMN.ALIAS, width: 70 },
          { ...COLUMN.TYPE, width: 45 },
          { ...COLUMN.DESCRIPTION, width: 80 },
        ]
      }
      className="ant-table--text-sm ml-2"
      scroll={{ x: 600 }}
      size="small"
      pagination={{
        hideOnSinglePage: true,
        size: 'small',
        pageSize: 10,
      }}
    />
  );
}
</file>

<file path="src/components/table/RelationTable.tsx">
import BaseTable, {
  Props,
  COLUMN,
  ExpandableRows,
} from '@/components/table/BaseTable';

export default function RelationTable(props: Props) {
  const { columns, showExpandable } = props;
  return (
    <BaseTable
      {...props}
      columns={
        columns || [
          { ...COLUMN.NAME, dataIndex: 'displayName' },
          COLUMN.RELATION_FROM,
          COLUMN.RELATION_TO,
          COLUMN.RELATION,
          { ...COLUMN.DESCRIPTION, width: 160 },
        ]
      }
      expandable={
        showExpandable
          ? {
              expandedRowRender: (record) => (
                <ExpandableRows
                  data={[
                    {
                      title: 'From',
                      value: `${record.fromModelDisplayName}.${record.fromColumnDisplayName}`,
                    },
                    {
                      title: 'To',
                      value: `${record.toModelDisplayName}.${record.toColumnDisplayName}`,
                    },
                    { title: 'Description', value: record.description || '-' },
                  ]}
                />
              ),
            }
          : null
      }
    />
  );
}
</file>

<file path="src/components/table/SelectionTable.tsx">
import { forwardRef, useContext, useState } from 'react';
import styled from 'styled-components';
import { Collapse, Row, RowProps, Table, TableProps } from 'antd';
import {
  FormItemInputContext,
  FormItemStatusContextProps,
} from 'antd/lib/form/context';

const { Panel } = Collapse;

const StyledCollapse = styled(Collapse)`
  &.ant-collapse.adm-error {
    border-color: var(--red-5);
    border-bottom: 1px solid var(--red-5);
  }

  &.ant-collapse {
    background-color: white;
    border-color: var(--gray-4);

    > .ant-collapse-item > .ant-collapse-header {
      padding: 16px 12px;
      align-items: center;
    }

    > .ant-collapse-item,
    .ant-collapse-content {
      border-color: var(--gray-4);
    }

    .ant-collapse-content-box {
      padding: 0px;
    }

    .ant-table {
      border: none;

      .ant-table-thead > tr > th {
        color: var(--gray-7);
        background-color: white;
      }

      &.ant-table-empty {
        .ant-empty-normal {
          margin: 16px 0;
        }
      }
    }
  }
`;

const StyledRow = styled(Row).attrs<{
  $isRowSelection: boolean;
}>((props) => ({
  className: `${props.$isRowSelection ? '' : 'ml-1'}`,
}))`` as React.ForwardRefExoticComponent<
  RowProps & React.RefAttributes<HTMLDivElement> & { $isRowSelection: boolean }
>;

type Props<T> = TableProps<T> & {
  enableRowSelection?: boolean;
  extra?: (
    onCollapseOpen: (
      event: React.MouseEvent<HTMLElement, MouseEvent>,
      collapseKey: string,
    ) => void,
  ) => React.ReactNode;
  onChange?: (value: any | null) => void;
  rowKey: (record: T) => string;
  tableTitle: string;
  tableHeader: React.ReactNode;
};

function SelectionTable<T extends Record<string, any>>(
  props: Props<T>,
  ref: React.Ref<HTMLDivElement>,
) {
  const {
    columns,
    dataSource,
    extra,
    enableRowSelection,
    onChange,
    rowKey,
    tableHeader,
    tableTitle,
  } = props;

  const formItemContext =
    useContext<FormItemStatusContextProps>(FormItemInputContext);
  const { status } = formItemContext;

  const collapseState = useCollapseState(tableTitle);

  const isRowSelection = Boolean(enableRowSelection);

  const rowSelection: TableProps<T>['rowSelection'] = isRowSelection
    ? {
        type: 'checkbox',
        onChange: (_selectedRowKeys: React.Key[], selectedRows) => {
          onChange && onChange(selectedRows);
        },
      }
    : undefined;

  return (
    <StyledCollapse
      className={status ? `adm-${status}` : ''}
      defaultActiveKey={collapseState.collapseDefaultActiveKey}
      onChange={collapseState.onChangeCollapsePanelState}
    >
      <Panel
        extra={extra && extra(collapseState.onCollapseOpen)}
        header={
          <StyledRow
            wrap={false}
            gutter={8}
            align="middle"
            $isRowSelection={isRowSelection}
          >
            {tableHeader}
          </StyledRow>
        }
        key={tableTitle}
        showArrow={false}
      >
        <Table
          ref={ref}
          columns={columns}
          dataSource={dataSource}
          rowKey={rowKey}
          rowSelection={rowSelection}
          pagination={{ hideOnSinglePage: true, pageSize: 50, size: 'small' }}
        />
      </Panel>
    </StyledCollapse>
  );
}

export default forwardRef(SelectionTable);

function useCollapseState(tableTitleName: string) {
  const [collapseDefaultActiveKey, setCollapseDefaultActiveKey] = useState<
    string[]
  >([tableTitleName]);

  const onChangeCollapsePanelState = (key: string | string[]) =>
    setCollapseDefaultActiveKey(key as string[]);

  const onCollapseOpen = (
    event: React.MouseEvent<HTMLElement, MouseEvent>,
    collapseKey: string,
  ) => {
    // Make sure the panel is open
    onChangeCollapsePanelState([collapseKey]);
    if (collapseDefaultActiveKey.includes(collapseKey)) {
      event.stopPropagation();
    }
  };

  return {
    collapseDefaultActiveKey,
    onChangeCollapsePanelState,
    onCollapseOpen,
  };
}
</file>

<file path="src/components/table/TableTransfer.tsx">
import React from 'react';
import styled from 'styled-components';
import { Table, Transfer, Tag } from 'antd';
import difference from 'lodash/difference';
import { TransferItem, TransferProps } from 'antd/es/transfer';
import { ColumnsType, TableRowSelection } from 'antd/es/table/interface';

const StyledTable = styled(Table)`
  .ant-table-row {
    cursor: pointer;
  }
  .ant-table-row-disabled {
    cursor: not-allowed;
    color: var(--gray-5);
    .ant-tag {
      color: var(--gray-5);
    }
  }
`;

// default left and right columns
export const defaultColumns = [
  {
    dataIndex: 'name',
    title: 'Column Name',
  },
  {
    dataIndex: 'type',
    title: 'Column Type',
    render: (type: string) => <Tag>{type.toUpperCase()}</Tag>,
  },
];

interface TableTransferProps extends TransferProps<TransferItem> {
  dataSource: any[];
  leftColumns?: ColumnsType<any>;
  rightColumns?: ColumnsType<any>;
}

const TableTransfer = (
  {
    leftColumns = defaultColumns,
    rightColumns = defaultColumns,
    ...restProps
  }: TableTransferProps,
  ref: any,
) => {
  return (
    <Transfer {...restProps} showSelectAll={false} listStyle={{ height: 332 }}>
      {({
        direction,
        filteredItems,
        onItemSelectAll,
        onItemSelect,
        selectedKeys: listSelectedKeys,
        disabled: listDisabled,
      }) => {
        const columns = direction === 'left' ? leftColumns : rightColumns;

        const rowSelection: TableRowSelection<TransferItem> = {
          getCheckboxProps: (item) => ({
            disabled: listDisabled || item.disabled,
          }),
          onSelectAll(selected, selectedRows) {
            const treeSelectedKeys = selectedRows
              .filter((item) => !item.disabled)
              .map(({ key }) => key);
            const diffKeys = selected
              ? difference(treeSelectedKeys, listSelectedKeys)
              : difference(listSelectedKeys, treeSelectedKeys);
            onItemSelectAll(diffKeys as string[], selected);
          },
          onSelect({ key }, selected) {
            onItemSelect(key as string, selected);
          },
          selectedRowKeys: listSelectedKeys,
        };

        return (
          <div ref={ref}>
            <StyledTable
              rowSelection={rowSelection}
              columns={columns}
              dataSource={filteredItems}
              size="small"
              style={
                {
                  pointerEvents: listDisabled ? 'none' : null,
                } as React.CSSProperties
              }
              onRow={({ key, disabled: itemDisabled, title }: any) => ({
                title,
                onClick: () => {
                  if (itemDisabled || listDisabled) return;
                  onItemSelect(
                    key as string,
                    !listSelectedKeys.includes(key as string),
                  );
                },
              })}
              rowClassName={({ disabled: itemDisabled }: any) =>
                itemDisabled ? 'ant-table-row-disabled' : ''
              }
              scroll={{ y: 200 }}
              pagination={false}
            />
          </div>
        );
      }}
    </Transfer>
  );
};

export default React.forwardRef(TableTransfer);
</file>

<file path="src/hooks/useAdjustAnswer.tsx">
import { useEffect, useMemo } from 'react';
import { cloneDeep } from 'lodash';
import { ApolloClient, NormalizedCacheObject } from '@apollo/client';
import { THREAD } from '@/apollo/client/graphql/home';
import { nextTick } from '@/utils/time';
import {
  useAdjustThreadResponseMutation,
  useCancelAdjustmentTaskMutation,
  useRerunAdjustmentTaskMutation,
  useThreadResponseLazyQuery,
} from '@/apollo/client/graphql/home.generated';
import {
  AskingTaskStatus,
  DetailedThread,
  ThreadResponse,
} from '@/apollo/client/graphql/__types__';

export const getIsFinished = (status: AskingTaskStatus) =>
  [
    AskingTaskStatus.FINISHED,
    AskingTaskStatus.FAILED,
    AskingTaskStatus.STOPPED,
  ].includes(status);

const handleUpdateThreadCache = (
  threadId: number,
  threadResponse: ThreadResponse,
  client: ApolloClient<NormalizedCacheObject>,
) => {
  const result = client.cache.readQuery<{ thread: DetailedThread }>({
    query: THREAD,
    variables: { threadId },
  });

  if (result?.thread) {
    client.cache.updateQuery(
      {
        query: THREAD,
        variables: { threadId },
      },
      (existingData) => {
        const isNewResponse = !existingData.thread.responses
          .map((r) => r.id)
          .includes(threadResponse.id);
        return {
          thread: {
            ...existingData.thread,
            responses: isNewResponse
              ? [...existingData.thread.responses, threadResponse]
              : existingData.thread.responses.map((response) => {
                  return response.id === threadResponse.id
                    ? cloneDeep(threadResponse)
                    : response;
                }),
          },
        };
      },
    );
  }
};

export default function useAdjustAnswer(threadId?: number) {
  const [cancelAdjustmentTask] = useCancelAdjustmentTaskMutation();
  const [rerunAdjustmentTask] = useRerunAdjustmentTaskMutation();
  const [adjustThreadResponse, adjustThreadResponseResult] =
    useAdjustThreadResponseMutation();
  const [fetchThreadResponse, threadResponseResult] =
    useThreadResponseLazyQuery({
      pollInterval: 1000,
    });

  const loading = adjustThreadResponseResult.loading;

  const adjustmentTask = useMemo(() => {
    return threadResponseResult.data?.threadResponse.adjustmentTask || null;
  }, [threadResponseResult.data]);

  const data = useMemo(() => {
    return {
      adjustmentTask,
    };
  }, [adjustmentTask]);

  useEffect(() => {
    const isFinished = getIsFinished(adjustmentTask?.status);
    if (isFinished) threadResponseResult.stopPolling();
  }, [adjustmentTask?.status]);

  const onAdjustReasoningSteps = async (
    responseId: number,
    input: { tables: string[]; sqlGenerationReasoning: string },
  ) => {
    const response = await adjustThreadResponse({
      variables: {
        responseId,
        data: {
          tables: input.tables,
          sqlGenerationReasoning: input.sqlGenerationReasoning,
        },
      },
    });

    // start polling new thread response
    const nextThreadResponse = response.data?.adjustThreadResponse;
    await fetchThreadResponse({
      variables: { responseId: nextThreadResponse.id },
    });

    // update new thread response to cache
    handleUpdateThreadCache(
      threadId,
      nextThreadResponse,
      threadResponseResult.client,
    );
  };

  const onAdjustSQL = async (responseId: number, sql: string) => {
    const response = await adjustThreadResponse({
      variables: { responseId, data: { sql } },
    });

    // update thread cache
    const nextThreadResponse = response.data?.adjustThreadResponse;
    handleUpdateThreadCache(
      threadId,
      nextThreadResponse,
      threadResponseResult.client,
    );

    // It won't have adjusmentTask, no need to fetch
  };

  const onStop = async (queryId?: string) => {
    const taskId =
      queryId ||
      adjustThreadResponseResult.data?.adjustThreadResponse?.adjustmentTask
        ?.queryId;
    if (taskId) {
      await cancelAdjustmentTask({ variables: { taskId } });
      // waiting for polling fetching stop
      await nextTick(1000);
    }
  };

  const onReRun = async (threadResponse: ThreadResponse) => {
    const responseId = threadResponse.id;
    await rerunAdjustmentTask({ variables: { responseId } });
    await fetchThreadResponse({ variables: { responseId } });
  };

  return {
    data,
    loading,
    onAdjustReasoningSteps,
    onAdjustSQL,
    onStop,
    onReRun,
  };
}
</file>

<file path="src/hooks/useAskingStreamTask.tsx">
import { useRef, useState } from 'react';

type useAskingStreamTaskReturn = [
  (queryId: string) => void,
  { data: string; loading: boolean; reset: () => void },
];

export default function useAskingStreamTask() {
  const eventSourceRef = useRef<EventSource | null>(null);
  const [loading, setLoading] = useState<boolean>(false);
  const [data, setData] = useState<string>('');

  const reset = () => {
    if (eventSourceRef.current) {
      eventSourceRef.current?.close();
      eventSourceRef.current = null;
    }
    setData('');
  };

  const fetchAskingStreamingTask = (queryId: string) => {
    setLoading(true);
    reset();

    const eventSource = new EventSource(
      `/api/ask_task/streaming?queryId=${queryId}`,
    );

    eventSource.onmessage = (event) => {
      const eventData = JSON.parse(event.data);
      if (eventData.done) {
        eventSource.close();
        setLoading(false);
      } else {
        setData((state) => state + (eventData?.message || ''));
      }
    };

    eventSource.onerror = (error) => {
      console.error(error);
      eventSource.close();
      setLoading(false);
    };

    eventSourceRef.current = eventSource;
  };

  return [
    fetchAskingStreamingTask,
    { data, loading, reset },
  ] as useAskingStreamTaskReturn;
}
</file>

<file path="src/hooks/useAskProcessState.tsx">
import { useState } from 'react';
import { PROCESS_STATE } from '@/utils/enum';
import {
  AskingTask,
  AskingTaskStatus,
  AskingTaskType,
} from '@/apollo/client/graphql/__types__';

export const getIsProcessing = (status: PROCESS_STATE) =>
  [
    PROCESS_STATE.UNDERSTANDING,
    PROCESS_STATE.SEARCHING,
    PROCESS_STATE.PLANNING,
    PROCESS_STATE.GENERATING,
    PROCESS_STATE.CORRECTING,
  ].includes(status);

export const convertAskingTaskToProcessState = (data: AskingTask) => {
  if (!data) return null;

  const processState = {
    [AskingTaskStatus.UNDERSTANDING]: PROCESS_STATE.UNDERSTANDING,
    [AskingTaskStatus.SEARCHING]: PROCESS_STATE.SEARCHING,
    [AskingTaskStatus.PLANNING]: PROCESS_STATE.PLANNING,
    [AskingTaskStatus.GENERATING]: PROCESS_STATE.GENERATING,
    [AskingTaskStatus.CORRECTING]: PROCESS_STATE.CORRECTING,
    [AskingTaskStatus.FINISHED]: PROCESS_STATE.FINISHED,
    [AskingTaskStatus.STOPPED]: PROCESS_STATE.STOPPED,
    [AskingTaskStatus.FAILED]: PROCESS_STATE.FAILED,
  }[data.status];

  if (
    data?.type === AskingTaskType.TEXT_TO_SQL &&
    processState === PROCESS_STATE.FINISHED &&
    data.candidates.length === 0
  ) {
    return PROCESS_STATE.NO_RESULT;
  }
  return processState;
};

export default function useAskProcessState() {
  const [currentState, setCurrentState] = useState<PROCESS_STATE>(
    PROCESS_STATE.IDLE,
  );

  const resetState = () => {
    setCurrentState(PROCESS_STATE.IDLE);
  };

  const matchedState = (askingTask: AskingTask) => {
    const targetState = convertAskingTaskToProcessState(askingTask);
    if (!targetState || targetState === currentState) return currentState;
    // Prevent unknown status, if not found we keep the current state
    if (ProcessStateMachine.canTransition(currentState, targetState)) {
      return targetState;
    } else {
      console.warn(
        `Invalid transition from ${currentState} to ${targetState}.`,
      );
      return currentState;
    }
  };

  const transitionTo = (targetState: PROCESS_STATE) => {
    setCurrentState(targetState);
  };

  const isFinished = () => {
    return currentState === PROCESS_STATE.FINISHED;
  };

  const isFailed = () => {
    return currentState === PROCESS_STATE.FAILED;
  };

  return {
    currentState,
    resetState,
    matchedState,
    transitionTo,
    isFinished,
    isFailed,
  };
}

export class ProcessStateMachine {
  private static transitions = {
    [PROCESS_STATE.IDLE]: {
      next: [PROCESS_STATE.UNDERSTANDING],
      prev: [],
    },
    [PROCESS_STATE.UNDERSTANDING]: {
      // probably skipped status if polling delay longer than AI processing time
      // so need to allow all possible statuses
      next: [
        PROCESS_STATE.SEARCHING,
        PROCESS_STATE.PLANNING,
        PROCESS_STATE.GENERATING,
      ],
      prev: [PROCESS_STATE.IDLE],
    },
    [PROCESS_STATE.SEARCHING]: {
      next: [PROCESS_STATE.PLANNING],
      prev: [PROCESS_STATE.UNDERSTANDING],
    },
    [PROCESS_STATE.PLANNING]: {
      next: [PROCESS_STATE.GENERATING],
      prev: [PROCESS_STATE.SEARCHING],
    },
    [PROCESS_STATE.GENERATING]: {
      next: [
        PROCESS_STATE.CORRECTING,
        PROCESS_STATE.FINISHED,
        PROCESS_STATE.FAILED,
      ],
      prev: [PROCESS_STATE.PLANNING],
    },
    [PROCESS_STATE.CORRECTING]: {
      next: [PROCESS_STATE.FINISHED, PROCESS_STATE.FAILED],
      prev: [PROCESS_STATE.GENERATING],
    },
    [PROCESS_STATE.FINISHED]: {
      next: [],
      prev: [PROCESS_STATE.GENERATING, PROCESS_STATE.CORRECTING],
    },
  };

  static canTransition(from: PROCESS_STATE, to: PROCESS_STATE) {
    // Allow transition to FINISHED & FAILED state from any state
    return (
      from === PROCESS_STATE.IDLE ||
      to === PROCESS_STATE.FINISHED ||
      to === PROCESS_STATE.FAILED ||
      to === PROCESS_STATE.STOPPED ||
      this.transitions[from]?.next.includes(to)
    );
  }

  static getAllNextStates(state: PROCESS_STATE, includeSelf = false) {
    const allNextStates = new Set<PROCESS_STATE>(includeSelf ? [state] : []);
    const collectNextStates = (currentState: PROCESS_STATE) => {
      const nextStates = this.transitions[currentState]?.next || [];
      nextStates.forEach((nextState) => {
        if (!allNextStates.has(nextState)) {
          allNextStates.add(nextState);
          collectNextStates(nextState);
        }
      });
    };
    collectNextStates(state);
    return Array.from(allNextStates);
  }
}
</file>

<file path="src/hooks/useAskPrompt.tsx">
import { useCallback, useEffect, useMemo, useState } from 'react';
import { cloneDeep, uniq } from 'lodash';
import {
  AdjustmentTask,
  AskingTask,
  AskingTaskStatus,
  AskingTaskType,
  DetailedThread,
  RecommendedQuestionsTask,
  RecommendedQuestionsTaskStatus,
  ThreadResponse,
} from '@/apollo/client/graphql/__types__';
import {
  useAskingTaskLazyQuery,
  useCancelAskingTaskMutation,
  useCreateAskingTaskMutation,
  useRerunAskingTaskMutation,
  useCreateInstantRecommendedQuestionsMutation,
  useInstantRecommendedQuestionsLazyQuery,
} from '@/apollo/client/graphql/home.generated';
import useAskingStreamTask from './useAskingStreamTask';
import { THREAD } from '@/apollo/client/graphql/home';
import { ApolloClient, NormalizedCacheObject } from '@apollo/client';
import { nextTick } from '@/utils/time';

export interface AskPromptData {
  originalQuestion: string;
  askingTask?: AskingTask;
  askingStreamTask?: string;
  recommendedQuestions?: RecommendedQuestionsTask;
}

export const getIsFinished = (status: AskingTaskStatus) =>
  [
    AskingTaskStatus.FINISHED,
    AskingTaskStatus.FAILED,
    AskingTaskStatus.STOPPED,
  ].includes(status);

export const canGenerateAnswer = (
  askingTask: AskingTask,
  adjustmentTask: AdjustmentTask,
) =>
  (askingTask === null && adjustmentTask === null) ||
  askingTask?.status === AskingTaskStatus.FINISHED ||
  adjustmentTask?.status === AskingTaskStatus.FINISHED;

export const canFetchThreadResponse = (askingTask: AskingTask) =>
  askingTask !== null &&
  askingTask?.status !== AskingTaskStatus.FAILED &&
  askingTask?.status !== AskingTaskStatus.STOPPED;

export const isReadyToThreadResponse = (askingTask: AskingTask) =>
  askingTask?.status === AskingTaskStatus.SEARCHING &&
  askingTask?.type === AskingTaskType.TEXT_TO_SQL;

export const isRecommendedFinished = (status: RecommendedQuestionsTaskStatus) =>
  [
    RecommendedQuestionsTaskStatus.FINISHED,
    RecommendedQuestionsTaskStatus.FAILED,

    // for existing thread response & existing projects that are not executed to generate recommendation questions
    RecommendedQuestionsTaskStatus.NOT_STARTED,
  ].includes(status);

const isNeedRecommendedQuestions = (askingTask: AskingTask) => {
  const isGeneralOrMisleadingQuery = [
    AskingTaskType.GENERAL,
    AskingTaskType.MISLEADING_QUERY,
  ].includes(askingTask?.type);
  const isFailed =
    askingTask?.type !== AskingTaskType.TEXT_TO_SQL &&
    askingTask?.status === AskingTaskStatus.FAILED;
  return isGeneralOrMisleadingQuery || isFailed;
};

const isNeedPreparing = (askingTask: AskingTask) =>
  askingTask?.type === AskingTaskType.TEXT_TO_SQL;

const handleUpdateThreadCache = (
  threadId: number,
  askingTask: AskingTask,
  client: ApolloClient<NormalizedCacheObject>,
) => {
  if (!askingTask) return;

  const result = client.cache.readQuery<{ thread: DetailedThread }>({
    query: THREAD,
    variables: { threadId },
  });

  if (result?.thread) {
    client.cache.updateQuery(
      {
        query: THREAD,
        variables: { threadId },
      },
      (existingData) => {
        return {
          thread: {
            ...existingData.thread,
            responses: existingData.thread.responses.map((response) => {
              if (response.askingTask?.queryId === askingTask?.queryId) {
                return {
                  ...response,
                  askingTask: cloneDeep(askingTask),
                };
              }
              return response;
            }),
          },
        };
      },
    );
  }
};

const handleUpdateRerunAskingTaskCache = (
  threadId: number,
  threadResponseId: number,
  askingTask: AskingTask,
  client: ApolloClient<NormalizedCacheObject>,
) => {
  if (!askingTask) return;

  const result = client.cache.readQuery<{ thread: DetailedThread }>({
    query: THREAD,
    variables: { threadId },
  });

  if (result?.thread) {
    const task = cloneDeep(askingTask);
    // bypass understanding status to thread response
    if (task.status === AskingTaskStatus.UNDERSTANDING) {
      task.status = AskingTaskStatus.SEARCHING;
      task.type = AskingTaskType.TEXT_TO_SQL;
    }
    client.cache.updateQuery(
      {
        query: THREAD,
        variables: { threadId },
      },
      (existingData) => {
        return {
          thread: {
            ...existingData.thread,
            responses: existingData.thread.responses.map((response) => {
              if (response.id === threadResponseId) {
                return { ...response, askingTask: task };
              }
              return response;
            }),
          },
        };
      },
    );
  }
};

export default function useAskPrompt(threadId?: number) {
  const [originalQuestion, setOriginalQuestion] = useState<string>('');
  const [threadQuestions, setThreadQuestions] = useState<string[]>([]);
  const [createAskingTask, createAskingTaskResult] =
    useCreateAskingTaskMutation();
  const [cancelAskingTask] = useCancelAskingTaskMutation();
  const [rerunAskingTask] = useRerunAskingTaskMutation();
  const [fetchAskingTask, askingTaskResult] = useAskingTaskLazyQuery({
    pollInterval: 1000,
  });
  const [fetchAskingStreamTask, askingStreamTaskResult] = useAskingStreamTask();
  const [createInstantRecommendedQuestions] =
    useCreateInstantRecommendedQuestionsMutation();
  const [fetchInstantRecommendedQuestions, instantRecommendedQuestionsResult] =
    useInstantRecommendedQuestionsLazyQuery({
      pollInterval: 1000,
    });

  const askingTask = useMemo(
    () => askingTaskResult.data?.askingTask || null,
    [askingTaskResult.data],
  );
  const askingTaskType = useMemo(() => askingTask?.type, [askingTask?.type]);
  const askingStreamTask = askingStreamTaskResult.data;
  const recommendedQuestions = useMemo(
    () =>
      instantRecommendedQuestionsResult.data?.instantRecommendedQuestions ||
      null,
    [instantRecommendedQuestionsResult.data],
  );

  const loading = askingStreamTaskResult.loading;

  const data = useMemo(
    () => ({
      originalQuestion,
      askingTask,
      askingStreamTask,
      recommendedQuestions,
    }),
    [originalQuestion, askingTask, askingStreamTask, recommendedQuestions],
  );

  const startRecommendedQuestions = useCallback(async () => {
    const previousQuestions = [
      // slice the last 5 questions in threadQuestions
      ...uniq(threadQuestions).slice(-5),
      originalQuestion,
    ];
    const response = await createInstantRecommendedQuestions({
      variables: { data: { previousQuestions } },
    });
    fetchInstantRecommendedQuestions({
      variables: { taskId: response.data.createInstantRecommendedQuestions.id },
    });
  }, [originalQuestion]);

  const checkFetchAskingStreamTask = useCallback(
    (task: AskingTask) => {
      if (!askingStreamTask && task.status === AskingTaskStatus.PLANNING) {
        fetchAskingStreamTask(task.queryId);
      }
    },
    [askingStreamTask],
  );

  useEffect(() => {
    const isFinished = getIsFinished(askingTask?.status);
    if (isFinished) askingTaskResult.stopPolling();

    // handle update cache for preparing component
    if (isNeedPreparing(askingTask)) {
      if (threadId) {
        handleUpdateThreadCache(threadId, askingTask, askingTaskResult.client);
        checkFetchAskingStreamTask(askingTask);
      }
    }
  }, [askingTask?.status, threadId, checkFetchAskingStreamTask]);

  useEffect(() => {
    // handle instant recommended questions
    if (isNeedRecommendedQuestions(askingTask)) {
      startRecommendedQuestions();
    }
  }, [askingTask?.type]);

  useEffect(() => {
    if (isRecommendedFinished(recommendedQuestions?.status))
      instantRecommendedQuestionsResult.stopPolling();
  }, [recommendedQuestions]);

  useEffect(() => {
    const taskId = createAskingTaskResult.data?.createAskingTask.id;
    if (taskId && askingTaskType === AskingTaskType.GENERAL) {
      fetchAskingStreamTask(taskId);
    }
  }, [askingTaskType, createAskingTaskResult.data]);

  const onStop = async (queryId?: string) => {
    const taskId = queryId || createAskingTaskResult.data?.createAskingTask.id;
    if (taskId) {
      await cancelAskingTask({ variables: { taskId } }).catch((error) =>
        console.error(error),
      );
      // waiting for polling fetching stop
      await nextTick(1000);
    }
  };

  const onReRun = async (threadResponse: ThreadResponse) => {
    askingStreamTaskResult.reset();
    setOriginalQuestion(threadResponse.question);
    try {
      const response = await rerunAskingTask({
        variables: { responseId: threadResponse.id },
      });
      const { data } = await fetchAskingTask({
        variables: { taskId: response.data.rerunAskingTask.id },
      });
      // update the asking task in cache manually
      handleUpdateRerunAskingTaskCache(
        threadId,
        threadResponse.id,
        data.askingTask,
        askingTaskResult.client,
      );
    } catch (error) {
      console.error(error);
    }
  };

  const onSubmit = async (value) => {
    askingStreamTaskResult.reset();
    setOriginalQuestion(value);
    try {
      const response = await createAskingTask({
        variables: { data: { question: value, threadId } },
      });
      await fetchAskingTask({
        variables: { taskId: response.data.createAskingTask.id },
      });
    } catch (error) {
      console.error(error);
    }
  };

  const onFetching = async (queryId: string) => {
    await fetchAskingTask({
      variables: { taskId: queryId },
    });
  };

  const onStopPolling = () => askingTaskResult.stopPolling();

  const onStopStreaming = () => askingStreamTaskResult.reset();

  const onStopRecommend = () => instantRecommendedQuestionsResult.stopPolling();

  const onStoreThreadQuestions = (questions: string[]) =>
    setThreadQuestions(questions);

  return {
    data,
    loading,
    onStop,
    onReRun,
    onSubmit,
    onFetching,
    onStopPolling,
    onStopStreaming,
    onStopRecommend,
    onStoreThreadQuestions,
    inputProps: {
      placeholder: threadId
        ? 'Ask follow-up questions to explore your data'
        : 'Ask to explore your data',
    },
  };
}
</file>

<file path="src/hooks/useAutoComplete.tsx">
import { useMemo } from 'react';
import { capitalize } from 'lodash';
import { useDiagramQuery } from '@/apollo/client/graphql/diagram.generated';
import { getNodeTypeIcon } from '@/utils/nodeType';
import {
  DiagramModel,
  DiagramView,
  DiagramModelField,
  DiagramViewField,
} from '@/apollo/client/graphql/__types__';

type Model = DiagramModel | DiagramView;
type Field = DiagramModelField | DiagramViewField;
type Convertor<T> = (item: (Model | Field) & { parent?: Model }) => T;

interface Props<T> {
  skip?: boolean;
  includeColumns?: boolean;
  convertor?: Convertor<T>;
}

const getDocHTML = (item: (Model | Field) & { parent?: Model }) => {
  return [
    '<div style="max-width: 380px;">',
    `<b style="display: block;color: var(--gray-8); padding: 0 4px 4px;">${item.referenceName}</b>`,
    item.description
      ? `<div style="color: var(--gray-7); padding: 4px 4px 0; border-top: 1px var(--gray-4) solid;">${item.description}</div>`
      : null,
    '</div>',
  ]
    .filter(Boolean)
    .join('');
};

const shouldQuoteIdentifier = (word: string) => {
  return /[^a-z0-9_]/.test(word) || /^\d/.test(word);
};

// For mention usage
export const convertMention = (item: (Model | Field) & { parent?: Model }) => {
  return {
    id: `${item.id}-${item.referenceName}`,
    label: item.displayName,
    value: item.referenceName,
    nodeType: capitalize(item.nodeType),
    meta: item.parent ? `${item.displayName}.${item.displayName}` : undefined,
    icon: getNodeTypeIcon(
      { nodeType: item.nodeType, type: (item as Field).type },
      { className: 'gray-8 mr-2' },
    ),
  };
};

// For ace completer usage
export const convertCompleter = (
  item: (Model | Field) & { parent?: Model },
) => {
  return {
    caption: item.parent
      ? `${item.parent.displayName}.${item.displayName}`
      : item.displayName,
    value: shouldQuoteIdentifier(item.referenceName)
      ? `"${item.referenceName}"`
      : item.referenceName,
    meta: item.nodeType.toLowerCase(),
    // Higher score for models, views
    score: item.parent ? 1 : 10,
    docHTML: getDocHTML(item),
  };
};

export type Mention = ReturnType<typeof convertMention>;
export type Completer = ReturnType<typeof convertCompleter>;

export default function useAutoComplete<T = Completer>(props: Props<T>) {
  const { includeColumns, skip } = props;
  const { data } = useDiagramQuery({ skip });

  // Defined convertor
  const convertor = (props.convertor || convertCompleter) as Convertor<T>;

  return useMemo(() => {
    const models = data?.diagram.models || [];
    const views = data?.diagram.views || [];

    return [...models, ...views].reduce((result, item) => {
      result.push(convertor(item));
      if (includeColumns) {
        item.fields.forEach((field) => {
          result.push(convertor({ ...field, parent: item }));
        });
      }
      return result;
    }, [] as T[]);
  }, [data?.diagram, includeColumns]);
}
</file>

<file path="src/hooks/useCheckOnboarding.tsx">
import { useEffect } from 'react';
import { useRouter } from 'next/router';
import { useOnboardingStatusQuery } from '@/apollo/client/graphql/onboarding.generated';
import { OnboardingStatus } from '@/apollo/client/graphql/__types__';
import { Path } from '@/utils/enum';

const redirectRoute = {
  [OnboardingStatus.DATASOURCE_SAVED]: Path.OnboardingModels,
  [OnboardingStatus.NOT_STARTED]: Path.OnboardingConnection,
  [OnboardingStatus.ONBOARDING_FINISHED]: Path.Modeling,
  [OnboardingStatus.WITH_SAMPLE_DATASET]: Path.Modeling,
};

export const useWithOnboarding = () => {
  const router = useRouter();
  const { data, loading } = useOnboardingStatusQuery();

  const onboardingStatus = data?.onboardingStatus?.status;

  useEffect(() => {
    if (onboardingStatus) {
      const newPath = redirectRoute[onboardingStatus];
      const pathname = router.pathname;

      // redirect to new path if onboarding is not completed
      if (newPath && newPath !== Path.Modeling) {
        // do not redirect if the new path and router pathname are the same
        if (newPath === pathname) {
          return;
        }

        // allow return back to previous steps
        if (
          router.pathname.startsWith(Path.Onboarding) &&
          onboardingStatus !== OnboardingStatus.ONBOARDING_FINISHED
        ) {
          return;
        }

        router.push(newPath);
        return;
      }

      // redirect to home page if onboarding is completed

      // redirect to the home page when entering the Index page
      if (pathname === '/') {
        router.push(newPath);
        return;
      }

      // redirect to home page since user using sample dataset
      if (
        pathname === Path.OnboardingRelationships &&
        onboardingStatus === OnboardingStatus.WITH_SAMPLE_DATASET
      ) {
        router.push(newPath);
        return;
      }

      // redirect to home page when entering the connection page or select models page
      if (
        [Path.OnboardingConnection, Path.OnboardingModels].includes(
          pathname as Path,
        )
      ) {
        router.push(newPath);
        return;
      }
    }
  }, [onboardingStatus, router.pathname]);

  return {
    loading,
    onboardingStatus,
  };
};

export default function useOnboardingStatus() {
  const { data, loading, error, refetch } = useOnboardingStatusQuery();

  return {
    loading,
    error,
    refetch,
    onboardingStatus: data?.onboardingStatus?.status,
  };
}
</file>

<file path="src/hooks/useCombineFieldOptions.tsx">
import { useEffect, useMemo, useState } from 'react';
import { useListModelsQuery } from '@/apollo/client/graphql/model.generated';
import {
  convertObjectToIdentifier,
  convertIdentifierToObject,
} from '@/utils/enum';
import { RelationsDataType } from '@/components/table/ModelRelationSelectionTable';
import { RelationFormValues } from '@/components/modals/RelationModal';

interface Props {
  // The initial base model of model select
  model?: string;
  // The models to be excluded from model select
  excludeModels?: string[];
}

// for identifier keys
const modelKeys = ['id', 'referenceName'];
const fieldKeys = ['id', 'referenceName'];

export const convertFormValuesToIdentifier = (
  relationFormValues: RelationFormValues,
) => {
  const fromModel: { id: string; referenceName: string } =
    convertIdentifierToObject(relationFormValues.fromField.model);

  const fromField: { id: string; referenceName: string } =
    convertIdentifierToObject(relationFormValues.fromField.field);

  const toModel: { id: string; referenceName: string } =
    convertIdentifierToObject(relationFormValues.toField.model);

  const toField: { id: string; referenceName: string } =
    convertIdentifierToObject(relationFormValues.toField.field);

  return {
    ...relationFormValues,
    fromField: {
      modelId: fromModel.id,
      modelName: fromModel.referenceName,
      fieldId: fromField.id,
      fieldName: fromField.referenceName,
    },
    toField: {
      modelId: toModel.id,
      modelName: toModel.referenceName,
      fieldId: toField.id,
      fieldName: toField.referenceName,
    },
  } as RelationsDataType;
};

export const convertDefaultValueToIdentifier = (defaultValue) => {
  const fromField = {
    model: {
      id: defaultValue.fromField.modelId,
      referenceName: defaultValue.fromField.modelName,
    },
    field: {
      id: defaultValue.fromField.fieldId,
      referenceName: defaultValue.fromField.fieldName,
    },
  };
  const toField = {
    model: {
      id: defaultValue.toField.modelId,
      referenceName: defaultValue.toField.modelName,
    },
    field: {
      id: defaultValue.toField.fieldId,
      referenceName: defaultValue.toField.fieldName,
    },
  };
  return {
    fromField: {
      model: convertObjectToIdentifier(fromField.model, modelKeys),
      field: convertObjectToIdentifier(fromField.field, fieldKeys),
    },
    toField: {
      model: convertObjectToIdentifier(toField.model, modelKeys),
      field: convertObjectToIdentifier(toField.field, fieldKeys),
    },
    type: defaultValue.type,
  };
};

export default function useCombineFieldOptions(props: Props) {
  const { model, excludeModels } = props;

  const [baseModel, setBaseModel] = useState<string>(model || '');

  // bind model to baseModel
  useEffect(() => setBaseModel(model), [model]);

  const { data } = useListModelsQuery({
    fetchPolicy: 'cache-and-network',
  });

  const allModels = useMemo(() => {
    if (!data) return [];

    return data.listModels.map((model) => ({
      id: model.id,
      referenceName: model.referenceName,
      displayName: model.displayName,
      fields: model.fields,
    }));
  }, [data]);

  const filteredModels = useMemo(
    () =>
      allModels.filter(
        (item) =>
          !(excludeModels && excludeModels.includes(item.referenceName)),
      ),
    [excludeModels, baseModel, data],
  );

  const modelOptions = useMemo(
    () =>
      filteredModels.map((model) => ({
        label: model.displayName,
        value: convertObjectToIdentifier(model, modelKeys),
        'data-testid': 'common__models__select-option',
      })),
    [filteredModels],
  );

  const selectedModel = useMemo(
    () => filteredModels.find((item) => item.referenceName === baseModel),
    [modelOptions, baseModel],
  );

  const fieldOptions = useMemo(
    () =>
      (selectedModel?.fields || []).map((field) => ({
        label: field.displayName,
        value: convertObjectToIdentifier(field, fieldKeys),
        'data-testid': 'common__fields__select-option',
      })),
    [selectedModel],
  );

  const onModelChange = (value: string) => {
    const model: { id: string; referenceName: string } =
      convertIdentifierToObject(value);
    setBaseModel(model.referenceName);
  };

  return { modelOptions, fieldOptions, onModelChange };
}
</file>

<file path="src/hooks/useDrawerAction.tsx">
import { useState } from 'react';
import { FORM_MODE } from '@/utils/enum';

export interface DrawerAction<TData = any> {
  visible: boolean;
  onClose: () => void;
  onSubmit?: (values: any) => Promise<void>;
  formMode?: FORM_MODE;
  // use as form default value or view data
  defaultValue?: TData;
}

export default function useDrawerAction() {
  const [visible, setVisible] = useState(false);
  const [formMode, setFormMode] = useState(FORM_MODE.CREATE);
  const [defaultValue, setDefaultValue] = useState(null);

  const openDrawer = (value?: any) => {
    value && setDefaultValue(value);
    value && setFormMode(FORM_MODE.EDIT);
    setVisible(true);
  };

  const closeDrawer = () => {
    setVisible(false);
    setDefaultValue(null);
    setFormMode(FORM_MODE.CREATE);
  };

  const updateState = (value?: any) => {
    setDefaultValue(value);
  };

  return {
    state: {
      visible,
      formMode,
      defaultValue,
    },
    openDrawer,
    closeDrawer,
    updateState,
  };
}
</file>

<file path="src/hooks/useDropdown.tsx">
import { useState } from 'react';

export default function useDropdown() {
  const [visible, setVisible] = useState<boolean>(false);

  const onVisibleChange = (visible: boolean) => setVisible(visible);

  const onCloseDropdownMenu = () => setVisible(false);

  return {
    visible,
    onVisibleChange,
    onCloseDropdownMenu,
  };
}
</file>

<file path="src/hooks/useExpressionFieldOptions.tsx">
import { ExpressionName } from '@/apollo/client/graphql/__types__';
import { getExpressionTexts } from '@/utils/data';
import {
  aggregations,
  mathFunctions,
  stringFunctions,
} from '@/utils/expressionType';
import { useMemo } from 'react';

export default function useExpressionFieldOptions() {
  const expressionOptions = useMemo(() => {
    const convertor = (name: ExpressionName) => {
      const texts = getExpressionTexts(name);
      return {
        label: texts.name,
        value: name,
        content: {
          title: texts.syntax,
          description: texts.description,
          expression: texts.syntax,
        },
      };
    };

    return [
      {
        label: 'Aggregation',
        options: aggregations.map(convertor),
      },
      {
        label: 'Math functions',
        options: mathFunctions.map(convertor),
      },
      {
        label: 'String functions',
        options: stringFunctions.map(convertor),
      },
    ];
  }, []);

  return expressionOptions;
}
</file>

<file path="src/hooks/useGlobalConfig.tsx">
import { useRouter } from 'next/router';
import { createContext, useContext, useEffect, useState } from 'react';
import { getUserConfig, UserConfig } from '@/utils/env';
import { trackUserTelemetry } from '@/utils/telemetry';

type ContextProps = {
  config?: UserConfig | null;
};

const GlobalConfigContext = createContext<ContextProps>({});

export const GlobalConfigProvider = ({ children }) => {
  const router = useRouter();
  const [config, setConfig] = useState<UserConfig | null>(null);

  useEffect(() => {
    getUserConfig()
      .then((config) => {
        setConfig(config);
        // telemetry setup
        const cleanup = trackUserTelemetry(router, config);
        return cleanup;
      })
      .catch((error) => {
        console.error('Failed to get user config', error);
      });
  }, [router]);

  const value = {
    config,
  };

  return (
    <GlobalConfigContext.Provider value={value}>
      {children}
    </GlobalConfigContext.Provider>
  );
};

export default function useGlobalConfig() {
  return useContext(GlobalConfigContext);
}
</file>

<file path="src/hooks/useHomeSidebar.tsx">
import { useMemo } from 'react';
import { useRouter } from 'next/router';
import { Path } from '@/utils/enum';
import {
  useDeleteThreadMutation,
  useThreadsQuery,
  useUpdateThreadMutation,
} from '@/apollo/client/graphql/home.generated';

export default function useHomeSidebar() {
  const router = useRouter();
  const { data, refetch } = useThreadsQuery({
    fetchPolicy: 'cache-and-network',
  });
  const [updateThread] = useUpdateThreadMutation();
  const [deleteThread] = useDeleteThreadMutation();

  const threads = useMemo(
    () =>
      (data?.threads || []).map((thread) => ({
        id: thread.id.toString(),
        name: thread.summary,
      })),
    [data],
  );

  const onSelect = (selectKeys: string[]) => {
    router.push(`${Path.Home}/${selectKeys[0]}`);
  };

  const onRename = async (id: string, newName: string) => {
    await updateThread({
      variables: { where: { id: Number(id) }, data: { summary: newName } },
    });
    refetch();
  };

  const onDelete = async (id) => {
    await deleteThread({ variables: { where: { id: Number(id) } } });
    refetch();
  };

  return {
    data: { threads },
    onSelect,
    onRename,
    onDelete,
    refetch,
  };
}
</file>

<file path="src/hooks/useModalAction.tsx">
import { useState } from 'react';
import { FORM_MODE } from '@/utils/enum';

export interface ModalAction<TData = any, SData = any> {
  visible: boolean;
  onClose: () => void;
  onSubmit?: (values: SData) => Promise<void>;
  formMode?: FORM_MODE;
  defaultValue?: TData;
  payload?: Record<string, any>;
}

export default function useModalAction() {
  const [visible, setVisible] = useState(false);
  const [formMode, setFormMode] = useState(FORM_MODE.CREATE);
  const [payload, setPayload] = useState(null);
  const [defaultValue, setDefaultValue] = useState(null);

  const openModal = (value?: any, payload?: any) => {
    payload && setPayload(payload);
    value && setDefaultValue(value);
    value && setFormMode(FORM_MODE.EDIT);
    setVisible(true);
  };

  const closeModal = () => {
    setVisible(false);
    setPayload(null);
    setDefaultValue(null);
    setFormMode(FORM_MODE.CREATE);
  };

  return {
    state: {
      visible,
      formMode,
      defaultValue,
      payload,
    },
    openModal,
    closeModal,
  };
}
</file>

<file path="src/hooks/useNativeSQL.tsx">
import { useState } from 'react';
import { useGetSettingsQuery } from '@/apollo/client/graphql/settings.generated';
import { useGetNativeSqlLazyQuery } from '@/apollo/client/graphql/home.generated';
import { DataSourceName } from '@/apollo/client/graphql/__types__';

export interface NativeSQLResult {
  data: string;
  dataSourceType: DataSourceName;
  hasNativeSQL: boolean;
  loading: boolean;
  nativeSQLMode: boolean;
  setNativeSQLMode: (value: boolean) => void;
}

// we assume that not having a sample dataset means supporting native SQL
function useNativeSQLInfo() {
  const { data: settingsQueryResult } = useGetSettingsQuery();
  const settings = settingsQueryResult?.settings;
  const dataSourceType = settings?.dataSource.type;
  const sampleDataset = settings?.dataSource.sampleDataset;

  return {
    hasNativeSQL: !Boolean(sampleDataset),
    dataSourceType,
  };
}

export default function useNativeSQL() {
  const nativeSQLInfo = useNativeSQLInfo();

  const [nativeSQLMode, setNativeSQLMode] = useState<boolean>(false);

  const [fetchNativeSQL, { data, loading }] = useGetNativeSqlLazyQuery({
    fetchPolicy: 'cache-and-network',
  });

  const nativeSQL = data?.nativeSql || '';
  const nativeSQLResult: NativeSQLResult = {
    ...nativeSQLInfo,
    data: nativeSQL,
    loading,
    nativeSQLMode,
    setNativeSQLMode,
  };

  return {
    fetchNativeSQL,
    nativeSQLResult,
  };
}
</file>

<file path="src/hooks/useRecommendedQuestionsInstruction.tsx">
import { useMemo, useState, useEffect } from 'react';
import { groupBy, orderBy, flatMap } from 'lodash';
import { message } from 'antd';
import Icon from '@/import/icon';
import ReloadOutlined from '@ant-design/icons/ReloadOutlined';
import { CopilotSVG } from '@/utils/svgs';
import { isRecommendedFinished } from '@/hooks/useAskPrompt';
import {
  ResultQuestion,
  RecommendedQuestionsTaskStatus,
} from '@/apollo/client/graphql/__types__';
import {
  useGetProjectRecommendationQuestionsLazyQuery,
  useGenerateProjectRecommendationQuestionsMutation,
} from '@/apollo/client/graphql/home.generated';

export interface GroupedQuestion {
  category: string;
  question: string;
  sql: string;
}

const getGroupedQuestions = (
  questions: ResultQuestion[],
): GroupedQuestion[] => {
  const groupedData = groupBy(questions, 'category');
  return orderBy(
    flatMap(groupedData),
    (item) => groupedData[item.category].length, // Sort by number of questions in each category
    'desc',
  );
};

export default function useRecommendedQuestionsInstruction() {
  const [showRetry, setShowRetry] = useState<boolean>(false);
  const [generating, setGenerating] = useState<boolean>(false);
  const [isRegenerate, setIsRegenerate] = useState<boolean>(false);
  const [
    showRecommendedQuestionsPromptMode,
    setShowRecommendedQuestionsPromptMode,
  ] = useState<boolean>(false);
  const [recommendedQuestions, setRecommendedQuestions] = useState<
    GroupedQuestion[]
  >([]);

  const [fetchRecommendationQuestions, recommendationQuestionsResult] =
    useGetProjectRecommendationQuestionsLazyQuery({
      pollInterval: 2000,
    });

  const [generateProjectRecommendationQuestions] =
    useGenerateProjectRecommendationQuestionsMutation();

  const recommendedQuestionsTask = useMemo(
    () =>
      recommendationQuestionsResult.data?.getProjectRecommendationQuestions ||
      null,
    [recommendationQuestionsResult.data],
  );

  useEffect(() => {
    const fetchRecommendationQuestionsData = async () => {
      const result = await fetchRecommendationQuestions();
      const data = result.data?.getProjectRecommendationQuestions;

      // for existing projects that do not have to generate recommended questions yet
      if (isRecommendedFinished(data.status)) {
        if (data.questions.length > 0) {
          // for regenerate then leave and go back to the home page
          setRecommendedQuestions(getGroupedQuestions(data.questions));

          setShowRecommendedQuestionsPromptMode(true);
        }
      }
    };

    fetchRecommendationQuestionsData();
  }, []);

  useEffect(() => {
    if (isRecommendedFinished(recommendedQuestionsTask?.status)) {
      recommendationQuestionsResult.stopPolling();

      if (recommendedQuestionsTask.questions.length === 0) {
        isRegenerate && setShowRetry(true);

        if (
          showRecommendedQuestionsPromptMode &&
          recommendedQuestionsTask.status ===
            RecommendedQuestionsTaskStatus.FAILED
        ) {
          message.error(
            `We couldn't regenerate questions right now. Let's try again later.`,
          );
        }
      } else {
        setIsRegenerate(true);

        // update to recommendedQuestions
        setRecommendedQuestions(
          getGroupedQuestions(recommendedQuestionsTask.questions),
        );
        setShowRecommendedQuestionsPromptMode(true);
      }

      setGenerating(false);
    }
  }, [recommendedQuestionsTask]);

  const onGetRecommendationQuestions = async () => {
    setGenerating(true);
    setIsRegenerate(true);
    try {
      await generateProjectRecommendationQuestions();
      fetchRecommendationQuestions();
    } catch (error) {
      console.error(error);
    }
  };

  const buttonProps = useMemo(() => {
    const baseProps = {
      loading: generating,
      onClick: onGetRecommendationQuestions,
    };

    if (showRecommendedQuestionsPromptMode && isRegenerate) {
      return {
        ...baseProps,
        icon: <ReloadOutlined />,
        children: 'Regenerate',
      };
    }

    return {
      ...baseProps,
      icon: showRetry ? (
        <ReloadOutlined />
      ) : (
        <Icon component={CopilotSVG} className="geekblue-6" />
      ),
      children: generating
        ? 'Generating questions'
        : showRetry
          ? 'Retry'
          : 'What could I ask?',
    };
  }, [generating, isRegenerate, showRetry, showRecommendedQuestionsPromptMode]);

  return {
    recommendedQuestions,
    generating,
    showRetry,
    showRecommendedQuestionsPromptMode,
    buttonProps,
  };
}
</file>

<file path="src/hooks/useRelationshipModal.tsx">
import { useMemo, useState } from 'react';
import { NODE_TYPE } from '@/utils/enum';
import { Diagram } from '@/utils/data';
import useModalAction from '@/hooks/useModalAction';

export default function useRelationshipModal(diagramData: Diagram | null) {
  const relationshipModal = useModalAction();

  const [selectedModelReferenceName, setSelectedModelReferenceName] =
    useState<string>(null);

  // Parse out the relationships data under all models
  const relationships = useMemo(
    () =>
      (diagramData?.models || []).reduce((acc, currentValue) => {
        const { referenceName, relationFields } = currentValue;
        const newRelationship = relationFields.map((relationship) => {
          return {
            id: relationship.relationId,
            fromField: {
              modelId: String(relationship.fromModelId),
              modelName: relationship.fromModelName,
              fieldId: String(relationship.fromColumnId),
              fieldName: relationship.fromColumnName,
            },
            toField: {
              modelId: String(relationship.toModelId),
              modelName: relationship.toModelName,
              fieldId: String(relationship.toColumnId),
              fieldName: relationship.toColumnName,
            },
            type: relationship.type,
          };
        });

        acc[referenceName] = newRelationship;
        return acc;
      }, {}),
    [diagramData],
  );

  const onClose = () => {
    setSelectedModelReferenceName(null);
    relationshipModal.closeModal();
  };

  const openModal = (data) => {
    // update mode
    if (data.nodeType === NODE_TYPE.RELATION) {
      setSelectedModelReferenceName(data.fromModelName);
      relationshipModal.openModal({
        relationId: data.relationId,
        fromField: {
          modelId: String(data.fromModelId),
          modelName: data.fromModelName,
          fieldId: String(data.fromColumnId),
          fieldName: data.fromColumnName,
        },
        toField: {
          modelId: String(data.toModelId),
          modelName: data.toModelName,
          fieldId: String(data.toColumnId),
          fieldName: data.toColumnName,
        },
        type: data.type,
      });
      return;
    }

    // create mode
    setSelectedModelReferenceName(data.referenceName);
    relationshipModal.openModal();
  };

  return {
    onClose,
    openModal,
    state: {
      ...relationshipModal.state,
      model: selectedModelReferenceName,
      relations: relationships,
    },
  };
}
</file>

<file path="src/hooks/useSetupConnection.tsx">
import { useState, useEffect } from 'react';
import { SETUP } from '@/utils/enum';
import { parseGraphQLError } from '@/utils/errorHandler';
import useSetupConnectionDataSource from './useSetupConnectionDataSource';
import useSetupConnectionSampleDataset from './useSetupConnectionSampleDataset';
import {
  DataSourceName,
  SampleDatasetName,
} from '@/apollo/client/graphql/__types__';

type StepData = {
  dataSource?: DataSourceName;
  template?: SampleDatasetName;
  properties?: JSON;
};

export default function useSetupConnection() {
  const [stepKey, setStepKey] = useState(SETUP.STARTER);
  const setupConnectionSampleDataset = useSetupConnectionSampleDataset();
  const setupConnectionDataSource = useSetupConnectionDataSource();
  const [connectError, setConnectError] = useState(null);

  const dataSource = setupConnectionDataSource.selected;
  const submitting =
    setupConnectionDataSource.loading || setupConnectionSampleDataset.loading;

  useEffect(() => {
    if (stepKey === SETUP.CREATE_DATA_SOURCE) {
      setConnectError(null);
    }
  }, [stepKey]);

  useEffect(() => {
    setConnectError(parseGraphQLError(setupConnectionDataSource.error));
  }, [setupConnectionDataSource.error]);

  const onBack = () => {
    if (stepKey === SETUP.CREATE_DATA_SOURCE) {
      setStepKey(SETUP.STARTER);
      setupConnectionDataSource.reset();
    }
  };

  const onNext = (data?: StepData) => {
    const dispatchStarter = (data: StepData) => {
      if (data.dataSource) {
        setupConnectionDataSource.selectDataSourceNext({
          dataSource: data.dataSource,
          dispatch: () => setStepKey(SETUP.CREATE_DATA_SOURCE),
        });
      } else {
        setupConnectionSampleDataset.saveSampleDataset(data.template);
      }
    };

    const dispatchCreateDataSource = (data: StepData) => {
      setupConnectionDataSource.saveDataSource(data.properties);
    };

    // Next strategy
    if (stepKey === SETUP.STARTER) {
      dispatchStarter(data);
    } else if (stepKey === SETUP.CREATE_DATA_SOURCE) {
      dispatchCreateDataSource(data);
    }
  };

  return {
    stepKey,
    dataSource,
    onBack,
    onNext,
    submitting,
    connectError,
  };
}
</file>

<file path="src/hooks/useSetupConnectionDataSource.tsx">
import { useRouter } from 'next/router';
import { useState, useCallback } from 'react';
import { Path, REDSHIFT_AUTH_METHOD } from '@/utils/enum';
import { useSaveDataSourceMutation } from '@/apollo/client/graphql/dataSource.generated';
import { DataSourceName } from '@/apollo/client/graphql/__types__';

const PASSWORD_PLACEHOLDER = '************';

export default function useSetupConnectionDataSource() {
  const router = useRouter();
  const [selected, setSelected] = useState<DataSourceName>();

  const [saveDataSourceMutation, { loading, error }] =
    useSaveDataSourceMutation({
      onError: (error) => console.error(error),
      onCompleted: () => completedDataSourceSave(),
    });

  const selectDataSourceNext = useCallback(
    (payload: { dataSource: DataSourceName; dispatch?: () => void }) => {
      setSelected(payload.dataSource);
      payload?.dispatch?.();
    },
    [router],
  );

  const saveDataSource = useCallback(
    async (properties?: Record<string, any>) => {
      await saveDataSourceMutation({
        variables: {
          data: {
            type: selected,
            properties: transformFormToProperties(properties, selected),
          },
        },
      });
    },
    [selected, saveDataSourceMutation],
  );

  const completedDataSourceSave = useCallback(async () => {
    router.push(Path.OnboardingModels);
  }, [selected, router]);

  return {
    loading,
    error,
    selected,
    saveDataSource,
    selectDataSourceNext,
    completedDataSourceSave,
    reset: () => setSelected(undefined),
  };
}

export const transformFormToProperties = (
  properties: Record<string, any>,
  dataSourceType: DataSourceName,
) => {
  if (dataSourceType === DataSourceName.DUCKDB) {
    const configurations = properties.configurations.reduce((acc, cur) => {
      if (cur.key && cur.value) {
        acc[cur.key] = cur.value;
      }

      return acc;
    }, {});

    return {
      ...properties,
      configurations,
      extensions: properties.extensions.filter((i) => i),
    };
  }

  return {
    ...properties,
    // remove password placeholder if user doesn't change the password
    password:
      properties?.password === PASSWORD_PLACEHOLDER
        ? undefined
        : properties?.password,

    awsSecretKey:
      properties?.awsSecretKey === PASSWORD_PLACEHOLDER
        ? undefined
        : properties?.awsSecretKey,
  };
};

export const transformPropertiesToForm = (
  properties: Record<string, any>,
  dataSourceType: DataSourceName,
) => {
  if (dataSourceType === DataSourceName.BIG_QUERY) {
    return { ...properties, credentials: undefined };
  } else if (dataSourceType === DataSourceName.DUCKDB) {
    const configurations = Object.entries(properties?.configurations || {}).map(
      ([key, value]) => ({ key, value }),
    );
    const extensions = properties?.extensions || [];
    return {
      ...properties,
      // If there are no configurations or extensions, add an empty one, or the form properties will break
      configurations: configurations.length
        ? configurations
        : [{ key: '', value: '' }],
      extensions: extensions.length ? extensions : [''],
    };
  } else if (dataSourceType === DataSourceName.REDSHIFT) {
    return {
      ...properties,
      ...(properties?.redshiftType === REDSHIFT_AUTH_METHOD.redshift
        ? {
            password: properties?.password || PASSWORD_PLACEHOLDER,
          }
        : {
            awsSecretKey: properties?.awsSecretKey || PASSWORD_PLACEHOLDER,
          }),
    };
  }

  return {
    ...properties,
    // provide a password placeholder to UI
    password: properties?.password || PASSWORD_PLACEHOLDER,
  };
};
</file>

<file path="src/hooks/useSetupConnectionSampleDataset.tsx">
import { useRouter } from 'next/router';
import { useCallback } from 'react';
import { Path } from '@/utils/enum';
import { ONBOARDING_STATUS } from '@/apollo/client/graphql/onboarding';
import { useStartSampleDatasetMutation } from '@/apollo/client/graphql/dataSource.generated';
import { SampleDatasetName } from '@/apollo/client/graphql/__types__';

export default function useSetupConnectionSampleDataset() {
  const router = useRouter();

  const [startSampleDatasetMutation, { loading, error }] =
    useStartSampleDatasetMutation({
      onError: (error) => console.error(error),
      onCompleted: () => router.push(Path.Modeling),
      refetchQueries: [{ query: ONBOARDING_STATUS }],
      awaitRefetchQueries: true,
    });

  const saveSampleDataset = useCallback(
    async (template: SampleDatasetName) => {
      await startSampleDatasetMutation({
        variables: { data: { name: template } },
      });
    },
    [startSampleDatasetMutation],
  );

  return {
    loading,
    error,
    saveSampleDataset,
  };
}
</file>

<file path="src/hooks/useSetupModels.tsx">
import { useState } from 'react';
import { Path, SETUP } from '@/utils/enum';
import { useRouter } from 'next/router';
import {
  useListDataSourceTablesQuery,
  useSaveTablesMutation,
} from '@/apollo/client/graphql/dataSource.generated';

export default function useSetupModels() {
  const [stepKey] = useState(SETUP.SELECT_MODELS);

  const router = useRouter();

  const { data, loading: fetching } = useListDataSourceTablesQuery({
    fetchPolicy: 'no-cache',
    onError: (error) => console.error(error),
  });

  const [saveTablesMutation, { loading: submitting }] = useSaveTablesMutation();

  const submitModels = async (tables: string[]) => {
    await saveTablesMutation({
      variables: {
        data: { tables },
      },
    });
    router.push(Path.OnboardingRelationships);
  };

  const onBack = () => {
    router.push(Path.OnboardingConnection);
  };

  const onNext = (data: { selectedTables: string[] }) => {
    submitModels(data.selectedTables);
  };

  return {
    submitting,
    fetching,
    stepKey,
    onBack,
    onNext,
    tables: data?.listDataSourceTables || [],
  };
}
</file>

<file path="src/hooks/useSetupRelations.tsx">
import { useMemo, useState } from 'react';
import { SETUP } from '@/utils/enum';
import { useRouter } from 'next/router';
import { SelectedRecommendRelations } from '@/components/pages/setup/DefineRelations';
import { Path } from '@/utils/enum';
import {
  useAutoGeneratedRelationsQuery,
  useSaveRelationsMutation,
} from '@/apollo/client/graphql/dataSource.generated';
import useOnboardingStatus from '@/hooks/useCheckOnboarding';

export default function useSetupRelations() {
  const [stepKey] = useState(SETUP.DEFINE_RELATIONS);
  const router = useRouter();
  const { refetch: refetchOnboardingStatus } = useOnboardingStatus();

  const { data, loading: fetching } = useAutoGeneratedRelationsQuery({
    fetchPolicy: 'no-cache',
  });
  const autoGenerateRelation = data?.autoGenerateRelation;

  const onFinish = () => {
    router.push(Path.Modeling);
    refetchOnboardingStatus();
  };

  const [saveRelationsMutation, { loading: submitting }] =
    useSaveRelationsMutation({
      onError: (error) => console.error(error),
      onCompleted: onFinish,
    });

  const submitRelations = async (relationsData: SelectedRecommendRelations) => {
    const relations = Object.entries(relationsData).reduce(
      (acc, [_modleName, relations]) => {
        const newRelations = relations.map((relation) => {
          return {
            fromModelId: Number(relation.fromField.modelId),
            fromColumnId: Number(relation.fromField.fieldId),
            toModelId: Number(relation.toField.modelId),
            toColumnId: Number(relation.toField.fieldId),
            type: relation.type,
          };
        });

        acc = [...acc, ...newRelations];
        return acc;
      },
      [],
    );

    // redirect to the home page if there is no relationship data needs to be saved
    if (relations.length === 0) {
      onFinish();
      return;
    }

    await saveRelationsMutation({
      variables: { data: { relations } },
    });
  };

  const onBack = () => {
    router.push('/setup/models');
  };

  const onNext = (data: { relations: SelectedRecommendRelations }) => {
    submitRelations(data.relations);
  };

  const recommendRelationsResult = useMemo(
    () =>
      (autoGenerateRelation || []).reduce(
        (acc, currentValue) => {
          const { displayName, referenceName, relations } = currentValue;
          const newRelations = relations.map((relation) => {
            return {
              name: relation.name,
              fromField: {
                modelId: String(relation.fromModelId),
                modelName: relation.fromModelReferenceName,
                fieldId: String(relation.fromColumnId),
                fieldName: relation.fromColumnReferenceName,
              },
              toField: {
                modelId: String(relation.toModelId),
                modelName: relation.toModelReferenceName,
                fieldId: String(relation.toColumnId),
                fieldName: relation.toColumnReferenceName,
              },
              type: relation.type,
              isAutoGenerated: true,
            };
          });

          acc['recommendRelations'][referenceName] = newRelations;
          acc['recommendNameMapping'][referenceName] = displayName;
          return acc;
        },
        {
          recommendRelations: {},
          recommendNameMapping: {},
        },
      ),
    [autoGenerateRelation],
  );

  return {
    fetching,
    submitting,
    stepKey,
    recommendRelationsResult,
    onBack,
    onNext,
    onSkip: onFinish,
  };
}
</file>

<file path="src/hooks/useStoreContext.tsx">
import { createContext, useContext } from 'react';

const contextMap = new Map<string, React.Context<any>>();

export const STORE = {
  PROMPT_THREAD: 'PromptThread',
};

// Base store context hook
export default function useStoreContext() {
  const createStore = (id: string) => {
    if (contextMap.has(id)) return contextMap.get(id);
    const context = createContext(null);
    contextMap.set(id, context);
    return context;
  };

  const clearStore = (id: string) => {
    contextMap.delete(id);
  };

  const useStore = (id: string) => {
    const context = contextMap.get(id);
    if (!context) throw new Error(`Context not found for id: ${id}`);
    return useContext(context);
  };

  return {
    createStore,
    clearStore,
    useStore,
  };
}
</file>

<file path="src/hooks/useTextBasedAnswerStreamTask.tsx">
import { useRef, useState } from 'react';

type TextBasedAnswerStreamTaskReturn = [
  (responseId: number) => void,
  {
    data: string;
    loading: boolean;
    onReset: () => void;
  },
];

export default function useTextBasedAnswerStreamTask() {
  const eventSourceRef = useRef<EventSource | null>(null);
  const [loading, setLoading] = useState<boolean>(false);
  const [data, setData] = useState<string>('');

  const onReset = () => {
    if (eventSourceRef.current) {
      eventSourceRef.current?.close();
      eventSourceRef.current = null;
    }
    setData('');
  };

  const fetchAnswerStreamingTask = (responseId: number) => {
    setLoading(true);
    onReset();

    const eventSource = new EventSource(
      `/api/ask_task/streaming_answer?responseId=${responseId}`,
    );

    eventSource.onmessage = (event) => {
      const eventData = JSON.parse(event.data);
      if (eventData.done) {
        eventSource.close();
        setLoading(false);
      } else {
        setData((state) => state + (eventData?.message || ''));
      }
    };

    eventSource.onerror = (error) => {
      console.error(error);
      eventSource.close();
      setLoading(false);
    };

    eventSourceRef.current = eventSource;
  };

  return [
    fetchAnswerStreamingTask,
    { data, loading, onReset },
  ] as TextBasedAnswerStreamTaskReturn;
}
</file>

<file path="src/import/antd.ts">
/*
 * On demand import components to avoid bundle size issue
 */

// export { default as Affix } from 'antd/lib/affix';
// export { default as Anchor } from 'antd/lib/anchor';
// export { default as AutoComplete } from 'antd/lib/auto-complete';
export { default as Alert } from 'antd/lib/alert';
// export { default as Avatar } from 'antd/lib/avatar';
// export { default as BackTop } from 'antd/lib/back-top';
export { default as Badge } from 'antd/lib/badge';
export { default as Breadcrumb } from 'antd/lib/breadcrumb';
export { default as Button } from 'antd/lib/button';
// export { default as Calendar } from 'antd/lib/calendar';
export { default as Card } from 'antd/lib/card';
export { default as Collapse } from 'antd/lib/collapse';
// export { default as Carousel } from 'antd/lib/carousel';
// export { default as Cascader } from 'antd/lib/cascader';
// export { default as Checkbox } from 'antd/lib/checkbox';
export { default as Col } from 'antd/lib/col';
// export { default as Comment } from 'antd/lib/comment';
// export { default as ConfigProvider } from 'antd/lib/config-provider';
export { default as DatePicker } from 'antd/lib/date-picker';
// export { default as Descriptions } from 'antd/lib/descriptions';
export { default as Divider } from 'antd/lib/divider';
export { default as Dropdown } from 'antd/lib/dropdown';
export { default as Drawer } from 'antd/lib/drawer';
export { default as Empty } from 'antd/lib/empty';
export { default as Form } from 'antd/lib/form';
// export { default as Grid } from 'antd/lib/grid';
export { default as Input } from 'antd/lib/input';
// export { default as Image } from 'antd/lib/image';
// export { default as InputNumber } from 'antd/lib/input-number';
export { default as Layout } from 'antd/lib/layout';
// export { default as List } from 'antd/lib/list';
export { default as message } from 'antd/lib/message';
export { default as Menu } from 'antd/lib/menu';
export { default as Mentions } from 'antd/lib/mentions';
export { default as Modal } from 'antd/lib/modal';
// export { default as Statistic } from 'antd/lib/statistic';
// export { default as notification } from 'antd/lib/notification';
// export { default as PageHeader } from 'antd/lib/page-header';
export { default as Pagination } from 'antd/lib/pagination';
export { default as Popconfirm } from 'antd/lib/popconfirm';
export { default as Popover } from 'antd/lib/popover';
// export { default as Progress } from 'antd/lib/progress';
export { default as Radio } from 'antd/lib/radio';
// export { default as Rate } from 'antd/lib/rate';
// export { default as Result } from 'antd/lib/result';
export { default as Row } from 'antd/lib/row';
export { default as Select } from 'antd/lib/select';
// export { default as Segmented } from 'antd/lib/segmented';
export { default as Skeleton } from 'antd/lib/skeleton';
// export { default as Slider } from 'antd/lib/slider';
export { default as Space } from 'antd/lib/space';
export { default as Spin } from 'antd/lib/spin';
export { default as Steps } from 'antd/lib/steps';
export { default as Switch } from 'antd/lib/switch';
export { default as Table } from 'antd/lib/table';
export { default as Transfer } from 'antd/lib/transfer';
export { default as Tree } from 'antd/lib/tree';
// export { default as TreeSelect } from 'antd/lib/tree-select';
export { default as Tabs } from 'antd/lib/tabs';
export { default as Tag } from 'antd/lib/tag';
export { default as TimePicker } from 'antd/lib/time-picker';
export { default as Timeline } from 'antd/lib/timeline';
export { default as Tooltip } from 'antd/lib/tooltip';
export { default as Typography } from 'antd/lib/typography';
export { default as Upload } from 'antd/lib/upload';
export { default as version } from 'antd/lib/version';
</file>

<file path="src/import/icon.ts">
/*
 * use client import to avoid bundle size issue
 */

import dynamic from 'next/dynamic';
export type { IconComponentProps } from '@ant-design/icons/lib/components/Icon';

const Icon = dynamic(() => import('@ant-design/icons/lib/components/Icon'), {
  ssr: false,
});

export default Icon;
</file>

<file path="src/pages/_app.tsx">
import { AppProps } from 'next/app';
import Head from 'next/head';
import { Spin } from 'antd';
import posthog from 'posthog-js';
import apolloClient from '@/apollo/client';
import { GlobalConfigProvider } from '@/hooks/useGlobalConfig';
import { PostHogProvider } from 'posthog-js/react';
import { ApolloProvider } from '@apollo/client';
import { defaultIndicator } from '@/components/PageLoading';

require('../styles/index.less');

Spin.setDefaultIndicator(defaultIndicator);

function App({ Component, pageProps }: AppProps) {
  return (
    <>
      <Head>
        <title>Wren AI</title>
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <GlobalConfigProvider>
        <ApolloProvider client={apolloClient}>
          <PostHogProvider client={posthog}>
            <main className="app">
              <Component {...pageProps} />
            </main>
          </PostHogProvider>
        </ApolloProvider>
      </GlobalConfigProvider>
    </>
  );
}

export default App;
</file>

<file path="src/pages/_document.tsx">
/* eslint-disable react/display-name */
import Document, {
  Html,
  Head,
  Main,
  NextScript,
  DocumentContext,
  DocumentInitialProps,
} from 'next/document';
import { ServerStyleSheet } from 'styled-components';

export default class AppDocument extends Document {
  static async getInitialProps(
    ctx: DocumentContext,
  ): Promise<DocumentInitialProps> {
    const originalRenderPage = ctx.renderPage;

    const sheet = new ServerStyleSheet();

    ctx.renderPage = () =>
      originalRenderPage({
        enhanceApp: (App) => (props) => sheet.collectStyles(<App {...props} />),
        enhanceComponent: (Component) => Component,
      });

    const intialProps = await Document.getInitialProps(ctx);
    const styles = sheet.getStyleElement();

    return { ...intialProps, styles };
  }

  render() {
    return (
      <Html>
        <Head>{this.props.styles}</Head>
        <body>
          <Main />
          <NextScript />
        </body>
      </Html>
    );
  }
}
</file>

<file path="src/pages/api-management/history.tsx">
import Link from 'next/link';
import { useState } from 'react';
import { Table, TableColumnsType, Button, Tag, Typography } from 'antd';
import { getAbsoluteTime } from '@/utils/time';
import useDrawerAction from '@/hooks/useDrawerAction';
import { getColumnSearchProps } from '@/utils/table';
import SiderLayout from '@/components/layouts/SiderLayout';
import PageLayout from '@/components/layouts/PageLayout';
import ApiOutlined from '@ant-design/icons/ApiOutlined';
import EyeOutlined from '@ant-design/icons/EyeOutlined';
import CheckCircleOutlined from '@ant-design/icons/CheckCircleOutlined';
import CloseCircleOutlined from '@ant-design/icons/CloseCircleOutlined';
import SQLCodeBlock from '@/components/code/SQLCodeBlock';
import DetailsDrawer from '@/components/pages/apiManagement/DetailsDrawer';
import { useApiHistoryQuery } from '@/apollo/client/graphql/apiManagement.generated';
import { ApiType, ApiHistoryResponse } from '@/apollo/client/graphql/__types__';

const PAGE_SIZE = 10;

export default function APIHistory() {
  const detailsDrawer = useDrawerAction();
  const [currentPage, setCurrentPage] = useState<number>(1);
  const [filters, setFilters] = useState<Record<string, any>>({});

  const { data, loading } = useApiHistoryQuery({
    fetchPolicy: 'cache-and-network',
    variables: {
      pagination: {
        offset: (currentPage - 1) * PAGE_SIZE,
        limit: PAGE_SIZE,
      },
      filter: {
        apiType: filters['apiType']?.[0],
        statusCode: filters['statusCode']?.[0],
        threadId: filters['threadId']?.[0],
      },
    },
    onError: (error) => console.error(error),
  });

  const columns: TableColumnsType<ApiHistoryResponse> = [
    {
      title: 'Timestamp',
      dataIndex: 'createdAt',
      key: 'createdAt',
      width: 180,
      render: (timestamp: string) => (
        <div className="gray-7">{getAbsoluteTime(timestamp)}</div>
      ),
    },
    {
      title: 'API type',
      dataIndex: 'apiType',
      key: 'apiType',
      width: 180,
      render: (type: ApiHistoryResponse['apiType']) => (
        <Tag className="gray-8">{type.toLowerCase()}</Tag>
      ),
      filters: Object.keys(ApiType).map((type) => ({
        text: type.toLowerCase(),
        value: type,
      })),
      filteredValue: filters['apiType'],
      filterMultiple: false,
    },
    {
      title: 'Status',
      dataIndex: 'statusCode',
      key: 'statusCode',
      width: 100,
      render: (status: number) => {
        const icon =
          status === 200 ? <CheckCircleOutlined /> : <CloseCircleOutlined />;
        const color = status === 200 ? 'success' : 'error';
        return (
          <Tag icon={icon} color={color}>
            {status}
          </Tag>
        );
      },
      filters: [
        { text: 'Successful (code: 2xx)', value: 200 },
        { text: 'Client error (code: 4xx)', value: 400 },
        { text: 'Server error (code: 5xx)', value: 500 },
      ],
      filteredValue: filters['statusCode'],
      filterMultiple: false,
    },
    {
      title: 'Question / SQL',
      dataIndex: 'requestPayload',
      key: 'requestPayload',
      render: (payload: Record<string, any>, record: ApiHistoryResponse) => {
        if (record.apiType === ApiType.RUN_SQL && payload.sql) {
          return (
            <div style={{ width: '100%' }}>
              <SQLCodeBlock code={payload.sql} maxHeight="130" />
            </div>
          );
        }
        return (
          <div className="gray-8">{payload.question || payload.sql || '-'}</div>
        );
      },
    },
    {
      title: 'Thread ID',
      dataIndex: 'threadId',
      key: 'threadId',
      width: 200,
      render: (threadId: string) => {
        if (!threadId) return <div className="gray-7">-</div>;
        return (
          <Typography.Text
            ellipsis
            className="gray-7"
            copyable={{ text: threadId }}
          >
            {threadId}
          </Typography.Text>
        );
      },
      ...getColumnSearchProps({
        dataIndex: 'threadId',
        placeholder: 'thread ID',
        filteredValue: filters['threadId'],
      }),
    },
    {
      title: 'Duration (ms)',
      dataIndex: 'durationMs',
      key: 'durationMs',
      width: 124,
      render: (durationMs: number) => (
        <div className="gray-7 text-right">{durationMs || '-'}</div>
      ),
    },
    {
      title: 'Actions',
      key: 'actions',
      width: 110,
      align: 'center',
      fixed: 'right',
      render: (record) => (
        <Button
          className="gray-8"
          type="text"
          size="small"
          onClick={() => detailsDrawer.openDrawer(record)}
        >
          <EyeOutlined /> Details
        </Button>
      ),
    },
  ];

  return (
    <SiderLayout loading={false} sidebar={null}>
      <PageLayout
        title={
          <>
            <ApiOutlined className="mr-2 gray-8" />
            API history
          </>
        }
        description={
          <>
            <div>
              Here you can view the full history of API calls, including request
              inputs, responses, and execution details.{' '}
              <Link
                className="gray-8 underline mr-2"
                href="https://docs.getwren.ai/oss/guide/api-access/history"
                target="_blank"
                rel="noopener noreferrer"
              >
                Learn more.
              </Link>
            </div>
          </>
        }
      >
        <Table
          className="ant-table-has-header"
          dataSource={data?.apiHistory.items || []}
          loading={loading}
          columns={columns}
          rowKey="id"
          pagination={{
            hideOnSinglePage: true,
            pageSize: PAGE_SIZE,
            size: 'small',
            total: data?.apiHistory.total,
          }}
          scroll={{ x: 1200 }}
          onChange={(pagination, filters, _sorter) => {
            setCurrentPage(pagination.current);
            setFilters(filters);
          }}
        />
        <DetailsDrawer
          {...detailsDrawer.state}
          onClose={detailsDrawer.closeDrawer}
        />
      </PageLayout>
    </SiderLayout>
  );
}
</file>

<file path="src/pages/api/ask_task/streaming_answer.ts">
import type { NextApiRequest, NextApiResponse } from 'next';
import { components } from '@/common';
import { ThreadResponseAnswerStatus } from '@/apollo/server/services/askingService';
import { TelemetryEvent } from '@/apollo/server/telemetry/telemetry';

const { wrenAIAdaptor, askingService, telemetry } = components;

class ContentMap {
  private contentMap: { [key: string]: string } = {};

  // Method to append (concatenate) content to the map
  public appendContent(key: string, content: string) {
    if (!this.contentMap[key]) {
      this.contentMap[key] = '';
    }
    this.contentMap[key] += content;
  }

  // Method to get content from the map
  public getContent(key: string): string | undefined {
    return this.contentMap[key];
  }

  // Method to remove content from the map
  public remove(key: string) {
    delete this.contentMap[key];
  }
}

const contentMap = new ContentMap();

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse,
) {
  if (req.method !== 'GET') {
    res.status(405).json({ error: 'Method Not Allowed' });
    return;
  }

  res.setHeader('Content-Type', 'text/event-stream');
  res.setHeader('Cache-Control', 'no-cache, no-transform');
  res.setHeader('Connection', 'keep-alive');
  res.flushHeaders();

  const { responseId } = req.query;
  if (!responseId) {
    res.status(400).json({ error: 'responseId is required' });
    return;
  }
  try {
    const response = await askingService.getResponse(Number(responseId));
    if (!response) {
      throw new Error(`Thread response ${responseId} not found`);
    }

    // check response status
    if (
      response.answerDetail?.status !== ThreadResponseAnswerStatus.STREAMING
    ) {
      throw new Error(
        `Thread response ${responseId} is not in streaming status`,
      );
    }

    const queryId = response.answerDetail?.queryId;
    if (!queryId) {
      throw new Error(`Thread response ${responseId} does not have queryId`);
    }

    const stream = await wrenAIAdaptor.streamTextBasedAnswer(queryId);

    stream.on('data', (chunk) => {
      // pass the chunk directly to the client
      const chunkString = chunk.toString('utf-8');
      let message = '';
      const match = chunkString.match(/data: {"message":"([\s\S]*?)"}/);
      if (match && match[1]) {
        message = match[1];
      } else {
        console.log(`not able to match: ${chunkString}`);
      }
      contentMap.appendContent(queryId, message);
      res.write(chunk);
    });

    stream.on('end', () => {
      res.write(`data: ${JSON.stringify({ done: true })}\n\n`);
      res.end();
      askingService
        .changeThreadResponseAnswerDetailStatus(
          Number(responseId),
          ThreadResponseAnswerStatus.FINISHED,
          contentMap.getContent(queryId),
        )
        .then(() => {
          console.log(
            'Thread response answer detail status updated to FINISHED',
          );
          contentMap.remove(queryId);
          telemetry.sendEvent(TelemetryEvent.HOME_ANSWER_QUESTION, {
            question: response.question,
          });
        })
        .catch((error) => {
          console.error(
            'Failed to update thread response answer detail status',
            error,
          );
          contentMap.remove(queryId);
          telemetry.sendEvent(
            TelemetryEvent.HOME_ANSWER_QUESTION,
            {
              question: response.question,
              error: error,
            },
            null,
            false,
          );
        });
    });

    // destroy the stream if the client closes the connection
    req.on('close', () => {
      stream.destroy();
      askingService
        .changeThreadResponseAnswerDetailStatus(
          Number(responseId),
          ThreadResponseAnswerStatus.INTERRUPTED,
          contentMap.getContent(queryId),
        )
        .then(() => {
          console.log(
            'Thread response answer detail status updated to INTERRUPTED',
          );
          contentMap.remove(queryId);
          telemetry.sendEvent(TelemetryEvent.HOME_ANSWER_QUESTION_INTERRUPTED, {
            question: response.question,
          });
        })
        .catch((error) => {
          console.error(
            'Failed to update thread response answer detail status',
            error,
          );
          contentMap.remove(queryId);
          telemetry.sendEvent(
            TelemetryEvent.HOME_ANSWER_QUESTION_INTERRUPTED,
            {
              question: response.question,
              error: error,
            },
            null,
            false,
          );
        });
    });
  } catch (error) {
    console.error(error);
    res.status(500).end();
  }
}
</file>

<file path="src/pages/api/ask_task/streaming.ts">
import type { NextApiRequest, NextApiResponse } from 'next';
import { components } from '@/common';

const { wrenAIAdaptor } = components;

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse,
) {
  res.setHeader('Content-Type', 'text/event-stream');
  res.setHeader('Cache-Control', 'no-cache, no-transform');
  res.setHeader('Connection', 'keep-alive');
  res.flushHeaders();

  const { queryId } = req.query;
  try {
    const stream = await wrenAIAdaptor.getAskStreamingResult(queryId as string);

    stream.on('data', (chunk) => {
      // pass the chunk directly to the client
      res.write(chunk);
    });

    stream.on('end', () => {
      res.write(`data: ${JSON.stringify({ done: true })}\n\n`);
      res.end();
    });

    // destroy the stream if the client closes the connection
    req.on('close', () => {
      stream.destroy();
    });
  } catch (error) {
    console.error(error);
    res.status(500).end();
  }
}
</file>

<file path="src/pages/api/config.ts">
import type { NextApiRequest, NextApiResponse } from 'next';
import { getConfig } from '@/apollo/server/config';

export default function handler(_: NextApiRequest, res: NextApiResponse) {
  const config = getConfig();
  const encodedTelemetryKey = config.posthogApiKey
    ? Buffer.from(config.posthogApiKey).toString('base64')
    : '';

  res.status(200).json({
    isTelemetryEnabled: config.telemetryEnabled || false,
    telemetryKey: encodedTelemetryKey,
    telemetryHost: config.posthogHost || '',
    userUUID: config.userUUID || '',
  });
}
</file>

<file path="src/pages/api/graphql.ts">
import microCors from 'micro-cors';
import { NextApiRequest, NextApiResponse, PageConfig } from 'next';
import { ApolloServer } from 'apollo-server-micro';
import { typeDefs } from '@server';
import resolvers from '@server/resolvers';
import { IContext } from '@server/types';
import { GraphQLError } from 'graphql';
import { getLogger } from '@server/utils';
import { getConfig } from '@server/config';
import { ModelService } from '@server/services/modelService';
import {
  defaultApolloErrorHandler,
  GeneralErrorCodes,
} from '@/apollo/server/utils/error';
import { TelemetryEvent } from '@/apollo/server/telemetry/telemetry';
import { components } from '@/common';

const serverConfig = getConfig();
const logger = getLogger('APOLLO');
logger.level = 'debug';

const cors = microCors();

export const config: PageConfig = {
  api: {
    bodyParser: false,
  },
};

const bootstrapServer = async () => {
  const {
    telemetry,

    // repositories
    projectRepository,
    modelRepository,
    modelColumnRepository,
    relationRepository,
    deployLogRepository,
    viewRepository,
    schemaChangeRepository,
    learningRepository,
    modelNestedColumnRepository,
    dashboardRepository,
    dashboardItemRepository,
    sqlPairRepository,
    instructionRepository,
    apiHistoryRepository,
    dashboardItemRefreshJobRepository,
    // adaptors
    wrenEngineAdaptor,
    ibisAdaptor,
    wrenAIAdaptor,

    // services
    projectService,
    queryService,
    askingService,
    deployService,
    mdlService,
    dashboardService,
    sqlPairService,

    instructionService,
    // background trackers
    projectRecommendQuestionBackgroundTracker,
    threadRecommendQuestionBackgroundTracker,
    dashboardCacheBackgroundTracker,
  } = components;

  const modelService = new ModelService({
    projectService,
    modelRepository,
    modelColumnRepository,
    relationRepository,
    viewRepository,
    mdlService,
    wrenEngineAdaptor,
    queryService,
  });

  // initialize services
  await Promise.all([
    askingService.initialize(),
    projectRecommendQuestionBackgroundTracker.initialize(),
    threadRecommendQuestionBackgroundTracker.initialize(),
  ]);

  const apolloServer: ApolloServer = new ApolloServer({
    typeDefs,
    resolvers,
    formatError: (error: GraphQLError) => {
      // stop print error stacktrace of dry run error
      if (error.extensions?.code === GeneralErrorCodes.DRY_RUN_ERROR) {
        return defaultApolloErrorHandler(error);
      }

      // print error stacktrace of graphql error
      const stacktrace = error.extensions?.exception?.stacktrace;
      if (stacktrace) {
        logger.error(stacktrace.join('\n'));
      }

      // print original error stacktrace
      const originalError = error.extensions?.originalError as Error;
      if (originalError) {
        logger.error(`== original error ==`);
        // error may not have stack, so print error message if stack is not available
        logger.error(originalError.stack || originalError.message);
      }

      // telemetry: capture internal server error
      if (error.extensions?.code === GeneralErrorCodes.INTERNAL_SERVER_ERROR) {
        telemetry.sendEvent(
          TelemetryEvent.GRAPHQL_ERROR,
          {
            originalErrorStack: originalError?.stack,
            originalErrorMessage: originalError?.message,
            errorMessage: error.message,
          },
          error.extensions?.service,
          false,
        );
      }
      return defaultApolloErrorHandler(error);
    },
    introspection: process.env.NODE_ENV !== 'production',
    context: (): IContext => ({
      config: serverConfig,
      telemetry,
      // adaptor
      wrenEngineAdaptor,
      ibisServerAdaptor: ibisAdaptor,
      wrenAIAdaptor,
      // services
      projectService,
      modelService,
      mdlService,
      deployService,
      askingService,
      queryService,
      dashboardService,
      sqlPairService,
      instructionService,
      // repository
      projectRepository,
      modelRepository,
      modelColumnRepository,
      modelNestedColumnRepository,
      relationRepository,
      viewRepository,
      deployRepository: deployLogRepository,
      schemaChangeRepository,
      learningRepository,
      dashboardRepository,
      dashboardItemRepository,
      sqlPairRepository,
      instructionRepository,
      apiHistoryRepository,
      dashboardItemRefreshJobRepository,
      // background trackers
      projectRecommendQuestionBackgroundTracker,
      threadRecommendQuestionBackgroundTracker,
      dashboardCacheBackgroundTracker,
    }),
  });
  await apolloServer.start();
  return apolloServer;
};

const startServer = bootstrapServer();

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  const apolloServer = await startServer;
  await apolloServer.createHandler({
    path: '/api/graphql',
  })(req, res);
};

export default cors((req: NextApiRequest, res: NextApiResponse) =>
  req.method === 'OPTIONS' ? res.status(200).end() : handler(req, res),
);
</file>

<file path="src/pages/api/v1/generate_sql.ts">
import { NextApiRequest, NextApiResponse } from 'next';
import { components } from '@/common';
import { ApiType, ApiHistory } from '@server/repositories/apiHistoryRepository';
import {
  AskResult,
  AskResultStatus,
  AskResultType,
  WrenAILanguage,
  WrenAIError,
} from '@/apollo/server/models/adaptor';
import * as Errors from '@/apollo/server/utils/error';
import { getLogger } from '@server/utils';
import { v4 as uuidv4 } from 'uuid';
import {
  ApiError,
  respondWith,
  handleApiError,
} from '@/apollo/server/utils/apiUtils';
import { DataSourceName } from '@server/types';

const logger = getLogger('API_GENERATE_SQL');
logger.level = 'debug';

const {
  apiHistoryRepository,
  projectService,
  deployService,
  wrenAIAdaptor,
  wrenEngineAdaptor,
  ibisAdaptor,
} = components;

interface GenerateSqlRequest {
  question: string;
  threadId?: string;
  language?: string;
  returnSqlDialect?: boolean;
}

const MAX_WAIT_TIME = 1000 * 60 * 3; // 3 minutes

const isAskResultFinished = (result: AskResult) => {
  return (
    result.status === AskResultStatus.FINISHED ||
    result.status === AskResultStatus.FAILED ||
    result.status === AskResultStatus.STOPPED ||
    result.error
  );
};

/**
 * Validates the AI result and throws appropriate errors for different failure cases
 * @param result The AI result to validate
 * @param taskQueryId The query ID of the task (used for explanation queries)
 * @throws ApiError if result contains errors or is of an invalid type
 */
const validateAskResult = (result: AskResult, taskQueryId: string): void => {
  // Check for error in result
  if (result.error) {
    const errorMessage =
      (result.error as WrenAIError).message || 'Unknown error';
    const additionalData: Record<string, any> = {};

    // Include invalid SQL if available
    if (result.invalidSql) {
      additionalData.invalidSql = result.invalidSql;
    }

    throw new ApiError(errorMessage, 400, result.error.code, additionalData);
  }

  // Check for misleading query type
  if (result.type === AskResultType.MISLEADING_QUERY) {
    throw new ApiError(
      result.intentReasoning ||
        Errors.errorMessages[Errors.GeneralErrorCodes.NON_SQL_QUERY],
      400,
      Errors.GeneralErrorCodes.NON_SQL_QUERY,
    );
  }

  // Check for general type response
  if (result.type === AskResultType.GENERAL) {
    throw new ApiError(
      result.intentReasoning ||
        Errors.errorMessages[Errors.GeneralErrorCodes.NON_SQL_QUERY],
      400,
      Errors.GeneralErrorCodes.NON_SQL_QUERY,
      { explanationQueryId: taskQueryId },
    );
  }
};

const transformHistoryInput = (histories: ApiHistory[]) => {
  if (!histories) {
    return [];
  }
  return histories
    .filter(
      (history) =>
        history.responsePayload?.sql && history.requestPayload?.question,
    )
    .map((history) => ({
      question: history.requestPayload?.question,
      sql: history.responsePayload?.sql,
    }));
};

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse,
) {
  const {
    question,
    threadId,
    language,
    returnSqlDialect = false,
  } = req.body as GenerateSqlRequest;
  const startTime = Date.now();
  let project;

  try {
    project = await projectService.getCurrentProject();

    // Only allow POST method
    if (req.method !== 'POST') {
      throw new ApiError('Method not allowed', 405);
    }

    // input validation
    if (!question) {
      throw new ApiError('Question is required', 400);
    }

    // get current project's last deployment
    const lastDeploy = await deployService.getLastDeployment(project.id);

    if (!lastDeploy) {
      throw new ApiError(
        'No deployment found, please deploy a model first',
        400,
        Errors.GeneralErrorCodes.NO_DEPLOYMENT_FOUND,
      );
    }

    // ask AI service to generate SQL
    const histories = threadId
      ? await apiHistoryRepository.findAllBy({ threadId })
      : undefined;
    const task = await wrenAIAdaptor.ask({
      query: question,
      deployId: lastDeploy.hash,
      histories: transformHistoryInput(histories) as any,
      configurations: {
        language:
          language || WrenAILanguage[project.language] || WrenAILanguage.EN,
      },
    });

    // polling for the result
    const deadline = Date.now() + MAX_WAIT_TIME;
    let result: AskResult;
    while (true) {
      result = await wrenAIAdaptor.getAskResult(task.queryId);
      if (isAskResultFinished(result)) {
        break;
      }

      if (Date.now() > deadline) {
        throw new ApiError(
          'Timeout waiting for SQL generation',
          500,
          Errors.GeneralErrorCodes.POLLING_TIMEOUT,
        );
      }

      await new Promise((resolve) => setTimeout(resolve, 1000)); // poll every second
    }

    // Validate the AI result
    validateAskResult(result, task.queryId);

    // Get the generated SQL
    let sql = result.response?.[0]?.sql;

    // Create a new thread if it's a new question
    const newThreadId = threadId || uuidv4();

    // If returnSqlDialect is true, also get and return the native SQL
    if (returnSqlDialect && sql) {
      let nativeSql: string;
      if (project.type === DataSourceName.DUCKDB) {
        nativeSql = await wrenEngineAdaptor.getNativeSQL(sql, {
          manifest: lastDeploy.manifest,
          modelingOnly: false,
        });
      } else {
        nativeSql = await ibisAdaptor.getNativeSql({
          dataSource: project.type,
          sql,
          mdl: lastDeploy.manifest,
        });
      }

      // If the native SQL is not empty, use it
      sql = nativeSql || sql;
    }

    // Return just the SQL
    await respondWith({
      res,
      statusCode: 200,
      responsePayload: {
        sql,
        threadId: newThreadId,
      },
      projectId: project.id,
      apiType: ApiType.GENERATE_SQL,
      startTime,
      requestPayload: req.body,
      threadId: newThreadId,
      headers: req.headers as Record<string, string>,
    });
  } catch (error) {
    await handleApiError({
      error,
      res,
      projectId: project?.id,
      apiType: ApiType.GENERATE_SQL,
      requestPayload: req.body,
      threadId,
      headers: req.headers as Record<string, string>,
      startTime,
      logger,
    });
  }
}
</file>

<file path="src/pages/api/v1/generate_vega_chart.ts">
import { NextApiRequest, NextApiResponse } from 'next';
import { components } from '@/common';
import { ApiType } from '@server/repositories/apiHistoryRepository';
import * as Errors from '@/apollo/server/utils/error';
import { v4 as uuidv4 } from 'uuid';
import {
  ApiError,
  respondWith,
  handleApiError,
} from '@/apollo/server/utils/apiUtils';
import {
  ChartResult,
  ChartStatus,
  WrenAILanguage,
} from '@/apollo/server/models/adaptor';
import { PreviewDataResponse } from '@server/services/queryService';
import { transformToObjects } from '@server/utils/dataUtils';
import { enhanceVegaSpec } from '@/utils/vegaSpecUtils';

const { projectService, wrenAIAdaptor, deployService, queryService } =
  components;

const MAX_WAIT_TIME = 1000 * 60 * 3; // 3 minutes

/**
 * Validates the chart generation result and checks for errors
 * @param result The chart result to validate
 * @throws ApiError if the result has errors or is in a failed state
 */
const validateChartResult = (result: ChartResult): void => {
  // Check for errors or failed status
  if (result.status === ChartStatus.FAILED || result.error) {
    throw new ApiError(
      result.error?.message || 'Failed to generate Vega spec',
      400,
      Errors.GeneralErrorCodes.FAILED_TO_GENERATE_VEGA_SCHEMA,
    );
  }

  // Verify that the chartSchema is present
  if (!result?.response?.chartSchema) {
    throw new ApiError('Failed to generate Vega spec', 500);
  }
};

interface GenerateVegaSpecRequest {
  question: string;
  sql: string;
  threadId?: string;
  sampleSize?: number;
}

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse,
) {
  const {
    question,
    sql,
    threadId,
    sampleSize = 10000,
  } = req.body as GenerateVegaSpecRequest;
  const startTime = Date.now();
  let project;

  try {
    project = await projectService.getCurrentProject();

    // Only allow POST method
    if (req.method !== 'POST') {
      throw new ApiError('Method not allowed', 405);
    }

    // Input validation
    if (!question) {
      throw new ApiError('Question is required', 400);
    }

    if (!sql) {
      throw new ApiError('SQL is required', 400);
    }

    if (
      !Number.isInteger(sampleSize) ||
      sampleSize <= 0 ||
      sampleSize > 1000000
    ) {
      throw new ApiError('Invalid sampleSize', 400);
    }

    // Get current project's last deployment
    const lastDeploy = await deployService.getLastDeployment(project.id);
    if (!lastDeploy) {
      throw new ApiError(
        'No deployment found, please deploy your project first',
        400,
        Errors.GeneralErrorCodes.NO_DEPLOYMENT_FOUND,
      );
    }

    // Execute the SQL query to get the data
    let queryResult: PreviewDataResponse;
    try {
      queryResult = (await queryService.preview(sql, {
        project,
        limit: sampleSize,
        manifest: lastDeploy.manifest,
        modelingOnly: false,
      })) as PreviewDataResponse;
    } catch (queryError) {
      throw new ApiError(
        queryError.message || 'Error executing SQL query',
        400,
        Errors.GeneralErrorCodes.INVALID_SQL_ERROR,
      );
    }

    // Transform query results to array of objects
    const dataObjects = transformToObjects(
      queryResult.columns,
      queryResult.data,
    );

    // Ask AI service to generate a Vega spec chart
    const task = await wrenAIAdaptor.generateChart({
      query: question,
      sql,
      projectId: project.id.toString(),
      configurations: {
        language: WrenAILanguage[project.language] || WrenAILanguage.EN,
      },
    });

    if (!task || !task.queryId) {
      throw new ApiError('Failed to start Vega spec generation task', 500);
    }

    // Poll for the result
    const deadline = Date.now() + MAX_WAIT_TIME;
    let result: ChartResult;
    while (true) {
      result = await wrenAIAdaptor.getChartResult(task.queryId);
      if (
        result.status === ChartStatus.FINISHED ||
        result.status === ChartStatus.FAILED
      ) {
        break;
      }

      if (Date.now() > deadline) {
        throw new ApiError(
          'Timeout waiting for Vega spec generation',
          500,
          Errors.GeneralErrorCodes.POLLING_TIMEOUT,
        );
      }

      await new Promise((resolve) => setTimeout(resolve, 1000)); // Poll every second
    }

    // Validate the chart result
    validateChartResult(result);

    // Create a new thread if it's a new question
    const newThreadId = threadId || uuidv4();

    // Get the generated Vega spec
    const vegaSpec = result?.response?.chartSchema;

    // Enhance the Vega spec with styling and configuration
    const enhancedVegaSpec = enhanceVegaSpec(vegaSpec, dataObjects);

    // Return the Vega spec with data included
    await respondWith({
      res,
      statusCode: 200,
      responsePayload: {
        vegaSpec: enhancedVegaSpec,
        threadId: newThreadId,
      },
      projectId: project.id,
      apiType: ApiType.GENERATE_VEGA_CHART,
      startTime,
      requestPayload: req.body,
      threadId: newThreadId,
      headers: req.headers as Record<string, string>,
    });
  } catch (error) {
    await handleApiError({
      error,
      res,
      projectId: project?.id,
      apiType: ApiType.GENERATE_VEGA_CHART,
      requestPayload: req.body,
      threadId,
      headers: req.headers as Record<string, string>,
      startTime,
    });
  }
}
</file>

<file path="src/pages/api/v1/run_sql.ts">
import { NextApiRequest, NextApiResponse } from 'next';
import { components } from '@/common';
import { ApiType } from '@server/repositories/apiHistoryRepository';
import * as Errors from '@/apollo/server/utils/error';
import { getLogger } from '@server/utils';
import { v4 as uuidv4 } from 'uuid';
import { PreviewDataResponse } from '@server/services/queryService';
import {
  ApiError,
  respondWith,
  handleApiError,
} from '@/apollo/server/utils/apiUtils';
import { transformToObjects } from '@server/utils/dataUtils';

const logger = getLogger('API_RUN_SQL');
logger.level = 'debug';

const { projectService, queryService, deployService } = components;

/**
 * Validates the SQL result and ensures it has the expected format
 * @param result The result to validate
 * @returns The validated result as PreviewDataResponse
 * @throws ApiError if the result is in an unexpected format
 */
const validateSqlResult = (result: any): PreviewDataResponse => {
  // Ensure we have a valid result with expected properties
  if (typeof result === 'boolean') {
    throw new ApiError('Unexpected query result format', 500);
  }

  return result as PreviewDataResponse;
};

interface RunSqlRequest {
  sql: string;
  threadId?: string;
  limit?: number;
}

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse,
) {
  const { sql, threadId, limit = 1000 } = req.body as RunSqlRequest;
  const startTime = Date.now();
  let project;

  try {
    // Only allow POST method
    if (req.method !== 'POST') {
      throw new ApiError('Method not allowed', 405);
    }

    // input validation
    if (!sql) {
      throw new ApiError('SQL is required', 400);
    }

    project = await projectService.getCurrentProject();

    const deployment = await deployService.getLastDeployment(project.id);

    if (!deployment) {
      throw new ApiError(
        'No deployment found, please deploy your project first',
        400,
        Errors.GeneralErrorCodes.NO_DEPLOYMENT_FOUND,
      );
    }

    const manifest = deployment.manifest;

    // Execute the SQL query
    try {
      const result = await queryService.preview(sql, {
        project,
        limit,
        manifest,
        modelingOnly: false,
      });

      // Validate the SQL result
      const queryResult = validateSqlResult(result);

      // Transform data into array of objects
      const transformedData = transformToObjects(
        queryResult.columns,
        queryResult.data,
      );

      // create a new thread if it's a new query
      const newThreadId = threadId || uuidv4();

      await respondWith({
        res,
        statusCode: 200,
        responsePayload: {
          records: transformedData,
          columns: queryResult.columns,
          threadId: newThreadId,
          totalRows: queryResult.data?.length || 0,
        },
        projectId: project.id,
        apiType: ApiType.RUN_SQL,
        startTime,
        requestPayload: req.body,
        threadId: newThreadId,
        headers: req.headers as Record<string, string>,
      });
    } catch (queryError) {
      logger.error('Error executing SQL:', queryError);
      throw new ApiError(
        queryError.message || 'Error executing SQL query',
        400,
        Errors.GeneralErrorCodes.INVALID_SQL_ERROR,
      );
    }
  } catch (error) {
    await handleApiError({
      error,
      res,
      projectId: project?.id,
      apiType: ApiType.RUN_SQL,
      requestPayload: req.body,
      threadId,
      headers: req.headers as Record<string, string>,
      startTime,
      logger,
    });
  }
}
</file>

<file path="src/pages/api/v1/stream_explanation.ts">
import type { NextApiRequest, NextApiResponse } from 'next';
import { components } from '@/common';

const { wrenAIAdaptor } = components;

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse,
) {
  res.setHeader('Content-Type', 'text/event-stream');
  res.setHeader('Cache-Control', 'no-cache, no-transform');
  res.setHeader('Connection', 'keep-alive');
  res.flushHeaders();

  const { queryId } = req.query;
  if (!queryId) {
    res.status(400).json({ error: 'queryId is required' });
    return;
  }

  try {
    const stream = await wrenAIAdaptor.getAskStreamingResult(queryId as string);

    stream.on('data', (chunk) => {
      // pass the chunk directly to the client
      res.write(chunk);
    });

    stream.on('end', () => {
      res.write(`data: ${JSON.stringify({ done: true })}\n\n`);
      res.end();
    });

    // destroy the stream if the client closes the connection
    req.on('close', () => {
      stream.destroy();
    });
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: error.message });
  }
}
</file>

<file path="src/pages/home/[id].tsx">
import { useRouter } from 'next/router';
import { useParams } from 'next/navigation';
import {
  ComponentRef,
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
} from 'react';
import { isEmpty } from 'lodash';
import { message } from 'antd';
import { Path } from '@/utils/enum';
import useHomeSidebar from '@/hooks/useHomeSidebar';
import SiderLayout from '@/components/layouts/SiderLayout';
import Prompt from '@/components/pages/home/prompt';
import useAskPrompt, {
  getIsFinished,
  canFetchThreadResponse,
  isRecommendedFinished,
} from '@/hooks/useAskPrompt';
import useAdjustAnswer from '@/hooks/useAdjustAnswer';
import useModalAction from '@/hooks/useModalAction';
import PromptThread from '@/components/pages/home/promptThread';
import SaveAsViewModal from '@/components/modals/SaveAsViewModal';
import QuestionSQLPairModal from '@/components/modals/QuestionSQLPairModal';
import AdjustReasoningStepsModal from '@/components/modals/AdjustReasoningStepsModal';
import AdjustSQLModal from '@/components/modals/AdjustSQLModal';
import { getAnswerIsFinished } from '@/components/pages/home/promptThread/TextBasedAnswer';
import { getIsChartFinished } from '@/components/pages/home/promptThread/ChartAnswer';
import { PromptThreadProvider } from '@/components/pages/home/promptThread/store';
import {
  useCreateThreadResponseMutation,
  useThreadQuery,
  useThreadResponseLazyQuery,
  useUpdateThreadResponseMutation,
  useGenerateThreadRecommendationQuestionsMutation,
  useGetThreadRecommendationQuestionsLazyQuery,
  useGenerateThreadResponseAnswerMutation,
  useGenerateThreadResponseChartMutation,
  useAdjustThreadResponseChartMutation,
} from '@/apollo/client/graphql/home.generated';
import { useCreateViewMutation } from '@/apollo/client/graphql/view.generated';
import {
  AdjustThreadResponseChartInput,
  CreateThreadResponseInput,
  ThreadResponse,
  CreateSqlPairInput,
} from '@/apollo/client/graphql/__types__';
import { useCreateSqlPairMutation } from '@/apollo/client/graphql/sqlPairs.generated';

const getThreadResponseIsFinished = (threadResponse: ThreadResponse) => {
  const { answerDetail, breakdownDetail, chartDetail } = threadResponse || {};
  // it means it's the old data before support text based answer
  const isBreakdownOnly = answerDetail === null && !isEmpty(breakdownDetail);

  // false make it keep polling when the text based answer is default needed.
  let isAnswerFinished = isBreakdownOnly ? null : false;
  let isChartFinished = null;

  // answerDetail status can be FAILED before getting queryId from Wren AI adapter
  if (answerDetail?.queryId || answerDetail?.status) {
    isAnswerFinished = getAnswerIsFinished(answerDetail?.status);
  }

  if (chartDetail?.queryId) {
    isChartFinished = getIsChartFinished(chartDetail?.status);
  }
  // if equal false, it means it has task & the task is not finished
  return isAnswerFinished !== false && isChartFinished !== false;
};

export default function HomeThread() {
  const $prompt = useRef<ComponentRef<typeof Prompt>>(null);
  const router = useRouter();
  const params = useParams();
  const homeSidebar = useHomeSidebar();
  const threadId = useMemo(() => Number(params?.id) || null, [params]);
  const askPrompt = useAskPrompt(threadId);
  const adjustAnswer = useAdjustAnswer(threadId);
  const saveAsViewModal = useModalAction();
  const questionSqlPairModal = useModalAction();
  const adjustReasoningStepsModal = useModalAction();
  const adjustSqlModal = useModalAction();

  const [showRecommendedQuestions, setShowRecommendedQuestions] =
    useState<boolean>(false);

  const [createViewMutation, { loading: creating }] = useCreateViewMutation({
    onError: (error) => console.error(error),
    onCompleted: () => message.success('Successfully created view.'),
  });

  const { data, updateQuery: updateThreadQuery } = useThreadQuery({
    variables: { threadId },
    fetchPolicy: 'cache-and-network',
    skip: threadId === null,
    onError: () => router.push(Path.Home),
  });
  const [createThreadResponse] = useCreateThreadResponseMutation({
    onCompleted(next) {
      const nextResponse = next.createThreadResponse;
      updateThreadQuery((prev) => {
        return {
          ...prev,
          thread: {
            ...prev.thread,
            responses: [...prev.thread.responses, nextResponse],
          },
        };
      });
    },
  });
  const [updateThreadResponse, { loading: threadResponseUpdating }] =
    useUpdateThreadResponseMutation({
      onCompleted: (data) => {
        message.success('Successfully updated the SQL statement');
        // trigger generate answer after sql statement updated
        onGenerateThreadResponseAnswer(data.updateThreadResponse.id);
      },
    });
  const [fetchThreadResponse, threadResponseResult] =
    useThreadResponseLazyQuery({
      pollInterval: 1000,
      onCompleted(next) {
        const nextResponse = next.threadResponse;
        updateThreadQuery((prev) => ({
          ...prev,
          thread: {
            ...prev.thread,
            responses: prev.thread.responses.map((response) =>
              response.id === nextResponse.id ? nextResponse : response,
            ),
          },
        }));
      },
    });

  const [generateThreadRecommendationQuestions] =
    useGenerateThreadRecommendationQuestionsMutation();

  const [
    fetchThreadRecommendationQuestions,
    threadRecommendationQuestionsResult,
  ] = useGetThreadRecommendationQuestionsLazyQuery({
    pollInterval: 1000,
  });

  const [generateThreadResponseAnswer] =
    useGenerateThreadResponseAnswerMutation();

  const [generateThreadResponseChart] =
    useGenerateThreadResponseChartMutation();
  const [adjustThreadResponseChart] = useAdjustThreadResponseChartMutation();

  const [createSqlPairMutation, { loading: createSqlPairLoading }] =
    useCreateSqlPairMutation({
      refetchQueries: ['SqlPairs'],
      awaitRefetchQueries: true,
      onError: (error) => console.error(error),
      onCompleted: () => {
        message.success('Successfully created question-sql pair.');
      },
    });

  const thread = useMemo(() => data?.thread || null, [data]);
  const responses = useMemo(() => thread?.responses || [], [thread]);
  const pollingResponse = useMemo(
    () => threadResponseResult.data?.threadResponse || null,
    [threadResponseResult.data],
  );
  const isPollingResponseFinished = useMemo(
    () => getThreadResponseIsFinished(pollingResponse),
    [pollingResponse],
  );

  const onFixSQLStatement = async (responseId: number, sql: string) => {
    await updateThreadResponse({
      variables: { where: { id: responseId }, data: { sql } },
    });
  };

  const onGenerateThreadResponseAnswer = async (responseId: number) => {
    await generateThreadResponseAnswer({ variables: { responseId } });
    fetchThreadResponse({ variables: { responseId } });
  };

  const onGenerateThreadResponseChart = async (responseId: number) => {
    await generateThreadResponseChart({ variables: { responseId } });
    fetchThreadResponse({ variables: { responseId } });
  };

  const onAdjustThreadResponseChart = async (
    responseId: number,
    data: AdjustThreadResponseChartInput,
  ) => {
    await adjustThreadResponseChart({
      variables: { responseId, data },
    });
    fetchThreadResponse({ variables: { responseId } });
  };

  const onGenerateThreadRecommendedQuestions = async () => {
    await generateThreadRecommendationQuestions({ variables: { threadId } });
    fetchThreadRecommendationQuestions({ variables: { threadId } });
  };

  const handleUnfinishedTasks = useCallback(
    (responses: ThreadResponse[]) => {
      // unfinished asking task
      const unfinishedAskingResponse = (responses || []).find(
        (response) =>
          response?.askingTask && !getIsFinished(response?.askingTask?.status),
      );
      if (unfinishedAskingResponse) {
        askPrompt.onFetching(unfinishedAskingResponse?.askingTask?.queryId);
        return;
      }

      // unfinished thread response
      const unfinishedThreadResponse = (responses || []).find(
        (response) => !getThreadResponseIsFinished(response),
      );

      if (
        canFetchThreadResponse(unfinishedThreadResponse?.askingTask) &&
        unfinishedThreadResponse
      ) {
        fetchThreadResponse({
          variables: { responseId: unfinishedThreadResponse.id },
        });
      }
    },
    [askPrompt, fetchThreadResponse],
  );

  // store thread questions for instant recommended questions
  const storeQuestionsToAskPrompt = useCallback(
    (responses: ThreadResponse[]) => {
      const questions = responses.flatMap((res) => res.question || []);
      if (questions) askPrompt.onStoreThreadQuestions(questions);
    },
    [askPrompt],
  );

  // stop all requests when change thread
  useEffect(() => {
    if (threadId !== null) {
      fetchThreadRecommendationQuestions({ variables: { threadId } });
      setShowRecommendedQuestions(true);
    }
    return () => {
      askPrompt.onStopPolling();
      threadResponseResult.stopPolling();
      threadRecommendationQuestionsResult.stopPolling();
      $prompt.current?.close();
    };
  }, [threadId]);

  // initialize asking task
  useEffect(() => {
    if (!responses) return;
    handleUnfinishedTasks(responses);
    storeQuestionsToAskPrompt(responses);
  }, [responses]);

  useEffect(() => {
    if (isPollingResponseFinished) {
      threadResponseResult.stopPolling();
      setShowRecommendedQuestions(true);
    }
  }, [isPollingResponseFinished]);

  const recommendedQuestions = useMemo(
    () =>
      threadRecommendationQuestionsResult.data
        ?.getThreadRecommendationQuestions || null,
    [threadRecommendationQuestionsResult.data],
  );

  useEffect(() => {
    if (isRecommendedFinished(recommendedQuestions?.status)) {
      threadRecommendationQuestionsResult.stopPolling();
    }
  }, [recommendedQuestions]);

  const onCreateResponse = async (payload: CreateThreadResponseInput) => {
    try {
      askPrompt.onStopPolling();

      const threadId = thread.id;
      await createThreadResponse({
        variables: { threadId, data: payload },
      });
      setShowRecommendedQuestions(false);
    } catch (error) {
      console.error(error);
    }
  };

  const providerValue = {
    data: thread,
    recommendedQuestions,
    showRecommendedQuestions,
    preparation: {
      askingStreamTask: askPrompt.data?.askingStreamTask,
      onStopAskingTask: askPrompt.onStop,
      onReRunAskingTask: askPrompt.onReRun,
      onStopAdjustTask: adjustAnswer.onStop,
      onReRunAdjustTask: adjustAnswer.onReRun,
      onFixSQLStatement,
      fixStatementLoading: threadResponseUpdating,
    },
    onOpenSaveAsViewModal: saveAsViewModal.openModal,
    onSelectRecommendedQuestion: onCreateResponse,
    onGenerateThreadRecommendedQuestions: onGenerateThreadRecommendedQuestions,
    onGenerateTextBasedAnswer: onGenerateThreadResponseAnswer,
    onGenerateChartAnswer: onGenerateThreadResponseChart,
    onAdjustChartAnswer: onAdjustThreadResponseChart,
    onOpenSaveToKnowledgeModal: questionSqlPairModal.openModal,
    onOpenAdjustReasoningStepsModal: adjustReasoningStepsModal.openModal,
    onOpenAdjustSQLModal: adjustSqlModal.openModal,
  };

  return (
    <SiderLayout loading={false} sidebar={homeSidebar}>
      <PromptThreadProvider value={providerValue}>
        <PromptThread />
      </PromptThreadProvider>

      <div className="py-12" />
      <Prompt
        ref={$prompt}
        {...askPrompt}
        onCreateResponse={onCreateResponse}
      />
      <SaveAsViewModal
        {...saveAsViewModal.state}
        loading={creating}
        onClose={saveAsViewModal.closeModal}
        onSubmit={async (values) => {
          await createViewMutation({
            variables: { data: values },
          });
        }}
      />
      <QuestionSQLPairModal
        {...questionSqlPairModal.state}
        onClose={questionSqlPairModal.closeModal}
        loading={createSqlPairLoading}
        onSubmit={async ({ data }: { data: CreateSqlPairInput }) => {
          await createSqlPairMutation({ variables: { data } });
        }}
      />

      <AdjustReasoningStepsModal
        {...adjustReasoningStepsModal.state}
        onClose={adjustReasoningStepsModal.closeModal}
        loading={adjustAnswer.loading}
        onSubmit={async (values) => {
          await adjustAnswer.onAdjustReasoningSteps(
            values.responseId,
            values.data,
          );
        }}
      />

      <AdjustSQLModal
        {...adjustSqlModal.state}
        onClose={adjustSqlModal.closeModal}
        loading={adjustAnswer.loading}
        onSubmit={async (values) =>
          await adjustAnswer.onAdjustSQL(values.responseId, values.sql)
        }
      />
    </SiderLayout>
  );
}
</file>

<file path="src/pages/home/dashboard.tsx">
import { useMemo, useRef } from 'react';
import { message } from 'antd';
import { Path } from '@/utils/enum';
import { useRouter } from 'next/router';
import SiderLayout from '@/components/layouts/SiderLayout';
import useHomeSidebar from '@/hooks/useHomeSidebar';
import useDrawerAction from '@/hooks/useDrawerAction';
import { LoadingWrapper } from '@/components/PageLoading';
import DashboardGrid from '@/components/pages/home/dashboardGrid';
import EmptyDashboard from '@/components/pages/home/dashboardGrid/EmptyDashboard';
import DashboardHeader from '@/components/pages/home/dashboardGrid/DashboardHeader';
import CacheSettingsDrawer, {
  Schedule,
} from '@/components/pages/home/dashboardGrid/CacheSettingsDrawer';
import {
  useDashboardQuery,
  useDeleteDashboardItemMutation,
  useUpdateDashboardItemLayoutsMutation,
  useSetDashboardScheduleMutation,
} from '@/apollo/client/graphql/dashboard.generated';
import { useGetSettingsQuery } from '@/apollo/client/graphql/settings.generated';
import {
  DataSource,
  DataSourceName,
  ItemLayoutInput,
} from '@/apollo/client/graphql/__types__';

const isSupportCachedSettings = (dataSource: DataSource) => {
  // DuckDB not supported, sample dataset as well
  return (
    !dataSource?.sampleDataset && dataSource?.type !== DataSourceName.DUCKDB
  );
};

export default function Dashboard() {
  const router = useRouter();
  const dashboardGridRef = useRef<{ onRefreshAll: () => void }>(null);
  const homeSidebar = useHomeSidebar();
  const cacheSettingsDrawer = useDrawerAction();
  const { data: settingsResult } = useGetSettingsQuery();
  const settings = settingsResult?.settings;
  const isSupportCached = useMemo(
    () => isSupportCachedSettings(settings?.dataSource),
    [settings?.dataSource],
  );

  const {
    data,
    loading,
    updateQuery: updateDashboardQuery,
  } = useDashboardQuery({
    fetchPolicy: 'cache-and-network',
    onError: () => {
      message.error('Failed to fetch dashboard items.');
      router.push(Path.Home);
    },
  });
  const dashboardItems = useMemo(
    () => data?.dashboard?.items || [],
    [data?.dashboard?.items],
  );

  const [setDashboardSchedule] = useSetDashboardScheduleMutation({
    refetchQueries: ['Dashboard'],
    onCompleted: () => {
      message.success('Successfully updated dashboard schedule.');
    },
    onError: (error) => console.error(error),
  });

  const [updateDashboardItemLayouts] = useUpdateDashboardItemLayoutsMutation({
    onError: () => {
      message.error('Failed to update dashboard item layouts.');
    },
  });
  const [deleteDashboardItem] = useDeleteDashboardItemMutation({
    onCompleted: (_, query) => {
      message.success('Successfully deleted dashboard item.');
      onRemoveDashboardItemFromQueryCache(query.variables.where.id);
    },
  });

  const onRemoveDashboardItemFromQueryCache = (id: number) => {
    updateDashboardQuery((prev) => {
      return {
        ...prev,
        dashboard: {
          ...prev.dashboard,
          items: prev?.dashboard?.items?.filter((item) => item.id !== id) || [],
        },
      };
    });
  };

  const onUpdateChange = async (layouts: ItemLayoutInput[]) => {
    if (layouts && layouts.length > 0) {
      await updateDashboardItemLayouts({ variables: { data: { layouts } } });
    }
  };

  const onDelete = async (id: number) => {
    await deleteDashboardItem({ variables: { where: { id } } });
  };

  return (
    <SiderLayout loading={false} color="gray-3" sidebar={homeSidebar}>
      <LoadingWrapper loading={loading}>
        <>
          <EmptyDashboard show={dashboardItems.length === 0}>
            <DashboardHeader
              isSupportCached={isSupportCached}
              schedule={data?.dashboard?.schedule as Schedule}
              nextScheduleTime={data?.dashboard?.nextScheduledAt}
              onCacheSettings={() => {
                cacheSettingsDrawer.openDrawer({
                  cacheEnabled: data?.dashboard?.cacheEnabled,
                  schedule: data?.dashboard?.schedule,
                });
              }}
              onRefreshAll={() => {
                dashboardGridRef?.current?.onRefreshAll();
              }}
            />
            <DashboardGrid
              ref={dashboardGridRef}
              items={dashboardItems}
              isSupportCached={isSupportCached}
              onUpdateChange={onUpdateChange}
              onDelete={onDelete}
            />
          </EmptyDashboard>
          {isSupportCached && (
            <CacheSettingsDrawer
              {...cacheSettingsDrawer.state}
              onClose={cacheSettingsDrawer.closeDrawer}
              onSubmit={async (values) => {
                await setDashboardSchedule({ variables: { data: values } });
              }}
            />
          )}
        </>
      </LoadingWrapper>
    </SiderLayout>
  );
}
</file>

<file path="src/pages/home/index.tsx">
import { ComponentRef, useMemo, useRef } from 'react';
import { useRouter } from 'next/router';
import { Button, Typography } from 'antd';
import { Logo } from '@/components/Logo';
import { Path } from '@/utils/enum';
import SiderLayout from '@/components/layouts/SiderLayout';
import Prompt from '@/components/pages/home/prompt';
import DemoPrompt from '@/components/pages/home/prompt/DemoPrompt';
import useHomeSidebar from '@/hooks/useHomeSidebar';
import useAskPrompt from '@/hooks/useAskPrompt';
import useRecommendedQuestionsInstruction from '@/hooks/useRecommendedQuestionsInstruction';
import RecommendedQuestionsPrompt from '@/components/pages/home/prompt/RecommendedQuestionsPrompt';
import {
  useSuggestedQuestionsQuery,
  useCreateThreadMutation,
  useThreadLazyQuery,
} from '@/apollo/client/graphql/home.generated';
import { useGetSettingsQuery } from '@/apollo/client/graphql/settings.generated';
import { CreateThreadInput } from '@/apollo/client/graphql/__types__';

const { Text } = Typography;

const Wrapper = ({ children }) => {
  return (
    <div
      className="d-flex align-center justify-center flex-column"
      style={{ height: '100%' }}
    >
      <Logo size={48} color="var(--gray-8)" />
      <div className="text-md text-medium gray-8 mt-3">
        Know more about your data
      </div>
      {children}
    </div>
  );
};

const SampleQuestionsInstruction = (props) => {
  const { sampleQuestions, onSelect } = props;

  return (
    <Wrapper>
      <DemoPrompt demo={sampleQuestions} onSelect={onSelect} />
    </Wrapper>
  );
};

function RecommendedQuestionsInstruction(props) {
  const { onSelect, loading } = props;

  const {
    buttonProps,
    generating,
    recommendedQuestions,
    showRetry,
    showRecommendedQuestionsPromptMode,
  } = useRecommendedQuestionsInstruction();

  return showRecommendedQuestionsPromptMode ? (
    <div
      className="d-flex align-center flex-column pt-10"
      style={{ margin: 'auto' }}
    >
      <RecommendedQuestionsPrompt
        recommendedQuestions={recommendedQuestions}
        onSelect={onSelect}
        loading={loading}
      />
      <div className="py-12" />
    </div>
  ) : (
    <Wrapper>
      <Button className="mt-6" {...buttonProps} />
      {generating && (
        <Text className="mt-3 text-sm gray-6">
          Thinking of good questions for you... (about 1 minute)
        </Text>
      )}
      {!generating && showRetry && (
        <Text className="mt-3 text-sm gray-6 text-center">
          We couldn't think of questions right now.
          <br />
          Let's try again later.
        </Text>
      )}
    </Wrapper>
  );
}

export default function Home() {
  const $prompt = useRef<ComponentRef<typeof Prompt>>(null);
  const router = useRouter();
  const homeSidebar = useHomeSidebar();
  const askPrompt = useAskPrompt();

  const { data: suggestedQuestionsData } = useSuggestedQuestionsQuery({
    fetchPolicy: 'cache-and-network',
  });
  const [createThread, { loading: threadCreating }] = useCreateThreadMutation({
    onCompleted: () => homeSidebar.refetch(),
  });
  const [preloadThread] = useThreadLazyQuery({
    fetchPolicy: 'cache-and-network',
  });

  const { data: settingsResult } = useGetSettingsQuery();
  const settings = settingsResult?.settings;
  const isSampleDataset = useMemo(
    () => Boolean(settings?.dataSource?.sampleDataset),
    [settings],
  );

  const sampleQuestions = useMemo(
    () => suggestedQuestionsData?.suggestedQuestions.questions || [],
    [suggestedQuestionsData],
  );

  const onSelectQuestion = async ({ question }) => {
    $prompt.current.submit(question);
  };

  const onCreateResponse = async (payload: CreateThreadInput) => {
    try {
      askPrompt.onStopPolling();
      const response = await createThread({ variables: { data: payload } });
      const threadId = response.data.createThread.id;
      await preloadThread({ variables: { threadId } });
      router.push(Path.Home + `/${threadId}`);
    } catch (error) {
      console.error(error);
    }
  };

  return (
    <SiderLayout loading={false} sidebar={homeSidebar}>
      {isSampleDataset && (
        <SampleQuestionsInstruction
          sampleQuestions={sampleQuestions}
          onSelect={onSelectQuestion}
        />
      )}

      {!isSampleDataset && (
        <RecommendedQuestionsInstruction
          onSelect={onCreateResponse}
          loading={threadCreating}
        />
      )}
      <Prompt
        ref={$prompt}
        {...askPrompt}
        onCreateResponse={onCreateResponse}
      />
    </SiderLayout>
  );
}
</file>

<file path="src/pages/index.tsx">
import { useWithOnboarding } from '@/hooks/useCheckOnboarding';
import PageLoading from '@/components/PageLoading';

export default function Index() {
  useWithOnboarding();

  return <PageLoading visible />;
}
</file>

<file path="src/pages/knowledge/instructions.tsx">
import Link from 'next/link';
import {
  Button,
  Tag,
  Table,
  TableColumnsType,
  Typography,
  message,
} from 'antd';
import styled from 'styled-components';
import SiderLayout from '@/components/layouts/SiderLayout';
import PageLayout from '@/components/layouts/PageLayout';
import { InstructionsSVG } from '@/utils/svgs';
import QuestionOutlined from '@ant-design/icons/QuestionOutlined';
import { MORE_ACTION } from '@/utils/enum';
import { getCompactTime } from '@/utils/time';
import { MoreButton } from '@/components/ActionButton';
import { InstructionDropdown } from '@/components/diagram/CustomDropdown';
import useDrawerAction from '@/hooks/useDrawerAction';
import useModalAction from '@/hooks/useModalAction';
import GlobalLabel from '@/components/pages/knowledge/GlobalLabel';
import InstructionModal from '@/components/modals/InstructionModal';
import InstructionDrawer from '@/components/pages/knowledge/InstructionDrawer';
import { Instruction } from '@/apollo/client/graphql/__types__';
import {
  useInstructionsQuery,
  useCreateInstructionMutation,
  useUpdateInstructionMutation,
  useDeleteInstructionMutation,
} from '@/apollo/client/graphql/instructions.generated';

const { Paragraph, Text } = Typography;

const StyledQuestionsBlock = styled.div`
  margin: -2px -4px;
`;

const StyledTag = styled(Tag)`
  &.ant-tag.ant-tag {
    display: inline-block;
    margin: 2px 4px;
    max-width: 100%;
  }
`;

const StyledInstructionsIcon = styled(InstructionsSVG)`
  width: 20px;
  height: 20px;
`;

export default function ManageInstructions() {
  const instructionModal = useModalAction();
  const instructionDrawer = useDrawerAction();

  const { data, loading } = useInstructionsQuery({
    fetchPolicy: 'cache-and-network',
  });
  const instructions = data?.instructions || [];

  const getBaseOptions = (options) => {
    return {
      onError: (error) => console.error(error),
      refetchQueries: ['Instructions'],
      awaitRefetchQueries: true,
      ...options,
    };
  };

  const [createInstructionMutation, { loading: createInstructionLoading }] =
    useCreateInstructionMutation(
      getBaseOptions({
        onCompleted: () => {
          message.success('Successfully created instruction.');
        },
      }),
    );

  const [updateInstructionMutation, { loading: updateInstructionLoading }] =
    useUpdateInstructionMutation(
      getBaseOptions({
        onCompleted: () => {
          message.success('Successfully updated instruction.');
        },
      }),
    );

  const [deleteInstructionMutation] = useDeleteInstructionMutation(
    getBaseOptions({
      onCompleted: () => {
        message.success('Successfully deleted instruction.');
      },
    }),
  );

  const onMoreClick = async (payload) => {
    const { type, data } = payload;
    if (type === MORE_ACTION.DELETE) {
      await deleteInstructionMutation({
        variables: { where: { id: data.id } },
      });
    } else if (type === MORE_ACTION.EDIT) {
      instructionModal.openModal(data);
    } else if (type === MORE_ACTION.VIEW_INSTRUCTION) {
      instructionDrawer.openDrawer(data);
    }
  };

  const columns: TableColumnsType<Instruction> = [
    {
      title: 'Instruction details',
      dataIndex: 'instruction',
      render: (instruction) => (
        <Paragraph title={instruction} ellipsis={{ rows: 3 }}>
          {instruction}
        </Paragraph>
      ),
    },
    {
      title: 'Matching questions',
      dataIndex: 'questions',
      width: '50%',
      render: (questions, record) => {
        if (record.isDefault) return <GlobalLabel />;

        const displayQuestions = questions.slice(0, 2);
        const moreCount = questions.length - 2;

        return (
          <StyledQuestionsBlock>
            {displayQuestions.map((question) => (
              <div key={question} className="mb-1">
                <StyledTag className="bg-gray-1 border-gray-5 text-truncate">
                  <QuestionOutlined className="geekblue-6" />
                  <Text className="gray-9" title={question}>
                    {question}
                  </Text>
                </StyledTag>
              </div>
            ))}
            {moreCount > 0 && (
              <div className="text-sm gray-7 pl-1">
                +{moreCount} more question{moreCount > 1 ? 's' : ''}
              </div>
            )}
          </StyledQuestionsBlock>
        );
      },
    },
    {
      title: 'Created time',
      dataIndex: 'createdAt',
      width: 130,
      render: (time) => <Text className="gray-7">{getCompactTime(time)}</Text>,
    },
    {
      key: 'action',
      width: 64,
      align: 'center',
      fixed: 'right',
      render: (_, record) => (
        <InstructionDropdown onMoreClick={onMoreClick} data={record}>
          <MoreButton className="gray-8" />
        </InstructionDropdown>
      ),
    },
  ];

  return (
    <SiderLayout loading={false}>
      <PageLayout
        title={
          <>
            <StyledInstructionsIcon className="mr-2 gray-8" />
            Manage instruction
          </>
        }
        titleExtra={
          <Button type="primary" onClick={() => instructionModal.openModal()}>
            Add an instruction
          </Button>
        }
        description={
          <>
            On this page, you can manage saved instructions that guide Wren AI
            in generating SQL queries. These instructions help Wren AI
            understand your data model and business rules, improving query
            accuracy and reducing the need for manual refinements.{' '}
            <Link
              className="gray-8 underline"
              href="https://docs.getwren.ai/oss/guide/knowledge/instructions"
              rel="noopener noreferrer"
              target="_blank"
            >
              Learn more.
            </Link>
          </>
        }
      >
        <Table
          className="ant-table-has-header"
          dataSource={instructions}
          loading={loading}
          columns={columns}
          rowKey="id"
          pagination={{
            hideOnSinglePage: true,
            pageSize: 10,
            size: 'small',
          }}
          scroll={{ x: 1080 }}
        />
        <InstructionDrawer
          {...instructionDrawer.state}
          onClose={instructionDrawer.closeDrawer}
        />
        <InstructionModal
          {...instructionModal.state}
          onClose={instructionModal.closeModal}
          loading={createInstructionLoading || updateInstructionLoading}
          onSubmit={async ({ id, data }) => {
            if (id) {
              await updateInstructionMutation({
                variables: { where: { id }, data },
              });
            } else {
              await createInstructionMutation({ variables: { data } });
            }
          }}
        />
      </PageLayout>
    </SiderLayout>
  );
}
</file>

<file path="src/pages/knowledge/question-sql-pairs.tsx">
import dynamic from 'next/dynamic';
import Link from 'next/link';
import { Button, message, Table, TableColumnsType, Typography } from 'antd';
import { format } from 'sql-formatter';
import SiderLayout from '@/components/layouts/SiderLayout';
import PageLayout from '@/components/layouts/PageLayout';
import FunctionOutlined from '@ant-design/icons/FunctionOutlined';
import { MORE_ACTION } from '@/utils/enum';
import { getCompactTime } from '@/utils/time';
import useDrawerAction from '@/hooks/useDrawerAction';
import useModalAction from '@/hooks/useModalAction';
import { MoreButton } from '@/components/ActionButton';
import { SQLPairDropdown } from '@/components/diagram/CustomDropdown';
import QuestionSQLPairModal from '@/components/modals/QuestionSQLPairModal';
import SQLPairDrawer from '@/components/pages/knowledge/SQLPairDrawer';
import { SqlPair } from '@/apollo/client/graphql/__types__';
import {
  useSqlPairsQuery,
  useCreateSqlPairMutation,
  useUpdateSqlPairMutation,
  useDeleteSqlPairMutation,
} from '@/apollo/client/graphql/sqlPairs.generated';

const SQLCodeBlock = dynamic(() => import('@/components/code/SQLCodeBlock'), {
  ssr: false,
});

const { Paragraph, Text } = Typography;

export default function ManageQuestionSQLPairs() {
  const questionSqlPairModal = useModalAction();
  const sqlPairDrawer = useDrawerAction();

  const { data, loading } = useSqlPairsQuery({
    fetchPolicy: 'cache-and-network',
  });
  const sqlPairs = data?.sqlPairs || [];

  const getBaseOptions = (options) => {
    return {
      onError: (error) => console.error(error),
      refetchQueries: ['SqlPairs'],
      awaitRefetchQueries: true,
      ...options,
    };
  };

  const [createSqlPairMutation, { loading: createSqlPairLoading }] =
    useCreateSqlPairMutation(
      getBaseOptions({
        onCompleted: () => {
          message.success('Successfully created question-sql pair.');
        },
      }),
    );

  const [deleteSqlPairMutation] = useDeleteSqlPairMutation(
    getBaseOptions({
      onCompleted: () => {
        message.success('Successfully deleted question-sql pair.');
      },
    }),
  );

  const [editSqlPairMutation, { loading: editSqlPairLoading }] =
    useUpdateSqlPairMutation(
      getBaseOptions({
        onCompleted: () => {
          message.success('Successfully updated question-sql pair.');
        },
      }),
    );

  const onMoreClick = async (payload) => {
    const { type, data } = payload;
    if (type === MORE_ACTION.DELETE) {
      await deleteSqlPairMutation({
        variables: { where: { id: data.id } },
      });
    } else if (type === MORE_ACTION.EDIT) {
      questionSqlPairModal.openModal(data);
    } else if (type === MORE_ACTION.VIEW_SQL_PAIR) {
      sqlPairDrawer.openDrawer({ ...data, sql: format(data.sql) });
    }
  };

  const columns: TableColumnsType<SqlPair> = [
    {
      title: 'Question',
      dataIndex: 'question',
      width: 300,
      render: (question) => (
        <Paragraph title={question} ellipsis={{ rows: 2 }}>
          {question}
        </Paragraph>
      ),
    },
    {
      title: 'SQL statement',
      dataIndex: 'sql',
      width: '60%',
      render: (sql) => (
        <div style={{ width: '100%' }}>
          <SQLCodeBlock code={sql} maxHeight="130" />
        </div>
      ),
    },
    {
      title: 'Created time',
      dataIndex: 'createdAt',
      width: 130,
      render: (time) => <Text className="gray-7">{getCompactTime(time)}</Text>,
    },
    {
      key: 'action',
      width: 64,
      align: 'center',
      fixed: 'right',
      render: (_, record) => (
        <SQLPairDropdown onMoreClick={onMoreClick} data={record}>
          <MoreButton className="gray-8" />
        </SQLPairDropdown>
      ),
    },
  ];

  return (
    <SiderLayout loading={false}>
      <PageLayout
        title={
          <>
            <FunctionOutlined className="mr-2 gray-8" />
            Manage question-SQL pairs
          </>
        }
        titleExtra={
          <Button
            type="primary"
            className=""
            onClick={() => questionSqlPairModal.openModal()}
          >
            Add question-SQL pair
          </Button>
        }
        description={
          <>
            On this page, you can manage your saved question-SQL pairs. These
            pairs help Wren AI learn how your organization writes SQL, allowing
            it to generate queries that better align with your expectations.{' '}
            <Link
              className="gray-8 underline"
              href="https://docs.getwren.ai/oss/guide/knowledge/question-sql-pairs"
              rel="noopener noreferrer"
              target="_blank"
            >
              Learn more.
            </Link>
          </>
        }
      >
        <Table
          className="ant-table-has-header"
          dataSource={sqlPairs}
          loading={loading}
          columns={columns}
          rowKey="id"
          pagination={{
            hideOnSinglePage: true,
            pageSize: 10,
            size: 'small',
          }}
          scroll={{ x: 1080 }}
        />
        <SQLPairDrawer
          {...sqlPairDrawer.state}
          onClose={sqlPairDrawer.closeDrawer}
        />
        <QuestionSQLPairModal
          {...questionSqlPairModal.state}
          onClose={questionSqlPairModal.closeModal}
          loading={createSqlPairLoading || editSqlPairLoading}
          onSubmit={async ({ id, data }) => {
            if (id) {
              await editSqlPairMutation({
                variables: { where: { id }, data },
              });
            } else {
              await createSqlPairMutation({ variables: { data } });
            }
          }}
        />
      </PageLayout>
    </SiderLayout>
  );
}
</file>

<file path="src/pages/modeling.tsx">
import dynamic from 'next/dynamic';
import { useRouter } from 'next/router';
import { useSearchParams } from 'next/navigation';
import { forwardRef, useEffect, useMemo, useRef } from 'react';
import { message } from 'antd';
import styled from 'styled-components';
import { MORE_ACTION, NODE_TYPE } from '@/utils/enum';
import { editCalculatedField } from '@/utils/modelingHelper';
import SiderLayout from '@/components/layouts/SiderLayout';
import MetadataDrawer from '@/components/pages/modeling/MetadataDrawer';
import EditMetadataModal from '@/components/pages/modeling/EditMetadataModal';
import CalculatedFieldModal from '@/components/modals/CalculatedFieldModal';
import ModelDrawer from '@/components/pages/modeling/ModelDrawer';
import RelationModal, {
  RelationFormValues,
} from '@/components/modals/RelationModal';
import useDrawerAction from '@/hooks/useDrawerAction';
import useModalAction from '@/hooks/useModalAction';
import useRelationshipModal from '@/hooks/useRelationshipModal';
import { convertFormValuesToIdentifier } from '@/hooks/useCombineFieldOptions';
import { ClickPayload } from '@/components/diagram/Context';
import { DeployStatusContext } from '@/components/deploy/Context';
import { DIAGRAM } from '@/apollo/client/graphql/diagram';
import { LIST_MODELS } from '@/apollo/client/graphql/model';
import { useDiagramQuery } from '@/apollo/client/graphql/diagram.generated';
import { useDeployStatusQuery } from '@/apollo/client/graphql/deploy.generated';
import { useDeleteViewMutation } from '@/apollo/client/graphql/view.generated';
import {
  useCreateModelMutation,
  useDeleteModelMutation,
  useUpdateModelMutation,
} from '@/apollo/client/graphql/model.generated';
import {
  useUpdateModelMetadataMutation,
  useUpdateViewMetadataMutation,
} from '@/apollo/client/graphql/metadata.generated';
import {
  useCreateCalculatedFieldMutation,
  useUpdateCalculatedFieldMutation,
  useDeleteCalculatedFieldMutation,
} from '@/apollo/client/graphql/calculatedField.generated';
import {
  useCreateRelationshipMutation,
  useDeleteRelationshipMutation,
  useUpdateRelationshipMutation,
} from '@/apollo/client/graphql/relationship.generated';
import * as events from '@/utils/events';

const Diagram = dynamic(() => import('@/components/diagram'), { ssr: false });
// https://github.com/vercel/next.js/issues/4957#issuecomment-413841689
const ForwardDiagram = forwardRef(function ForwardDiagram(props: any, ref) {
  return <Diagram {...props} forwardRef={ref} />;
});

const DiagramWrapper = styled.div`
  position: relative;
  height: 100%;
`;

export default function Modeling() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const diagramRef = useRef(null);

  const { data } = useDiagramQuery({
    fetchPolicy: 'cache-and-network',
    onCompleted: () => {
      diagramRef.current?.fitView();
    },
  });

  const deployStatusQueryResult = useDeployStatusQuery({
    pollInterval: 1000,
    fetchPolicy: 'no-cache',
  });

  const refetchQueries = [{ query: DIAGRAM }];
  const refetchQueriesForModel = [...refetchQueries, { query: LIST_MODELS }];
  const getBaseOptions = (options) => {
    return {
      onError: (error) => console.error(error),
      refetchQueries,
      awaitRefetchQueries: true,
      ...options,
      onCompleted: () => {
        // refetch to get latest deploy status
        deployStatusQueryResult.refetch();

        options.onCompleted && options.onCompleted();
      },
    };
  };

  const [createCalculatedField, { loading: calculatedFieldCreating }] =
    useCreateCalculatedFieldMutation(
      getBaseOptions({
        onError: null,
        onCompleted: () => {
          message.success('Successfully created calculated field.');
        },
      }),
    );

  const [updateCalculatedField, { loading: calculatedFieldUpdating }] =
    useUpdateCalculatedFieldMutation(
      getBaseOptions({
        onError: null,
        onCompleted: () => {
          message.success('Successfully updated calculated field.');
        },
      }),
    );

  const [deleteCalculatedField] = useDeleteCalculatedFieldMutation(
    getBaseOptions({
      onCompleted: () => {
        message.success('Successfully deleted calculated field.');
      },
    }),
  );

  const [createModelMutation, { loading: modelCreating }] =
    useCreateModelMutation(
      getBaseOptions({
        onCompleted: () => {
          message.success('Successfully created model.');
        },
        refetchQueries: refetchQueriesForModel,
      }),
    );

  const [deleteModelMutation] = useDeleteModelMutation(
    getBaseOptions({
      onCompleted: () => {
        message.success('Successfully deleted model.');
      },
      refetchQueries: refetchQueriesForModel,
    }),
  );

  const [updateModelMutation, { loading: modelUpdating }] =
    useUpdateModelMutation(
      getBaseOptions({
        onCompleted: () => {
          message.success('Successfully updated model.');
        },
        refetchQueries: refetchQueriesForModel,
      }),
    );

  const [deleteViewMutation] = useDeleteViewMutation(
    getBaseOptions({
      onCompleted: () => {
        message.success('Successfully deleted view.');
      },
    }),
  );

  const [updateModelMetadata, { loading: modelMetadataUpdating }] =
    useUpdateModelMetadataMutation(
      getBaseOptions({
        onCompleted: () => {
          message.success('Successfully updated model metadata.');
        },
      }),
    );

  const [createRelationshipMutation, { loading: relationshipCreating }] =
    useCreateRelationshipMutation(
      getBaseOptions({
        onCompleted: () => {
          message.success('Successfully created relationship.');
        },
      }),
    );

  const [deleteRelationshipMutation] = useDeleteRelationshipMutation(
    getBaseOptions({
      onCompleted: () => {
        message.success('Successfully deleted relationship.');
      },
    }),
  );

  const [updateRelationshipMutation, { loading: relationshipUpdating }] =
    useUpdateRelationshipMutation(
      getBaseOptions({
        onCompleted: () => {
          message.success('Successfully updated relationship.');
        },
      }),
    );

  const [updateViewMetadata, { loading: viewMetadataUpdating }] =
    useUpdateViewMetadataMutation(
      getBaseOptions({
        onCompleted: () => {
          message.success('Successfully updated view metadata.');
        },
      }),
    );

  const diagramData = useMemo(() => {
    if (!data) return null;
    return data?.diagram;
  }, [data]);

  const metadataDrawer = useDrawerAction();
  const modelDrawer = useDrawerAction();
  const editMetadataModal = useModalAction();
  const calculatedFieldModal = useModalAction();
  const relationshipModal = useRelationshipModal(diagramData);

  const queryParams = {
    viewId: searchParams.get('viewId'),
    openMetadata: searchParams.get('openMetadata'),
  };

  // doing actions if the route has specific query params
  useEffect(() => {
    if (!diagramData) return;
    // open view metadata drawer
    if (queryParams.viewId && queryParams.openMetadata) {
      const searchedView = diagramData.views.find(
        (view) => view.viewId === Number(queryParams.viewId),
      );
      !!searchedView && metadataDrawer.openDrawer(searchedView);
      // clear query params after opening the drawer
      router.replace(router.pathname);
    }
  }, [queryParams, diagramData]);

  useEffect(() => {
    if (metadataDrawer.state.visible) {
      const data = metadataDrawer.state.defaultValue;
      let currentNodeData = null;
      switch (data.nodeType) {
        case NODE_TYPE.MODEL: {
          currentNodeData = diagramData.models.find(
            (model) => model.modelId === data.modelId,
          );
          break;
        }

        case NODE_TYPE.VIEW: {
          currentNodeData = diagramData.views.find(
            (view) => view.viewId === data.viewId,
          );
          break;
        }

        default:
          break;
      }

      metadataDrawer.updateState(currentNodeData);
    }
  }, [diagramData]);

  // register event listener for global
  useEffect(() => {
    events.subscribe(events.EVENT_NAME.GO_TO_FIRST_MODEL, goToFirstModel);
    return () => {
      events.unsubscribe(events.EVENT_NAME.GO_TO_FIRST_MODEL, goToFirstModel);
    };
  }, []);

  const goToFirstModel = () => {
    if (diagramRef.current) {
      const { getNodes } = diagramRef.current;
      const node = getNodes()[0];
      node?.id && onSelect([node.id]);
    }
  };

  const onSelect = (selectKeys) => {
    if (diagramRef.current) {
      const { getNodes, fitBounds } = diagramRef.current;
      const node = getNodes().find((node) => node.id === selectKeys[0]);
      const position = {
        ...node.position,
        width: node.width,
        height: node.height,
      };
      fitBounds(position);
    }
  };

  const onNodeClick = async (payload: ClickPayload) => {
    metadataDrawer.openDrawer(payload.data);
  };

  const onMoreClick = (payload) => {
    const { type, data } = payload;
    const { nodeType } = data;
    const action = {
      [MORE_ACTION.UPDATE_COLUMNS]: () => {
        switch (nodeType) {
          case NODE_TYPE.MODEL:
            modelDrawer.openDrawer(data);
            break;
          default:
            console.log(data);
            break;
        }
      },
      [MORE_ACTION.EDIT]: () => {
        switch (nodeType) {
          case NODE_TYPE.CALCULATED_FIELD:
            editCalculatedField(
              { ...payload, diagramData },
              calculatedFieldModal.openModal,
            );
            break;
          case NODE_TYPE.RELATION:
            relationshipModal.openModal(data);
            break;

          default:
            console.log(data);
            break;
        }
      },
      [MORE_ACTION.DELETE]: async () => {
        switch (nodeType) {
          case NODE_TYPE.MODEL:
            await deleteModelMutation({
              variables: { where: { id: data.modelId } },
            });
            break;
          case NODE_TYPE.CALCULATED_FIELD:
            await deleteCalculatedField({
              variables: { where: { id: data.columnId } },
            });
            break;
          case NODE_TYPE.RELATION:
            await deleteRelationshipMutation({
              variables: { where: { id: data.relationId } },
            });
            break;
          case NODE_TYPE.VIEW:
            await deleteViewMutation({
              variables: { where: { id: data.viewId } },
            });
            break;

          default:
            console.log(data);
            break;
        }
      },
    };
    action[type] && action[type]();
  };

  const onAddClick = (payload) => {
    const { targetNodeType, data } = payload;
    switch (targetNodeType) {
      case NODE_TYPE.CALCULATED_FIELD:
        calculatedFieldModal.openModal(null, {
          models: diagramData.models,
          sourceModel: data,
        });
        break;
      case NODE_TYPE.RELATION:
        relationshipModal.openModal(data);
        break;
      default:
        console.log('add', targetNodeType);
        break;
    }
  };

  const calculatedFieldLoading =
    calculatedFieldCreating || calculatedFieldUpdating;
  const editMetadataLoading = modelMetadataUpdating || viewMetadataUpdating;
  const modelLoading = modelCreating || modelUpdating;
  const relationshipLoading = relationshipUpdating || relationshipCreating;

  return (
    <DeployStatusContext.Provider value={{ ...deployStatusQueryResult }}>
      <SiderLayout
        loading={diagramData === null}
        sidebar={{
          data: diagramData,
          onOpenModelDrawer: modelDrawer.openDrawer,
          onSelect,
        }}
      >
        <DiagramWrapper>
          <ForwardDiagram
            ref={diagramRef}
            data={diagramData}
            onMoreClick={onMoreClick}
            onNodeClick={onNodeClick}
            onAddClick={onAddClick}
          />
        </DiagramWrapper>
        <MetadataDrawer
          {...metadataDrawer.state}
          onClose={metadataDrawer.closeDrawer}
          onEditClick={editMetadataModal.openModal}
        />
        <EditMetadataModal
          {...editMetadataModal.state}
          onClose={editMetadataModal.closeModal}
          loading={editMetadataLoading}
          onSubmit={async ({ nodeType, data }) => {
            const { modelId, viewId, ...metadata } = data;
            switch (nodeType) {
              case NODE_TYPE.MODEL: {
                await updateModelMetadata({
                  variables: { where: { id: modelId }, data: metadata },
                });
                break;
              }

              case NODE_TYPE.VIEW: {
                await updateViewMetadata({
                  variables: { where: { id: viewId }, data: metadata },
                });
                break;
              }

              default:
                console.log('onSubmit', nodeType, data);
                break;
            }
          }}
        />
        <ModelDrawer
          {...modelDrawer.state}
          onClose={modelDrawer.closeDrawer}
          submitting={modelLoading}
          onSubmit={async ({ id, data }) => {
            if (id) {
              await updateModelMutation({ variables: { where: { id }, data } });
            } else {
              await createModelMutation({ variables: { data } });
            }
          }}
        />
        <CalculatedFieldModal
          {...calculatedFieldModal.state}
          onClose={calculatedFieldModal.closeModal}
          loading={calculatedFieldLoading}
          onSubmit={async ({ id, data }) => {
            if (id) {
              await updateCalculatedField({
                variables: { where: { id }, data },
              });
            } else {
              await createCalculatedField({ variables: { data } });
            }
          }}
        />
        <RelationModal
          {...relationshipModal.state}
          onClose={relationshipModal.onClose}
          loading={relationshipLoading}
          onSubmit={async (
            values: RelationFormValues & { relationId?: number },
          ) => {
            const relation = convertFormValuesToIdentifier(values);
            if (values.relationId) {
              await updateRelationshipMutation({
                variables: {
                  where: { id: values.relationId },
                  data: { type: relation.type },
                },
              });
            } else {
              await createRelationshipMutation({
                variables: {
                  data: {
                    fromModelId: Number(relation.fromField.modelId),
                    fromColumnId: Number(relation.fromField.fieldId),
                    toModelId: Number(relation.toField.modelId),
                    toColumnId: Number(relation.toField.fieldId),
                    type: relation.type,
                  },
                },
              });
            }
          }}
        />
      </SiderLayout>
    </DeployStatusContext.Provider>
  );
}
</file>

<file path="src/pages/setup/connection.tsx">
import { useMemo } from 'react';
import SimpleLayout from '@/components/layouts/SimpleLayout';
import ContainerCard from '@/components/pages/setup/ContainerCard';
import useSetupConnection from '@/hooks/useSetupConnection';
import { SETUP_STEPS } from '@/components/pages/setup/utils';

export default function SetupConnection() {
  const { connectError, dataSource, onBack, onNext, stepKey, submitting } =
    useSetupConnection();

  const current = useMemo(() => SETUP_STEPS[stepKey], [stepKey]);

  return (
    <SimpleLayout>
      <ContainerCard step={current.step} maxWidth={current.maxWidth}>
        <current.component
          connectError={connectError}
          dataSource={dataSource}
          onNext={onNext}
          onBack={onBack}
          submitting={submitting}
        />
      </ContainerCard>
    </SimpleLayout>
  );
}
</file>

<file path="src/pages/setup/models.tsx">
import { useMemo } from 'react';
import SimpleLayout from '@/components/layouts/SimpleLayout';
import ContainerCard from '@/components/pages/setup/ContainerCard';
import useSetupModels from '@/hooks/useSetupModels';
import { SETUP_STEPS } from '@/components/pages/setup/utils';

export default function SetupModels() {
  const { fetching, stepKey, tables, onNext, onBack, submitting } =
    useSetupModels();

  const current = useMemo(() => SETUP_STEPS[stepKey], [stepKey]);

  return (
    <SimpleLayout>
      <ContainerCard step={current.step} maxWidth={current.maxWidth}>
        <current.component
          fetching={fetching}
          onBack={onBack}
          onNext={onNext}
          submitting={submitting}
          tables={tables}
        />
      </ContainerCard>
    </SimpleLayout>
  );
}
</file>

<file path="src/pages/setup/relationships.tsx">
import { useMemo } from 'react';
import SimpleLayout from '@/components/layouts/SimpleLayout';
import ContainerCard from '@/components/pages/setup/ContainerCard';
import useSetupRelations from '@/hooks/useSetupRelations';
import { SETUP_STEPS } from '@/components/pages/setup/utils';

export default function SetupRelationships() {
  const {
    fetching,
    stepKey,
    recommendRelationsResult,
    onNext,
    onBack,
    onSkip,
    submitting,
  } = useSetupRelations();

  const current = useMemo(() => SETUP_STEPS[stepKey], [stepKey]);

  return (
    <SimpleLayout>
      <ContainerCard step={current.step} maxWidth={current.maxWidth}>
        <current.component
          fetching={fetching}
          {...recommendRelationsResult}
          onNext={onNext}
          onBack={onBack}
          onSkip={onSkip}
          submitting={submitting}
        />
      </ContainerCard>
    </SimpleLayout>
  );
}
</file>

<file path="src/styles/antd-variables.less">
// Using in appendData, only for variables defination
@import '~antd/lib/style/themes/default.less';

@prefix: adm;

// -------- Colors
// >> Secondary
@citrus-base: #f58433;
@citrus-1: #fff9f0;
@citrus-2: #ffedd9;
@citrus-3: #ffd9b0;
@citrus-4: #ffc187;
@citrus-5: #ffa75e;
@citrus-6: @citrus-base;
@citrus-7: #cf6421;
@citrus-8: #a84713;
@citrus-9: #822f08;
@citrus-10: #5c1d05;

// >> Neutral
@gray-1: #fff;
@gray-2: #fafafa;
@gray-3: #f5f5f5;
@gray-4: #f0f0f0;
@gray-5: #d9d9d9;
@gray-6: #bfbfbf;
@gray-7: #8c8c8c;
@gray-8: #65676c;
@gray-9: #434343;
@gray-10: #262626;
@gray-11: #1f1f1f;
@gray-12: #141414;
@gray-13: #000;

@preset-colors: pink, magenta, red, volcano, orange, yellow, gold, cyan, lime,
  green, blue, geekblue, purple, citrus, gray;

@black: @gray-13;
@white: @gray-1;

@primary-color: @geekblue-6;

@text-color: @gray-10;
@heading-color: @gray-9;
@success-color: @green-6;
@warning-color: @gold-6;
@error-color: @red-5;
@disabled-color: rgba(0, 0, 0, 0.25);

// Functions
.make-color-variables(@i: length(@preset-colors)) when (@i > 0) {
  .make-color-variables(@i - 1);
  @color: extract(@preset-colors, @i);
  each(range(1, 10, 1), {
    @colorVar: '@{color}-@{index}';
    --@{color}-@{index}: @@colorVar;
  });
}

// Header
@layout-header-height: 20px;

// Components
@layout-body-background: #fff;
@layout-header-background: #fff;

@card-background: #fff;
@breadcrumb-last-item-color: @text-color;
@table-padding-vertical: 12px;
@table-header-cell-split-color: transparent;
@border-radius-base: 4px;

// Typography
@typography-title-font-weight: 700;
@heading-1-size: ceil(@font-size-base * 2.85);
// @heading-2-size: ceil(@font-size-base * 2.14);
// @heading-3-size: ceil(@font-size-base * 1.71);
// @heading-4-size: ceil(@font-size-base * 1.42);
// @heading-5-size: ceil(@font-size-base * 1.14);

// Avatar
@avatar-size-xs: 16px;
@avatar-font-size-xs: 12px;

@tooltip-bg: @gray-10;
</file>

<file path="src/styles/components/alert.less">
.ant-alert {
  align-items: flex-start;
  .anticon-exclamation-circle, .anticon-warning {
    margin-top: 4px;
  }
  .ant-alert-message {
    color: currentColor;
  }
}
</file>

<file path="src/styles/components/avatar.less">
.adm-avatar {
  &-xs {
    .avatar-size(@avatar-size-xs, @avatar-font-size-xs);
  }
}
</file>

<file path="src/styles/components/button.less">
.adm-btn-no-style {
  cursor: pointer;
  background: transparent;
  line-height: 1.2;
  height: auto;
  border: none;
}

.adm-onboarding-btn {
  width: 130px;
}

.adm-modeling-header-btn {
  width: 60px;
}

.adm-fix-it-btn {
  border-color: @citrus-6;
  color: @citrus-6;
  background-color: @citrus-1;
  &:hover,&:focus {
    background-color: @citrus-1;
    border-color: @citrus-4;
    color: @citrus-5;
  }
}
</file>

<file path="src/styles/components/chart.less">
.@{prefix}-chart {
  position: relative;
  margin: 0 auto;
  padding: 16px 0;

  &-additional {
    position: absolute;
    z-index: 1;
    top: 16px;
    right: 36px;

    button {
      background: white;
      border: 1px solid @gray-5;
      border-radius: 4px;
      padding: 0 2px;
      cursor: pointer;
      width: 28px;
      height: 28px;
      opacity: 0.4;
      color: @gray-8;
      transition: all 0.4s ease-in;

      &:hover {
        opacity: 1;
      }

      +button {
        margin-left: 8px;
      }
    }
  }

  &--no-actions {
    padding: 0;
    .vega-embed .chart-wrapper {
      padding-top: 0 !important;
    }
    .vega-embed summary {
      display: none;
    }
  }

  .vega-embed {
    &:hover {
      summary {
        opacity: 0.4 !important;
      }
    }

    summary {
      border-radius: 4px;
      border: 1px solid @gray-5;
      box-shadow: none;
      transition: all 0.4s ease-in;
      color: @gray-8;
      opacity: 0.4 !important;

      &:hover {
        opacity: 1 !important;
      }
    }

    .chart-wrapper {
      padding-top: 40px;
    }

    &.has-actions {
      padding-right: 0;
    }

    .vega-actions {
      border: 1px solid @gray-5;
      box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.1);

      a {
        font-size: 12px;
        padding: 6px 16px;
      }
    }
  }

  &__fullscreen {
    position: absolute;
    top: 32px;
    right: 0px;
  }

  .ant-btn-icon-only {
    width: auto;
    height: auto;
    padding: 6px;
  }
}

#vg-tooltip-element.vg-tooltip.custom-theme {
  display: none;
  background-color: @gray-10;
  color: @gray-1;
  border-color: @gray-9;
  animation: fade-in 0.2s ease-out;

  table tr td.key {
    color: @gray-6;
  }
}

#vg-tooltip-element.visible {
  display: block !important;
}
</file>

<file path="src/styles/components/driver.less">
body {
  .driver-popover {
    background-color: @gray-10;
    color: white;
    box-shadow: none;
    border-radius: 10px;
    padding: 16px 0;

    .driver-popover-close-btn {
      color: @gray-7;
      &:hover {
        color: @gray-1;
      }
    }
  }

  .driver-popover-title,
  .driver-popover-description,
  .driver-popover-footer {
    padding: 0 16px;
  }

  .driver-popover-title {
    img {
      display: block;
      width: 100%;
    }

    &[style*=block] +.driver-popover-description {
      margin-top: 8px;
    }
  }

  .driver-popover-description {
    color: @gray-5;
  }

  .driver-popover-arrow-side-left {
    border-left-color: @gray-10;
  }
  .driver-popover-arrow-side-right {
    border-right-color: @gray-10;
  }
  .driver-popover-arrow-side-top {
    border-top-color: @gray-10;
  }
  .driver-popover-arrow-side-bottom {
    border-bottom-color: @gray-10;
  }

  .driver-popover-progress-text {
    color: @gray-7;
  }

  .driver-popover-footer button {
    font-size: @font-size-base;
    border-radius: 4px;
    border: none;
    min-width: 76px;
    text-align: center;
    + button {
      margin-left: 8px;
    }
  }
}
</file>

<file path="src/styles/components/scrollbar.less">
.adm-scrollbar-track {
  scrollbar-width: thin;
  scrollbar-color: @gray-5 transparent;
}
</file>

<file path="src/styles/components/select.less">
.adm-model-field-select-dropdown {
  .ant-select-item-option-grouped {
    padding: 5px 12px;
  }
}
</file>

<file path="src/styles/components/table.less">
// override antd styles
.ant-table {
  border: 1px @gray-4 solid;

  .ant-table-row:last-child .ant-table-cell {
    border-bottom: none;
  }

  &.ant-table-empty {
    .ant-table-body {
      overflow: auto !important;
    }

    .ant-table-tbody .ant-table-cell {
      border-bottom: none;
    }
  }

  .ant-table-expanded-row {
    > .ant-table-cell {
      background-color: @gray-3;
    }
  }

  .adm-nested-table {
    .ant-table {
      border: none;
      border-radius: 0;

      .ant-table-thead > tr > th {
        background: @gray-2;
      }

      .ant-table-tbody > tr.ant-table-row:hover > td,
      .ant-table-tbody > tr > td.ant-table-cell-row-hover {
        background: @gray-2;
      }
    }
  }

  &--text-sm {
    .ant-table {
      font-size: @font-size-sm !important;
    }
  }
}

.ant-table-wrapper:not(.ant-table-has-header) {
  .ant-table-empty {
    border: none;

    .ant-empty-normal {
      margin: 80px 0;
    }
  }
}
</file>

<file path="src/styles/components/tag.less">
.ant-tag {
  &--geekblue {
    color: @geekblue-6;
    background: @geekblue-1;
    border-color: @geekblue-6;
  }
  &--citrus {
    color: @citrus-6;
    background: @citrus-1;
    border-color: @citrus-6;
  }
}
</file>

<file path="src/styles/components/transfer.less">
.ant-transfer {
  .ant-transfer-list {
    min-width: 0;
  }

  .ant-table-wrapper:not(.ant-table-has-header) {
    .ant-table-empty {
      .ant-empty-normal {
        margin: 58px 0px;
      }
    }
  }
}
</file>

<file path="src/styles/index.less">
@import '~antd/dist/antd.less';

// Components
@import './components/table.less';
@import './components/avatar.less';
@import './components/button.less';
@import './components/transfer.less';
@import './components/select.less';
@import './components/alert.less';
@import './components/tag.less';
@import './components/driver.less';
@import './components/chart.less';
@import './components/scrollbar.less';

// Layouts
@import './layouts/global.less';
@import './layouts/main.less';

// Utilities
@import './utilities/animation.less';
@import './utilities/display.less';
@import './utilities/flex.less';
@import './utilities/grid.less';
@import './utilities/text.less';
@import './utilities/color.less';
@import './utilities/spacing.less';
@import './utilities/border.less';
</file>

<file path="src/styles/layouts/global.less">
:root {
  .make-color-variables();
  --disabled: @disabled-color;
}

body {
  min-width: 360px;
}

@media (prefers-color-scheme: dark) {
  html body {
    background: #fff;
  }
  h1.next-error-h1 {
    border-right: 1px solid rgba(0, 0, 0, 0.3);
  }
}
</file>

<file path="src/styles/layouts/main.less">
.@{prefix}-main {
  min-height: 100vh;
  height: 100%;
}

.adm-layout {
  height: 100%;
}

.adm-content {
  height: calc(100vh - 48px);
  overflow: auto;
}
</file>

<file path="src/styles/utilities/animation.less">
@keyframes fade-in {
  0% {
    opacity: 0;
  }
  100% {
    opacity: 1;
  }
}
</file>

<file path="src/styles/utilities/border.less">
.border {
  border-width: 1px !important;
  border-style: solid !important;

  &-t {
    border-top-width: 1px !important;
    border-top-style: solid !important;
  }
  &-r {
    border-right-width: 1px !important;
    border-right-style: solid !important;
  }
  &-l {
    border-left-width: 1px !important;
    border-left-style: solid !important;
  }
  &-b {
    border-bottom-width: 1px !important;
    border-bottom-style: solid !important;
  }
}

.rounded {
  border-radius: 4px !important;
}

.rounded-pill {
  border-radius: 999px !important;
}
</file>

<file path="src/styles/utilities/color.less">
.make-color-classes(@i: length(@preset-colors)) when (@i > 0) {
  .make-color-classes(@i - 1);
  @color: extract(@preset-colors, @i);
  each(range(1, 10), {
    @colorVar: ~'var(--@{color}-@{index})';
    .bg-@{color}-@{index} {
      background-color: @colorVar !important;
    }
    .@{color}-@{index} {
      color: @colorVar !important;
    }
    .border-@{color}-@{index} {
      border-color: @colorVar !important;
    }
  });
}

.make-color-classes();

*[class*='hover\:'] {
  transition: color 0.3s ease;
}

.hover\:text:hover {
  color: var(--geekblue-6) !important;
}
</file>

<file path="src/styles/utilities/display.less">
.make-display-classes() {
  @preset-display: {
    block: block;
    inline: inline;
    inline-block: inline-block;
    flex: flex;
    inline-flex: inline-flex;
    grid: grid;
    none: none;
  };
  each(@preset-display, {
    .d-@{key} {
      display: @value !important;
    }
  });
}

.make-display-classes();

.cursor-pointer {
  cursor: pointer !important;
}

.cursor-wait {
  cursor: wait !important;
}

.cursor-not-allowed {
  cursor: not-allowed !important;
}

.select-none {
  user-select: none !important;
}

.overflow-hidden {
  overflow: hidden !important;
}

.scrollable-y {
  overflow: hidden auto !important;
}

.scrollable-x {
  overflow: auto hidden !important;
}
</file>

<file path="src/styles/utilities/flex.less">
.justify {
  &-start {
    justify-content: flex-start !important;
  }
  &-end {
    justify-content: flex-end !important;
  }
  &-center {
    justify-content: center !important;
  }
  &-space-between {
    justify-content: space-between !important;
  }
}

.align {
  &-start {
    align-items: flex-start !important;
  }
  &-end {
    align-items: flex-end !important;
  }
  &-center {
    align-items: center !important;
  }
  &-baseline {
    align-items: baseline !important;
  }
}

.flex {
  &-shrink-0 {
    flex-shrink: 0 !important;
  }

  &-shrink-1 {
    flex-shrink: 1 !important;
  }

  &-grow-0 {
    flex-grow: 0 !important;
  }

  &-grow-1 {
    flex-grow: 1 !important;
  }

  &-row {
    flex-direction: row !important;
  }

  &-column {
    flex-direction: column !important;
  }
}
</file>

<file path="src/styles/utilities/grid.less">
.make-grid-classes(@i: 6) when (@i >= 1) {
  .make-grid-classes(@i - 1);
  .grid-columns-@{i} {
    grid-template-columns: repeat(@i, 1fr) !important;
  }

  // grid gap
  @base-gap: 4px;
  @gap: @i * @base-gap;

  .g-@{i} {
    column-gap: @gap !important;
    row-gap: @gap !important;
  }
  .gx-@{i} {
    column-gap: @gap !important;
  }
  .gy-@{i} {
    row-gap: @gap !important;
  }
}

.make-grid-classes();
</file>

<file path="src/styles/utilities/spacing.less">
.make-spacing-classes(@i: 15) when (@i >= 0) {
  .make-spacing-classes(@i - 1);
  @preset: {
    m: margin;
    p: padding;
  };
  @base-spacing: 4px;
  @spacing: @i * @base-spacing;

  each(@preset, {
    .@{key}-@{i} {
      @{value}: @spacing !important;
    }
    .@{key}x-@{i} {
      @{value}-left: @spacing !important;
      @{value}-right: @spacing !important;
    }
    .@{key}y-@{i} {
      @{value}-top: @spacing !important;
      @{value}-bottom: @spacing !important;
    }
    .@{key}t-@{i} {
      @{value}-top: @spacing !important;
    }
    .@{key}l-@{i} {
      @{value}-left: @spacing !important;
    }
    .@{key}r-@{i} {
      @{value}-right: @spacing !important;
    }
    .@{key}b-@{i} {
      @{value}-bottom: @spacing !important;
    }

    // Negative spacing
    .-@{key}-@{i} {
      @{value}: -@spacing !important;
    }
    .-@{key}x-@{i} {
      @{value}-left: -@spacing !important;
      @{value}-right: -@spacing !important;
    }
    .-@{key}y-@{i} {
      @{value}-top: -@spacing !important;
      @{value}-bottom: -@spacing !important;
    }
    .-@{key}t-@{i} {
      @{value}-top: -@spacing !important;
    }
    .-@{key}l-@{i} {
      @{value}-left: -@spacing !important;
    }
    .-@{key}r-@{i} {
      @{value}-right: -@spacing !important;
    }
    .-@{key}b-@{i} {
      @{value}-bottom: -@spacing !important;
    }
  });
}

.make-spacing-classes();
</file>

<file path="src/styles/utilities/text.less">
.make-text-classes() {
  @preset-text: {
    base: @font-size-base;
    xs: @font-size-sm - 2px;
    sm: @font-size-sm;
    md: @font-size-lg;
    lg: @font-size-lg + 2px;
  };
  each(@preset-text, {
    .text-@{key} {
      font-size: @value !important;
    }
  });
}

.text-left {
  text-align: left !important;
}

.text-right {
  text-align: right !important;
}

.text-center {
  text-align: center !important;
}

.text-extra-bold {
  font-weight: 800 !important;
}

.text-bold {
  font-weight: 700 !important;
}

.text-semi-bold {
  font-weight: 600 !important;
}

.text-medium {
  font-weight: 500 !important;
}

.make-text-classes();

.text-truncate {
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.text-family-base {
  font-family: @font-family !important;
}

.text-nowrap {
  white-space: nowrap !important;
}

.underline {
  text-decoration: underline !important;
}

.hover\:underline:hover {
  text-decoration: underline !important;
}

.text-break-word {
  overflow-wrap: break-word !important;
  word-break: break-word !important;
}
</file>

<file path="src/utils/columnType.tsx">
import {
  NumericIcon,
  ColumnsIcon,
  JsonBracesIcon,
  StringIcon,
  TextIcon,
  CalendarIcon,
  TickIcon,
  IdIcon,
  BinaryIcon,
} from './icons';
import { COLUMN_TYPE } from './enum';

export const getColumnTypeIcon = (payload: { type: string }, attrs?: any) => {
  const { type } = payload;
  const compareString = type.toUpperCase();
  switch (compareString) {
    case COLUMN_TYPE.BOOLEAN:
      return <TickIcon {...attrs} />;

    case COLUMN_TYPE.JSON:
    case COLUMN_TYPE.RECORD:
      return <JsonBracesIcon {...attrs} />;

    case COLUMN_TYPE.TEXT:
      return <TextIcon {...attrs} />;

    case COLUMN_TYPE.BYTEA:
    case COLUMN_TYPE.VARBINARY:
      return <BinaryIcon {...attrs} />;

    case COLUMN_TYPE.UUID:
    case COLUMN_TYPE.OID:
      return <IdIcon {...attrs} />;

    case COLUMN_TYPE.TINYINT:
    case COLUMN_TYPE.INT2:
    case COLUMN_TYPE.SMALLINT:
    case COLUMN_TYPE.INT4:
    case COLUMN_TYPE.INTEGER:
    case COLUMN_TYPE.INT8:
    case COLUMN_TYPE.BIGINT:
    case COLUMN_TYPE.INT64:
    case COLUMN_TYPE.NUMERIC:
    case COLUMN_TYPE.DECIMAL:
    case COLUMN_TYPE.FLOAT4:
    case COLUMN_TYPE.REAL:
    case COLUMN_TYPE.FLOAT8:
    case COLUMN_TYPE.DOUBLE:
    case COLUMN_TYPE.INET:
      return <NumericIcon {...attrs} />;

    case COLUMN_TYPE.VARCHAR:
    case COLUMN_TYPE.CHAR:
    case COLUMN_TYPE.BPCHAR:
    case COLUMN_TYPE.STRING:
    case COLUMN_TYPE.NAME:
      return <StringIcon {...attrs} />;

    case COLUMN_TYPE.TIMESTAMP:
    case COLUMN_TYPE.TIMESTAMPTZ:
    case COLUMN_TYPE.DATE:
    case COLUMN_TYPE.INTERVAL:
      return <CalendarIcon {...attrs} />;

    default: {
      return <ColumnsIcon {...attrs} />;
    }
  }
};
</file>

<file path="src/utils/data/dictionary.ts">
import { ExpressionName } from '@/apollo/client/graphql/__types__';
import { JOIN_TYPE } from '@/utils/enum';

const DefaultText = 'Unknown';

export const getJoinTypeText = (type) =>
  ({
    [JOIN_TYPE.MANY_TO_ONE]: 'Many-to-one',
    [JOIN_TYPE.ONE_TO_MANY]: 'One-to-many',
    [JOIN_TYPE.ONE_TO_ONE]: 'One-to-one',
  })[type] || DefaultText;

export const getExpressionTexts = (type) =>
  ({
    // Aggregations
    [ExpressionName.AVG]: {
      name: 'Average',
      syntax: 'avg(column)',
      description: 'Returns the average of the values in the column.',
    },
    [ExpressionName.COUNT]: {
      name: 'Count',
      syntax: 'count(column)',
      description:
        'Returns the count of non-null rows (also known as records) in the selected data.',
    },
    [ExpressionName.MAX]: {
      name: 'Max',
      syntax: 'max(column)',
      description: 'Returns the largest value found in the column.',
    },
    [ExpressionName.MIN]: {
      name: 'Min',
      syntax: 'min(column)',
      description: 'Returns the smallest value found in the column.',
    },
    [ExpressionName.SUM]: {
      name: 'Sum',
      syntax: 'sum(column)',
      description: 'Adds up all the values of the column.',
    },

    // Math functions
    [ExpressionName.ABS]: {
      name: 'Absolute',
      syntax: 'abs(column)',
      description:
        'Returns the absolute (positive) value of the specified column.',
    },
    [ExpressionName.CBRT]: {
      name: 'Cube root',
      syntax: 'cbrt(column)',
      description: 'Returns the cube root of the number.',
    },
    [ExpressionName.CEIL]: {
      name: 'Ceil',
      syntax: 'ceil(column)',
      description: 'Rounds a decimal up (ceil as in ceiling).',
    },
    [ExpressionName.EXP]: {
      name: 'Exponential',
      syntax: 'exp(column)',
      description:
        'Returns Euler’s number, e, raised to the power of the supplied number.',
    },
    [ExpressionName.FLOOR]: {
      name: 'Floor',
      syntax: 'floor(column)',
      description: 'Rounds a decimal number down.',
    },
    [ExpressionName.LN]: {
      name: 'Natural logarithm',
      syntax: 'ln(column)',
      description: 'Returns the natural logarithm of the number.',
    },
    [ExpressionName.LOG10]: {
      name: 'Log10',
      syntax: 'log10(column)',
      description: 'Returns the base 10 log of the number.',
    },
    [ExpressionName.ROUND]: {
      name: 'Round',
      syntax: 'round(column)',
      description:
        'Rounds a decimal number either up or down to the nearest integer value.',
    },
    [ExpressionName.SIGN]: {
      name: 'Signum',
      syntax: 'sign(column)',
      description: 'Returns the signum function of the number.',
    },

    // String functions
    [ExpressionName.LENGTH]: {
      name: 'Length',
      syntax: 'length(column)',
      description: 'Returns the number of characters in string.',
    },
    [ExpressionName.REVERSE]: {
      name: 'Reverse',
      syntax: 'reverse(column)',
      description: 'Returns string with the characters in reverse order.',
    },
  })[type] || {
    name: DefaultText,
    syntax: DefaultText,
    description: DefaultText,
  };
</file>

<file path="src/utils/data/index.ts">
export * from './type';
export * from './dictionary';
</file>

<file path="src/utils/data/type/index.ts">
export * from './modeling';
</file>

<file path="src/utils/data/type/modeling.ts">
import {
  DiagramModel,
  DiagramModelField,
  DiagramModelRelationField,
  DiagramView,
  DiagramViewField,
} from '@/apollo/client/graphql/__types__';
export type {
  Diagram,
  DiagramModel,
  DiagramModelField,
  DiagramModelRelationField,
  DiagramView,
} from '@/apollo/client/graphql/__types__';

export type ComposeDiagram = (DiagramModel | DiagramView) &
  Partial<
    Pick<
      DiagramModel,
      | 'modelId'
      | 'calculatedFields'
      | 'relationFields'
      | 'refSql'
      | 'refreshTime'
      | 'cached'
      | 'sourceTableName'
    >
  > &
  Partial<Pick<DiagramView, 'viewId' | 'statement'>>;

export type ComposeDiagramField = (
  | DiagramModelField
  | DiagramModelRelationField
  | DiagramViewField
) &
  Partial<Pick<DiagramModel, 'description'>> &
  Partial<
    Pick<DiagramModelField, 'isPrimaryKey' | 'columnId' | 'nestedFields'>
  > &
  Partial<
    Pick<
      DiagramModelRelationField,
      | 'fromModelName'
      | 'fromModelDisplayName'
      | 'fromColumnName'
      | 'fromColumnDisplayName'
      | 'toModelName'
      | 'toModelDisplayName'
      | 'toColumnName'
      | 'toColumnDisplayName'
      | 'relationId'
    >
  >;

export type CachedProps = {
  cached: boolean;
  refreshTime?: string;
};
</file>

<file path="src/utils/dataSourceType.ts">
import { DATA_SOURCES } from '@/utils/enum';
import BigQueryProperties from '@/components/pages/setup/dataSources/BigQueryProperties';
import DuckDBProperties from '@/components/pages/setup/dataSources/DuckDBProperties';
import MySQLProperties from '@/components/pages/setup/dataSources/MySQLProperties';
import OracleProperties from '@/components/pages/setup/dataSources/OracleProperties';
import PostgreSQLProperties from '@/components/pages/setup/dataSources/PostgreSQLProperties';
import SQLServerProperties from '@/components/pages/setup/dataSources/SQLServerProperties';
import ClickHouseProperties from '@/components/pages/setup/dataSources/ClickHouseProperties';
import TrinoProperties from '@/components/pages/setup/dataSources/TrinoProperties';
import SnowflakeProperties from '@/components/pages/setup/dataSources/SnowflakeProperties';
import AthenaProperties from '@/components/pages/setup/dataSources/AthenaProperties';
import RedshiftProperties from '@/components/pages/setup/dataSources/RedshiftProperties';

export const getDataSourceImage = (dataSource: DATA_SOURCES | string) => {
  switch (dataSource) {
    case DATA_SOURCES.BIG_QUERY:
      return '/images/dataSource/bigQuery.svg';
    case DATA_SOURCES.POSTGRES:
      return '/images/dataSource/postgreSql.svg';
    case DATA_SOURCES.MYSQL:
      return '/images/dataSource/mysql.svg';
    case DATA_SOURCES.ORACLE:
      return '/images/dataSource/oracle.svg';
    case DATA_SOURCES.MSSQL:
      return '/images/dataSource/sqlserver.svg';
    case DATA_SOURCES.CLICK_HOUSE:
      return '/images/dataSource/clickhouse.svg';
    case DATA_SOURCES.DUCKDB:
      return '/images/dataSource/duckDb.svg';
    case DATA_SOURCES.TRINO:
      return '/images/dataSource/trino.svg';
    case DATA_SOURCES.SNOWFLAKE:
      return '/images/dataSource/snowflake.svg';
    case DATA_SOURCES.ATHENA:
      return '/images/dataSource/athena.svg';
    case DATA_SOURCES.REDSHIFT:
      return '/images/dataSource/redshift.svg';
    default:
      return null;
  }
};

export const getDataSourceName = (dataSource: DATA_SOURCES | string) => {
  switch (dataSource) {
    case DATA_SOURCES.BIG_QUERY:
      return 'BigQuery';
    case DATA_SOURCES.POSTGRES:
      return 'PostgreSQL';
    case DATA_SOURCES.MYSQL:
      return 'MySQL';
    case DATA_SOURCES.ORACLE:
      return 'Oracle';
    case DATA_SOURCES.MSSQL:
      return 'SQL Server';
    case DATA_SOURCES.CLICK_HOUSE:
      return 'ClickHouse';
    case DATA_SOURCES.DUCKDB:
      return 'DuckDB';
    case DATA_SOURCES.TRINO:
      return 'Trino';
    case DATA_SOURCES.SNOWFLAKE:
      return 'Snowflake';
    case DATA_SOURCES.ATHENA:
      return 'Athena (Trino)';
    case DATA_SOURCES.REDSHIFT:
      return 'Redshift';
    default:
      return '';
  }
};

export const getDataSourceProperties = (dataSource: DATA_SOURCES | string) => {
  switch (dataSource) {
    case DATA_SOURCES.BIG_QUERY:
      return BigQueryProperties;
    case DATA_SOURCES.POSTGRES:
      return PostgreSQLProperties;
    case DATA_SOURCES.MYSQL:
      return MySQLProperties;
    case DATA_SOURCES.ORACLE:
      return OracleProperties;
    case DATA_SOURCES.MSSQL:
      return SQLServerProperties;
    case DATA_SOURCES.CLICK_HOUSE:
      return ClickHouseProperties;
    case DATA_SOURCES.DUCKDB:
      return DuckDBProperties;
    case DATA_SOURCES.TRINO:
      return TrinoProperties;
    case DATA_SOURCES.SNOWFLAKE:
      return SnowflakeProperties;
    case DATA_SOURCES.ATHENA:
      return AthenaProperties;
    case DATA_SOURCES.REDSHIFT:
      return RedshiftProperties;
    default:
      return null;
  }
};

export const getDataSourceConfig = (dataSource: DATA_SOURCES | string) => {
  return {
    label: getDataSourceName(dataSource),
    logo: getDataSourceImage(dataSource),
    value: DATA_SOURCES[dataSource],
  };
};

export const getDataSourceFormComponent = (
  dataSource: DATA_SOURCES | string,
) => {
  return { component: getDataSourceProperties(dataSource) || (() => null) };
};
</file>

<file path="src/utils/diagram/creator.ts">
import { Edge, Node, Viewport, ReactFlowJsonObject } from 'reactflow';
import { Diagram } from '@/utils/data/type';
import { Transformer } from './transformer';

export class DiagramCreator {
  private nodes: Node[];
  private edges: Edge[];
  private viewport: Viewport = { x: 0, y: 0, zoom: 1 };

  constructor(data: Diagram) {
    const transformedData = new Transformer(data);
    this.nodes = transformedData.nodes;
    this.edges = transformedData.edges;
  }

  public toJsonObject(): ReactFlowJsonObject {
    return {
      nodes: this.nodes,
      edges: this.edges,
      viewport: this.viewport,
    };
  }
}
</file>

<file path="src/utils/diagram/index.ts">
export * from './creator';
export * from './transformer';
</file>

<file path="src/utils/diagram/transformer.ts">
import { Edge, Node, Position } from 'reactflow';
import { EDGE_TYPE, MARKER_TYPE, NODE_TYPE, JOIN_TYPE } from '@/utils/enum';
import {
  ComposeDiagram,
  Diagram,
  DiagramModel,
  DiagramModelRelationField,
  DiagramView,
} from '@/utils/data';

export const Config = {
  // the number of nodes in one row
  nodesInRow: 4,
  // the width of the model
  width: 200,
  // height should be calculated depending on the number of columns
  height: undefined,
  // the height of the model header
  headerHeight: 32,
  // the height of the model column
  columnHeight: 32,
  // the height of more tip
  moreTipHeight: 25,
  // the columns limit
  columnsLimit: 10,
  // the overflow of the model body
  bodyOverflow: 'auto',
  // the margin x between the model and the other models
  marginX: 100,
  // the margin y between the model and the other models
  marginY: 50,
  // the model preserved height, for example: the model has 3 subtitles
  modelNodePreservedHeight: 32 * 3,
  // the view preserved height, for example: the view has 1 subtitle
  viewNodePreservedHeight: 32 * 1,
};

const convertBooleanToNumber = (value) => (value ? 1 : 0);

const getLimitedColumnsLengthProps = (columns: any[] = []) => {
  const isOverLimit = columns.length > Config.columnsLimit;
  const limitedLength = isOverLimit ? Config.columnsLimit : columns.length;
  return {
    isOverLimit,
    limitedLength,
    originalLength: columns.length,
  };
};

type NodeWithData = Node<{
  originalData: ComposeDiagram;
  index: number;
  // highlight column ids inside
  highlight: string[];
}>;

type EdgeWithData = Edge<{
  relation?: DiagramModelRelationField;
  highlight: boolean;
}>;

type StartPoint = { x: number; y: number; floor: number };

export class Transformer {
  private readonly config: typeof Config = Config;
  private models: DiagramModel[];
  public nodes: NodeWithData[] = [];
  private views: DiagramView[];
  public edges: Edge[] = [];
  private start: StartPoint = {
    x: 0,
    y: 0,
    floor: 0,
  };

  constructor(data: Diagram) {
    this.models = data?.models || [];
    this.views = data?.views || [];
    this.init();
  }

  public init() {
    const allNodeData = [...this.models, ...this.views];
    for (const data of allNodeData) {
      this.addOne(data);
    }
  }

  public addOne(data: ComposeDiagram) {
    const { nodeType } = data;
    // set position
    const nodeX = this.start.x;
    const nodeY = this.start.y;
    const node = this.createNode({ nodeType, data, x: nodeX, y: nodeY });

    // from the first model
    this.nodes.push(node);

    // update started point
    this.updateNextStartedPoint();
  }

  private updateNextStartedPoint() {
    const width = this.getNodeWidth();
    let floorHeight = 0;
    const { length } = this.nodes;
    const { marginX, marginY, nodesInRow } = this.config;
    const isNextFloor = length % nodesInRow === 0;
    if (isNextFloor) {
      this.start.floor++;
      const lastFloorIndex = nodesInRow * (this.start.floor - 1);
      const composeDiagrams: ComposeDiagram[] = [
        ...this.models,
        ...this.views,
      ].slice(lastFloorIndex, lastFloorIndex + 4);

      const modelWithMostColumns = composeDiagrams.reduce((prev, current) => {
        const prevColumns = [
          ...prev.fields,
          ...(prev?.calculatedFields || []),
          ...(current?.relationFields || []),
        ];
        const currentColumns = [
          ...current.fields,
          ...(current?.calculatedFields || []),
          ...(current?.relationFields || []),
        ];
        return prevColumns.length > currentColumns.length ? prev : current;
      }, composeDiagrams[0]);

      floorHeight = this.getNodeHeight(modelWithMostColumns) + marginY;
    }

    this.start.x = this.start.x + width + marginX;
    if (isNextFloor) this.start.x = 0;
    this.start.y = this.start.y + floorHeight;
  }

  private createNode(props: {
    nodeType: NODE_TYPE | string;
    data: ComposeDiagram;
    x: number;
    y: number;
  }): NodeWithData {
    const { nodeType, data, x, y } = props;
    // check nodeType and add edge
    switch (nodeType) {
      case NODE_TYPE.MODEL:
        this.addModelEdge(data as DiagramModel);
        break;
      default:
        break;
    }

    return {
      id: data.id,
      type: nodeType,
      position: { x, y },
      dragHandle: '.dragHandle',
      data: {
        originalData: data,
        index: this.nodes.length,
        highlight: [],
      },
    };
  }

  private addModelEdge(data: DiagramModel) {
    const { relationFields } = data;
    for (const relationField of relationFields) {
      // check if edge already exist
      const hasEdgeExist = this.edges.some((edge) => {
        // the edge should be unique as relationId
        const edgeRelationId = edge.data?.relation?.relationId;
        return edgeRelationId === relationField.relationId;
      });
      if (hasEdgeExist) continue;

      // prepare to add new edge
      const targetModel = this.models.find(
        (model) =>
          model.id !== data.id &&
          [relationField.fromModelName, relationField.toModelName].includes(
            model.referenceName,
          ),
      )!;

      // skip the edge if model not found
      if (!targetModel) continue;

      const targetField = targetModel.relationFields.find(
        (field) =>
          [
            `${field.fromModelName}.${field.fromColumnName}`,
            `${field.toModelName}.${field.toColumnName}`,
          ].toString() ===
          [
            `${relationField.fromModelName}.${relationField.fromColumnName}`,
            `${relationField.toModelName}.${relationField.toColumnName}`,
          ].toString(),
      );

      // check what source and target relation order
      const relationModels = [
        relationField.fromModelName,
        relationField.toModelName,
      ];
      const sourceJoinIndex = relationModels.findIndex(
        (name) => name === data.referenceName,
      );
      const targetJoinIndex = relationModels.findIndex(
        (name) => name === targetModel?.referenceName,
      );

      targetModel &&
        this.edges.push(
          this.createEdge({
            type: EDGE_TYPE.MODEL,
            joinType: relationField.type,
            sourceModel: data,
            sourceField: relationField,
            sourceJoinIndex,
            targetModel,
            targetField,
            targetJoinIndex,
          }),
        );
    }
  }

  private createEdge(props: {
    type?: EDGE_TYPE;
    sourceModel: ComposeDiagram;
    sourceField?: DiagramModelRelationField;
    sourceJoinIndex?: number;
    targetModel: ComposeDiagram;
    targetField?: DiagramModelRelationField;
    targetJoinIndex?: number;
    joinType?: JOIN_TYPE | string;
    animated?: boolean;
  }): EdgeWithData {
    const {
      type,
      sourceModel,
      sourceField,
      sourceJoinIndex,
      targetModel,
      targetField,
      targetJoinIndex,
      joinType,
      animated,
    } = props;
    const source = sourceModel.id;
    const target = targetModel.id;
    const [sourcePos, targetPos] = this.detectEdgePosition(source, target);
    const sourceHandle = `${sourceField?.id || source}_${sourcePos}`;
    const targetHandle = `${targetField?.id || target}_${targetPos}`;

    const markerStart = this.getMarker(joinType!, sourceJoinIndex!, sourcePos);
    const markerEnd = this.getMarker(joinType!, targetJoinIndex!, targetPos);

    return {
      id: `${sourceHandle}_${targetHandle}`,
      type,
      source,
      target,
      sourceHandle,
      targetHandle,
      markerStart,
      markerEnd,
      data: {
        relation: sourceField,
        highlight: false,
      },
      animated,
    };
  }

  private getFloorIndex(index: number): number {
    const { nodesInRow } = this.config;
    return index % nodesInRow;
  }

  private detectEdgePosition(source: string, target: string) {
    const position = [];
    const [sourceIndex, targetIndex] = [...this.models].reduce(
      (result, current, index) => {
        if (current.id === source) result[0] = index;
        if (current.id === target) result[1] = index;
        return result;
      },
      [-1, -1],
    );
    const sourceFloorIndex = this.getFloorIndex(sourceIndex);
    const targetFloorIndex = this.getFloorIndex(targetIndex);

    if (sourceFloorIndex === targetFloorIndex) {
      position[0] = Position.Left;
      position[1] = Position.Left;
    } else if (sourceFloorIndex > targetFloorIndex) {
      position[0] = Position.Left;
      position[1] = Position.Right;
    } else {
      position[0] = Position.Right;
      position[1] = Position.Left;
    }
    return position;
  }

  private getMarker(
    joinType: JOIN_TYPE | string,
    joinIndex: number,
    position?: Position,
  ) {
    const markers =
      {
        [JOIN_TYPE.ONE_TO_ONE]: [MARKER_TYPE.ONE, MARKER_TYPE.ONE],
        [JOIN_TYPE.ONE_TO_MANY]: [MARKER_TYPE.ONE, MARKER_TYPE.MANY],
        [JOIN_TYPE.MANY_TO_ONE]: [MARKER_TYPE.MANY, MARKER_TYPE.ONE],
      }[joinType] || [];
    return markers[joinIndex] + (position ? `_${position}` : '');
  }

  private getNodeWidth() {
    return this.config.width;
  }

  private getNodeHeight(composeDiagram: ComposeDiagram) {
    const {
      height: nodeHeight,
      headerHeight,
      columnHeight,
      moreTipHeight,
      modelNodePreservedHeight,
      viewNodePreservedHeight,
    } = this.config;

    // get preserved height setting
    const preservedHeightMap = {
      [NODE_TYPE.MODEL]: modelNodePreservedHeight,
      [NODE_TYPE.VIEW]: viewNodePreservedHeight,
    };
    const preservedHeight = preservedHeightMap[composeDiagram.nodeType];

    // check if columns limit is reached
    const { limitedLength: fieldsLength, isOverLimit: isFieldsOverLimit } =
      getLimitedColumnsLengthProps(composeDiagram.fields);
    const {
      limitedLength: calculatedFieldsLength,
      isOverLimit: isCalculatedFieldsOverLimit,
    } = getLimitedColumnsLengthProps(composeDiagram?.calculatedFields);
    const {
      limitedLength: relationFieldsLength,
      isOverLimit: isRelationsOverLimit,
    } = getLimitedColumnsLengthProps(composeDiagram?.relationFields);

    // count more tip
    const moreTipCount =
      convertBooleanToNumber(isFieldsOverLimit) +
      convertBooleanToNumber(isCalculatedFieldsOverLimit) +
      convertBooleanToNumber(isRelationsOverLimit);

    // calculate all block height
    const displayHeaderHeight = headerHeight;
    const displayColumnHeight =
      nodeHeight ||
      columnHeight *
        (fieldsLength + calculatedFieldsLength + relationFieldsLength);
    const displayMoreTipHeight = moreTipHeight * moreTipCount;
    // padding remain
    const paddingHeight = 4;

    return (
      displayHeaderHeight +
      displayColumnHeight +
      displayMoreTipHeight +
      preservedHeight +
      paddingHeight
    );
  }
}
</file>

<file path="src/utils/enum/columnType.ts">
// Refer to backend connector types:
// src/apollo/server/connectors/types.ts

export enum COLUMN_TYPE {
  // Boolean Types
  BOOLEAN = 'BOOLEAN',

  // Numeric Types
  TINYINT = 'TINYINT',

  INT2 = 'INT2',
  SMALLINT = 'SMALLINT', // alias for INT2

  INT4 = 'INT4',
  INTEGER = 'INTEGER', // alias for INT4

  INT8 = 'INT8',
  BIGINT = 'BIGINT', // alias for INT8

  INT64 = 'INT64',

  NUMERIC = 'NUMERIC',
  DECIMAL = 'DECIMAL',

  // Floating-Point Types
  FLOAT4 = 'FLOAT4',
  REAL = 'REAL', // alias for FLOAT4

  FLOAT8 = 'FLOAT8',
  DOUBLE = 'DOUBLE', // alias for FLOAT8

  // Character Types
  VARCHAR = 'VARCHAR',
  CHAR = 'CHAR',
  BPCHAR = 'BPCHAR', // BPCHAR is fixed-length, blank padded string
  TEXT = 'TEXT', // alias for VARCHAR
  STRING = 'STRING', // alias for VARCHAR
  NAME = 'NAME', // alias for VARCHAR

  // Date/Time Types
  TIMESTAMP = 'TIMESTAMP',
  TIMESTAMPTZ = 'TIMESTAMP WITH TIME ZONE',
  DATE = 'DATE',
  INTERVAL = 'INTERVAL',

  // JSON Types
  JSON = 'JSON',

  // Record Types
  RECORD = 'RECORD',

  // Object identifiers (OIDs) are used internally by PostgreSQL as primary keys for various system tables.
  // https://www.postgresql.org/docs/current/datatype-oid.html
  OID = 'OID',

  // Binary Data Types
  BYTEA = 'BYTEA',
  VARBINARY = 'VARBINARY',

  // UUID Type
  UUID = 'UUID',

  // Network Address Types
  INET = 'INET',

  // Unknown Type
  UNKNOWN = 'UNKNOWN',
}
</file>

<file path="src/utils/enum/dataSources.ts">
export { RedshiftConnectionType as REDSHIFT_AUTH_METHOD } from '@/apollo/client/graphql/__types__';

export enum DATA_SOURCES {
  BIG_QUERY = 'BIG_QUERY',
  DUCKDB = 'DUCKDB',
  POSTGRES = 'POSTGRES',
  MYSQL = 'MYSQL',
  ORACLE = 'ORACLE',
  MSSQL = 'MSSQL',
  CLICK_HOUSE = 'CLICK_HOUSE',
  TRINO = 'TRINO',
  SNOWFLAKE = 'SNOWFLAKE',
  ATHENA = 'ATHENA',
  REDSHIFT = 'REDSHIFT',
}
</file>

<file path="src/utils/enum/diagram.ts">
export enum MARKER_TYPE {
  MANY = 'many',
  ONE = 'one',
}

export enum EDGE_TYPE {
  STEP = 'step',
  SMOOTHSTEP = 'smoothstep',
  BEZIER = 'bezier',
  MODEL = 'model',
  METRIC = 'metric',
}
</file>

<file path="src/utils/enum/dropdown.ts">
export enum MORE_ACTION {
  EDIT = 'edit',
  DELETE = 'delete',
  UPDATE_COLUMNS = 'update_columns',
  CACHE_SETTINGS = 'cache_settings',
  REFRESH = 'refresh',
  HIDE_CATEGORY = 'hide_category',
  VIEW_SQL_PAIR = 'view_sql_pair',
  VIEW_INSTRUCTION = 'view_instruction',
  ADJUST_SQL = 'adjust_sql',
  ADJUST_STEPS = 'adjust_steps',
}
</file>

<file path="src/utils/enum/form.ts">
export enum FORM_MODE {
  CREATE = 'CREATE',
  EDIT = 'EDIT',
}

// identifier separated by special & unique symbol
const specialSymbol = '☺';

export const convertObjectToIdentifier = <T>(obj: T, paths: string[]): string =>
  paths.map((path) => `${path}:${obj[path] || ''}`).join(specialSymbol);

export const convertIdentifierToObject = <T>(identifier: string): T =>
  Object.fromEntries(
    identifier.split(specialSymbol).map((str) => str.split(':')),
  );
</file>

<file path="src/utils/enum/home.ts">
export enum COLLAPSE_CONTENT_TYPE {
  NONE = 'none',
  VIEW_SQL = 'view_sql',
  PREVIEW_DATA = 'preview_data',
}

export enum PROCESS_STATE {
  IDLE,
  UNDERSTANDING,
  SEARCHING,
  PLANNING,
  GENERATING,
  CORRECTING,
  FINISHED,
  FAILED,
  STOPPED,
  NO_RESULT,
}

export enum ANSWER_TAB_KEYS {
  ANSWER = 'answer',
  VIEW_SQL = 'view-sql',
  CHART = 'chart',
}
</file>

<file path="src/utils/enum/index.ts">
export * from './form';
export * from './setup';
export * from './dataSources';
export * from './columnType';
export * from './modeling';
export * from './path';
export * from './diagram';
export * from './home';
export * from './settings';
export * from './dropdown';
export * from './menu';
</file>

<file path="src/utils/enum/menu.ts">
export enum MENU_KEY {
  QUESTION_SQL_PAIRS = 'question-sql-pairs',
  INSTRUCTIONS = 'instructions',
  API_HISTORY = 'api-history',
  API_REFERENCE = 'api-reference',
}
</file>

<file path="src/utils/enum/modeling.ts">
export {
  NodeType as NODE_TYPE,
  RelationType as JOIN_TYPE,
} from '@/apollo/client/graphql/__types__';
</file>

<file path="src/utils/enum/path.ts">
export enum Path {
  Home = '/home',
  HomeDashboard = '/home/dashboard',
  Thread = '/home/[id]',
  Modeling = '/modeling',
  Onboarding = '/setup',
  OnboardingConnection = '/setup/connection',
  OnboardingModels = '/setup/models',
  OnboardingRelationships = '/setup/relationships',
  Knowledge = '/knowledge',
  KnowledgeQuestionSQLPairs = '/knowledge/question-sql-pairs',
  KnowledgeInstructions = '/knowledge/instructions',
  APIManagement = '/api-management',
  APIManagementHistory = '/api-management/history',
}
</file>

<file path="src/utils/enum/settings.ts">
export enum SETTINGS {
  DATA_SOURCE = 'DATA_SOURCE',
  PROJECT = 'PROJECT',
}
</file>

<file path="src/utils/enum/setup.ts">
export enum SETUP {
  STARTER = 'starter',
  CREATE_DATA_SOURCE = 'createDataSource',
  SELECT_MODELS = 'selectModels',
  RECOMMEND_RELATIONS = 'recommendRelations',
  DEFINE_RELATIONS = 'defineRelations',
}
</file>

<file path="src/utils/env.ts">
const env = {
  isDevelopment: process.env.NODE_ENV === 'development',
  isProduction: process.env.NODE_ENV === 'production',
};

export default env;

export type UserConfig = {
  isTelemetryEnabled: boolean;
  telemetryKey: string;
  telemetryHost: string;
  userUUID: string;
};

// Get the user configuration
export const getUserConfig = async (): Promise<UserConfig> => {
  const config = await fetch('/api/config').then((res) => res.json());
  const decodedTelemetryKey = Buffer.from(
    config.telemetryKey,
    'base64',
  ).toString();
  return { ...config, telemetryKey: decodedTelemetryKey };
};
</file>

<file path="src/utils/error/dictionary.ts">
export const ERROR_TEXTS = {
  CONNECTION: {
    DISPLAY_NAME: {
      REQUIRED: 'Please input display name.',
    },
    PROJECT_ID: {
      REQUIRED: 'Please input project id.',
    },
    DATASET_ID: {
      REQUIRED: 'Please input dataset ID.',
    },
    CREDENTIAL: {
      REQUIRED: 'Please upload credential.',
    },
    INIT_SQL: {
      REQUIRED: 'Please input initial SQL statements.',
    },
    CONFIGURATION: {
      KEY: {
        REQUIRED: 'Please input configuration key.',
      },
      VALUE: {
        REQUIRED: 'Please input configuration value.',
      },
    },
    HOST: {
      REQUIRED: 'Please input host.',
      INVALID:
        "Invalid host. Use 'host.docker.internal' on macOS/Windows to connect to the local database.",
    },
    PORT: {
      REQUIRED: 'Please input port.',
    },
    USERNAME: {
      REQUIRED: 'Please input username.',
    },
    PASSWORD: {
      REQUIRED: 'Please input password.',
    },
    DATABASE: {
      REQUIRED: 'Please input database name.',
    },
    SCHEMA: {
      REQUIRED: 'Please input schema name.',
    },
    SCHEMAS: {
      REQUIRED: 'Please input list of catalog.schema separated by comma.',
    },
    ACCOUNT: {
      REQUIRED: 'Please input account.',
    },
    S3_STAGING_DIR: {
      REQUIRED: 'Please input S3 staging directory.',
    },
    AWS_REGION: {
      REQUIRED: 'Please input AWS region.',
    },
    AWS_ACCESS_KEY: {
      REQUIRED: 'Please input AWS access key ID.',
    },
    AWS_SECRET_KEY: {
      REQUIRED: 'Please input AWS secret access key.',
    },
    CLUSTER_IDENTIFIER: {
      REQUIRED: 'Please input cluster identifier.',
    },
  },
  ADD_RELATION: {
    FROM_FIELD: {
      REQUIRED: 'Please select a field.',
    },
    TO_FIELD: {
      REQUIRED: 'Please select a field.',
    },
    RELATION_TYPE: {
      REQUIRED: 'Please select a relationship type.',
    },
    RELATIONSHIP: {
      EXIST: 'This relationship already exists.',
    },
  },
  SETUP_MODEL: {
    TABLE: {
      REQUIRED: 'Please select at least one table.',
    },
  },
  SAVE_AS_VIEW: {
    NAME: {
      REQUIRED: 'Please input view name.',
    },
  },
  MODELING_CREATE_MODEL: {
    TABLE: {
      REQUIRED: 'Please select a table.',
    },
    COLUMNS: {
      REQUIRED: 'Please select at least one column.',
    },
    PRIMARY_KEY: {
      INVALID:
        'Please select again, the primary key must be one of the selected columns.',
    },
  },
  CALCULATED_FIELD: {
    NAME: {
      REQUIRED: 'Please input field name.',
    },
    EXPRESSION: {
      REQUIRED: 'Please select an expression.',
    },
    LINEAGE: {
      REQUIRED: 'Please select a field.',
      INVALID_STRING_TYPE: 'Please select a string type field.',
      INVALID_NUMBER_TYPE: 'Please select a number type field.',
    },
  },
  SQL_PAIR: {
    SQL: {
      REQUIRED: 'Please input SQL statement.',
    },
    QUESTION: {
      REQUIRED: 'Please input a matching question.',
      MAX_LENGTH: 'Question must be 300 characters or fewer.',
    },
  },
  INSTRUCTION: {
    DETAILS: {
      REQUIRED: 'Please input an instruction details.',
    },
    QUESTIONS: {
      REQUIRED: 'Please input a matching question.',
    },
    IS_DEFAULT_GLOBAL: {
      REQUIRED: 'Please select how to apply this instruction.',
    },
  },
  FIX_SQL: {
    SQL: {
      REQUIRED: 'Please input SQL statement.',
    },
  },
  ADJUST_REASONING: {
    SELECTED_MODELS: {
      REQUIRED: 'Please select at least one model',
    },
    STEPS: {
      REQUIRED: 'Please input reasoning steps',
      MAX_LENGTH: 'Reasoning steps must be 6000 characters or fewer.',
    },
  },
  IMPORT_DATA_SOURCE_SQL: {
    SQL: {
      REQUIRED: 'Please input SQL statement.',
    },
  },
  CRON: {
    REQUIRED: 'Please input cron expression.',
    INVALID: 'Invalid cron expression.',
  },
  CACHE_SETTINGS: {
    DAY: {
      REQUIRED: 'Please select day.',
    },
    TIME: {
      REQUIRED: 'Please select time.',
    },
  },
};
</file>

<file path="src/utils/error/index.ts">
export * from './dictionary';
</file>

<file path="src/utils/errorHandler.tsx">
import { GraphQLError } from 'graphql';
import { ErrorResponse } from '@apollo/client/link/error';
import { ApolloError } from '@apollo/client';
import { message } from 'antd';

// Refer to backend GeneralErrorCodes for mapping
export const ERROR_CODES = {
  INVALID_CALCULATED_FIELD: 'INVALID_CALCULATED_FIELD',
  CONNECTION_REFUSED: 'CONNECTION_REFUSED',
  NO_CHART: 'NO_CHART',
};

/**
 * Replace the token %{s} in the message with the detail message.
 * For example:
 *
 *  Input: ('Failed to update %{data source}.')
 *  Output: Failed to update data source.
 *
 *  Input: ('Failed to update %{data source}.', 'The data source is not found.')
 *  Output: Failed to update - The data source is not found.
 *
 * @param message The default message with replace token %{s}.
 * @param detailMessage The detail message.
 * @returns string
 */
const replaceMessage = (message: string, detailMessage?: string) => {
  const regex = /\%\{.+\}/;
  const textWithoutTokenRegex = /(?<=\%\{).+(?=\})/;
  const matchText = message.match(textWithoutTokenRegex);
  if (matchText === null) {
    console.warn('Replace token not found in message:', message);
    return message;
  }
  return detailMessage
    ? message.replace(regex, `- ${detailMessage}`)
    : message.replace(regex, matchText[0]);
};

abstract class ErrorHandler {
  public handle(error: GraphQLError) {
    const errorMessage = this.getErrorMessage(error);
    if (errorMessage) message.error(errorMessage);
  }

  abstract getErrorMessage(error: GraphQLError): string | null;
}

const errorHandlers = new Map<string, ErrorHandler>();

class SaveTablesErrorHandler extends ErrorHandler {
  public getErrorMessage(error: GraphQLError) {
    switch (error.extensions?.code) {
      default:
        return 'Failed to create model(s).';
    }
  }
}

class SaveRelationsErrorHandler extends ErrorHandler {
  public getErrorMessage(error: GraphQLError) {
    switch (error.extensions?.code) {
      default:
        return 'Failed to define relations.';
    }
  }
}

class CreateAskingTaskErrorHandler extends ErrorHandler {
  public getErrorMessage(error: GraphQLError) {
    switch (error.extensions?.code) {
      default:
        return 'Failed to create asking task.';
    }
  }
}

class CreateThreadErrorHandler extends ErrorHandler {
  public getErrorMessage(error: GraphQLError) {
    switch (error.extensions?.code) {
      default:
        return 'Failed to create thread.';
    }
  }
}

class UpdateThreadErrorHandler extends ErrorHandler {
  public getErrorMessage(error: GraphQLError) {
    switch (error.extensions?.code) {
      default:
        return 'Failed to update thread.';
    }
  }
}

class DeleteThreadErrorHandler extends ErrorHandler {
  public getErrorMessage(error: GraphQLError) {
    switch (error.extensions?.code) {
      default:
        return 'Failed to delete thread.';
    }
  }
}

class CreateThreadResponseErrorHandler extends ErrorHandler {
  public getErrorMessage(error: GraphQLError) {
    switch (error.extensions?.code) {
      default:
        return 'Failed to create thread response.';
    }
  }
}

class UpdateThreadResponseErrorHandler extends ErrorHandler {
  public getErrorMessage(error: GraphQLError) {
    switch (error.extensions?.code) {
      default:
        return 'Failed to update thread response.';
    }
  }
}

class GenerateThreadResponseAnswerErrorHandler extends ErrorHandler {
  public getErrorMessage(error: GraphQLError) {
    switch (error.extensions?.code) {
      default:
        return 'Failed to generate thread response answer.';
    }
  }
}

class AdjustThreadResponseErrorHandler extends ErrorHandler {
  public getErrorMessage(error: GraphQLError) {
    switch (error.extensions?.code) {
      default:
        return 'Failed to adjust thread response answer.';
    }
  }
}

class CreateViewErrorHandler extends ErrorHandler {
  public getErrorMessage(error: GraphQLError) {
    switch (error.extensions?.code) {
      default:
        return 'Failed to create view.';
    }
  }
}

class UpdateDataSourceErrorHandler extends ErrorHandler {
  public getErrorMessage(error: GraphQLError) {
    switch (error.extensions?.code) {
      default:
        return replaceMessage(
          `Failed to update %{data source}.`,
          error.message,
        );
    }
  }
}

class CreateModelErrorHandler extends ErrorHandler {
  public getErrorMessage(error: GraphQLError) {
    switch (error.extensions?.code) {
      default:
        return 'Failed to create model.';
    }
  }
}

class UpdateModelErrorHandler extends ErrorHandler {
  public getErrorMessage(error: GraphQLError) {
    switch (error.extensions?.code) {
      default:
        return 'Failed to update model.';
    }
  }
}

class DeleteModelErrorHandler extends ErrorHandler {
  public getErrorMessage(error: GraphQLError) {
    switch (error.extensions?.code) {
      default:
        return 'Failed to delete model.';
    }
  }
}

class UpdateModelMetadataErrorHandler extends ErrorHandler {
  public getErrorMessage(error: GraphQLError) {
    switch (error.extensions?.code) {
      default:
        return 'Failed to update model metadata.';
    }
  }
}

class CreateCalculatedFieldErrorHandler extends ErrorHandler {
  public getErrorMessage(error: GraphQLError) {
    switch (error.extensions?.code) {
      default:
        return 'Failed to create calculated field.';
    }
  }
}

class UpdateCalculatedFieldErrorHandler extends ErrorHandler {
  public getErrorMessage(error: GraphQLError) {
    switch (error.extensions?.code) {
      default:
        return 'Failed to update calculated field.';
    }
  }
}

class DeleteCalculatedFieldErrorHandler extends ErrorHandler {
  public getErrorMessage(error: GraphQLError) {
    switch (error.extensions?.code) {
      default:
        return 'Failed to delete calculated field.';
    }
  }
}

class CreateRelationshipErrorHandler extends ErrorHandler {
  public getErrorMessage(error: GraphQLError) {
    switch (error.extensions?.code) {
      default:
        return 'Failed to create relationship.';
    }
  }
}

class UpdateRelationshipErrorHandler extends ErrorHandler {
  public getErrorMessage(error: GraphQLError) {
    switch (error.extensions?.code) {
      default:
        return 'Failed to update relationship.';
    }
  }
}

class DeleteRelationshipErrorHandler extends ErrorHandler {
  public getErrorMessage(error: GraphQLError) {
    switch (error.extensions?.code) {
      default:
        return 'Failed to delete relationship.';
    }
  }
}

class UpdateViewMetadataErrorHandler extends ErrorHandler {
  public getErrorMessage(error: GraphQLError) {
    switch (error.extensions?.code) {
      default:
        return 'Failed to update view metadata.';
    }
  }
}

class TriggerDataSourceDetectionErrorHandler extends ErrorHandler {
  public getErrorMessage(error: GraphQLError) {
    switch (error.extensions?.code) {
      default:
        return 'Failed to scan data source.';
    }
  }
}

class ResolveSchemaChangeErrorHandler extends ErrorHandler {
  public getErrorMessage(error: GraphQLError) {
    switch (error.extensions?.code) {
      default:
        return 'Failed to resolve schema change.';
    }
  }
}

class CreateDashboardItemErrorHandler extends ErrorHandler {
  public getErrorMessage(error: GraphQLError) {
    switch (error.extensions?.code) {
      default:
        return 'Failed to create dashboard item.';
    }
  }
}

class UpdateDashboardItemErrorHandler extends ErrorHandler {
  public getErrorMessage(error: GraphQLError) {
    switch (error.extensions?.code) {
      default:
        return 'Failed to update dashboard item.';
    }
  }
}

class UpdateDashboardItemLayoutsErrorHandler extends ErrorHandler {
  public getErrorMessage(error: GraphQLError) {
    switch (error.extensions?.code) {
      default:
        return 'Failed to update dashboard item layouts.';
    }
  }
}

class DeleteDashboardItemErrorHandler extends ErrorHandler {
  public getErrorMessage(error: GraphQLError) {
    switch (error.extensions?.code) {
      default:
        return 'Failed to delete dashboard item.';
    }
  }
}

class SetDashboardScheduleErrorHandler extends ErrorHandler {
  public getErrorMessage(error: GraphQLError) {
    switch (error.extensions?.code) {
      default:
        return 'Failed to set dashboard schedule.';
    }
  }
}

class CreateSqlPairErrorHandler extends ErrorHandler {
  public getErrorMessage(error: GraphQLError) {
    switch (error.extensions?.code) {
      default:
        return 'Failed to create question-sql pair.';
    }
  }
}

class UpdateSqlPairErrorHandler extends ErrorHandler {
  public getErrorMessage(error: GraphQLError) {
    switch (error.extensions?.code) {
      default:
        return 'Failed to update question-sql pair.';
    }
  }
}

class DeleteSqlPairErrorHandler extends ErrorHandler {
  public getErrorMessage(error: GraphQLError) {
    switch (error.extensions?.code) {
      default:
        return 'Failed to delete question-sql pair.';
    }
  }
}

class CreateInstructionErrorHandler extends ErrorHandler {
  public getErrorMessage(error: GraphQLError) {
    switch (error.extensions?.code) {
      default:
        return 'Failed to create instruction.';
    }
  }
}

class UpdateInstructionErrorHandler extends ErrorHandler {
  public getErrorMessage(error: GraphQLError) {
    switch (error.extensions?.code) {
      default:
        return 'Failed to update instruction.';
    }
  }
}

class DeleteInstructionErrorHandler extends ErrorHandler {
  public getErrorMessage(error: GraphQLError) {
    switch (error.extensions?.code) {
      default:
        return 'Failed to delete instruction.';
    }
  }
}

errorHandlers.set('SaveTables', new SaveTablesErrorHandler());
errorHandlers.set('SaveRelations', new SaveRelationsErrorHandler());
errorHandlers.set('CreateAskingTask', new CreateAskingTaskErrorHandler());
errorHandlers.set('CreateThread', new CreateThreadErrorHandler());
errorHandlers.set('UpdateThread', new UpdateThreadErrorHandler());
errorHandlers.set('DeleteThread', new DeleteThreadErrorHandler());
errorHandlers.set(
  'CreateThreadResponse',
  new CreateThreadResponseErrorHandler(),
);
errorHandlers.set(
  'UpdateThreadResponse',
  new UpdateThreadResponseErrorHandler(),
);
errorHandlers.set(
  'GenerateThreadResponseAnswer',
  new GenerateThreadResponseAnswerErrorHandler(),
);
errorHandlers.set(
  'AdjustThreadResponse',
  new AdjustThreadResponseErrorHandler(),
);

errorHandlers.set('CreateView', new CreateViewErrorHandler());
errorHandlers.set('UpdateDataSource', new UpdateDataSourceErrorHandler());
errorHandlers.set('CreateModel', new CreateModelErrorHandler());
errorHandlers.set('UpdateModel', new UpdateModelErrorHandler());
errorHandlers.set('DeleteModel', new DeleteModelErrorHandler());
errorHandlers.set('UpdateModelMetadata', new UpdateModelMetadataErrorHandler());
errorHandlers.set('UpdateViewMetadata', new UpdateViewMetadataErrorHandler());
errorHandlers.set(
  'CreateCalculatedField',
  new CreateCalculatedFieldErrorHandler(),
);
errorHandlers.set(
  'UpdateCalculatedField',
  new UpdateCalculatedFieldErrorHandler(),
);
errorHandlers.set(
  'DeleteCalculatedField',
  new DeleteCalculatedFieldErrorHandler(),
);

// Relationship
errorHandlers.set('CreateRelationship', new CreateRelationshipErrorHandler());
errorHandlers.set('UpdateRelationship', new UpdateRelationshipErrorHandler());
errorHandlers.set('DeleteRelationship', new DeleteRelationshipErrorHandler());

// Schema change
errorHandlers.set(
  'TriggerDataSourceDetection',
  new TriggerDataSourceDetectionErrorHandler(),
);
errorHandlers.set('ResolveSchemaChange', new ResolveSchemaChangeErrorHandler());

// Dashboard
errorHandlers.set('CreateDashboardItem', new CreateDashboardItemErrorHandler());
errorHandlers.set('UpdateDashboardItem', new UpdateDashboardItemErrorHandler());
errorHandlers.set(
  'UpdateDashboardItemLayouts',
  new UpdateDashboardItemLayoutsErrorHandler(),
);
errorHandlers.set('DeleteDashboardItem', new DeleteDashboardItemErrorHandler());
errorHandlers.set(
  'SetDashboardSchedule',
  new SetDashboardScheduleErrorHandler(),
);

// SQL Pair
errorHandlers.set('CreateSqlPair', new CreateSqlPairErrorHandler());
errorHandlers.set('UpdateSqlPair', new UpdateSqlPairErrorHandler());
errorHandlers.set('DeleteSqlPair', new DeleteSqlPairErrorHandler());

// Instruction
errorHandlers.set('CreateInstruction', new CreateInstructionErrorHandler());
errorHandlers.set('UpdateInstruction', new UpdateInstructionErrorHandler());
errorHandlers.set('DeleteInstruction', new DeleteInstructionErrorHandler());

const errorHandler = (error: ErrorResponse) => {
  // networkError
  if (error.networkError) {
    message.error(
      'No internet. Please check your network connection and try again.',
    );
  }

  const operationName = error?.operation?.operationName || '';
  if (error.graphQLErrors) {
    for (const err of error.graphQLErrors) {
      errorHandlers.get(operationName)?.handle(err);
    }
  }
};

export default errorHandler;

export const parseGraphQLError = (error: ApolloError) => {
  if (!error) return null;
  const graphQLErrors: GraphQLError = error.graphQLErrors?.[0];
  const extensions = graphQLErrors?.extensions || {};
  return {
    message: extensions.message as string,
    shortMessage: extensions.shortMessage as string,
    code: extensions.code as string,
    stacktrace: extensions?.stacktrace as Array<string> | undefined,
  };
};
</file>

<file path="src/utils/events.tsx">
export const subscribe = (eventName: string, listener: any) => {
  document.addEventListener(eventName, listener);
};

export const unsubscribe = (eventName: string, listener: any) => {
  document.removeEventListener(eventName, listener);
};

export const dispatch = (eventName: string, detail?: any) => {
  const event = new CustomEvent(eventName, { detail });
  document.dispatchEvent(event);
};

export const EVENT_NAME = {
  GO_TO_FIRST_MODEL: 'goToFirstModel',
};
</file>

<file path="src/utils/expressionType.ts">
import { ExpressionName } from '@/apollo/client/graphql/__types__';

export const aggregations = [
  ExpressionName.AVG,
  ExpressionName.COUNT,
  ExpressionName.MAX,
  ExpressionName.MIN,
  ExpressionName.SUM,
];

export const mathFunctions = [
  ExpressionName.ABS,
  ExpressionName.CBRT,
  ExpressionName.CEIL,
  ExpressionName.EXP,
  ExpressionName.FLOOR,
  ExpressionName.LN,
  ExpressionName.LOG10,
  ExpressionName.ROUND,
  ExpressionName.SIGN,
];

export const stringFunctions = [ExpressionName.LENGTH, ExpressionName.REVERSE];
</file>

<file path="src/utils/helper.ts">
import { omitBy, isUndefined } from 'lodash';

/**
 * @function
 * @description Remove undefined property value in an object
 */
export const compactObject = <T>(obj: T) => {
  return omitBy(obj, isUndefined) as T;
};

/**
 * @function
 * @description Retrieve json without error
 */
export const parseJson = (data) => {
  try {
    return JSON.parse(data);
  } catch (_e) {
    return data;
  }
};

export const attachLoading = (
  asyncRequest: (...args: any[]) => Promise<any>,
  setLoading: React.Dispatch<React.SetStateAction<boolean>>,
) => {
  return async (...args) => {
    setLoading(true);
    try {
      await asyncRequest(...args);
    } finally {
      setLoading(false);
    }
  };
};
</file>

<file path="src/utils/icons.ts">
import styled from 'styled-components';
import { Columns } from '@styled-icons/fa-solid';
import {
  Calendar,
  Text,
  InfoCircle,
  Cube,
  LineChart,
  IdCard,
} from '@styled-icons/boxicons-regular';
import { Braces, Map2 } from '@styled-icons/remix-line';
import {
  SortNumerically,
  SortAlphabetically,
  Tick,
} from '@styled-icons/typicons';
import {
  VpnKey,
  CenterFocusWeak,
  Refresh,
  Pageview,
  Explore,
  Translate,
  OpenInNew,
} from '@styled-icons/material-outlined';
import FieldBinaryOutlined from '@ant-design/icons/FieldBinaryOutlined';
import MonitorOutlined from '@ant-design/icons/MonitorOutlined';
import SwapOutlined from '@ant-design/icons/SwapOutlined';
import ShareAltOutlined from '@ant-design/icons/ShareAltOutlined';
import { Binoculars, LightningCharge } from '@styled-icons/bootstrap';
import MoreOutlined from '@ant-design/icons/MoreOutlined';
import { Sparkles } from '@styled-icons/ionicons-outline';
import { Discord, Github } from '@styled-icons/fa-brands';

export const NumericIcon = styled(SortNumerically)`
  height: 1em;
`;
export const TickIcon = styled(Tick)`
  height: 1em;
`;
export const StringIcon = styled(SortAlphabetically)`
  height: 1em;
`;
export const TextIcon = styled(Text)`
  height: 1em;
`;
export const CalendarIcon = styled(Calendar)`
  height: 1em;
`;
export const IdIcon = styled(IdCard)`
  height: 1em;
`;
export const JsonBracesIcon = styled(Braces)`
  height: 1em;
`;
export const BinaryIcon = styled(FieldBinaryOutlined)`
  height: 1em;
`;
export const ColumnsIcon = styled(Columns)`
  height: 1em;
`;
export const InfoIcon = styled(InfoCircle)`
  height: 1em;
`;
export const PrimaryKeyIcon = styled(VpnKey)`
  height: 1em;
`;
export const ModelIcon = styled(Cube)`
  height: 1em;
`;
export const FocusIcon = styled(CenterFocusWeak)`
  height: 1em;
`;
export const MapIcon = styled(Map2)`
  height: 1em;
`;
export const RelationshipIcon = styled(SwapOutlined)`
  height: 1em;
`;
export const MonitorIcon = styled(MonitorOutlined)`
  height: 1em;
`;
export const RefreshIcon = styled(Refresh)``;
export const MetricIcon = styled(LineChart)`
  height: 1em;
`;
export const ShareIcon = styled(ShareAltOutlined)``;
export const LightningIcon = styled(LightningCharge)`
  height: 1em;
`;
export const MoreIcon = styled(MoreOutlined)``;
export const ViewIcon = styled(Pageview)`
  height: 1em;
`;
export const ExploreIcon = styled(Explore)`
  height: 1em;
`;
export const SparklesIcon = styled(Sparkles)`
  height: 1em;
`;

export const BinocularsIcon = styled(Binoculars)`
  height: 16px;
  width: 14px;
`;

export const DiscordIcon = styled(Discord)`
  height: 1em;
`;

export const GithubIcon = styled(Github)`
  height: 1em;
`;

export const TranslateIcon = styled(Translate)`
  height: 1em;
`;

export const OpenInNewIcon = styled(OpenInNew)`
  height: 1em;
`;
</file>

<file path="src/utils/iteration.tsx">
interface Props {
  [key: string]: any;
  data: any[];
  // by default it will use item['key'] as keyIndex unless specifying keyIndex
  keyIndex?: string | ((item: any) => string);
}

export type IterableComponent<T = any> = {
  data: T[];
  index: number;
  key: string;
} & T;

export const makeIterable = (Template: React.FC<IterableComponent<any>>) => {
  const Iterator = (props: Props) => {
    const { data, keyIndex = 'key', ...restProps } = props;
    const result = data.map((item, index) => {
      const key =
        typeof keyIndex === 'function' ? keyIndex(item) : item[keyIndex];
      return (
        <Template
          data={data}
          index={index}
          key={`${index}-${key}`}
          {...restProps}
          {...item}
        />
      );
    });
    return <>{result}</>;
  };

  return Iterator;
};
</file>

<file path="src/utils/language.ts">
import { ProjectLanguage } from '@/apollo/client/graphql/__types__';

export const getLanguageText = (language: ProjectLanguage) =>
  ({
    [ProjectLanguage.EN]: 'English',
    [ProjectLanguage.ES]: 'Spanish',
    [ProjectLanguage.FR]: 'French',
    [ProjectLanguage.ZH_TW]: 'Traditional Chinese',
    [ProjectLanguage.ZH_CN]: 'Simplified Chinese',
    [ProjectLanguage.DE]: 'German',
    [ProjectLanguage.PT]: 'Portuguese',
    [ProjectLanguage.RU]: 'Russian',
    [ProjectLanguage.JA]: 'Japanese',
    [ProjectLanguage.KO]: 'Korean',
  })[language] || language;
</file>

<file path="src/utils/modelingHelper.ts">
import { keyBy } from 'lodash';
import { Diagram, DiagramModel } from '@/utils/data/type';
import { getFieldValue } from '@/components/selectors/lineageSelector/FieldSelect';

export const editCalculatedField = (
  payload: { diagramData: Diagram; data: any },
  openCalculatedFieldModal: (defaultValue: any, payload: any) => void,
) => {
  const { diagramData, data } = payload;
  const sourceModel = diagramData.models.find(
    (model) => model.modelId === data.modelId,
  );

  const getField = (model: DiagramModel, columnId: number) => {
    return [...(model?.fields || []), ...(model?.calculatedFields || [])].find(
      (field) => field.columnId === columnId,
    );
  };

  // Retrieve from the source model directly if only one id in lineage
  const isSourceModelField = data.lineage.length === 1;
  if (isSourceModelField) {
    const field = getField(sourceModel, data.lineage[0]);
    openCalculatedFieldModal &&
      openCalculatedFieldModal(
        {
          columnId: data.columnId,
          name: data.displayName,
          expression: data.aggregation,
          lineage: [getFieldValue(field)],
        },
        {
          models: diagramData.models,
          sourceModel,
        },
      );
    return;
  }

  // Otherwise, retrieve all relations and column by their id
  const allModelsMap = keyBy(diagramData.models, 'referenceName');
  const relationIds = [...data.lineage];
  const lastColumnId = relationIds.pop(); // it will also remove the last column id from relationIds

  let nextModel = null;
  const relations = relationIds.reduce((result, relationId) => {
    const relation = (nextModel || sourceModel).relationFields.find(
      (relation) => relation.relationId === relationId,
    );
    nextModel = allModelsMap[relation.referenceName];
    return [...result, relation];
  }, []);

  const lastRelation = relations[relations.length - 1];
  const lastModel = allModelsMap[lastRelation.referenceName];
  const field = getField(lastModel, lastColumnId);

  openCalculatedFieldModal &&
    openCalculatedFieldModal(
      {
        columnId: data.columnId,
        name: data.displayName,
        expression: data.aggregation,
        lineage: [...relations, field].map(getFieldValue),
      },
      {
        models: diagramData.models,
        sourceModel,
      },
    );
};
</file>

<file path="src/utils/nodeType.tsx">
import { getColumnTypeIcon } from './columnType';
import { COLUMN_TYPE, NODE_TYPE } from './enum';
import { MetricIcon, ModelIcon, RelationshipIcon, ViewIcon } from './icons';

export const getNodeTypeIcon = (
  payload: { nodeType: NODE_TYPE | string; type?: COLUMN_TYPE | string },
  attrs?: any,
) => {
  const { nodeType, type } = payload;
  switch (nodeType) {
    case NODE_TYPE.MODEL:
      return <ModelIcon title="Model" {...attrs} />;
    case NODE_TYPE.METRIC:
      return <MetricIcon title="Metric" {...attrs} />;
    case NODE_TYPE.VIEW:
      return <ViewIcon title="View" {...attrs} />;
    case NODE_TYPE.RELATION:
      return <RelationshipIcon title="Relationship" {...attrs} />;

    case NODE_TYPE.FIELD:
      return type ? getColumnTypeIcon({ type }, attrs) : null;

    default:
      return null;
  }
};
</file>

<file path="src/utils/svgs/CopilotSVG.tsx">
export const CopilotSVG = ({
  fillCurrentColor = true,
  className,
}: {
  fillCurrentColor?: boolean;
  className?: string;
}) => (
  <svg
    className={className}
    width="14"
    height="14"
    viewBox="0 0 24 24"
    fill="none"
    xmlns="http://www.w3.org/2000/svg"
  >
    <path
      d="M18.6562 11.7478L13.9791 10.0247L12.2522 5.34375C12.1201 4.98542 11.8813 4.67621 11.5679 4.45781C11.2546 4.2394 10.8819 4.12231 10.5 4.12231C10.1181 4.12231 9.74535 4.2394 9.43205 4.45781C9.11875 4.67621 8.87993 4.98542 8.74781 5.34375L7.02469 10.0247L2.34375 11.7478C1.98542 11.8799 1.67621 12.1187 1.45781 12.432C1.2394 12.7454 1.12231 13.1181 1.12231 13.5C1.12231 13.8819 1.2394 14.2546 1.45781 14.568C1.67621 14.8813 1.98542 15.1201 2.34375 15.2522L7.02094 16.9753L8.74781 21.6562C8.87993 22.0146 9.11875 22.3238 9.43205 22.5422C9.74535 22.7606 10.1181 22.8777 10.5 22.8777C10.8819 22.8777 11.2546 22.7606 11.5679 22.5422C11.8813 22.3238 12.1201 22.0146 12.2522 21.6562L13.9753 16.9791L18.6562 15.2522C19.0146 15.1201 19.3238 14.8813 19.5422 14.568C19.7606 14.2546 19.8777 13.8819 19.8777 13.5C19.8777 13.1181 19.7606 12.7454 19.5422 12.432C19.3238 12.1187 19.0146 11.8799 18.6562 11.7478ZM13.0312 14.9259C12.7777 15.0192 12.5475 15.1664 12.3565 15.3574C12.1655 15.5484 12.0183 15.7787 11.925 16.0322L10.5 19.9012L9.07406 16.0312C8.98079 15.778 8.83365 15.548 8.64282 15.3572C8.45198 15.1663 8.222 15.0192 7.96875 14.9259L4.09875 13.5L7.96875 12.0741C8.222 11.9808 8.45198 11.8337 8.64282 11.6428C8.83365 11.452 8.98079 11.222 9.07406 10.9688L10.5 7.09875L11.9259 10.9688C12.0192 11.2223 12.1664 11.4525 12.3574 11.6435C12.5484 11.8345 12.7787 11.9817 13.0322 12.075L16.9012 13.5L13.0312 14.9259ZM13.125 3.75C13.125 3.45163 13.2435 3.16548 13.4545 2.9545C13.6655 2.74353 13.9516 2.625 14.25 2.625H15.375V1.5C15.375 1.20163 15.4935 0.915483 15.7045 0.704505C15.9155 0.493526 16.2016 0.375 16.5 0.375C16.7984 0.375 17.0845 0.493526 17.2955 0.704505C17.5065 0.915483 17.625 1.20163 17.625 1.5V2.625H18.75C19.0484 2.625 19.3345 2.74353 19.5455 2.9545C19.7565 3.16548 19.875 3.45163 19.875 3.75C19.875 4.04837 19.7565 4.33452 19.5455 4.5455C19.3345 4.75647 19.0484 4.875 18.75 4.875H17.625V6C17.625 6.29837 17.5065 6.58452 17.2955 6.7955C17.0845 7.00647 16.7984 7.125 16.5 7.125C16.2016 7.125 15.9155 7.00647 15.7045 6.7955C15.4935 6.58452 15.375 6.29837 15.375 6V4.875H14.25C13.9516 4.875 13.6655 4.75647 13.4545 4.5455C13.2435 4.33452 13.125 4.04837 13.125 3.75ZM23.625 8.25C23.625 8.54837 23.5065 8.83452 23.2955 9.0455C23.0845 9.25647 22.7984 9.375 22.5 9.375H22.125V9.75C22.125 10.0484 22.0065 10.3345 21.7955 10.5455C21.5845 10.7565 21.2984 10.875 21 10.875C20.7016 10.875 20.4155 10.7565 20.2045 10.5455C19.9935 10.3345 19.875 10.0484 19.875 9.75V9.375H19.5C19.2016 9.375 18.9155 9.25647 18.7045 9.0455C18.4935 8.83452 18.375 8.54837 18.375 8.25C18.375 7.95163 18.4935 7.66548 18.7045 7.4545C18.9155 7.24353 19.2016 7.125 19.5 7.125H19.875V6.75C19.875 6.45163 19.9935 6.16548 20.2045 5.9545C20.4155 5.74353 20.7016 5.625 21 5.625C21.2984 5.625 21.5845 5.74353 21.7955 5.9545C22.0065 6.16548 22.125 6.45163 22.125 6.75V7.125H22.5C22.7984 7.125 23.0845 7.24353 23.2955 7.4545C23.5065 7.66548 23.625 7.95163 23.625 8.25Z"
      fill={fillCurrentColor ? 'currentColor' : undefined}
    />
  </svg>
);
</file>

<file path="src/utils/svgs/EditSVG.tsx">
export const EditSVG = ({
  fillCurrentColor = true,
  className,
}: {
  fillCurrentColor?: boolean;
  className?: string;
}) => (
  <svg
    className={className}
    width="14"
    height="14"
    viewBox="0 0 14 14"
    fill="none"
    xmlns="http://www.w3.org/2000/svg"
  >
    <path
      fillRule="evenodd"
      clipRule="evenodd"
      d="M10.9929 5.04652L10.3083 5.7311L11.602 7.0247L12.2867 6.34012C12.2652 6.26694 12.2367 6.18523 12.2012 6.0998C12.1016 5.86038 11.968 5.64205 11.8296 5.5036C11.6911 5.36514 11.4727 5.23157 11.2333 5.13201C11.1479 5.09648 11.0661 5.06797 10.9929 5.04652ZM10.6592 7.96748L9.36549 6.67388L5.92291 10.1162C5.50551 10.5335 5.25873 11.2125 5.12676 11.8724C5.09852 12.0136 5.07652 12.1489 5.0594 12.2738C5.18415 12.2566 5.31921 12.2346 5.46023 12.2064C6.11984 12.0744 6.79883 11.8275 7.21669 11.4097L10.6592 7.96748ZM4.33325 13C3.66659 13 3.66659 12.9996 3.66659 12.9996L3.66659 12.9983L3.66659 12.9957L3.66664 12.9882L3.66695 12.9637C3.66728 12.9432 3.66793 12.9146 3.66917 12.8787C3.67164 12.807 3.67649 12.7058 3.68602 12.5818C3.70502 12.3349 3.74295 11.9928 3.81931 11.611C3.96692 10.8728 4.27927 9.87414 4.98014 9.17333L10.2919 3.8619C10.4156 3.73825 10.5829 3.66813 10.7578 3.66667C11.0504 3.66422 11.4208 3.76595 11.7452 3.90087C12.0828 4.04124 12.47 4.25846 12.7723 4.56075C13.0747 4.86305 13.2919 5.25027 13.4323 5.58782C13.5672 5.91229 13.669 6.28262 13.6665 6.57528C13.6651 6.75017 13.5949 6.91748 13.4713 7.04115L8.15946 12.3525C7.45837 13.0536 6.45995 13.3661 5.72188 13.5138C5.34011 13.5902 4.99815 13.6282 4.75126 13.6472C4.62736 13.6567 4.5262 13.6616 4.4545 13.6641C4.41863 13.6653 4.39004 13.6659 4.36957 13.6663L4.34504 13.6666L4.33751 13.6666L4.33497 13.6666L4.33401 13.6666C4.33401 13.6666 4.33325 13.6666 4.33325 13ZM4.33325 13V13.6666C3.96506 13.6666 3.66659 13.3678 3.66659 12.9996L4.33325 13Z"
      fill={fillCurrentColor ? 'currentColor' : undefined}
    />
    <path
      fillRule="evenodd"
      clipRule="evenodd"
      d="M3.99992 0.333313C4.28687 0.333313 4.54163 0.516933 4.63237 0.789161L5.27697 2.72293L7.21074 3.36752C7.48297 3.45827 7.66659 3.71303 7.66659 3.99998C7.66659 4.28693 7.48297 4.54169 7.21074 4.63244L5.27697 5.27703L4.63237 7.2108C4.54163 7.48303 4.28687 7.66665 3.99992 7.66665C3.71297 7.66665 3.45821 7.48303 3.36746 7.2108L2.72287 5.27703L0.7891 4.63244C0.516872 4.54169 0.333252 4.28693 0.333252 3.99998C0.333252 3.71303 0.516872 3.45827 0.7891 3.36752L2.72287 2.72293L3.36746 0.789161C3.45821 0.516933 3.71297 0.333313 3.99992 0.333313ZM3.99992 3.10816L3.88237 3.4608C3.81602 3.65987 3.65981 3.81608 3.46074 3.88244L3.1081 3.99998L3.46074 4.11752C3.65981 4.18388 3.81602 4.34009 3.88237 4.53916L3.99992 4.89179L4.11746 4.53916C4.18382 4.34009 4.34003 4.18388 4.5391 4.11752L4.89173 3.99998L4.5391 3.88244C4.34003 3.81608 4.18382 3.65987 4.11746 3.4608L3.99992 3.10816Z"
      fill={fillCurrentColor ? 'currentColor' : undefined}
    />
  </svg>
);
</file>

<file path="src/utils/svgs/index.ts">
export * from './CopilotSVG';
export * from './RobotSVG';
export * from './InstructionsSVG';
export * from './EditSVG';
</file>

<file path="src/utils/svgs/InstructionsSVG.tsx">
export const InstructionsSVG = ({
  fillCurrentColor = true,
  className,
}: {
  fillCurrentColor?: boolean;
  className?: string;
}) => (
  <svg
    className={className}
    width="14"
    height="14"
    viewBox="0 0 14 15"
    fill="none"
    xmlns="http://www.w3.org/2000/svg"
  >
    <path
      fillRule="evenodd"
      clipRule="evenodd"
      d="M2.63962 1.97296L3.36755 -0.210815H4.63246L5.36038 1.97296L7.54415 2.70088V3.96579L5.36038 4.69372L4.63246 6.87749H3.36755L2.63962 4.69372L0.455849 3.96579V2.70088L2.63962 1.97296ZM4 2.10819L3.79912 2.71082L3.37749 3.13246L2.77485 3.33334L3.37749 3.53421L3.79912 3.95585L4 4.55849L4.20088 3.95585L4.62252 3.53421L5.22515 3.33334L4.62252 3.13246L4.20088 2.71082L4 2.10819ZM11.3926 4.02504C11.0926 4.00053 10.7044 4.00001 10.1333 4.00001H9.33332V2.66668H10.1609C10.6975 2.66667 11.1404 2.66666 11.5012 2.69614C11.8759 2.72675 12.2204 2.79246 12.544 2.95732C13.0457 3.21299 13.4537 3.62094 13.7093 4.1227C13.8742 4.44626 13.9399 4.79073 13.9705 5.16546C14 5.52625 14 5.96915 14 6.50579V8.82719C14 9.36383 14 9.80673 13.9705 10.1675C13.9399 10.5423 13.8742 10.8867 13.7093 11.2103C13.4537 11.712 13.0457 12.12 12.544 12.3757C12.2204 12.5405 11.8759 12.6062 11.5012 12.6368C11.1404 12.6663 10.6975 12.6663 10.1609 12.6663H10.0209L8.5062 14.4338L7.49378 14.4338L5.97905 12.6663H5.83911C5.30247 12.6663 4.85957 12.6663 4.49877 12.6368C4.12404 12.6062 3.77957 12.5405 3.45602 12.3757C2.95425 12.12 2.5463 11.712 2.29064 11.2103C2.12578 10.8867 2.06007 10.5422 2.02945 10.1675C1.99997 9.80672 1.99998 9.36382 1.99999 8.82717L1.99999 8.33315H3.33332V8.79963C3.33332 9.37069 3.33384 9.75888 3.35836 10.0589C3.38224 10.3512 3.42552 10.5007 3.47865 10.605C3.60648 10.8558 3.81045 11.0598 4.06134 11.1876C4.1656 11.2408 4.31507 11.2841 4.60735 11.3079C4.90741 11.3324 5.2956 11.333 5.86666 11.333H6.59237L7.99999 12.9755L9.40763 11.333H10.1333C10.7044 11.333 11.0926 11.3324 11.3926 11.3079C11.6849 11.2841 11.8344 11.2408 11.9386 11.1876C12.1895 11.0598 12.3935 10.8558 12.5213 10.605C12.5745 10.5007 12.6177 10.3512 12.6416 10.0589C12.6661 9.75888 12.6667 9.37069 12.6667 8.79964V6.53334C12.6667 5.96229 12.6661 5.57409 12.6416 5.27403C12.6177 4.98176 12.5745 4.83229 12.5213 4.72802C12.3935 4.47714 12.1895 4.27316 11.9386 4.14533C11.8344 4.09221 11.6849 4.04892 11.3926 4.02504Z"
      fill={fillCurrentColor ? 'currentColor' : undefined}
    />
    <path
      fillRule="evenodd"
      clipRule="evenodd"
      d="M7.18377 7.18378L7.62053 5.87351H8.37947L8.81623 7.18378L10.1265 7.62053V8.37948L8.81623 8.81623L8.37947 10.1265H7.62053L7.18377 8.81623L5.87351 8.37948V7.62053L7.18377 7.18378Z"
      fill={fillCurrentColor ? 'currentColor' : undefined}
    />
  </svg>
);
</file>

<file path="src/utils/svgs/RobotSVG.tsx">
export const RobotSVG = ({
  fillCurrentColor = true,
  className,
}: {
  fillCurrentColor?: boolean;
  className?: string;
}) => (
  <svg
    className={className}
    width="14"
    height="14"
    viewBox="0 0 17 20"
    fill="none"
    xmlns="http://www.w3.org/2000/svg"
  >
    <path
      fillRule="evenodd"
      clipRule="evenodd"
      d="M5.21025 5.02381H11.0755C11.8038 5.0238 12.4049 5.02379 12.8945 5.06379C13.4031 5.10535 13.8706 5.19452 14.3097 5.41826C14.9906 5.76523 15.5443 6.31888 15.8913 6.99984C16.115 7.43896 16.2042 7.90645 16.2457 8.41501C16.2857 8.90466 16.2857 9.50574 16.2857 10.234V14.2898C16.2857 15.0181 16.2857 15.6191 16.2457 16.1088C16.2042 16.6174 16.115 17.0849 15.8913 17.524C15.5443 18.2049 14.9906 18.7586 14.3097 19.1055C13.8706 19.3293 13.4031 19.4185 12.8945 19.46C12.4049 19.5 11.8038 19.5 11.0754 19.5H5.21027C4.48196 19.5 3.88086 19.5 3.39121 19.46C2.88264 19.4185 2.41515 19.3293 1.97603 19.1055C1.29507 18.7586 0.741424 18.2049 0.394453 17.524C0.170714 17.0849 0.0815369 16.6174 0.0399855 16.1088C-2.06409e-05 15.6191 -1.11504e-05 15.0181 3.90216e-07 14.2897V10.2341C-1.11504e-05 9.50576 -2.06409e-05 8.90467 0.0399855 8.41502C0.0815369 7.90645 0.170714 7.43896 0.394453 6.99984C0.741424 6.31888 1.29507 5.76523 1.97603 5.41826C2.41515 5.19452 2.88264 5.10535 3.39121 5.06379C3.88086 5.02379 4.48195 5.0238 5.21025 5.02381ZM3.53856 6.86731C3.1419 6.89972 2.93905 6.95846 2.79754 7.03056C2.45706 7.20404 2.18024 7.48087 2.00675 7.82135C1.93465 7.96285 1.87591 8.16571 1.8435 8.56237C1.81023 8.96959 1.80952 9.49643 1.80952 10.2714V14.2524C1.80952 15.0274 1.81023 15.5542 1.8435 15.9614C1.87591 16.3581 1.93465 16.561 2.00675 16.7025C2.18024 17.0429 2.45706 17.3198 2.79754 17.4932C2.93905 17.5653 3.1419 17.6241 3.53856 17.6565C3.94578 17.6898 4.47262 17.6905 5.24762 17.6905H11.0381C11.8131 17.6905 12.3399 17.6898 12.7472 17.6565C13.1438 17.6241 13.3467 17.5653 13.4882 17.4932C13.8287 17.3198 14.1055 17.0429 14.279 16.7025C14.3511 16.561 14.4098 16.3581 14.4422 15.9614C14.4755 15.5542 14.4762 15.0274 14.4762 14.2524V10.2714C14.4762 9.49643 14.4755 8.96959 14.4422 8.56237C14.4098 8.16571 14.3511 7.96285 14.279 7.82135C14.1055 7.48087 13.8287 7.20404 13.4882 7.03056C13.3467 6.95846 13.1438 6.89972 12.7472 6.86731C12.3399 6.83404 11.8131 6.83333 11.0381 6.83333H5.24762C4.47262 6.83333 3.94578 6.83404 3.53856 6.86731Z"
      fill={fillCurrentColor ? 'currentColor' : undefined}
    />
    <path
      fillRule="evenodd"
      clipRule="evenodd"
      d="M6.33337 2.69857L6.33333 3.21434C6.3333 3.71403 5.9282 4.11908 5.42852 4.11905C4.92883 4.11902 4.52378 3.71392 4.52381 3.21423L4.52387 2.30947C4.52388 2.07611 4.61406 1.85178 4.77557 1.68334C4.99499 1.4545 5.32229 1.12171 5.89443 0.873475C6.44775 0.6334 7.16129 0.5 8.1429 0.5C9.12451 0.5 9.83805 0.63341 10.3914 0.873493C10.9635 1.12173 11.2908 1.45452 11.5102 1.68332C11.6717 1.85177 11.7619 2.07613 11.7619 2.30952V3.21429C11.7619 3.71397 11.3568 4.11905 10.8571 4.11905C10.3575 4.11905 9.95238 3.71397 9.95238 3.21429V2.69856C9.8723 2.63607 9.78449 2.58269 9.67111 2.53349C9.4179 2.42363 8.97077 2.30952 8.1429 2.30952C7.31502 2.30952 6.86788 2.42362 6.61467 2.53348C6.50127 2.58269 6.41345 2.63607 6.33337 2.69857Z"
      fill={fillCurrentColor ? 'currentColor' : undefined}
    />
    <path
      fillRule="evenodd"
      clipRule="evenodd"
      d="M4.70476 13.5286C5.00457 13.1288 5.57168 13.0478 5.97143 13.3476C6.70123 13.895 7.4087 14.0718 8.14237 14.0714C8.87603 14.071 9.58508 13.8945 10.3143 13.3476C10.714 13.0478 11.2811 13.1288 11.581 13.5286C11.8808 13.9283 11.7997 14.4954 11.4 14.7952C10.3197 15.6055 9.21764 15.8804 8.14335 15.881C7.06593 15.8815 5.96543 15.605 4.88572 14.7952C4.48597 14.4954 4.40495 13.9283 4.70476 13.5286Z"
      fill={fillCurrentColor ? 'currentColor' : undefined}
    />
    <path
      d="M3.61905 10.9048C3.61905 10.1552 4.22666 9.54762 4.97619 9.54762C5.72572 9.54762 6.33333 10.1552 6.33333 10.9048C6.33333 11.6543 5.72572 12.2619 4.97619 12.2619C4.22666 12.2619 3.61905 11.6543 3.61905 10.9048Z"
      fill={fillCurrentColor ? 'currentColor' : undefined}
    />
    <path
      d="M9.95238 10.9048C9.95238 10.1552 10.56 9.54762 11.3095 9.54762C12.0591 9.54762 12.6667 10.1552 12.6667 10.9048C12.6667 11.6543 12.0591 12.2619 11.3095 12.2619C10.56 12.2619 9.95238 11.6543 9.95238 10.9048Z"
      fill={fillCurrentColor ? 'currentColor' : undefined}
    />
  </svg>
);
</file>

<file path="src/utils/table.tsx">
import { useEffect } from 'react';
import moment from 'moment';
import { Input, Button, Space, DatePicker, Divider } from 'antd';
import SearchOutlined from '@ant-design/icons/SearchOutlined';
import CalendarOutlined from '@ant-design/icons/CalendarOutlined';

export const getColumnSearchProps = (props: {
  dataIndex: string;
  placeholder?: string;
  onFilter?: (value: string, record: any) => boolean;
  filteredValue?: any[];
}) => ({
  filterDropdown: (filters: any) => {
    return <SearchFilter {...filters} {...props} />;
  },
  filterIcon: (filtered: boolean) => (
    <SearchOutlined
      style={{ color: filtered ? 'var(--geekblue-6)' : undefined }}
    />
  ),
  filteredValue: props.filteredValue,
});

export const getColumnDateFilterProps = (props: {
  dataIndex: string;
  onFilter?: (value: any, record: any) => boolean;
  filteredValue?: [string, string] | null;
}) => ({
  filterDropdown: (filters) => {
    return <DateFilter {...filters} {...props} />;
  },
  filterIcon: (filtered: boolean) => (
    <CalendarOutlined
      style={{ color: filtered ? 'var(--geekblue-6)' : undefined }}
    />
  ),
  filteredValue: props.filteredValue,
});

const SearchFilter = ({
  setSelectedKeys,
  selectedKeys,
  confirm,
  clearFilters,
  visible,
  dataIndex,
  placeholder,
  filteredValue,
}) => {
  useEffect(() => {
    if (!visible && selectedKeys.length === 0) confirm();
  }, [visible]);
  return (
    <>
      <Space className="p-2">
        <Input
          size="small"
          placeholder={`Search ${placeholder || dataIndex}`}
          value={selectedKeys[0]}
          onChange={(e) =>
            setSelectedKeys(e.target.value ? [e.target.value] : [])
          }
          onPressEnter={() => confirm()}
          style={{ width: 188 }}
        />
      </Space>
      <Divider style={{ margin: 0 }} />
      <Space className="d-flex justify-end p-2">
        <Button
          type="link"
          onClick={() => clearFilters()}
          size="small"
          disabled={!filteredValue}
        >
          Reset
        </Button>
        <Button type="primary" onClick={() => confirm()} size="small">
          Search
        </Button>
      </Space>
    </>
  );
};

const DateFilter = ({
  filteredValue,
  setSelectedKeys,
  selectedKeys,
  confirm,
  clearFilters,
  visible,
}) => {
  useEffect(() => {
    if (!visible && selectedKeys.length === 0) confirm();
  }, [visible]);
  return (
    <>
      <Space className="p-2">
        <DatePicker.RangePicker
          placeholder={['Start Date', 'End Date']}
          value={[
            selectedKeys[0] ? moment(selectedKeys[0]) : null,
            selectedKeys[1] ? moment(selectedKeys[1]) : null,
          ]}
          onChange={(dates) => {
            const values = dates
              ? [dates[0]?.format('YYYY-MM-DD'), dates[1]?.format('YYYY-MM-DD')]
              : [];
            setSelectedKeys(values);
          }}
          style={{ width: 250 }}
        />
      </Space>
      <Divider style={{ margin: 0 }} />
      <Space className="d-flex justify-end p-2">
        <Button
          type="link"
          onClick={() => clearFilters()}
          size="small"
          disabled={!filteredValue}
        >
          Reset
        </Button>
        <Button type="primary" onClick={() => confirm()} size="small">
          OK
        </Button>
      </Space>
    </>
  );
};
</file>

<file path="src/utils/telemetry.ts">
import posthog from 'posthog-js';
import { NextRouter } from 'next/router';
import env, { UserConfig } from '@/utils/env';

const setupPostHog = (userConfig) => {
  // Check that PostHog is client-side (used to handle Next.js SSR)
  if (typeof window !== 'undefined') {
    posthog.init(userConfig.telemetryKey, {
      api_host: userConfig.telemetryHost,
      autocapture: {
        dom_event_allowlist: ['click'],
        css_selector_allowlist: ['[data-ph-capture="true"]'],
      },
      session_recording: {
        maskAllInputs: false,
        maskInputOptions: {
          password: true,
        },
      },
      disable_session_recording: env.isDevelopment,
      debug: false,
      loaded: () => {
        console.log('PostHog initialized.');
      },
    });
    // set up distinct id to posthog
    if (userConfig.userUUID) posthog.identify(userConfig.userUUID);
  }
};

export const trackUserTelemetry = (router: NextRouter, config: UserConfig) => {
  const handlePostHogPageView = () => {
    posthog.capture('$pageview');
  };

  // Track PostHog
  if (config.isTelemetryEnabled) {
    setupPostHog(config);
    router.events.on('routeChangeComplete', handlePostHogPageView);
  }

  return () => {
    router.events.off('routeChangeComplete', handlePostHogPageView);
  };
};
</file>

<file path="src/utils/time.ts">
import dayJs from 'dayjs';
import utc from 'dayjs/plugin/utc';
import relativeTime from 'dayjs/plugin/relativeTime';

dayJs.extend(utc);
dayJs.extend(relativeTime);

export const browserTimeZone = Intl.DateTimeFormat().resolvedOptions().timeZone;

export const nextTick = (ms = 1) =>
  new Promise((resolve) => setTimeout(resolve, ms));

export const getRelativeTime = (time: string) => {
  return dayJs(time).fromNow();
};

export const getAbsoluteTime = (time: string) => {
  return dayJs(time).format('YYYY-MM-DD HH:mm:ss');
};

export const getCompactTime = (time: string) => {
  return dayJs(time).format('YYYY-MM-DD HH:mm');
};

export const getFullNameDate = (time: string) => {
  return dayJs(time).format('MMMM DD, YYYY');
};

export const getShortDate = (time: string) => {
  return dayJs(time).format('MMM DD');
};
</file>

<file path="src/utils/validator/calculatedFieldValidator.ts">
import { COLUMN_TYPE, NODE_TYPE } from '@/utils/enum';
import { ERROR_TEXTS } from '@/utils/error';
import { mathFunctions, stringFunctions } from '@/utils/expressionType';
import { ExpressionName } from '@/apollo/client/graphql/__types__';

export const createLineageSelectorNameValidator =
  (validateCalculatedField: any) => async (_rule: any, value: string) => {
    if (!value) {
      return Promise.reject(ERROR_TEXTS.CALCULATED_FIELD.NAME.REQUIRED);
    }

    const result = await validateCalculatedField(value);

    const { valid, message } = result?.data?.validateCalculatedField;

    if (!valid) {
      return Promise.reject(message);
    }

    return Promise.resolve();
  };

const makeCheckAllowType =
  (functions: ExpressionName[], allowTypes: COLUMN_TYPE[]) =>
  (expression: ExpressionName, value) => {
    const isField = [NODE_TYPE.FIELD, NODE_TYPE.CALCULATED_FIELD].includes(
      value.nodeType,
    );

    // ignore if not a column or not a string function
    if (!isField || !functions.includes(expression)) {
      return true;
    }

    return allowTypes.includes(value.type.toLocaleUpperCase());
  };

export const checkStringFunctionAllowType = makeCheckAllowType(
  stringFunctions,
  [
    COLUMN_TYPE.VARCHAR,
    COLUMN_TYPE.CHAR,
    COLUMN_TYPE.BPCHAR,
    COLUMN_TYPE.TEXT,
    COLUMN_TYPE.STRING,
    COLUMN_TYPE.NAME,
  ],
);

export const checkNumberFunctionAllowType = makeCheckAllowType(mathFunctions, [
  COLUMN_TYPE.TINYINT,
  COLUMN_TYPE.INT2,
  COLUMN_TYPE.SMALLINT,
  COLUMN_TYPE.INT4,
  COLUMN_TYPE.INTEGER,
  COLUMN_TYPE.INT8,
  COLUMN_TYPE.BIGINT,
  COLUMN_TYPE.INT64,
  COLUMN_TYPE.NUMERIC,
  COLUMN_TYPE.DECIMAL,
  COLUMN_TYPE.FLOAT4,
  COLUMN_TYPE.REAL,
  COLUMN_TYPE.FLOAT8,
  COLUMN_TYPE.DOUBLE,
]);

export const createLineageSelectorValidator =
  (expression: ExpressionName) =>
  (_rule: any, value: Record<string, any>[]) => {
    if (!value)
      return Promise.reject(
        new Error(ERROR_TEXTS.CALCULATED_FIELD.LINEAGE.REQUIRED),
      );

    const lastValue = value[value.length - 1];
    if (
      ![NODE_TYPE.FIELD, NODE_TYPE.CALCULATED_FIELD].includes(
        lastValue.nodeType,
      )
    ) {
      return Promise.reject(
        new Error(ERROR_TEXTS.CALCULATED_FIELD.LINEAGE.REQUIRED),
      );
    }

    if (!checkStringFunctionAllowType(expression, lastValue)) {
      return Promise.reject(
        new Error(ERROR_TEXTS.CALCULATED_FIELD.LINEAGE.INVALID_STRING_TYPE),
      );
    }

    if (!checkNumberFunctionAllowType(expression, lastValue)) {
      return Promise.reject(
        new Error(ERROR_TEXTS.CALCULATED_FIELD.LINEAGE.INVALID_NUMBER_TYPE),
      );
    }

    return Promise.resolve();
  };
</file>

<file path="src/utils/validator/cronValidator.ts">
import { CronExpressionParser } from 'cron-parser';
import { ERROR_TEXTS } from '@/utils/error';

export const isValidCronLength = (cron: string) => {
  return cron?.trim().split(' ').length === 5;
};

export const cronValidator = (_, value: string) => {
  if (!value) return Promise.reject(ERROR_TEXTS.CRON.REQUIRED);
  if (!isValidCronLength(value)) {
    return Promise.reject(ERROR_TEXTS.CRON.INVALID);
  }
  try {
    CronExpressionParser.parse(value, { tz: 'UTC' });
    return Promise.resolve();
  } catch (error) {
    return Promise.reject(error.message);
  }
};
</file>

<file path="src/utils/validator/hostValidator.ts">
import { ERROR_TEXTS } from '@/utils/error';

export const hostValidator = (_, value) => {
  if (!value) {
    return Promise.reject(ERROR_TEXTS.CONNECTION.HOST.REQUIRED);
  }

  if (['localhost', '127.0.0.1'].includes(value)) {
    return Promise.reject(ERROR_TEXTS.CONNECTION.HOST.INVALID);
  }

  return Promise.resolve();
};
</file>

<file path="src/utils/validator/index.ts">
export * from './calculatedFieldValidator';
export * from './viewValidator';
export * from './relationshipValidator';
export * from './hostValidator';
export * from './sqlPairValidator';
export * from './cronValidator';
</file>

<file path="src/utils/validator/relationshipValidator.ts">
import { FormInstance } from 'antd';
import { ERROR_TEXTS } from '@/utils/error';
import { RelationsDataType } from '@/components/table/ModelRelationSelectionTable';
import { SelectedRecommendRelations } from '@/components/pages/setup/DefineRelations';
import { convertFormValuesToIdentifier } from '@/hooks/useCombineFieldOptions';
import { FormFieldKey } from '@/components/modals/RelationModal';

/**
 * Check if the relationship already exists
 *
 * Consider: Assume we have an existing relationship: Customers.orderId -> Orders.orderId, One-to-Many
 * There are two cases to check:
 * 1. Same as from and to of existing relationship
 *    (E.g., add new relationship: Customers.orderId -> Orders.orderId)
 * 2. Reverse of from and to of existing relationship
 *    (E.g., add new relationship: Orders.orderId -> Customers.orderId)
 *
 * @param existingRelationships
 * @param formValues
 * @returns boolean
 */
const isExistRelationship = (
  relationships: SelectedRecommendRelations,
  formValues: RelationsDataType,
) => {
  const relationshipsByFromFieldModel =
    relationships[formValues.fromField.modelName];
  const isDuplicate = Boolean(
    relationshipsByFromFieldModel.find(
      (relationship) =>
        relationship.fromField.modelId === formValues.fromField.modelId &&
        relationship.fromField.fieldId === formValues.fromField.fieldId &&
        relationship.toField.modelId === formValues.toField.modelId &&
        relationship.toField.fieldId === formValues.toField.fieldId,
    ),
  );

  if (isDuplicate) return true;

  const relationshipsbyToFieldModel =
    relationships[formValues.toField.modelName];
  const isReverseDuplicate = Boolean(
    relationshipsbyToFieldModel.find(
      (relationship) =>
        relationship.fromField.modelId === formValues.toField.modelId &&
        relationship.fromField.fieldId === formValues.toField.fieldId &&
        relationship.toField.modelId === formValues.fromField.modelId &&
        relationship.toField.fieldId === formValues.fromField.fieldId,
    ),
  );

  return isReverseDuplicate;
};

export const createRelationshipFromFieldValidator =
  (
    skip = false,
    relationships: SelectedRecommendRelations,
    getFieldValue: FormInstance['getFieldValue'],
  ) =>
  async (_, value: any) => {
    if (!value || !value.field) {
      return Promise.reject(ERROR_TEXTS.ADD_RELATION.FROM_FIELD.REQUIRED);
    }

    if (!skip) {
      const toField = getFieldValue(FormFieldKey.TO_FIELD);
      if (toField && toField.model && toField.field) {
        if (
          isExistRelationship(
            relationships,
            convertFormValuesToIdentifier({
              fromField: value,
              toField,
            }),
          )
        ) {
          return Promise.reject(ERROR_TEXTS.ADD_RELATION.RELATIONSHIP.EXIST);
        }
      }
    }

    return Promise.resolve();
  };

export const createRelationshipToFieldValidator =
  (
    skip = false,
    relationships: SelectedRecommendRelations,
    getFieldValue: FormInstance['getFieldValue'],
  ) =>
  async (_, value: any) => {
    if (!value || !value.field) {
      return Promise.reject(ERROR_TEXTS.ADD_RELATION.TO_FIELD.REQUIRED);
    }

    if (!skip) {
      const fromField = getFieldValue(FormFieldKey.FROM_FIELD);
      if (fromField && fromField.model && fromField.field) {
        if (
          isExistRelationship(
            relationships,
            convertFormValuesToIdentifier({
              fromField,
              toField: value,
            }),
          )
        ) {
          return Promise.reject(ERROR_TEXTS.ADD_RELATION.RELATIONSHIP.EXIST);
        }
      }
    }

    return Promise.resolve();
  };
</file>

<file path="src/utils/validator/sqlPairValidator.ts">
export const createSQLPairQuestionValidator =
  (errorObj: any) => async (_rule: any, value: string) => {
    if (!value) {
      return Promise.reject(errorObj.REQUIRED);
    }

    if (value.trim() === '') {
      return Promise.reject(errorObj.REQUIRED);
    }

    if (value.length > 300) {
      return Promise.reject(errorObj.MAX_LENGTH);
    }

    return Promise.resolve();
  };
</file>

<file path="src/utils/validator/viewValidator.ts">
import { ERROR_TEXTS } from '@/utils/error';

export const createViewNameValidator =
  (validateViewMutation: any) => async (_rule: any, value: string) => {
    if (!value) {
      return Promise.reject(ERROR_TEXTS.SAVE_AS_VIEW.NAME.REQUIRED);
    }

    const validateViewResult = await validateViewMutation({
      variables: { data: { name: value } },
    });

    const { valid, message } = validateViewResult?.data?.validateView;

    if (!valid) {
      return Promise.reject(message);
    }

    return Promise.resolve();
  };
</file>

<file path="src/utils/vegaSpecUtils.test.ts">
import { enhanceVegaSpec } from './vegaSpecUtils';

describe('vegaSpecUtils', () => {
  describe('enhanceVegaSpec', () => {
    it('should enhance a bar chart with proper styling and interactivity', () => {
      // Input Vega spec
      const inputSpec = {
        title: 'Total Payments by Customer State',
        mark: {
          type: 'bar',
        },
        encoding: {
          x: {
            field: 'customer_state',
            type: 'nominal',
            title: 'Customer State',
          },
          y: {
            field: 'total_payment_value',
            type: 'quantitative',
            title: 'Total Payment Value',
          },
        },
        $schema: 'https://vega.github.io/schema/vega-lite/v5.json',
        data: {
          values: [],
        },
      };

      // Sample data
      const dataValues = [
        {
          customer_state: 'RR',
          total_payment_value: 10064.62,
        },
        {
          customer_state: 'PI',
          total_payment_value: 108523.97000000003,
        },
        {
          customer_state: 'PE',
          total_payment_value: 324850.4399999999,
        },
        {
          customer_state: 'PB',
          total_payment_value: 141545.7199999999,
        },
        {
          customer_state: 'RO',
          total_payment_value: 60866.2,
        },
        {
          customer_state: 'SE',
          total_payment_value: 75246.25,
        },
        {
          customer_state: 'TO',
          total_payment_value: 61485.32999999993,
        },
        {
          customer_state: 'AP',
          total_payment_value: 16262.8,
        },
        {
          customer_state: 'GO',
          total_payment_value: 350092.3100000009,
        },
        {
          customer_state: 'ES',
          total_payment_value: 325967.55000000045,
        },
        {
          customer_state: 'AM',
          total_payment_value: 27966.93,
        },
        {
          customer_state: 'SC',
          total_payment_value: 623086.43,
        },
        {
          customer_state: 'PA',
          total_payment_value: 218295.85,
        },
        {
          customer_state: 'MT',
          total_payment_value: 187029.28999999986,
        },
        {
          customer_state: 'AL',
          total_payment_value: 96962.06000000003,
        },
        {
          customer_state: 'SP',
          total_payment_value: 5998226.959999885,
        },
        {
          customer_state: 'MG',
          total_payment_value: 1872257.2600000093,
        },
        {
          customer_state: 'DF',
          total_payment_value: 355141.0799999998,
        },
        {
          customer_state: 'MA',
          total_payment_value: 152523.02000000002,
        },
        {
          customer_state: 'MS',
          total_payment_value: 137534.84000000003,
        },
        {
          customer_state: 'BA',
          total_payment_value: 616645.8200000012,
        },
        {
          customer_state: 'RJ',
          total_payment_value: 2144379.68999999,
        },
        {
          customer_state: 'PR',
          total_payment_value: 811156.379999998,
        },
        {
          customer_state: 'RN',
          total_payment_value: 102718.13,
        },
        {
          customer_state: 'AC',
          total_payment_value: 19680.62,
        },
        {
          customer_state: 'RS',
          total_payment_value: 890898.5399999967,
        },
        {
          customer_state: 'CE',
          total_payment_value: 279464.0300000001,
        },
      ];

      // Process spec with our utility
      const enhancedSpec: any = enhanceVegaSpec(inputSpec, dataValues);
      console.log(JSON.stringify(enhancedSpec, null, 2));

      // Define expected values for important properties
      expect(enhancedSpec).toEqual(
        expect.objectContaining({
          $schema: 'https://vega.github.io/schema/vega-lite/v5.json',
          title: 'Total Payments by Customer State',
          width: 'container',
          height: 'container',
          autosize: expect.objectContaining({
            type: 'fit',
            contains: 'padding',
          }),
          mark: expect.objectContaining({
            type: 'bar',
          }),
        }),
      );

      // Check for config
      expect(enhancedSpec.config).toEqual(
        expect.objectContaining({
          mark: { tooltip: true },
          font: 'Roboto, Arial, Noto Sans, sans-serif',
          bar: { color: '#1570EF' },
          axisX: { labelAngle: -45 },
        }),
      );

      // Check for data values
      expect(enhancedSpec.data).toEqual({
        values: dataValues,
      });

      // Check for encodings
      expect(enhancedSpec.encoding).toEqual(
        expect.objectContaining({
          x: {
            field: 'customer_state',
            type: 'nominal',
            title: 'Customer State',
          },
          y: {
            field: 'total_payment_value',
            type: 'quantitative',
            title: 'Total Payment Value',
          },
          color: expect.objectContaining({
            field: 'customer_state',
            type: 'nominal',
            title: 'Customer State',
            scale: expect.objectContaining({
              range: expect.arrayContaining(['#7763CF', '#1570EF']),
            }),
          }),
          opacity: {
            condition: {
              param: 'hover',
              value: 1,
            },
            value: 0.3,
          },
        }),
      );

      // Check for interaction params
      expect(enhancedSpec.params).toEqual([
        {
          name: 'hover',
          select: {
            type: 'point',
            on: 'mouseover',
            clear: 'mouseout',
            fields: ['customer_state'],
          },
        },
      ]);
    });

    it('should handle line charts appropriately', () => {
      const lineSpec = {
        title: 'Value Over Time',
        mark: 'line',
        encoding: {
          x: {
            field: 'month',
            type: 'temporal',
            title: 'Month',
          },
          y: {
            field: 'value',
            type: 'quantitative',
            title: 'Value',
          },
        },
      };

      const data = [
        { month: '2023-01', value: 10 },
        { month: '2023-02', value: 20 },
        { month: '2023-03', value: 15 },
      ];

      const enhanced: any = enhanceVegaSpec(lineSpec, data);

      // Check that line chart gets point property set to true
      expect(enhanced.mark).toEqual(
        expect.objectContaining({
          type: 'line',
          point: true,
        }),
      );
    });

    it('should handle pie/arc charts appropriately', () => {
      const pieSpec = {
        title: 'Distribution by Category',
        mark: 'arc',
        encoding: {
          theta: {
            field: 'value',
            type: 'quantitative',
          },
          color: {
            field: 'category',
            type: 'nominal',
          },
        },
      };

      const data = [
        { category: 'A', value: 30 },
        { category: 'B', value: 45 },
        { category: 'C', value: 25 },
      ];

      const enhanced: any = enhanceVegaSpec(pieSpec, data);

      // Check that arc chart gets innerRadius for donut style
      expect(enhanced.mark).toEqual(
        expect.objectContaining({
          type: 'arc',
          innerRadius: 60,
        }),
      );
    });

    it('should handle stacked bar charts appropriately', () => {
      const stackedBarSpec = {
        title: 'Sales by Region and Product',
        mark: 'bar',
        encoding: {
          x: {
            field: 'region',
            type: 'nominal',
            title: 'Region',
          },
          y: {
            field: 'sales',
            type: 'quantitative',
            title: 'Sales',
            stack: true,
          },
          color: {
            field: 'product',
            type: 'nominal',
          },
        },
      };

      const data = [
        { region: 'North', product: 'A', sales: 100 },
        { region: 'North', product: 'B', sales: 150 },
        { region: 'South', product: 'A', sales: 120 },
        { region: 'South', product: 'B', sales: 180 },
        { region: 'East', product: 'A', sales: 90 },
        { region: 'East', product: 'B', sales: 110 },
        { region: 'West', product: 'A', sales: 140 },
        { region: 'West', product: 'B', sales: 160 },
      ];

      const enhanced: any = enhanceVegaSpec(stackedBarSpec, data);

      // Check that bar chart gets proper stacking
      expect(enhanced.encoding.y.stack).toBe('zero');
    });
  });
});
</file>

<file path="src/utils/vegaSpecUtils.ts">
import { TopLevelSpec, Config } from 'vega-lite';

// Enum for mark types matching the frontend implementation
export enum MarkType {
  ARC = 'arc',
  AREA = 'area',
  BAR = 'bar',
  BOXPLOT = 'boxplot',
  CIRCLE = 'circle',
  ERRORBAND = 'errorband',
  ERRORBAR = 'errorbar',
  IMAGE = 'image',
  LINE = 'line',
  POINT = 'point',
  RECT = 'rect',
  RULE = 'rule',
  SQUARE = 'square',
  TEXT = 'text',
  TICK = 'tick',
  TRAIL = 'trail',
}

// Constants from handler.ts
const COLOR = {
  GRAY_10: '#262626',
  GRAY_9: '#434343',
  GRAY_8: '#65676c',
  GRAY_5: '#d9d9d9',
};

// Default color scheme
const colorScheme = [
  '#7763CF',
  '#444CE7',
  '#1570EF',
  '#0086C9',
  '#3E4784',
  '#E31B54',
  '#EC4A0A',
  '#EF8D0C',
  '#EBC405',
  '#5381AD',
];

const DEFAULT_COLOR = colorScheme[2];

// Configuration object identical to handler.ts
const config: Config = {
  mark: { tooltip: true },
  font: 'Roboto, Arial, Noto Sans, sans-serif',
  padding: {
    top: 30,
    bottom: 20,
    left: 0,
    right: 0,
  },
  title: {
    color: COLOR.GRAY_10,
    fontSize: 14,
  },
  axis: {
    labelPadding: 0,
    labelOffset: 0,
    labelFontSize: 10,
    gridColor: COLOR.GRAY_5,
    titleColor: COLOR.GRAY_9,
    labelColor: COLOR.GRAY_8,
    labelFont: ' Roboto, Arial, Noto Sans, sans-serif',
  },
  axisX: { labelAngle: -45 },
  line: {
    color: DEFAULT_COLOR,
  },
  bar: {
    color: DEFAULT_COLOR,
  },
  legend: {
    symbolLimit: 15,
    columns: 1,
    labelFontSize: 10,
    labelColor: COLOR.GRAY_8,
    titleColor: COLOR.GRAY_9,
    titleFontSize: 14,
  },
  range: {
    category: colorScheme,
    ordinal: colorScheme,
    diverging: colorScheme,
    symbol: colorScheme,
    heatmap: colorScheme,
    ramp: colorScheme,
  },
  point: { size: 60, color: DEFAULT_COLOR },
};

/**
 * VegaSpecHandler provides methods to enhance and standardize Vega specifications
 * Similar to the frontend handler.ts but focusing only on core styling needs
 */
export class VegaSpecHandler {
  public config: Config;
  public data: { values: any[] };
  public encoding: any;
  public mark: any;
  public width: 'container';
  public height: 'container';
  public autosize: { type: string; contains: string };
  public params: any[];
  public title: string;
  public $schema: string;

  constructor(spec: any, dataValues: any[]) {
    this.config = config;
    this.$schema = 'https://vega.github.io/schema/vega-lite/v5.json';
    this.title = spec.title;
    this.width = 'container';
    this.height = 'container';
    this.autosize = { type: 'fit', contains: 'padding' };
    this.data = { values: dataValues };
    this.params = [
      {
        name: 'hover',
        select: {
          type: 'point',
          on: 'mouseover',
          clear: 'mouseout',
        },
      },
    ];

    // Clone to avoid mutating the original spec
    const clonedSpec = { ...spec };
    this.parseSpec(clonedSpec);
  }

  /**
   * Returns the complete enhanced Vega specification
   */
  public getChartSpec(): TopLevelSpec {
    return {
      $schema: this.$schema,
      config: this.config,
      title: this.title,
      data: this.data,
      mark: this.mark,
      width: this.width,
      height: this.height,
      autosize: this.autosize,
      encoding: this.encoding,
      params: this.params,
    } as TopLevelSpec;
  }

  /**
   * Parses the input specification to extract and enhance components
   */
  private parseSpec(spec: any): void {
    if ('mark' in spec) {
      const mark =
        typeof spec.mark === 'string' ? { type: spec.mark } : spec.mark;
      this.addMark(mark);
    }

    if ('encoding' in spec) {
      this.addEncoding(spec.encoding);
    }
  }

  /**
   * Processes and enhances the mark specification
   */
  private addMark(mark: any): void {
    this.mark = {
      type: mark.type,
    };

    // Handle specific mark types if needed
    if (mark.type === MarkType.LINE) {
      this.mark.point = true;
    } else if (mark.type === MarkType.ARC) {
      // Default inner radius for donut charts
      this.mark.innerRadius = 60;
    }
  }

  /**
   * Processes and enhances encoding with proper color and interactivity
   */
  private addEncoding(encoding: any): void {
    this.encoding = { ...encoding };

    // Add color field if not provided
    this.addColorEncoding();

    // Handle special case for bar charts
    this.handleBarChartEncoding();

    // Add interactivity through opacity
    this.addOpacityForInteractivity();
  }

  /**
   * Handles special encoding for bar charts
   */
  private handleBarChartEncoding(): void {
    if (this.mark.type === MarkType.BAR) {
      // Handle stacking for bar charts
      if (this.encoding.y && 'stack' in this.encoding.y) {
        this.encoding.y.stack = 'zero';
      }

      // Handle xOffset titles if present
      if (this.encoding.xOffset) {
        const xOffset = this.encoding.xOffset;
        let title = xOffset.title;

        // Find xOffset title if not provided
        if (!title && xOffset.field) {
          title = this.findFieldTitleInEncoding(xOffset.field);
        }

        if (title) {
          this.encoding.xOffset.title = title;
        }
      }
    }
  }

  /**
   * Utility to find a field's title from other encodings
   */
  private findFieldTitleInEncoding(field: string): string | undefined {
    const axes = ['x', 'y', 'xOffset', 'color'];

    for (const axis of axes) {
      if (this.encoding[axis]?.field === field && this.encoding[axis]?.title) {
        return this.encoding[axis].title;
      }
    }

    return undefined;
  }

  /**
   * Adds or enhances color encoding
   */
  private addColorEncoding(): void {
    // If no color encoding exists, use a nominal axis
    if (!this.encoding.color) {
      const nominalAxis = ['x', 'y'].find(
        (axis) => this.encoding[axis]?.type === 'nominal',
      );

      if (nominalAxis) {
        const category = this.encoding[nominalAxis];
        this.encoding.color = {
          field: category.field,
          type: category.type,
          title: category.title || category.field,
          scale: {
            range: colorScheme,
          },
        };
      }
    } else if (this.encoding.color && !this.encoding.color.scale) {
      // Add color scale if not present
      this.encoding.color.scale = {
        range: colorScheme,
      };
    }

    // Set up hover fields for the interactive parameter
    if (this.params && this.encoding.color?.field) {
      this.params[0].select.fields = [this.encoding.color.field];
    }
  }

  /**
   * Adds opacity encoding for hover interactivity
   */
  private addOpacityForInteractivity(): void {
    // Add opacity for hover effect
    if (!this.encoding.opacity) {
      this.encoding.opacity = {
        condition: {
          param: 'hover',
          value: 1,
        },
        value: 0.3,
      };
    }
  }
}

/**
 * Enhances a Vega specification with standard configuration and styling
 *
 * @param vegaSpec The original Vega specification from the AI model
 * @param dataValues The data to be visualized
 * @returns Enhanced Vega specification with consistent styling
 */
export function enhanceVegaSpec(
  vegaSpec: any,
  dataValues: any[],
): TopLevelSpec {
  const handler = new VegaSpecHandler(vegaSpec, dataValues);
  return handler.getChartSpec();
}
</file>

<file path="tools/knex.js">
const DB_TYPE = process.env.DB_TYPE; // export DB_TYPE=pg
const PG_URL = process.env.PG_URL;
const DEBUG = process.env.DEBUG === 'true'; // export DEBUG=true
const SQLITE_FILE = process.env.SQLITE_FILE; // export SQLITE_FILE=./db.sqlite3

const getKnex = () => {
  if (DB_TYPE === 'pg') {
    console.log('using pg');
    /* eslint-disable @typescript-eslint/no-var-requires */
    return require('knex')({
      client: 'pg',
      connection: PG_URL,
      debug: DEBUG,
      pool: { min: 2, max: 10 },
    });
  } else {
    console.log('using sqlite');
    /* eslint-disable @typescript-eslint/no-var-requires */
    return require('knex')({
      client: 'better-sqlite3',
      connection: {
        filename: SQLITE_FILE,
      },
      useNullAsDefault: true,
    });
  }
};

const main = async () => {
  const knex = getKnex();
  const query = knex.queryBuilder();

  const projects = await query
    .select('*')
    .from('instruction')
    .whereIn('id', [7, 8]);

  console.log(projects);
  process.exit(0);
};

main();
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "es2015",
    "lib": ["es2017", "dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "skipDefaultLibCheck": true,
    "strict": false,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "forceConsistentCasingInFileNames": true,
    "allowSyntheticDefaultImports": true,
    "experimentalDecorators": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"],
      "@server": ["./src/apollo/server/index.ts"],
      "@server/*": ["./src/apollo/server/*"],
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
</file>

</files>
